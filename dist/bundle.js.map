{"version":3,"sources":["webpack:///dist/bundle.js","webpack:///webpack/bootstrap 30f52ee540e1c7d1a85d","webpack:///./src/ts/app.ts","webpack:///./~/three/three.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","Three","text","renderer","WebGLRenderer","clearDepth","document","getElementById","innerText","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","THREE","REVISION","undefined","Number","EPSILON","Math","pow","sign","x","Function","prototype","name","Object","defineProperty","get","this","toString","match","assign","writable","configurable","value","target","TypeError","to","i","n","arguments","length","nextSource","keysArray","keys","nextIndex","len","nextKey","desc","getOwnPropertyDescriptor","enumerable","MOUSE","LEFT","MIDDLE","RIGHT","CullFaceNone","CullFaceBack","CullFaceFront","CullFaceFrontBack","FrontFaceDirectionCW","FrontFaceDirectionCCW","BasicShadowMap","PCFShadowMap","PCFSoftShadowMap","FrontSide","BackSide","DoubleSide","FlatShading","SmoothShading","NoColors","FaceColors","VertexColors","NoBlending","NormalBlending","AdditiveBlending","SubtractiveBlending","MultiplyBlending","CustomBlending","AddEquation","SubtractEquation","ReverseSubtractEquation","MinEquation","MaxEquation","ZeroFactor","OneFactor","SrcColorFactor","OneMinusSrcColorFactor","SrcAlphaFactor","OneMinusSrcAlphaFactor","DstAlphaFactor","OneMinusDstAlphaFactor","DstColorFactor","OneMinusDstColorFactor","SrcAlphaSaturateFactor","NeverDepth","AlwaysDepth","LessDepth","LessEqualDepth","EqualDepth","GreaterEqualDepth","GreaterDepth","NotEqualDepth","MultiplyOperation","MixOperation","AddOperation","NoToneMapping","LinearToneMapping","ReinhardToneMapping","Uncharted2ToneMapping","CineonToneMapping","UVMapping","CubeReflectionMapping","CubeRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","SphericalReflectionMapping","CubeUVReflectionMapping","CubeUVRefractionMapping","RepeatWrapping","ClampToEdgeWrapping","MirroredRepeatWrapping","NearestFilter","NearestMipMapNearestFilter","NearestMipMapLinearFilter","LinearFilter","LinearMipMapNearestFilter","LinearMipMapLinearFilter","UnsignedByteType","ByteType","ShortType","UnsignedShortType","IntType","UnsignedIntType","FloatType","HalfFloatType","UnsignedShort4444Type","UnsignedShort5551Type","UnsignedShort565Type","AlphaFormat","RGBFormat","RGBAFormat","LuminanceFormat","LuminanceAlphaFormat","RGBEFormat","RGB_S3TC_DXT1_Format","RGBA_S3TC_DXT1_Format","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","RGB_PVRTC_4BPPV1_Format","RGB_PVRTC_2BPPV1_Format","RGBA_PVRTC_4BPPV1_Format","RGBA_PVRTC_2BPPV1_Format","RGB_ETC1_Format","LoopOnce","LoopRepeat","LoopPingPong","InterpolateDiscrete","InterpolateLinear","InterpolateSmooth","ZeroCurvatureEnding","ZeroSlopeEnding","WrapAroundEnding","TrianglesDrawMode","TriangleStripDrawMode","TriangleFanDrawMode","LinearEncoding","sRGBEncoding","GammaEncoding","RGBEEncoding","LogLuvEncoding","RGBM7Encoding","RGBM16Encoding","RGBDEncoding","Color","color","fromArray","set","constructor","r","g","b","copy","setHex","setStyle","setScalar","scalar","hex","floor","setRGB","setHSL","hue2rgb","q","t","h","s","l","euclideanModulo","clamp","style","handleAlpha","string","parseFloat","console","warn","exec","components","min","parseInt","size","charAt","ColorKeywords","clone","copyGammaToLinear","gammaFactor","copyLinearToGamma","safeInverse","convertGammaToLinear","convertLinearToGamma","sqrt","getHex","getHexString","slice","getHSL","optionalTarget","hue","saturation","hsl","max","lightness","delta","getStyle","offsetHSL","add","addColors","color1","color2","addScalar","multiply","multiplyScalar","lerp","alpha","equals","array","offset","toArray","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","Quaternion","y","z","w","_x","_y","_z","_w","onChangeCallback","quaternion","setFromEuler","euler","update","Euler","Error","c1","cos","c2","c3","s1","sin","s2","s3","order","setFromAxisAngle","axis","angle","halfAngle","setFromRotationMatrix","te","elements","m11","m12","m13","m21","m22","m23","m31","m32","m33","trace","setFromUnitVectors","v1","EPS","vFrom","vTo","Vector3","dot","abs","crossVectors","normalize","inverse","conjugate","v","lengthSq","multiplyQuaternions","a","qax","qay","qaz","qaw","qbx","qby","qbz","qbw","slerp","qb","cosHalfTheta","sinHalfTheta","halfTheta","atan2","ratioA","ratioB","onChange","callback","qa","qm","slerpFlat","dst","dstOffset","src0","srcOffset0","src1","srcOffset1","x0","y0","z0","w0","x1","y1","z1","w1","dir","sqrSin","tDir","f","Vector2","width","height","setX","setY","setComponent","index","getComponent","addVectors","addScaledVector","sub","subVectors","subScalar","isFinite","divide","divideScalar","clampScalar","minVal","maxVal","clampLength","ceil","round","roundToZero","negate","lengthManhattan","PI","distanceTo","distanceToSquared","dx","dy","setLength","lerpVectors","v2","fromAttribute","attribute","itemSize","rotateAround","center","setZ","multiplyVectors","applyEuler","error","applyQuaternion","applyAxisAngle","applyMatrix3","e","applyMatrix4","applyProjection","d","qx","qy","qz","qw","ix","iy","iz","iw","project","matrix","camera","Matrix4","multiplyMatrices","projectionMatrix","getInverse","matrixWorld","unproject","transformDirection","cross","ax","ay","az","bx","by","bz","projectOnVector","vector","projectOnPlane","planeNormal","reflect","normal","angleTo","theta","acos","dz","setFromSpherical","sinPhiRadius","phi","radius","setFromMatrixPosition","setFromMatrixColumn","setFromMatrixScale","sx","sy","sz","Vector4","setW","setAxisAngleFromQuaternion","setAxisAngleFromRotationMatrix","epsilon","epsilon2","xx","yy","zz","xy","xz","yz","_order","DefaultOrder","RotationOrders","asin","setFromQuaternion","makeRotationFromQuaternion","setFromVector3","reorder","newOrder","toVector3","optionalResult","Line3","start","end","line","result","distanceSq","distance","at","closestPointToPointParameter","startP","startEnd","point","clampToLine","startEnd2","startEnd_startP","closestPointToPoint","Box2","Infinity","setFromPoints","points","makeEmpty","il","expandByPoint","setFromCenterAndSize","halfSize","box","isEmpty","expandByVector","expandByScalar","containsPoint","containsBox","getParameter","intersectsBox","clampPoint","distanceToPoint","clampedPoint","intersect","union","translate","Box3","setFromArray","minX","minY","minZ","maxX","maxY","maxZ","setFromObject","object","scope","updateMatrixWorld","traverse","node","geometry","boundingBox","computeBoundingBox","intersectsSphere","closestPoint","sphere","intersectsPlane","plane","constant","getBoundingSphere","Sphere","Matrix3","Float32Array","n11","n12","n13","n21","n22","n23","n31","n32","n33","identity","me","setFromMatrix4","applyToVector3Array","j","applyToBuffer","buffer","getX","getY","getZ","setXYZ","determinant","throwOnDegenerate","t11","t12","t13","det","msg","transpose","tmp","flattenToArrayOffset","getNormalMatrix","matrix4","transposeIntoArray","n14","n24","n34","n41","n42","n43","n44","copyPosition","extractBasis","xAxis","yAxis","zAxis","makeBasis","extractRotation","scaleX","scaleY","scaleZ","makeRotationFromEuler","ae","af","be","bf","ce","cf","de","df","ac","ad","bc","bd","x2","y2","z2","wx","wy","wz","lookAt","eye","up","a11","a12","a13","a14","a21","a22","a23","a24","a31","a32","a33","a34","a41","a42","a43","a44","b11","b12","b13","b14","b21","b22","b23","b24","b31","b32","b33","b34","b41","b42","b43","b44","multiplyToArray","getPosition","setPosition","t14","scale","getMaxScaleOnAxis","scaleXSq","scaleYSq","scaleZSq","makeTranslation","makeRotationX","makeRotationY","makeRotationZ","makeRotationAxis","tx","ty","makeScale","compose","position","decompose","invSX","invSY","invSZ","makeFrustum","left","right","bottom","top","near","far","makePerspective","fov","aspect","ymax","degToRad","ymin","xmin","xmax","makeOrthographic","Ray","origin","direction","ray","recast","directionDistance","distanceSqToPoint","distanceSqToSegment","segCenter","segDir","diff","v0","optionalPointOnRay","optionalPointOnSegment","s0","sqrDist","extDet","segExtent","a01","b0","b1","invDet","intersectSphere","tca","d2","radius2","thc","t0","t1","distanceToPlane","denominator","intersectPlane","distToPoint","intersectBox","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","intersectTriangle","edge1","edge2","backfaceCulling","DdN","DdQxE2","DdE1xQ","QdN","optionalCenter","maxRadiusSq","empty","radiusSum","deltaLengthSq","getBoundingBox","Frustum","p0","p1","p2","p3","p4","p5","planes","Plane","frustum","setFromMatrix","me0","me1","me2","me3","me4","me5","me6","me7","me8","me9","me10","me11","me12","me13","me14","me15","setComponents","intersectsObject","boundingSphere","computeBoundingSphere","negRadius","d1","setFromNormalAndCoplanarPoint","setFromCoplanarPoints","inverseNormalLength","distanceToSphere","projectPoint","orthoPoint","perpendicularMagnitude","intersectLine","intersectsLine","startSign","endSign","coplanarPoint","m1","optionalNormalMatrix","normalMatrix","newNormal","newCoplanarPoint","Spherical","other","makeSafe","vec3","generateUUID","chars","split","uuid","Array","rnd","random","join","mapLinear","a1","a2","b2","smoothstep","smootherstep","random16","randInt","low","high","randFloat","randFloatSpread","range","degreeToRadiansFactor","degrees","radToDeg","radianToDegreesFactor","radians","isPowerOfTwo","nearestPowerOfTwo","log","LN2","nextPowerOfTwo","Spline","interpolate","t2","t3","intPoint","weight","w2","w3","pa","pb","pc","pd","v3","initFromArray","getPoint","k","getControlPointsArray","coords","getLength","nSubDivisions","nSamples","oldIntPoint","oldPosition","tmpVec","chunkLengths","totalLength","chunks","total","reparametrizeByArcLength","samplingCoef","indexCurrent","indexNext","realDistance","sampling","newpoints","sl","push","Triangle","resultLengthSq","barycoordFromPoint","dot00","dot01","dot02","dot11","dot12","denom","invDenom","u","setFromPointsAndIndices","i0","i1","i2","triangle","area","midpoint","Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","_cachedIndex","valueSize","evaluate","pp","validate_interval","seek","linear_scan","forward_scan","giveUpAt","afterEnd_","t1global","beforeStart_","mid","intervalChanged_","interpolate_","settings","DefaultSettings_","getSettings_","copySampleValue_","values","stride","CubicInterpolant","_weightPrev","_offsetPrev","_weightNext","_offsetNext","create","endingStart","endingEnd","iPrev","iNext","tPrev","tNext","halfDt","o1","o0","oP","oN","wP","wN","ppp","sP","sN","DiscreteInterpolant","LinearInterpolant","offset1","offset0","weight1","weight0","QuaternionLinearInterpolant","Clock","autoStart","startTime","oldTime","elapsedTime","running","performance","now","stop","getElapsedTime","getDelta","newTime","EventDispatcher","apply","addEventListener","hasEventListener","removeEventListener","dispatchEvent","type","listener","_listeners","listeners","indexOf","listenerArray","splice","event","Layers","mask","channel","enable","toggle","disable","test","layers","ascSort","intersectObject","raycaster","intersects","recursive","visible","raycast","children","Raycaster","params","Mesh","Line","LOD","Points","threshold","Sprite","defineProperties","PointCloud","linePrecision","setFromCamera","PerspectiveCamera","OrthographicCamera","sort","intersectObjects","objects","isArray","Object3D","onRotationChange","rotation","onQuaternionChange","Object3DIdCount","parent","DefaultUp","modelViewMatrix","rotationAutoUpdate","matrixAutoUpdate","DefaultMatrixAutoUpdate","matrixWorldNeedsUpdate","castShadow","receiveShadow","frustumCulled","renderOrder","userData","applyMatrix","setRotationFromAxisAngle","setRotationFromEuler","setRotationFromMatrix","setRotationFromQuaternion","rotateOnAxis","q1","rotateX","rotateY","rotateZ","translateOnAxis","translateX","translateY","translateZ","localToWorld","worldToLocal","remove","getObjectById","getObjectByProperty","getObjectByName","child","getWorldPosition","getWorldQuaternion","getWorldRotation","getWorldScale","getWorldDirection","traverseVisible","traverseAncestors","updateMatrix","force","toJSON","meta","extractFromCache","cache","key","data","metadata","isRootObject","output","geometries","materials","textures","images","version","generator","JSON","stringify","material","source","parse","Face3","materialIndex","vertexNormals","vertexColors","BufferAttribute","dynamic","updateRange","count","needsUpdate","setDynamic","copyAt","index1","index2","copyArray","copyColorsArray","colors","copyIndicesArray","indices","copyVector2sArray","vectors","copyVector3sArray","copyVector4sArray","getW","setXY","setXYZW","Int8Attribute","Int8Array","Uint8Attribute","Uint8Array","Uint8ClampedAttribute","Uint8ClampedArray","Int16Attribute","Int16Array","Uint16Attribute","Uint16Array","Int32Attribute","Int32Array","Uint32Attribute","Uint32Array","Float32Attribute","Float64Attribute","Float64Array","DynamicBufferAttribute","InstancedBufferAttribute","meshPerAttribute","InterleavedBuffer","InstancedInterleavedBuffer","InterleavedBufferAttribute","interleavedBuffer","Geometry","GeometryIdCount","vertices","faces","faceVertexUvs","morphTargets","morphNormals","skinWeights","skinIndices","lineDistances","verticesNeedUpdate","elementsNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","vertex","face","jl","obj","fromBufferGeometry","addFace","normals","tempNormals","uvs","tempUVs","uvs2","tempUVs2","attributes","positions","uv","uv2","groups","group","computeFaceNormals","cb","ab","fl","vA","vB","vC","computeVertexNormals","areaWeighted","vl","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","faceNormal","dstNormalsFace","dstNormalsVertex","computeTangents","computeLineDistances","merge","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","uvs1","vertexCopy","faceCopy","faceVertexNormals","faceVertexColors","uvCopy","mergeMesh","mesh","mergeVertices","verticesMap","unique","changes","precisionPoints","precision","faceIndicesToRemove","dupIndex","idx","sortFacesByMaterialIndex","materialIndexSort","_id","newUvs1","newUvs2","setBit","enabled","getNormalIndex","hash","normalsHash","getColorIndex","colorsHash","getUvIndex","uvsHash","parameters","hasMaterial","hasFaceUv","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","hasFaceVertexColor","faceType","uvsCopy","kl","dispose","DirectGeometry","computeGroups","fromGeometry","morphTargetsPosition","hasFaceVertexUv2","morphTargetsLength","morphTargetsNormal","morphNormalsLength","hasSkinIndices","hasSkinWeights","vertexUvs","morphTarget","morphNormal","BufferGeometry","morphAttributes","drawRange","getIndex","setIndex","addAttribute","getAttribute","removeAttribute","addGroup","clearGroups","setDrawRange","updateFromObject","direct","__directGeometry","lineDistance","fromDirectGeometry","TypeArray","isNaN","pA","pB","pC","normalizeNormals","attribute1","attributeArray1","attribute2","attributeArray2","attributeSize","toNonIndexed","geometry2","array2","MaxIndex","InstancedBufferGeometry","maxInstancedCount","instances","Uniform","onUpdate","onUpdateCallback","AnimationClip","duration","tracks","resetDuration","trim","optimize","track","times","json","jsonTracks","frameTime","fps","KeyframeTrack","clip","clipTracks","CreateFromMorphTargetSequence","morphTargetSequence","numMorphTargets","AnimationUtils","getKeyframeOrder","sortedArray","NumberKeyframeTrack","findByName","clipArray","CreateClipsFromMorphTargetSequences","animationToMorphTargets","pattern","parts","animationMorphTargets","clips","parseAnimation","animation","bones","nodeName","addNonemptyTrack","trackType","trackName","animationKeys","propertyName","destTracks","flattenJSON","clipName","hierarchyTracks","hierarchy","morphTargetNames","morphTargetName","animationKey","time","boneName","VectorKeyframeTrack","QuaternionKeyframeTrack","AnimationMixer","root","_root","_initMemoryManager","_accuIndex","timeScale","clipAction","optionalRoot","prototypeAction","rootUuid","clipObject","actionsForClip","_actionsByClip","existingAction","actionByRoot","knownActions","_clip","newAction","_Action","_bindAction","_addInactiveAction","stopAllAction","actions","_actions","nActions","_nActiveActions","bindings","_bindings","nBindings","_nActiveBindings","reset","useCount","deltaTime","timeDirection","accuIndex","action","_update","getRoot","uncacheClip","actionsByClip","actionsToRemove","_deactivateAction","cacheIndex","_cacheIndex","lastInactiveAction","_byClipCacheIndex","pop","_removeInactiveBindingsForAction","uncacheRoot","_removeInactiveAction","bindingsByRoot","_bindingsByRootAndName","bindingByName","binding","restoreOriginalState","_removeInactiveBinding","uncacheAction","mixer","localRoot","_mixer","_localRoot","nTracks","interpolants","interpolantSettings","interpolant","createInterpolant","_interpolantSettings","_interpolants","_propertyBindings","_timeScaleInterpolant","_weightInterpolant","loop","_loopCount","_startTime","_effectiveTimeScale","_effectiveWeight","repetitions","paused","clampWhenFinished","zeroSlopeAtStart","zeroSlopeAtEnd","play","_activateAction","stopFading","stopWarping","isRunning","_isActiveAction","isScheduled","startAt","setLoop","mode","setEffectiveWeight","getEffectiveWeight","fadeIn","_scheduleFading","fadeOut","crossFadeFrom","fadeOutAction","warp","fadeInDuration","fadeOutDuration","startEndRatio","endStartRatio","crossFadeTo","fadeInAction","weightInterpolant","_takeBackControlInterpolant","setEffectiveTimeScale","getEffectiveTimeScale","setDuration","syncWith","halt","_currentTimeScale","startTimeScale","endTimeScale","_lendControlInterpolant","timeScaleInterpolant","getMixer","getClip","timeRunning","_updateTimeScale","clipTime","_updateTime","_updateWeight","propertyMixers","accumulate","interpolantValue","pause","loopCount","pingPong","_setEndings","loopDelta","pending","atStart","atEnd","weightNow","weightThen","bindingsByName","referenceCount","_addInactiveBinding","path","parsedPath","PropertyMixer","PropertyBinding","ValueTypeName","getValueSize","_lendBinding","saveOriginalState","_lendAction","_takeBackBinding","_takeBackAction","_controlInterpolants","_nActiveControlInterpolants","stats","inUse","controlInterpolants","knownActionsForClip","lastKnownAction","byClipCacheIndex","prevIndex","lastActiveIndex","firstInactiveAction","firstInactiveIndex","lastActiveAction","propBinding","rootNode","lastInactiveBinding","remove_empty_map","_","firstInactiveBinding","lastActiveBinding","_controlInterpolantsResultBuffer","__cacheIndex","lastActiveInterpolant","AnimationObjectGroup","var_args","_objects","nCachedObjects_","_indicesByUUID","_paths","_parsedPaths","_bindingsIndicesByPath","bindingsPerObject","nObjects","nCachedObjects","indicesByUUID","paths","parsedPaths","knownObject","firstActiveIndex","lastCachedObject","bindingsForPath","lastCached","lastCachedIndex","firstActiveObject","firstActive","uncache","lastIndex","lastObject","last","subscribe_","indicesByPath","unsubscribe_","lastBindingsIndex","lastBindings","lastBindingsPath","arraySlice","from","isTypedArray","subarray","convertArray","forceClone","BYTES_PER_ELEMENT","ArrayBuffer","isView","DataView","compareTime","nValues","srcOffset","jsonKeys","valuePropertyName","interpolation","TimeBufferType","ValueBufferType","setInterpolation","DefaultInterpolation","validate","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","InterpolantFactoryMethodSmooth","factoryMethod","message","getInterpolation","shift","timeOffset","endTime","nKeys","valid","prevTime","currTime","writeIndex","keep","timeNext","offsetP","offsetN","readOffset","writeOffset","_getTrackTypeForValueTypeName","typeName","toLowerCase","ColorKeyframeTrack","BooleanKeyframeTrack","StringKeyframeTrack","parseTrackName","findNode","getValue","targetArray","bind","setValue","sourceArray","targetObject","objectName","propertyIndex","_getValue_unavailable","_setValue_unavailable","objectIndex","skeleton","nodeProperty","versioning","Versioning","None","NeedsUpdate","MatrixWorldNeedsUpdate","bindingType","BindingType","Direct","ArrayElement","resolvedProperty","HasFromToArray","EntireArray","GetterByBindingType","SetterByBindingTypeAndVersioning","unbind","_getValue_unbound","_setValue_unbound","dest","Composite","targetGroup","optionalParsedPath","_targetGroup","firstValidIndex","re","matches","results","searchSkeleton","bone","searchNodeSubtree","childNode","subTreeNode","mixFunction","bufferType","_slerp","_select","_lerp","_mixBufferRegion","cumulativeWeight","currentWeight","mix","originalValueOffset","IntepolateDiscrete","Audio","context","createBufferSource","onended","onEnded","gain","createGain","connect","getInput","autoplay","playbackRate","isPlaying","hasPlaybackControl","sourceType","filter","getOutput","load","file","AudioBuffer","setBuffer","setNodeSource","audioNode","audioBuffer","onReady","currentTime","disconnect","getFilter","setFilter","setPlaybackRate","getPlaybackRate","getLoop","setVolume","getVolume","AudioAnalyser","audio","fftSize","analyser","createAnalyser","frequencyBinCount","getData","getByteFrequencyData","ready","readyCallbacks","request","XMLHttpRequest","open","responseType","onload","decodeAudioData","response","send","PositionalAudio","panner","createPanner","setRefDistance","refDistance","getRefDistance","setRolloffFactor","rolloffFactor","getRolloffFactor","setDistanceModel","distanceModel","getDistanceModel","setMaxDistance","maxDistance","getMaxDistance","AudioListener","window","AudioContext","webkitAudioContext","destination","removeFilter","setMasterVolume","getMasterVolume","orientation","setOrientation","Camera","matrixWorldInverse","CubeCamera","cubeResolution","cameraPX","cameraNX","cameraPY","cameraNY","cameraPZ","cameraNZ","options","format","magFilter","minFilter","renderTarget","WebGLRenderTargetCube","updateCubeMap","scene","generateMipmaps","texture","activeCubeFace","render","setRenderTarget","zoom","updateProjectionMatrix","cx","cy","focalLength","setLens","frameHeight","atan","setViewOffset","fullWidth","fullHeight","StereoCamera","cameraL","cameraR","eyeRight","eyeLeft","eyeSep","eyeSepOnProjection","Light","intensity","groundColor","decay","penumbra","LightShadow","bias","mapSize","map","AmbientLight","DirectionalLight","shadow","HemisphereLight","skyColor","PointLight","power","SpotLight","Cache","files","clear","Loader","onLoadStart","onLoadProgress","onLoadComplete","crossOrigin","extractUrlBase","url","initMaterials","texturePath","createMaterial","textureLoader","materialLoader","loadTexture","repeat","wrap","anisotropy","fullPath","loader","Handlers","setCrossOrigin","wrapS","wrapT","TextureLoader","MaterialLoader","blending","specular","emissive","shininess","mapDiffuseRepeat","mapDiffuseOffset","mapDiffuseWrap","mapDiffuseAnisotropy","lightMap","mapLightRepeat","mapLightOffset","mapLightWrap","mapLightAnisotropy","aoMap","mapAORepeat","mapAOOffset","mapAOWrap","mapAOAnisotropy","bumpMap","mapBumpRepeat","mapBumpOffset","mapBumpWrap","mapBumpAnisotropy","bumpScale","normalMap","mapNormalRepeat","mapNormalOffset","mapNormalWrap","mapNormalAnisotropy","normalScale","specularMap","mapSpecularRepeat","mapSpecularOffset","mapSpecularWrap","mapSpecularAnisotropy","alphaMap","mapAlphaRepeat","mapAlphaOffset","mapAlphaWrap","mapAlphaAnisotropy","side","opacity","transparent","setTextures","handlers","regex","XHRLoader","manager","DefaultLoadingManager","onLoad","onProgress","onError","cached","setTimeout","overrideMimeType","status","itemEnd","itemError","withCredentials","itemStart","setPath","setResponseType","setWithCredentials","FontLoader","Font","substring","ImageLoader","image","createElement","src","JSONLoader","statusDomElement","_statusDomElement","setTexturePath","parseModel","isBitSet","fi","zLength","colorIndex","normalIndex","uvIndex","isQuad","faceA","faceB","uvLayer","nUvLayers","parseSkin","influencesPerVertex","parseMorphing","dstVertices","srcVertices","morphColors","parseAnimations","outputAnimations","animations","concat","morphAnimationClips","LoadingManager","isLoading","itemsLoaded","itemsTotal","onStart","BufferGeometryLoader","TYPED_ARRAYS","typedArray","drawcalls","offsets","getTexture","roughness","metalness","uniforms","vertexShader","fragmentShader","shading","alphaTest","depthTest","depthWrite","colorWrite","wireframe","wireframeLinewidth","sizeAttenuation","displacementMap","displacementScale","displacementBias","roughnessMap","metalnessMap","emissiveMap","emissiveIntensity","envMap","combine","reflectivity","lightMapIntensity","aoMapIntensity","ObjectLoader","lastIndexOf","parseGeometries","parseImages","parseTextures","parseMaterials","parseObject","geometryLoader","bufferGeometryLoader","widthSegments","heightSegments","depth","depthSegments","segments","thetaStart","thetaLength","radiusTop","radiusBottom","radialSegments","openEnded","phiStart","phiLength","DodecahedronGeometry","detail","IcosahedronGeometry","OctahedronGeometry","TetrahedronGeometry","innerRadius","outerRadius","thetaSegments","phiSegments","tube","tubularSegments","arc","LatheGeometry","loadImage","parseConstant","Texture","mapping","getGeometry","getMaterial","Scene","SkinnedMesh","Group","levels","level","addLevel","CubeTextureLoader","urls","CubeTexture","DataTextureLoader","BinaryTextureLoader","_parser","DataTexture","texData","mipmaps","mipmapCount","CompressedTextureLoader","texDatas","CompressedTexture","isCubemap","Material","MaterialIdCount","blendSrc","blendDst","blendEquation","blendSrcAlpha","blendDstAlpha","blendEquationAlpha","depthFunc","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","premultipliedAlpha","overdraw","_needsUpdate","setValues","newValue","currentValue","isRoot","LineBasicMaterial","linewidth","linecap","linejoin","fog","LineDashedMaterial","dashSize","gapSize","MeshBasicMaterial","refractionRatio","wireframeLinecap","wireframeLinejoin","skinning","MeshLambertMaterial","MeshPhongMaterial","MeshStandardMaterial","envMapIntensity","MeshDepthMaterial","MeshNormalMaterial","MultiMaterial","PointsMaterial","ShaderMaterial","defines","lights","extensions","derivatives","fragDepth","drawBuffers","shaderTextureLOD","defaultAttributeValues","index0AttributeName","UniformsUtils","RawShaderMaterial","SpriteMaterial","TextureIdCount","sourceFile","DEFAULT_IMAGE","DEFAULT_MAPPING","premultiplyAlpha","flipY","unpackAlignment","encoding","getDataURL","canvas","toDataURL","getContext","drawImage","transformUv","CanvasTexture","VideoTexture","video","requestAnimationFrame","readyState","HAVE_ENOUGH_DATA","inverseMatrix","testPoint","rayPointDistanceSq","localThresholdSq","intersectPoint","distanceToRay","localThreshold","LineSegments","precisionSq","vStart","vEnd","interSegment","interRay","step","distSq","faceIndex","nbVertices","LineStrip","LinePieces","drawMode","updateMorphTargets","setDrawMode","morphTargetBase","morphTargetInfluences","morphTargetDictionary","ml","getMorphTargetIndexByName","uvIntersection","uv1","uv3","barycoord","checkIntersection","intersectionPointWorld","checkBufferGeometryIntersection","intersection","intersectionPoint","uvA","uvB","uvC","tempA","tempB","tempC","fvA","fvB","fvC","isFaceMaterial","faceMaterial","morphInfluences","tl","influence","targets","uvs_f","Bone","skin","Skeleton","boneInverses","useVertexTexture","identityMatrix","boneTextureWidth","boneTextureHeight","boneMatrices","boneTexture","calculateInverses","bl","pose","offsetMatrix","bindMode","bindMatrix","bindMatrixInverse","gbone","pos","rotq","scl","normalizeSkinWeights","sw","vec","skinWeight","getObjectForDistance","matrixPosition","guessSizeSq","Particle","LensFlare","lensFlares","positionScreen","customUpdateCallback","updateLensFlares","flare","vecX","vecY","wantedRotation","overrideMaterial","autoUpdate","Fog","FogExp2","density","ShaderChunk","merged","uniforms_src","uniforms_dst","parameter_src","UniformsLib","common","diffuse","offsetRepeat","flipEnvMap","aomap","lightmap","emissivemap","bumpmap","normalmap","displacementmap","roughnessmap","metalnessmap","fogDensity","fogNear","fogFar","fogColor","ambientLightColor","directionalLights","properties","shadowBias","shadowRadius","shadowMapSize","directionalShadowMap","directionalShadowMatrix","spotLights","coneCos","penumbraCos","spotShadowMap","spotShadowMatrix","pointLights","pointShadowMap","pointShadowMatrix","hemisphereLights","ShaderLib","basic","lambert","phong","standard","dashed","totalSize","mNear","mFar","cube","tCube","tFlip","equirect","tEquirect","depthRGBA","distanceRGBA","lightPos","getTargetPixelRatio","_currentRenderTarget","_pixelRatio","glClearColor","_premultipliedAlpha","state","clearColor","setDefaultGLState","init","scissor","_currentScissor","_scissor","viewport","_currentViewport","_viewport","_clearColor","_clearAlpha","resetGLState","_currentProgram","_currentCamera","_currentGeometryProgram","_currentMaterialId","onContextLost","preventDefault","onTextureDispose","deallocateTexture","_infoMemory","onRenderTargetDispose","deallocateRenderTarget","onMaterialDispose","deallocateMaterial","textureProperties","__image__webglTextureCube","_gl","deleteTexture","__webglInit","__webglTexture","renderTargetProperties","deleteFramebuffer","__webglFramebuffer","deleteRenderbuffer","__webglDepthbuffer","releaseMaterialProgramReference","programInfo","program","programCache","releaseProgram","setupVertexAttributes","startIndex","extension","initAttributes","geometryAttributes","programAttributes","getAttributes","materialDefaultAttributeValues","programAttribute","geometryAttribute","getAttributeBuffer","enableAttributeAndDivisor","enableAttribute","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","FLOAT","vertexAttrib2fv","vertexAttrib3fv","vertexAttrib4fv","vertexAttrib1fv","disableUnusedAttributes","absNumericalSort","painterSortStable","reversePainterSortStable","pushRenderItem","transparentObjects","transparentObjectsLastIndex","opaqueObjects","opaqueObjectsLastIndex","renderItem","_vector3","projectObject","_frustum","sprites","ImmediateRenderObject","_this","sortObjects","_projScreenMatrix","groupMaterial","renderObjects","renderList","setMaterial","setProgram","renderBufferImmediate","renderBufferDirect","initMaterial","materialProperties","getParameters","_lights","code","getProgramCode","programChange","shaderID","shader","__webglShader","acquireProgram","numSupportedMorphTargets","maxMorphTargets","numSupportedMorphNormals","maxMorphNormals","uniformsList","uniformLocations","getUniforms","location","lightsHash","ambient","directional","spot","hemi","hasDynamicUniforms","uniform","setMaterialFaces","setBlending","setDepthFunc","setDepthTest","setDepthWrite","setColorWrite","setPolygonOffset","CULL_FACE","setFlipSided","_usedTextureUnits","refreshProgram","refreshMaterial","refreshLights","p_uniforms","m_uniforms","useProgram","uniformMatrix4fv","capabilities","logarithmicDepthBuffer","uniform1f","logDepthBufFC","cameraPosition","uniform3f","viewMatrix","toneMappingExposure","toneMappingWhitePoint","floatVertexTextures","textureUnit","getTextureUnit","uniform1i","setTexture","boneGlobalMatrices","markUniformsLightsNeedsUpdate","refreshUniformsFog","refreshUniformsCommon","refreshUniformsLine","refreshUniformsDash","refreshUniformsPoints","refreshUniformsLambert","refreshUniformsPhong","refreshUniformsStandard","loadUniformsGeneric","loadUniformsMatrices","modelMatrix","updateDynamicUniforms","dynamicUniforms","uvScaleMap","WebGLRenderTarget","_canvas","clientHeight","uniformMatrix3fv","maxTextures","loadUniform","uniform2f","uniform4f","uniform1iv","uniform3iv","uniform1fv","uniform2fv","uniform3fv","uniform4fv","uniformMatrix2fv","property","locationProperty","valueProperty","_array","i3","i4","setCubeTexture","setCubeTextureDynamic","setupLights","ll","light","directionalLength","pointLength","spotLength","hemiLength","shadowsLength","shadowsPointLight","lightCache","shadows","setTextureParameters","textureType","isPowerOfTwoImage","texParameteri","TEXTURE_WRAP_S","paramThreeToGL","TEXTURE_WRAP_T","TEXTURE_MAG_FILTER","TEXTURE_MIN_FILTER","CLAMP_TO_EDGE","filterFallback","__currentAnisotropy","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","getMaxAnisotropy","uploadTexture","slot","createTexture","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","pixelStorei","UNPACK_FLIP_Y_WEBGL","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_ALIGNMENT","clampToMaxSize","maxTextureSize","textureNeedsPowerOfTwo","makePowerOfTwo","glFormat","glType","mipmap","texImage2D","getCompressedTextureFormats","compressedTexImage2D","generateMipmap","__version","maxSize","HTMLImageElement","HTMLCanvasElement","TEXTURE_CUBE_MAP","isCompressed","isDataTexture","cubeImage","autoScaleCubemaps","maxCubemapSize","TEXTURE_CUBE_MAP_POSITIVE_X","setupFrameBufferTexture","framebuffer","attachment","textureTarget","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","setupRenderBufferStorage","renderbuffer","bindRenderbuffer","RENDERBUFFER","depthBuffer","stencilBuffer","renderbufferStorage","DEPTH_COMPONENT16","framebufferRenderbuffer","DEPTH_ATTACHMENT","DEPTH_STENCIL","DEPTH_STENCIL_ATTACHMENT","RGBA4","setupDepthRenderbuffer","isCube","createRenderbuffer","setupRenderTarget","isTargetPowerOfTwo","createFramebuffer","COLOR_ATTACHMENT0","updateRenderTargetMipmap","NEAREST","LINEAR","REPEAT","MIRRORED_REPEAT","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","UNSIGNED_BYTE","UNSIGNED_SHORT_4_4_4_4","UNSIGNED_SHORT_5_5_5_1","UNSIGNED_SHORT_5_6_5","BYTE","SHORT","UNSIGNED_SHORT","INT","UNSIGNED_INT","HALF_FLOAT_OES","ALPHA","RGB","RGBA","LUMINANCE","LUMINANCE_ALPHA","FUNC_ADD","FUNC_SUBTRACT","FUNC_REVERSE_SUBTRACT","ZERO","ONE","SRC_COLOR","ONE_MINUS_SRC_COLOR","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","DST_ALPHA","ONE_MINUS_DST_ALPHA","DST_COLOR","ONE_MINUS_DST_COLOR","SRC_ALPHA_SATURATE","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","COMPRESSED_RGB_PVRTC_2BPPV1_IMG","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","COMPRESSED_RGBA_PVRTC_2BPPV1_IMG","COMPRESSED_RGB_ETC1_WEBGL","MIN_EXT","MAX_EXT","_context","_alpha","_depth","_stencil","stencil","_antialias","antialias","_preserveDrawingBuffer","preserveDrawingBuffer","domElement","autoClear","autoClearColor","autoClearDepth","autoClearStencil","gammaInput","gammaOutput","physicallyCorrectLights","toneMapping","_currentFramebuffer","_currentScissorTest","_width","_height","_scissorTest","_infoRender","calls","info","memory","programs","getShaderPrecisionFormat","rangeMin","rangeMax","WebGLExtensions","WebGLCapabilities","WebGLState","WebGLProperties","WebGLObjects","WebGLPrograms","WebGLLights","bufferRenderer","WebGLBufferRenderer","indexedBufferRenderer","WebGLIndexedBufferRenderer","shadowMap","WebGLShadowMap","spritePlugin","SpritePlugin","lensFlarePlugin","LensFlarePlugin","getContextAttributes","forceContextLoss","loseContext","MAX_TEXTURE_MAX_ANISOTROPY_EXT","getPrecision","getPixelRatio","setPixelRatio","setSize","getSize","updateStyle","setViewport","setScissor","setScissorTest","boolean","getClearColor","setClearColor","getClearAlpha","setClearAlpha","bits","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","clearStencil","clearTarget","buffers","hasPositions","createBuffer","hasNormals","hasUvs","hasColors","bufferData","positionArray","DYNAMIC_DRAW","normalArray","nx","ny","nz","uvArray","colorArray","drawArrays","TRIANGLES","updateBuffers","geometryProgram","activeInfluences","getWireframeAttribute","ELEMENT_ARRAY_BUFFER","dataStart","dataCount","rangeStart","rangeCount","groupStart","groupCount","drawStart","drawEnd","drawCount","setLineWidth","setMode","LINES","TRIANGLE_STRIP","TRIANGLE_FAN","lineWidth","LINE_STRIP","POINTS","renderInstances","forceClear","setFaceCulling","cullFace","frontFaceDirection","frontFace","CW","CCW","BACK","FRONT","FRONT_AND_BACK","complete","getCurrentRenderTarget","scissorTest","activeMipMapLevel","readRenderTargetPixels","restore","IMPLEMENTATION_COLOR_READ_FORMAT","IMPLEMENTATION_COLOR_READ_TYPE","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","readPixels","drawArraysInstancedANGLE","drawElements","drawElementsInstancedANGLE","gl","getExtension","getMaxPrecision","VERTEX_SHADER","HIGH_FLOAT","FRAGMENT_SHADER","MEDIUM_FLOAT","MAX_TEXTURE_IMAGE_UNITS","maxVertexTextures","MAX_VERTEX_TEXTURE_IMAGE_UNITS","MAX_TEXTURE_SIZE","MAX_CUBE_MAP_TEXTURE_SIZE","maxAttributes","MAX_VERTEX_ATTRIBS","maxVertexUniforms","MAX_VERTEX_UNIFORM_VECTORS","maxVaryings","MAX_VARYING_VECTORS","maxFragmentUniforms","MAX_FRAGMENT_UNIFORM_VECTORS","vertexTextures","floatFragmentTextures","_maxPrecision","WebGLGeometries","onGeometryDispose","buffergeometry","_bufferGeometry","deleteAttribute","deleteAttributes","bufferproperty","__webglBuffer","deleteBuffer","removeAttributeBuffer","updateAttribute","attributeProperties","updateBuffer","usage","STATIC_DRAW","bufferSubData","edges","checkEdge","list","WebGLProgram","getEncodingComponents","getTexelDecodingFunction","functionName","getTexelEncodingFunction","getToneMappingFunction","toneMappingName","generateExtensions","rendererExtensions","envMapCubeUV","flatShading","filterEmptyLine","generateDefines","fetchUniformLocations","identifiers","getProgramParameter","ACTIVE_UNIFORMS","getActiveUniform","getUniformLocation","structRe","structName","structProperty","uniformsStruct","arrayStructRe","arrayName","arrayIndex","arrayProperty","uniformsArray","uniformsArrayIndex","arrayRe","fetchAttributeLocations","ACTIVE_ATTRIBUTES","getActiveAttrib","getAttribLocation","replaceLightNums","replace","numDirLights","numSpotLights","numPointLights","numHemiLights","parseIncludes","include","unrollLoops","snippet","unroll","programIdCount","shadowMapTypeDefine","shadowMapType","envMapTypeDefine","envMapModeDefine","envMapBlendingDefine","prefixVertex","prefixFragment","gammaFactorDefine","customExtensions","customDefines","createProgram","supportsVertexTextures","maxBones","doubleSided","flipSided","shadowMapEnabled","pointLightShadows","useFog","fogExp","outputEncoding","mapEncoding","envMapEncoding","emissiveMapEncoding","vertexGlsl","fragmentGlsl","glVertexShader","WebGLShader","glFragmentShader","attachShader","bindAttribLocation","linkProgram","programLog","getProgramInfoLog","vertexLog","getShaderInfoLog","fragmentLog","runnable","haveDiagnostics","LINK_STATUS","getError","VALIDATE_STATUS","diagnostics","prefix","deleteShader","cachedUniforms","cachedAttributes","destroy","deleteProgram","usedTimes","allocateBones","nVertexUniforms","nVertexMatrices","getTextureEncodingFromMap","gammaOverrideLinear","shaderIDs","parameterNames","envMapMode","parameterName","pl","addLineNumbers","lines","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","_renderer","getDepthMaterial","isPointLight","lightPositionWorld","newMaterial","materialVariants","_depthMaterials","customMaterial","customDepthMaterial","_distanceMaterials","customDistanceMaterial","useMorphing","useSkinning","variantIndex","_MorphingFlag","_SkinningFlag","shadowCamera","_renderList","_state","_shadowMapSize","_lookTarget","_lightPositionWorld","_NumberOfMaterialVariants","cubeDirections","cubeUps","cube2DViewPorts","depthShader","depthUniforms","distanceShader","distanceUniforms","depthMaterial","distanceMaterial","USE_SHADOWMAP","faceCount","BLEND","vpWidth","vpHeight","pars","shadowMatrix","vpDimensions","clearAlpha","newAttributes","enabledAttributes","attributeDivisors","compressedTextureFormats","currentBlending","currentBlendEquation","currentBlendSrc","currentBlendDst","currentBlendEquationAlpha","currentBlendSrcAlpha","currentBlendDstAlpha","currentPremultipledAlpha","currentDepthFunc","currentDepthWrite","currentColorWrite","currentStencilWrite","currentStencilFunc","currentStencilRef","currentStencilMask","currentStencilFail","currentStencilZFail","currentStencilZPass","currentFlipSided","currentLineWidth","currentPolygonOffsetFactor","currentPolygonOffsetUnits","currentScissorTest","currentTextureSlot","currentBoundTextures","currentClearColor","currentClearDepth","currentClearStencil","currentScissor","currentViewport","emptyTexture","DEPTH_TEST","LEQUAL","blendFunc","enableVertexAttribArray","vertexAttribDivisorANGLE","disableVertexAttribArray","formats","COMPRESSED_TEXTURE_FORMATS","blendEquationSeparate","blendFuncSeparate","NEVER","ALWAYS","LESS","EQUAL","GEQUAL","GREATER","NOTEQUAL","depthMask","colorMask","setStencilFunc","stencilFunc","stencilRef","stencilMask","setStencilOp","stencilFail","stencilZFail","stencilZPass","stencilOp","setStencilTest","stencilTest","STENCIL_TEST","setStencilWrite","stencilWrite","factor","units","POLYGON_OFFSET_FILL","getScissorTest","SCISSOR_TEST","webglSlot","webglType","webglTexture","boundTexture","flares","vertexBuffer","elementBuffer","tempTexture","occlusionTexture","hasVertexTexture","renderType","occlusionMap","screenPosition","tempPosition","invAspect","halfViewportWidth","halfViewportHeight","screenPositionPixels","TEXTURE1","copyTexImage2D","sprite","uvOffset","uvScale","fogType","fillStyle","fillRect","spritePosition","spriteRotation","spriteScale","oldFogType","sceneFogType","isIntersectionBox","isIntersectionSphere","multiplyVector3","multiplyVector3Array","extractPosition","multiplyVector4","rotateAxis","crossVector","rotateByAxis","isIntersectionLine","isIntersectionPlane","setEulerFromRotationMatrix","setEulerFromQuaternion","getPositionFromMatrix","getScaleFromMatrix","getColumnFromMatrix","Face4","Vertex","eulerOrder","getChildByName","renderDepth","useQuaternion","ParticleSystem","onlyShadow","shadowCameraFov","shadowCameraLeft","shadowCameraRight","shadowCameraTop","shadowCameraBottom","shadowCameraNear","shadowCameraFar","shadowCameraVisible","shadowDarkness","shadowMapWidth","shadowMapHeight","addIndex","addDrawCall","indexOffset","clearDrawCalls","computeOffsets","wrapAround","wrapRGB","PointCloudMaterial","ParticleBasicMaterial","ParticleSystemMaterial","metal","supportsFloatTextures","supportsHalfFloatTextures","supportsStandardDerivatives","supportsCompressedTextureS3TC","supportsCompressedTexturePVRTC","supportsBlendMinMax","supportsInstancedArrays","enableScissorTest","addPrePlugin","addPostPlugin","updateShadowMap","shadowMapCullFace","GeometryUtils","geometry1","ImageUtils","loadTextureCube","loadCompressedTexture","loadCompressedTextureCube","Projector","projectVector","unprojectVector","pickingRay","CanvasRenderer","MeshFaceMaterial","CurveUtils","tangentQuadraticBezier","tangentCubicBezier","tangentSpline","h00","h10","h01","h11","SceneUtils","createMultiMaterialObject","detach","attach","ShapeUtils","contour","triangulate","snip","verts","px","py","aX","aY","bX","bY","cX","cY","apx","apy","bpx","bpy","cpx","cpy","cCROSSap","bCROSScp","aCROSSbp","vertIndices","nv","triangulateShape","holes","point_in_segment_2D_colin","inSegPt1","inSegPt2","inOtherPt","intersect_segments_2D","inSeg1Pt1","inSeg1Pt2","inSeg2Pt1","inSeg2Pt2","inExcludeAdjacentSegs","seg1dx","seg1dy","seg2dx","seg2dy","seg1seg2dx","seg1seg2dy","limit","perpSeg1","perpSeg2","factorSeg1","seg1Pt","seg2Pt","seg1min","seg1max","seg1minVal","seg1maxVal","seg2min","seg2max","seg2minVal","seg2maxVal","isPointInsideAngle","inVertex","inLegFromPt","inLegToPt","legFromPtX","legFromPtY","legToPtX","legToPtY","otherPtX","otherPtY","from2toAngle","from2otherAngle","other2toAngle","removeHoles","isCutLineInsideAngles","inShapeIdx","inHoleIdx","lastShapeIdx","shape","prevShapeIdx","nextShapeIdx","insideAngle","hole","lastHoleIdx","prevHoleIdx","nextHoleIdx","intersectsShapeEdge","inShapePt","inHolePt","sIdx","nextIdx","intersectsHoleEdge","ihIdx","chkHole","hIdx","indepHoles","holeIndex","shapeIndex","shapePt","holePt","holeIdx","cutKey","tmpShape1","tmpShape2","tmpHole1","tmpHole2","failedCuts","hl","minShapeIndex","counter","h2","allPointsMap","allpoints","shapeWithoutHoles","triangles","isClockWise","pts","b2p0","b2p1","b2p2","b3","b3p0","b3p1","b3p2","b3p3","Curve","getPointAt","getUtoTmapping","getPoints","divisions","getSpacedPoints","lengths","getLengths","cacheArcLengths","current","sum","updateArcLengths","targetArcLength","arcLengths","comparison","lengthBefore","lengthAfter","segmentLength","segmentFraction","getTangent","pt1","pt2","getTangentAt","getPointFunc","CurvePath","curves","autoClose","curve","closePath","startPoint","endPoint","LineCurve","curveLengths","getCurveLengths","lens","cacheLengths","sums","createPointsGeometry","createGeometry","createSpacedPointsGeometry","generateShapes","createPaths","String","resolution","ret","createPath","glyph","glyphs","cpx0","cpy0","cpx1","cpy1","cpx2","cpy2","laste","Path","o","outline","_cachedOutline","moveTo","lineTo","quadraticCurveTo","bezierCurveTo","ha","shapes","toShapes","fromPoints","args","lastargs","aCPx","aCPy","QuadraticBezierCurve","aCP1x","aCP1y","aCP2x","aCP2y","CubicBezierCurve","splineThru","npts","SplineCurve","aRadius","aStartAngle","aEndAngle","aClockwise","absarc","absellipse","ellipse","xRadius","yRadius","aRotation","EllipseCurve","lastPoint","item","spts","spline","deltaAngle","tdivisions","isCCW","noHoles","extractSubpaths","inActions","subPaths","lastPath","toShapesNoHoles","inSubpaths","tmpPath","tmpShape","Shape","isPointInsidePolygon","inPt","inPolygon","polyLen","inside","edgeLowPt","edgeHighPt","edgeDx","edgeDy","perpEdge","solid","holesFirst","tmpPoints","betterShapeHoles","newShapes","newShapeHoles","mainIdx","ambiguous","toChange","sLen","sho","ho","hole_unassigned","s2Idx","froms","tos","tmpHoles","extrude","ExtrudeGeometry","makeGeometry","ShapeGeometry","getPointsHoles","holesPts","extractAllPoints","extractPoints","tangent","point0","point1","point2","point3","ArcCurve","LineCurve3","QuadraticBezierCurve3","CubicBezierCurve3","SplineCurve3","CatmullRomCurve3","CubicPoly","pz","c0","initNonuniformCatmullRom","x3","dt0","dt1","dt2","initCatmullRom","tension","calc","closed","ClosedSplineCurve3","BoxGeometry","BoxBufferGeometry","CubeGeometry","calculateVertexCount","buildPlane","udir","vdir","gridX","gridY","segmentWidth","segmentHeight","widthHalf","heightHalf","depthHalf","gridX1","gridY1","vertexCounter","vertexBufferOffset","uvBufferOffset","numberOfVertices","indexBufferOffset","vertexCount","indexCount","CircleGeometry","CircleBufferGeometry","ii","segment","CylinderBufferGeometry","calculateIndexCount","generateTorso","tanTheta","indexRow","halfHeight","indexArray","generateCap","centerIndexStart","centerIndexEnd","CylinderGeometry","EdgesGeometry","thresholdAngle","sortFunction","thresholdDot","edge","vert1","vert2","face1","face2","addShapeList","addShape","scalePt2","pt","getBevelVec","inPrev","inNext","v_trans_x","v_trans_y","shrink_by","v_prev_x","v_prev_y","v_next_x","v_next_y","v_prev_lensq","collinear0","v_prev_len","v_next_len","ptPrevShift_x","ptPrevShift_y","ptNextShift_x","ptNextShift_y","sf","v_trans_lensq","direction_eq","buildLidFaces","bevelEnabled","layer","vlen","flen","f3","steps","bevelSegments","buildSideFaces","layeroffset","sidewalls","ahole","slen1","slen2","f4","shapesOffset","uvgen","generateTopUV","wallContour","stepIndex","stepsLength","contourIndex1","contourIndex2","generateSideWallUV","extrudePts","splineTube","binormal","position2","amount","bevelThickness","bevelSize","curveSegments","extrudePath","extrudeByPath","UVGenerator","WorldUVGenerator","frames","TubeGeometry","FrenetFrames","shapePoints","reverse","bs","vert","contourMovements","oneHoleMovements","holesMovements","verticesMovements","binormals","indexA","indexB","indexC","indexD","LatheBufferGeometry","base","inverseSegments","n1","n2","PlaneGeometry","PlaneBufferGeometry","width_half","height_half","segment_width","segment_height","offset2","RingBufferGeometry","radiusStep","thetaSegmentLevel","RingGeometry","SphereGeometry","SphereBufferGeometry","thetaEnd","verticesRow","v4","TextGeometry","font","TorusBufferGeometry","TorusGeometry","TorusKnotBufferGeometry","calculatePositionOnCurve","cu","su","quOverP","cs","P1","P2","B","T","N","TorusKnotGeometry","heightScale","taper","NoTaper","ip","jp","uva","uvb","uvc","uvd","grid","numpoints","pos2","tangents","SinusoidalTaper","initialNormal3","smallest","MAX_VALUE","tz","mat","PolyhedronGeometry","prepare","that","azimuth","inclination","make","centroid","azi","correctUV","subdivide","cols","aj","bj","rows","ParametricGeometry","func","slices","stacks","sliceCount","WireframeGeometry","numEdges","ol","numTris","AxisHelper","ArrowHelper","lineGeometry","coneGeometry","headLength","headWidth","cone","setDirection","setColor","BoxHelper","BoundingBoxHelper","CameraHelper","addLine","addPoint","pointMap","hexFrustum","hexCone","hexUp","hexTarget","hexCross","setPoint","DirectionalLightHelper","lightPlane","targetLine","EdgesHelper","FaceNormalsHelper","nNormals","objGeometry","GridHelper","setColors","colorCenterLine","colorGrid","HemisphereLightHelper","sphereSize","lightSphere","PointLightHelper","SkeletonHelper","getBoneList","boneList","matrixWorldInv","boneMatrix","SpotLightHelper","vector2","coneLength","coneWidth","VertexNormalsHelper","objPos","objNorm","WireframeHelper","renderCallback","MorphBlendMesh","animationsMap","animationsList","numFrames","startFrame","endFrame","createAnimation","setAnimationWeight","lastFrame","currentFrame","active","directionBackwards","mirroredLoop","autoCreateAnimations","firstAnimation","frameRanges","morph","setAnimationDirectionForward","setAnimationDirectionBackward","setAnimationFPS","setAnimationDuration","setAnimationTime","getAnimationTime","getAnimationDuration","playAnimation","stopAnimation","keyframe"],"mappings":"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","file":"./dist/bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar Three = __webpack_require__(1);\r\n\tvar text = \"hello world!\";\r\n\tvar renderer = new Three.WebGLRenderer();\r\n\trenderer.clearDepth();\r\n\tdocument.getElementById(\"main\").innerText = text;\r\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var self = self || {};// File:src/Three.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tvar THREE = { REVISION: '75' };\r\n\t\r\n\t//\r\n\t\r\n\tif ( true ) {\r\n\t\r\n\t\t!(__WEBPACK_AMD_DEFINE_FACTORY__ = (THREE), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t\r\n\t} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {\r\n\t\r\n\t\tmodule.exports = THREE;\r\n\t\r\n\t}\r\n\t\r\n\t//\r\n\t\r\n\tif ( Number.EPSILON === undefined ) {\r\n\t\r\n\t\tNumber.EPSILON = Math.pow( 2, - 52 );\r\n\t\r\n\t}\r\n\t\r\n\t//\r\n\t\r\n\tif ( Math.sign === undefined ) {\r\n\t\r\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\r\n\t\r\n\t\tMath.sign = function ( x ) {\r\n\t\r\n\t\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\r\n\t\r\n\t\t};\r\n\t\r\n\t}\r\n\t\r\n\tif ( Function.prototype.name === undefined && Object.defineProperty !== undefined ) {\r\n\t\r\n\t\t// Missing in IE9-11.\r\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\r\n\t\r\n\t\tObject.defineProperty( Function.prototype, 'name', {\r\n\t\r\n\t\t\tget: function () {\r\n\t\r\n\t\t\t\treturn this.toString().match( /^\\s*function\\s*(\\S*)\\s*\\(/ )[ 1 ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t} );\r\n\t\r\n\t}\r\n\t\r\n\tif ( Object.assign === undefined ) {\r\n\t\r\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\r\n\t\r\n\t\tObject.defineProperty( Object, 'assign', {\r\n\t\r\n\t\t\twritable: true,\r\n\t\t\tconfigurable: true,\r\n\t\r\n\t\t\tvalue: function ( target ) {\r\n\t\r\n\t\t\t\t'use strict';\r\n\t\r\n\t\t\t\tif ( target === undefined || target === null ) {\r\n\t\r\n\t\t\t\t\tthrow new TypeError( \"Cannot convert first argument to object\" );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar to = Object( target );\r\n\t\r\n\t\t\t\tfor ( var i = 1, n = arguments.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\tvar nextSource = arguments[ i ];\r\n\t\r\n\t\t\t\t\tif ( nextSource === undefined || nextSource === null ) continue;\r\n\t\r\n\t\t\t\t\tnextSource = Object( nextSource );\r\n\t\r\n\t\t\t\t\tvar keysArray = Object.keys( nextSource );\r\n\t\r\n\t\t\t\t\tfor ( var nextIndex = 0, len = keysArray.length; nextIndex !== len; ++ nextIndex ) {\r\n\t\r\n\t\t\t\t\t\tvar nextKey = keysArray[ nextIndex ];\r\n\t\t\t\t\t\tvar desc = Object.getOwnPropertyDescriptor( nextSource, nextKey );\r\n\t\r\n\t\t\t\t\t\tif ( desc !== undefined && desc.enumerable ) {\r\n\t\r\n\t\t\t\t\t\t\tto[ nextKey ] = nextSource[ nextKey ];\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn to;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t} );\r\n\t\r\n\t}\r\n\t\r\n\t// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button\r\n\t\r\n\tTHREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\r\n\t\r\n\t// GL STATE CONSTANTS\r\n\t\r\n\tTHREE.CullFaceNone = 0;\r\n\tTHREE.CullFaceBack = 1;\r\n\tTHREE.CullFaceFront = 2;\r\n\tTHREE.CullFaceFrontBack = 3;\r\n\t\r\n\tTHREE.FrontFaceDirectionCW = 0;\r\n\tTHREE.FrontFaceDirectionCCW = 1;\r\n\t\r\n\t// SHADOWING TYPES\r\n\t\r\n\tTHREE.BasicShadowMap = 0;\r\n\tTHREE.PCFShadowMap = 1;\r\n\tTHREE.PCFSoftShadowMap = 2;\r\n\t\r\n\t// MATERIAL CONSTANTS\r\n\t\r\n\t// side\r\n\t\r\n\tTHREE.FrontSide = 0;\r\n\tTHREE.BackSide = 1;\r\n\tTHREE.DoubleSide = 2;\r\n\t\r\n\t// shading\r\n\t\r\n\tTHREE.FlatShading = 1;\r\n\tTHREE.SmoothShading = 2;\r\n\t\r\n\t// colors\r\n\t\r\n\tTHREE.NoColors = 0;\r\n\tTHREE.FaceColors = 1;\r\n\tTHREE.VertexColors = 2;\r\n\t\r\n\t// blending modes\r\n\t\r\n\tTHREE.NoBlending = 0;\r\n\tTHREE.NormalBlending = 1;\r\n\tTHREE.AdditiveBlending = 2;\r\n\tTHREE.SubtractiveBlending = 3;\r\n\tTHREE.MultiplyBlending = 4;\r\n\tTHREE.CustomBlending = 5;\r\n\t\r\n\t// custom blending equations\r\n\t// (numbers start from 100 not to clash with other\r\n\t// mappings to OpenGL constants defined in Texture.js)\r\n\t\r\n\tTHREE.AddEquation = 100;\r\n\tTHREE.SubtractEquation = 101;\r\n\tTHREE.ReverseSubtractEquation = 102;\r\n\tTHREE.MinEquation = 103;\r\n\tTHREE.MaxEquation = 104;\r\n\t\r\n\t// custom blending destination factors\r\n\t\r\n\tTHREE.ZeroFactor = 200;\r\n\tTHREE.OneFactor = 201;\r\n\tTHREE.SrcColorFactor = 202;\r\n\tTHREE.OneMinusSrcColorFactor = 203;\r\n\tTHREE.SrcAlphaFactor = 204;\r\n\tTHREE.OneMinusSrcAlphaFactor = 205;\r\n\tTHREE.DstAlphaFactor = 206;\r\n\tTHREE.OneMinusDstAlphaFactor = 207;\r\n\t\r\n\t// custom blending source factors\r\n\t\r\n\t//THREE.ZeroFactor = 200;\r\n\t//THREE.OneFactor = 201;\r\n\t//THREE.SrcAlphaFactor = 204;\r\n\t//THREE.OneMinusSrcAlphaFactor = 205;\r\n\t//THREE.DstAlphaFactor = 206;\r\n\t//THREE.OneMinusDstAlphaFactor = 207;\r\n\tTHREE.DstColorFactor = 208;\r\n\tTHREE.OneMinusDstColorFactor = 209;\r\n\tTHREE.SrcAlphaSaturateFactor = 210;\r\n\t\r\n\t// depth modes\r\n\t\r\n\tTHREE.NeverDepth = 0;\r\n\tTHREE.AlwaysDepth = 1;\r\n\tTHREE.LessDepth = 2;\r\n\tTHREE.LessEqualDepth = 3;\r\n\tTHREE.EqualDepth = 4;\r\n\tTHREE.GreaterEqualDepth = 5;\r\n\tTHREE.GreaterDepth = 6;\r\n\tTHREE.NotEqualDepth = 7;\r\n\t\r\n\t\r\n\t// TEXTURE CONSTANTS\r\n\t\r\n\tTHREE.MultiplyOperation = 0;\r\n\tTHREE.MixOperation = 1;\r\n\tTHREE.AddOperation = 2;\r\n\t\r\n\t// Tone Mapping modes\r\n\t\r\n\tTHREE.NoToneMapping = 0; // do not do any tone mapping, not even exposure (required for special purpose passes.)\r\n\tTHREE.LinearToneMapping = 1; // only apply exposure.\r\n\tTHREE.ReinhardToneMapping = 2;\r\n\tTHREE.Uncharted2ToneMapping = 3; // John Hable\r\n\tTHREE.CineonToneMapping = 4;  // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\r\n\t\r\n\t// Mapping modes\r\n\t\r\n\tTHREE.UVMapping = 300;\r\n\t\r\n\tTHREE.CubeReflectionMapping = 301;\r\n\tTHREE.CubeRefractionMapping = 302;\r\n\t\r\n\tTHREE.EquirectangularReflectionMapping = 303;\r\n\tTHREE.EquirectangularRefractionMapping = 304;\r\n\t\r\n\tTHREE.SphericalReflectionMapping = 305;\r\n\tTHREE.CubeUVReflectionMapping = 306;\r\n\tTHREE.CubeUVRefractionMapping = 307;\r\n\t\r\n\t// Wrapping modes\r\n\t\r\n\tTHREE.RepeatWrapping = 1000;\r\n\tTHREE.ClampToEdgeWrapping = 1001;\r\n\tTHREE.MirroredRepeatWrapping = 1002;\r\n\t\r\n\t// Filters\r\n\t\r\n\tTHREE.NearestFilter = 1003;\r\n\tTHREE.NearestMipMapNearestFilter = 1004;\r\n\tTHREE.NearestMipMapLinearFilter = 1005;\r\n\tTHREE.LinearFilter = 1006;\r\n\tTHREE.LinearMipMapNearestFilter = 1007;\r\n\tTHREE.LinearMipMapLinearFilter = 1008;\r\n\t\r\n\t// Data types\r\n\t\r\n\tTHREE.UnsignedByteType = 1009;\r\n\tTHREE.ByteType = 1010;\r\n\tTHREE.ShortType = 1011;\r\n\tTHREE.UnsignedShortType = 1012;\r\n\tTHREE.IntType = 1013;\r\n\tTHREE.UnsignedIntType = 1014;\r\n\tTHREE.FloatType = 1015;\r\n\tTHREE.HalfFloatType = 1025;\r\n\t\r\n\t// Pixel types\r\n\t\r\n\t//THREE.UnsignedByteType = 1009;\r\n\tTHREE.UnsignedShort4444Type = 1016;\r\n\tTHREE.UnsignedShort5551Type = 1017;\r\n\tTHREE.UnsignedShort565Type = 1018;\r\n\t\r\n\t// Pixel formats\r\n\t\r\n\tTHREE.AlphaFormat = 1019;\r\n\tTHREE.RGBFormat = 1020;\r\n\tTHREE.RGBAFormat = 1021;\r\n\tTHREE.LuminanceFormat = 1022;\r\n\tTHREE.LuminanceAlphaFormat = 1023;\r\n\t// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders\r\n\tTHREE.RGBEFormat = THREE.RGBAFormat; //1024;\r\n\t\r\n\t// DDS / ST3C Compressed texture formats\r\n\t\r\n\tTHREE.RGB_S3TC_DXT1_Format = 2001;\r\n\tTHREE.RGBA_S3TC_DXT1_Format = 2002;\r\n\tTHREE.RGBA_S3TC_DXT3_Format = 2003;\r\n\tTHREE.RGBA_S3TC_DXT5_Format = 2004;\r\n\t\r\n\t\r\n\t// PVRTC compressed texture formats\r\n\t\r\n\tTHREE.RGB_PVRTC_4BPPV1_Format = 2100;\r\n\tTHREE.RGB_PVRTC_2BPPV1_Format = 2101;\r\n\tTHREE.RGBA_PVRTC_4BPPV1_Format = 2102;\r\n\tTHREE.RGBA_PVRTC_2BPPV1_Format = 2103;\r\n\t\r\n\t// ETC compressed texture formats\r\n\t\r\n\tTHREE.RGB_ETC1_Format = 2151;\r\n\t\r\n\t// Loop styles for AnimationAction\r\n\t\r\n\tTHREE.LoopOnce = 2200;\r\n\tTHREE.LoopRepeat = 2201;\r\n\tTHREE.LoopPingPong = 2202;\r\n\t\r\n\t// Interpolation\r\n\t\r\n\tTHREE.InterpolateDiscrete = 2300;\r\n\tTHREE.InterpolateLinear = 2301;\r\n\tTHREE.InterpolateSmooth = 2302;\r\n\t\r\n\t// Interpolant ending modes\r\n\t\r\n\tTHREE.ZeroCurvatureEnding = 2400;\r\n\tTHREE.ZeroSlopeEnding = 2401;\r\n\tTHREE.WrapAroundEnding = 2402;\r\n\t\r\n\t// Triangle Draw modes\r\n\t\r\n\tTHREE.TrianglesDrawMode = 0;\r\n\tTHREE.TriangleStripDrawMode = 1;\r\n\tTHREE.TriangleFanDrawMode = 2;\r\n\t\r\n\t// Texture Encodings\r\n\t\r\n\tTHREE.LinearEncoding = 3000; // No encoding at all.\r\n\tTHREE.sRGBEncoding = 3001;\r\n\tTHREE.GammaEncoding = 3007; // uses GAMMA_FACTOR, for backwards compatibility with WebGLRenderer.gammaInput/gammaOutput\r\n\t\r\n\t// The following Texture Encodings are for RGB-only (no alpha) HDR light emission sources.\r\n\t// These encodings should not specified as output encodings except in rare situations.\r\n\tTHREE.RGBEEncoding = 3002; // AKA Radiance.\r\n\tTHREE.LogLuvEncoding = 3003;\r\n\tTHREE.RGBM7Encoding = 3004;\r\n\tTHREE.RGBM16Encoding = 3005;\r\n\tTHREE.RGBDEncoding = 3006; // MaxRange is 256.\r\n\t\r\n\t// File:src/math/Color.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Color = function ( color ) {\r\n\t\r\n\t\tif ( arguments.length === 3 ) {\r\n\t\r\n\t\t\treturn this.fromArray( arguments );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn this.set( color );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Color.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Color,\r\n\t\r\n\t\tr: 1, g: 1, b: 1,\r\n\t\r\n\t\tset: function ( value ) {\r\n\t\r\n\t\t\tif ( value instanceof THREE.Color ) {\r\n\t\r\n\t\t\t\tthis.copy( value );\r\n\t\r\n\t\t\t} else if ( typeof value === 'number' ) {\r\n\t\r\n\t\t\t\tthis.setHex( value );\r\n\t\r\n\t\t\t} else if ( typeof value === 'string' ) {\r\n\t\r\n\t\t\t\tthis.setStyle( value );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetScalar: function ( scalar ) {\r\n\t\r\n\t\t\tthis.r = scalar;\r\n\t\t\tthis.g = scalar;\r\n\t\t\tthis.b = scalar;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetHex: function ( hex ) {\r\n\t\r\n\t\t\thex = Math.floor( hex );\r\n\t\r\n\t\t\tthis.r = ( hex >> 16 & 255 ) / 255;\r\n\t\t\tthis.g = ( hex >> 8 & 255 ) / 255;\r\n\t\t\tthis.b = ( hex & 255 ) / 255;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRGB: function ( r, g, b ) {\r\n\t\r\n\t\t\tthis.r = r;\r\n\t\t\tthis.g = g;\r\n\t\t\tthis.b = b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetHSL: function () {\r\n\t\r\n\t\t\tfunction hue2rgb( p, q, t ) {\r\n\t\r\n\t\t\t\tif ( t < 0 ) t += 1;\r\n\t\t\t\tif ( t > 1 ) t -= 1;\r\n\t\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\r\n\t\t\t\tif ( t < 1 / 2 ) return q;\r\n\t\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\r\n\t\t\t\treturn p;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn function ( h, s, l ) {\r\n\t\r\n\t\t\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\t\t\t\th = THREE.Math.euclideanModulo( h, 1 );\r\n\t\t\t\ts = THREE.Math.clamp( s, 0, 1 );\r\n\t\t\t\tl = THREE.Math.clamp( l, 0, 1 );\r\n\t\r\n\t\t\t\tif ( s === 0 ) {\r\n\t\r\n\t\t\t\t\tthis.r = this.g = this.b = l;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\r\n\t\t\t\t\tvar q = ( 2 * l ) - p;\r\n\t\r\n\t\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\r\n\t\t\t\t\tthis.g = hue2rgb( q, p, h );\r\n\t\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tsetStyle: function ( style ) {\r\n\t\r\n\t\t\tfunction handleAlpha( string ) {\r\n\t\r\n\t\t\t\tif ( string === undefined ) return;\r\n\t\r\n\t\t\t\tif ( parseFloat( string ) < 1 ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\tvar m;\r\n\t\r\n\t\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\r\n\t\r\n\t\t\t\t// rgb / hsl\r\n\t\r\n\t\t\t\tvar color;\r\n\t\t\t\tvar name = m[ 1 ];\r\n\t\t\t\tvar components = m[ 2 ];\r\n\t\r\n\t\t\t\tswitch ( name ) {\r\n\t\r\n\t\t\t\t\tcase 'rgb':\r\n\t\t\t\t\tcase 'rgba':\r\n\t\r\n\t\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\t\r\n\t\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\r\n\t\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\r\n\t\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\r\n\t\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\r\n\t\r\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\r\n\t\r\n\t\t\t\t\t\t\treturn this;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\t\r\n\t\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\r\n\t\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\r\n\t\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\r\n\t\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\r\n\t\r\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\r\n\t\r\n\t\t\t\t\t\t\treturn this;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'hsl':\r\n\t\t\t\t\tcase 'hsla':\r\n\t\r\n\t\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\t\r\n\t\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\r\n\t\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\r\n\t\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\r\n\t\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\r\n\t\r\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\r\n\t\r\n\t\t\t\t\t\t\treturn this.setHSL( h, s, l );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\r\n\t\r\n\t\t\t\t// hex color\r\n\t\r\n\t\t\t\tvar hex = m[ 1 ];\r\n\t\t\t\tvar size = hex.length;\r\n\t\r\n\t\t\t\tif ( size === 3 ) {\r\n\t\r\n\t\t\t\t\t// #ff0\r\n\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\r\n\t\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\r\n\t\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\r\n\t\r\n\t\t\t\t\treturn this;\r\n\t\r\n\t\t\t\t} else if ( size === 6 ) {\r\n\t\r\n\t\t\t\t\t// #ff0000\r\n\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\r\n\t\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\r\n\t\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\r\n\t\r\n\t\t\t\t\treturn this;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( style && style.length > 0 ) {\r\n\t\r\n\t\t\t\t// color keywords\r\n\t\t\t\tvar hex = THREE.ColorKeywords[ style ];\r\n\t\r\n\t\t\t\tif ( hex !== undefined ) {\r\n\t\r\n\t\t\t\t\t// red\r\n\t\t\t\t\tthis.setHex( hex );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// unknown color\r\n\t\t\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor( this.r, this.g, this.b );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( color ) {\r\n\t\r\n\t\t\tthis.r = color.r;\r\n\t\t\tthis.g = color.g;\r\n\t\t\tthis.b = color.b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyGammaToLinear: function ( color, gammaFactor ) {\r\n\t\r\n\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\t\r\n\t\t\tthis.r = Math.pow( color.r, gammaFactor );\r\n\t\t\tthis.g = Math.pow( color.g, gammaFactor );\r\n\t\t\tthis.b = Math.pow( color.b, gammaFactor );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyLinearToGamma: function ( color, gammaFactor ) {\r\n\t\r\n\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\t\r\n\t\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\r\n\t\r\n\t\t\tthis.r = Math.pow( color.r, safeInverse );\r\n\t\t\tthis.g = Math.pow( color.g, safeInverse );\r\n\t\t\tthis.b = Math.pow( color.b, safeInverse );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tconvertGammaToLinear: function () {\r\n\t\r\n\t\t\tvar r = this.r, g = this.g, b = this.b;\r\n\t\r\n\t\t\tthis.r = r * r;\r\n\t\t\tthis.g = g * g;\r\n\t\t\tthis.b = b * b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tconvertLinearToGamma: function () {\r\n\t\r\n\t\t\tthis.r = Math.sqrt( this.r );\r\n\t\t\tthis.g = Math.sqrt( this.g );\r\n\t\t\tthis.b = Math.sqrt( this.b );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetHex: function () {\r\n\t\r\n\t\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetHexString: function () {\r\n\t\r\n\t\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetHSL: function ( optionalTarget ) {\r\n\t\r\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\t\r\n\t\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\r\n\t\r\n\t\t\tvar r = this.r, g = this.g, b = this.b;\r\n\t\r\n\t\t\tvar max = Math.max( r, g, b );\r\n\t\t\tvar min = Math.min( r, g, b );\r\n\t\r\n\t\t\tvar hue, saturation;\r\n\t\t\tvar lightness = ( min + max ) / 2.0;\r\n\t\r\n\t\t\tif ( min === max ) {\r\n\t\r\n\t\t\t\thue = 0;\r\n\t\t\t\tsaturation = 0;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tvar delta = max - min;\r\n\t\r\n\t\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\r\n\t\r\n\t\t\t\tswitch ( max ) {\r\n\t\r\n\t\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\r\n\t\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\r\n\t\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\thue /= 6;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\thsl.h = hue;\r\n\t\t\thsl.s = saturation;\r\n\t\t\thsl.l = lightness;\r\n\t\r\n\t\t\treturn hsl;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetStyle: function () {\r\n\t\r\n\t\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\r\n\t\r\n\t\t},\r\n\t\r\n\t\toffsetHSL: function ( h, s, l ) {\r\n\t\r\n\t\t\tvar hsl = this.getHSL();\r\n\t\r\n\t\t\thsl.h += h; hsl.s += s; hsl.l += l;\r\n\t\r\n\t\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tadd: function ( color ) {\r\n\t\r\n\t\t\tthis.r += color.r;\r\n\t\t\tthis.g += color.g;\r\n\t\t\tthis.b += color.b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddColors: function ( color1, color2 ) {\r\n\t\r\n\t\t\tthis.r = color1.r + color2.r;\r\n\t\t\tthis.g = color1.g + color2.g;\r\n\t\t\tthis.b = color1.b + color2.b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.r += s;\r\n\t\t\tthis.g += s;\r\n\t\t\tthis.b += s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiply: function ( color ) {\r\n\t\r\n\t\t\tthis.r *= color.r;\r\n\t\t\tthis.g *= color.g;\r\n\t\t\tthis.b *= color.b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.r *= s;\r\n\t\t\tthis.g *= s;\r\n\t\t\tthis.b *= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerp: function ( color, alpha ) {\r\n\t\r\n\t\t\tthis.r += ( color.r - this.r ) * alpha;\r\n\t\t\tthis.g += ( color.g - this.g ) * alpha;\r\n\t\t\tthis.b += ( color.b - this.b ) * alpha;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( c ) {\r\n\t\r\n\t\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis.r = array[ offset ];\r\n\t\t\tthis.g = array[ offset + 1 ];\r\n\t\t\tthis.b = array[ offset + 2 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this.r;\r\n\t\t\tarray[ offset + 1 ] = this.g;\r\n\t\t\tarray[ offset + 2 ] = this.b;\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\r\n\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\r\n\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\r\n\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\r\n\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\r\n\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\r\n\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\r\n\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\r\n\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\r\n\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\r\n\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\r\n\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\r\n\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\r\n\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\r\n\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\r\n\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\r\n\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\r\n\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\r\n\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\r\n\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\r\n\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\r\n\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\r\n\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\r\n\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\r\n\t\r\n\t// File:src/math/Quaternion.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @author bhouston / http://clara.io\r\n\t */\r\n\t\r\n\tTHREE.Quaternion = function ( x, y, z, w ) {\r\n\t\r\n\t\tthis._x = x || 0;\r\n\t\tthis._y = y || 0;\r\n\t\tthis._z = z || 0;\r\n\t\tthis._w = ( w !== undefined ) ? w : 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Quaternion.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Quaternion,\r\n\t\r\n\t\tget x () {\r\n\t\r\n\t\t\treturn this._x;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset x ( value ) {\r\n\t\r\n\t\t\tthis._x = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget y () {\r\n\t\r\n\t\t\treturn this._y;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset y ( value ) {\r\n\t\r\n\t\t\tthis._y = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget z () {\r\n\t\r\n\t\t\treturn this._z;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset z ( value ) {\r\n\t\r\n\t\t\tthis._z = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget w () {\r\n\t\r\n\t\t\treturn this._w;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset w ( value ) {\r\n\t\r\n\t\t\tthis._w = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset: function ( x, y, z, w ) {\r\n\t\r\n\t\t\tthis._x = x;\r\n\t\t\tthis._y = y;\r\n\t\t\tthis._z = z;\r\n\t\t\tthis._w = w;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( quaternion ) {\r\n\t\r\n\t\t\tthis._x = quaternion.x;\r\n\t\t\tthis._y = quaternion.y;\r\n\t\t\tthis._z = quaternion.z;\r\n\t\t\tthis._w = quaternion.w;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromEuler: function ( euler, update ) {\r\n\t\r\n\t\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\t\r\n\t\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\r\n\t\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\r\n\t\t\t//\tcontent/SpinCalc.m\r\n\t\r\n\t\t\tvar c1 = Math.cos( euler._x / 2 );\r\n\t\t\tvar c2 = Math.cos( euler._y / 2 );\r\n\t\t\tvar c3 = Math.cos( euler._z / 2 );\r\n\t\t\tvar s1 = Math.sin( euler._x / 2 );\r\n\t\t\tvar s2 = Math.sin( euler._y / 2 );\r\n\t\t\tvar s3 = Math.sin( euler._z / 2 );\r\n\t\r\n\t\t\tvar order = euler.order;\r\n\t\r\n\t\t\tif ( order === 'XYZ' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\t\r\n\t\t\t} else if ( order === 'YXZ' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\t\r\n\t\t\t} else if ( order === 'ZXY' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\t\r\n\t\t\t} else if ( order === 'ZYX' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\t\r\n\t\t\t} else if ( order === 'YZX' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\t\r\n\t\t\t} else if ( order === 'XZY' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( update !== false ) this.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromAxisAngle: function ( axis, angle ) {\r\n\t\r\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\r\n\t\r\n\t\t\t// assumes axis is normalized\r\n\t\r\n\t\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\r\n\t\r\n\t\t\tthis._x = axis.x * s;\r\n\t\t\tthis._y = axis.y * s;\r\n\t\t\tthis._z = axis.z * s;\r\n\t\t\tthis._w = Math.cos( halfAngle );\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromRotationMatrix: function ( m ) {\r\n\t\r\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n\t\r\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\t\r\n\t\t\tvar te = m.elements,\r\n\t\r\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\r\n\t\r\n\t\t\t\ttrace = m11 + m22 + m33,\r\n\t\t\t\ts;\r\n\t\r\n\t\t\tif ( trace > 0 ) {\r\n\t\r\n\t\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\r\n\t\r\n\t\t\t\tthis._w = 0.25 / s;\r\n\t\t\t\tthis._x = ( m32 - m23 ) * s;\r\n\t\t\t\tthis._y = ( m13 - m31 ) * s;\r\n\t\t\t\tthis._z = ( m21 - m12 ) * s;\r\n\t\r\n\t\t\t} else if ( m11 > m22 && m11 > m33 ) {\r\n\t\r\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\r\n\t\r\n\t\t\t\tthis._w = ( m32 - m23 ) / s;\r\n\t\t\t\tthis._x = 0.25 * s;\r\n\t\t\t\tthis._y = ( m12 + m21 ) / s;\r\n\t\t\t\tthis._z = ( m13 + m31 ) / s;\r\n\t\r\n\t\t\t} else if ( m22 > m33 ) {\r\n\t\r\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\r\n\t\r\n\t\t\t\tthis._w = ( m13 - m31 ) / s;\r\n\t\t\t\tthis._x = ( m12 + m21 ) / s;\r\n\t\t\t\tthis._y = 0.25 * s;\r\n\t\t\t\tthis._z = ( m23 + m32 ) / s;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\r\n\t\r\n\t\t\t\tthis._w = ( m21 - m12 ) / s;\r\n\t\t\t\tthis._x = ( m13 + m31 ) / s;\r\n\t\t\t\tthis._y = ( m23 + m32 ) / s;\r\n\t\t\t\tthis._z = 0.25 * s;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromUnitVectors: function () {\r\n\t\r\n\t\t\t// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\r\n\t\r\n\t\t\t// assumes direction vectors vFrom and vTo are normalized\r\n\t\r\n\t\t\tvar v1, r;\r\n\t\r\n\t\t\tvar EPS = 0.000001;\r\n\t\r\n\t\t\treturn function ( vFrom, vTo ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\r\n\t\t\t\tr = vFrom.dot( vTo ) + 1;\r\n\t\r\n\t\t\t\tif ( r < EPS ) {\r\n\t\r\n\t\t\t\t\tr = 0;\r\n\t\r\n\t\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\r\n\t\r\n\t\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tv1.crossVectors( vFrom, vTo );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis._x = v1.x;\r\n\t\t\t\tthis._y = v1.y;\r\n\t\t\t\tthis._z = v1.z;\r\n\t\t\t\tthis._w = r;\r\n\t\r\n\t\t\t\tthis.normalize();\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tinverse: function () {\r\n\t\r\n\t\t\tthis.conjugate().normalize();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tconjugate: function () {\r\n\t\r\n\t\t\tthis._x *= - 1;\r\n\t\t\tthis._y *= - 1;\r\n\t\t\tthis._z *= - 1;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdot: function ( v ) {\r\n\t\r\n\t\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthSq: function () {\r\n\t\r\n\t\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlength: function () {\r\n\t\r\n\t\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\tvar l = this.length();\r\n\t\r\n\t\t\tif ( l === 0 ) {\r\n\t\r\n\t\t\t\tthis._x = 0;\r\n\t\t\t\tthis._y = 0;\r\n\t\t\t\tthis._z = 0;\r\n\t\t\t\tthis._w = 1;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tl = 1 / l;\r\n\t\r\n\t\t\t\tthis._x = this._x * l;\r\n\t\t\t\tthis._y = this._y * l;\r\n\t\t\t\tthis._z = this._z * l;\r\n\t\t\t\tthis._w = this._w * l;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiply: function ( q, p ) {\r\n\t\r\n\t\t\tif ( p !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\r\n\t\t\t\treturn this.multiplyQuaternions( q, p );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.multiplyQuaternions( this, q );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyQuaternions: function ( a, b ) {\r\n\t\r\n\t\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\r\n\t\r\n\t\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\r\n\t\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\r\n\t\r\n\t\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\r\n\t\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\r\n\t\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\r\n\t\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tslerp: function ( qb, t ) {\r\n\t\r\n\t\t\tif ( t === 0 ) return this;\r\n\t\t\tif ( t === 1 ) return this.copy( qb );\r\n\t\r\n\t\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\r\n\t\r\n\t\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\r\n\t\r\n\t\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\r\n\t\r\n\t\t\tif ( cosHalfTheta < 0 ) {\r\n\t\r\n\t\t\t\tthis._w = - qb._w;\r\n\t\t\t\tthis._x = - qb._x;\r\n\t\t\t\tthis._y = - qb._y;\r\n\t\t\t\tthis._z = - qb._z;\r\n\t\r\n\t\t\t\tcosHalfTheta = - cosHalfTheta;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.copy( qb );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( cosHalfTheta >= 1.0 ) {\r\n\t\r\n\t\t\t\tthis._w = w;\r\n\t\t\t\tthis._x = x;\r\n\t\t\t\tthis._y = y;\r\n\t\t\t\tthis._z = z;\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\r\n\t\r\n\t\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\r\n\t\r\n\t\t\t\tthis._w = 0.5 * ( w + this._w );\r\n\t\t\t\tthis._x = 0.5 * ( x + this._x );\r\n\t\t\t\tthis._y = 0.5 * ( y + this._y );\r\n\t\t\t\tthis._z = 0.5 * ( z + this._z );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\r\n\t\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\r\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\r\n\t\r\n\t\t\tthis._w = ( w * ratioA + this._w * ratioB );\r\n\t\t\tthis._x = ( x * ratioA + this._x * ratioB );\r\n\t\t\tthis._y = ( y * ratioA + this._y * ratioB );\r\n\t\t\tthis._z = ( z * ratioA + this._z * ratioB );\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( quaternion ) {\r\n\t\r\n\t\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis._x = array[ offset ];\r\n\t\t\tthis._y = array[ offset + 1 ];\r\n\t\t\tthis._z = array[ offset + 2 ];\r\n\t\t\tthis._w = array[ offset + 3 ];\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this._x;\r\n\t\t\tarray[ offset + 1 ] = this._y;\r\n\t\t\tarray[ offset + 2 ] = this._z;\r\n\t\t\tarray[ offset + 3 ] = this._w;\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tonChange: function ( callback ) {\r\n\t\r\n\t\t\tthis.onChangeCallback = callback;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tonChangeCallback: function () {}\r\n\t\r\n\t};\r\n\t\r\n\tObject.assign( THREE.Quaternion, {\r\n\t\r\n\t\tslerp: function( qa, qb, qm, t ) {\r\n\t\r\n\t\t\treturn qm.copy( qa ).slerp( qb, t );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tslerpFlat: function(\r\n\t\t\t\tdst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\r\n\t\r\n\t\t\t// fuzz-free, array-based Quaternion SLERP operation\r\n\t\r\n\t\t\tvar x0 = src0[ srcOffset0 + 0 ],\r\n\t\t\t\ty0 = src0[ srcOffset0 + 1 ],\r\n\t\t\t\tz0 = src0[ srcOffset0 + 2 ],\r\n\t\t\t\tw0 = src0[ srcOffset0 + 3 ],\r\n\t\r\n\t\t\t\tx1 = src1[ srcOffset1 + 0 ],\r\n\t\t\t\ty1 = src1[ srcOffset1 + 1 ],\r\n\t\t\t\tz1 = src1[ srcOffset1 + 2 ],\r\n\t\t\t\tw1 = src1[ srcOffset1 + 3 ];\r\n\t\r\n\t\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\r\n\t\r\n\t\t\t\tvar s = 1 - t,\r\n\t\r\n\t\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\r\n\t\r\n\t\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\r\n\t\t\t\t\tsqrSin = 1 - cos * cos;\r\n\t\r\n\t\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\r\n\t\t\t\tif ( sqrSin > Number.EPSILON ) {\r\n\t\r\n\t\t\t\t\tvar sin = Math.sqrt( sqrSin ),\r\n\t\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\r\n\t\r\n\t\t\t\t\ts = Math.sin( s * len ) / sin;\r\n\t\t\t\t\tt = Math.sin( t * len ) / sin;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar tDir = t * dir;\r\n\t\r\n\t\t\t\tx0 = x0 * s + x1 * tDir;\r\n\t\t\t\ty0 = y0 * s + y1 * tDir;\r\n\t\t\t\tz0 = z0 * s + z1 * tDir;\r\n\t\t\t\tw0 = w0 * s + w1 * tDir;\r\n\t\r\n\t\t\t\t// Normalize in case we just did a lerp:\r\n\t\t\t\tif ( s === 1 - t ) {\r\n\t\r\n\t\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\r\n\t\r\n\t\t\t\t\tx0 *= f;\r\n\t\t\t\t\ty0 *= f;\r\n\t\t\t\t\tz0 *= f;\r\n\t\t\t\t\tw0 *= f;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tdst[ dstOffset ] = x0;\r\n\t\t\tdst[ dstOffset + 1 ] = y0;\r\n\t\t\tdst[ dstOffset + 2 ] = z0;\r\n\t\t\tdst[ dstOffset + 3 ] = w0;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/math/Vector2.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author philogb / http://blog.thejit.org/\r\n\t * @author egraether / http://egraether.com/\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t */\r\n\t\r\n\tTHREE.Vector2 = function ( x, y ) {\r\n\t\r\n\t\tthis.x = x || 0;\r\n\t\tthis.y = y || 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Vector2.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Vector2,\r\n\t\r\n\t\tget width() {\r\n\t\r\n\t\t\treturn this.x;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset width( value ) {\r\n\t\r\n\t\t\tthis.x = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget height() {\r\n\t\r\n\t\t\treturn this.y;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset height( value ) {\r\n\t\r\n\t\t\tthis.y = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t//\r\n\t\r\n\t\tset: function ( x, y ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetScalar: function ( scalar ) {\r\n\t\r\n\t\t\tthis.x = scalar;\r\n\t\t\tthis.y = scalar;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetX: function ( x ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetY: function ( y ) {\r\n\t\r\n\t\t\tthis.y = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetComponent: function ( index, value ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: this.x = value; break;\r\n\t\t\t\tcase 1: this.y = value; break;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetComponent: function ( index ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: return this.x;\r\n\t\t\t\tcase 1: return this.y;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor( this.x, this.y );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( v ) {\r\n\t\r\n\t\t\tthis.x = v.x;\r\n\t\t\tthis.y = v.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tadd: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.addVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x += v.x;\r\n\t\t\tthis.y += v.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x += s;\r\n\t\t\tthis.y += s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x + b.x;\r\n\t\t\tthis.y = a.y + b.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScaledVector: function ( v, s ) {\r\n\t\r\n\t\t\tthis.x += v.x * s;\r\n\t\t\tthis.y += v.y * s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsub: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.subVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x -= v.x;\r\n\t\t\tthis.y -= v.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x -= s;\r\n\t\t\tthis.y -= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x - b.x;\r\n\t\t\tthis.y = a.y - b.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiply: function ( v ) {\r\n\t\r\n\t\t\tthis.x *= v.x;\r\n\t\t\tthis.y *= v.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyScalar: function ( scalar ) {\r\n\t\r\n\t\t\tif ( isFinite( scalar ) ) {\r\n\t\r\n\t\t\t\tthis.x *= scalar;\r\n\t\t\t\tthis.y *= scalar;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.x = 0;\r\n\t\t\t\tthis.y = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdivide: function ( v ) {\r\n\t\r\n\t\t\tthis.x /= v.x;\r\n\t\t\tthis.y /= v.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdivideScalar: function ( scalar ) {\r\n\t\r\n\t\t\treturn this.multiplyScalar( 1 / scalar );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmin: function ( v ) {\r\n\t\r\n\t\t\tthis.x = Math.min( this.x, v.x );\r\n\t\t\tthis.y = Math.min( this.y, v.y );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmax: function ( v ) {\r\n\t\r\n\t\t\tthis.x = Math.max( this.x, v.x );\r\n\t\t\tthis.y = Math.max( this.y, v.y );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclamp: function ( min, max ) {\r\n\t\r\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\t\r\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampScalar: function () {\r\n\t\r\n\t\t\tvar min, max;\r\n\t\r\n\t\t\treturn function clampScalar( minVal, maxVal ) {\r\n\t\r\n\t\t\t\tif ( min === undefined ) {\r\n\t\r\n\t\t\t\t\tmin = new THREE.Vector2();\r\n\t\t\t\t\tmax = new THREE.Vector2();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tmin.set( minVal, minVal );\r\n\t\t\t\tmax.set( maxVal, maxVal );\r\n\t\r\n\t\t\t\treturn this.clamp( min, max );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclampLength: function ( min, max ) {\r\n\t\r\n\t\t\tvar length = this.length();\r\n\t\r\n\t\t\tthis.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfloor: function () {\r\n\t\r\n\t\t\tthis.x = Math.floor( this.x );\r\n\t\t\tthis.y = Math.floor( this.y );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tceil: function () {\r\n\t\r\n\t\t\tthis.x = Math.ceil( this.x );\r\n\t\t\tthis.y = Math.ceil( this.y );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tround: function () {\r\n\t\r\n\t\t\tthis.x = Math.round( this.x );\r\n\t\t\tthis.y = Math.round( this.y );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\troundToZero: function () {\r\n\t\r\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnegate: function () {\r\n\t\r\n\t\t\tthis.x = - this.x;\r\n\t\t\tthis.y = - this.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdot: function ( v ) {\r\n\t\r\n\t\t\treturn this.x * v.x + this.y * v.y;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthSq: function () {\r\n\t\r\n\t\t\treturn this.x * this.x + this.y * this.y;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlength: function () {\r\n\t\r\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthManhattan: function() {\r\n\t\r\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\treturn this.divideScalar( this.length() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tangle: function () {\r\n\t\r\n\t\t\t// computes the angle in radians with respect to the positive x-axis\r\n\t\r\n\t\t\tvar angle = Math.atan2( this.y, this.x );\r\n\t\r\n\t\t\tif ( angle < 0 ) angle += 2 * Math.PI;\r\n\t\r\n\t\t\treturn angle;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceTo: function ( v ) {\r\n\t\r\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToSquared: function ( v ) {\r\n\t\r\n\t\t\tvar dx = this.x - v.x, dy = this.y - v.y;\r\n\t\t\treturn dx * dx + dy * dy;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetLength: function ( length ) {\r\n\t\r\n\t\t\treturn this.multiplyScalar( length / this.length() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerp: function ( v, alpha ) {\r\n\t\r\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerpVectors: function ( v1, v2, alpha ) {\r\n\t\r\n\t\t\tthis.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( v ) {\r\n\t\r\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis.x = array[ offset ];\r\n\t\t\tthis.y = array[ offset + 1 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this.x;\r\n\t\t\tarray[ offset + 1 ] = this.y;\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromAttribute: function ( attribute, index, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tindex = index * attribute.itemSize + offset;\r\n\t\r\n\t\t\tthis.x = attribute.array[ index ];\r\n\t\t\tthis.y = attribute.array[ index + 1 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\trotateAround: function ( center, angle ) {\r\n\t\r\n\t\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\r\n\t\r\n\t\t\tvar x = this.x - center.x;\r\n\t\t\tvar y = this.y - center.y;\r\n\t\r\n\t\t\tthis.x = x * c - y * s + center.x;\r\n\t\t\tthis.y = x * s + y * c + center.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Vector3.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author *kile / http://kile.stravaganza.org/\r\n\t * @author philogb / http://blog.thejit.org/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author egraether / http://egraether.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.Vector3 = function ( x, y, z ) {\r\n\t\r\n\t\tthis.x = x || 0;\r\n\t\tthis.y = y || 0;\r\n\t\tthis.z = z || 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Vector3.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Vector3,\r\n\t\r\n\t\tset: function ( x, y, z ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t\tthis.z = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetScalar: function ( scalar ) {\r\n\t\r\n\t\t\tthis.x = scalar;\r\n\t\t\tthis.y = scalar;\r\n\t\t\tthis.z = scalar;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetX: function ( x ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetY: function ( y ) {\r\n\t\r\n\t\t\tthis.y = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetZ: function ( z ) {\r\n\t\r\n\t\t\tthis.z = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetComponent: function ( index, value ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: this.x = value; break;\r\n\t\t\t\tcase 1: this.y = value; break;\r\n\t\t\t\tcase 2: this.z = value; break;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetComponent: function ( index ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: return this.x;\r\n\t\t\t\tcase 1: return this.y;\r\n\t\t\t\tcase 2: return this.z;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor( this.x, this.y, this.z );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( v ) {\r\n\t\r\n\t\t\tthis.x = v.x;\r\n\t\t\tthis.y = v.y;\r\n\t\t\tthis.z = v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tadd: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.addVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x += v.x;\r\n\t\t\tthis.y += v.y;\r\n\t\t\tthis.z += v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x += s;\r\n\t\t\tthis.y += s;\r\n\t\t\tthis.z += s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x + b.x;\r\n\t\t\tthis.y = a.y + b.y;\r\n\t\t\tthis.z = a.z + b.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScaledVector: function ( v, s ) {\r\n\t\r\n\t\t\tthis.x += v.x * s;\r\n\t\t\tthis.y += v.y * s;\r\n\t\t\tthis.z += v.z * s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsub: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.subVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x -= v.x;\r\n\t\t\tthis.y -= v.y;\r\n\t\t\tthis.z -= v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x -= s;\r\n\t\t\tthis.y -= s;\r\n\t\t\tthis.z -= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x - b.x;\r\n\t\t\tthis.y = a.y - b.y;\r\n\t\t\tthis.z = a.z - b.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiply: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.multiplyVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x *= v.x;\r\n\t\t\tthis.y *= v.y;\r\n\t\t\tthis.z *= v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyScalar: function ( scalar ) {\r\n\t\r\n\t\t\tif ( isFinite( scalar ) ) {\r\n\t\r\n\t\t\t\tthis.x *= scalar;\r\n\t\t\t\tthis.y *= scalar;\r\n\t\t\t\tthis.z *= scalar;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.x = 0;\r\n\t\t\t\tthis.y = 0;\r\n\t\t\t\tthis.z = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x * b.x;\r\n\t\t\tthis.y = a.y * b.y;\r\n\t\t\tthis.z = a.z * b.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyEuler: function () {\r\n\t\r\n\t\t\tvar quaternion;\r\n\t\r\n\t\t\treturn function applyEuler( euler ) {\r\n\t\r\n\t\t\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\t\r\n\t\t\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\t\r\n\t\t\t\tthis.applyQuaternion( quaternion.setFromEuler( euler ) );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tapplyAxisAngle: function () {\r\n\t\r\n\t\t\tvar quaternion;\r\n\t\r\n\t\t\treturn function applyAxisAngle( axis, angle ) {\r\n\t\r\n\t\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\t\r\n\t\t\t\tthis.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tapplyMatrix3: function ( m ) {\r\n\t\r\n\t\t\tvar x = this.x;\r\n\t\t\tvar y = this.y;\r\n\t\t\tvar z = this.z;\r\n\t\r\n\t\t\tvar e = m.elements;\r\n\t\r\n\t\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\r\n\t\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\r\n\t\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function ( m ) {\r\n\t\r\n\t\t\t// input: THREE.Matrix4 affine matrix\r\n\t\r\n\t\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\r\n\t\t\tvar e = m.elements;\r\n\t\r\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\r\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\r\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyProjection: function ( m ) {\r\n\t\r\n\t\t\t// input: THREE.Matrix4 projection matrix\r\n\t\r\n\t\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\r\n\t\t\tvar e = m.elements;\r\n\t\t\tvar d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\r\n\t\r\n\t\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\r\n\t\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\r\n\t\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyQuaternion: function ( q ) {\r\n\t\r\n\t\t\tvar x = this.x;\r\n\t\t\tvar y = this.y;\r\n\t\t\tvar z = this.z;\r\n\t\r\n\t\t\tvar qx = q.x;\r\n\t\t\tvar qy = q.y;\r\n\t\t\tvar qz = q.z;\r\n\t\t\tvar qw = q.w;\r\n\t\r\n\t\t\t// calculate quat * vector\r\n\t\r\n\t\t\tvar ix =  qw * x + qy * z - qz * y;\r\n\t\t\tvar iy =  qw * y + qz * x - qx * z;\r\n\t\t\tvar iz =  qw * z + qx * y - qy * x;\r\n\t\t\tvar iw = - qx * x - qy * y - qz * z;\r\n\t\r\n\t\t\t// calculate result * inverse quat\r\n\t\r\n\t\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\r\n\t\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\r\n\t\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tproject: function () {\r\n\t\r\n\t\t\tvar matrix;\r\n\t\r\n\t\t\treturn function project( camera ) {\r\n\t\r\n\t\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\r\n\t\t\t\treturn this.applyProjection( matrix );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tunproject: function () {\r\n\t\r\n\t\t\tvar matrix;\r\n\t\r\n\t\t\treturn function unproject( camera ) {\r\n\t\r\n\t\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\r\n\t\t\t\treturn this.applyProjection( matrix );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttransformDirection: function ( m ) {\r\n\t\r\n\t\t\t// input: THREE.Matrix4 affine matrix\r\n\t\t\t// vector interpreted as a direction\r\n\t\r\n\t\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\r\n\t\t\tvar e = m.elements;\r\n\t\r\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\r\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\r\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\r\n\t\r\n\t\t\tthis.normalize();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdivide: function ( v ) {\r\n\t\r\n\t\t\tthis.x /= v.x;\r\n\t\t\tthis.y /= v.y;\r\n\t\t\tthis.z /= v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdivideScalar: function ( scalar ) {\r\n\t\r\n\t\t\treturn this.multiplyScalar( 1 / scalar );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmin: function ( v ) {\r\n\t\r\n\t\t\tthis.x = Math.min( this.x, v.x );\r\n\t\t\tthis.y = Math.min( this.y, v.y );\r\n\t\t\tthis.z = Math.min( this.z, v.z );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmax: function ( v ) {\r\n\t\r\n\t\t\tthis.x = Math.max( this.x, v.x );\r\n\t\t\tthis.y = Math.max( this.y, v.y );\r\n\t\t\tthis.z = Math.max( this.z, v.z );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclamp: function ( min, max ) {\r\n\t\r\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\t\r\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampScalar: function () {\r\n\t\r\n\t\t\tvar min, max;\r\n\t\r\n\t\t\treturn function clampScalar( minVal, maxVal ) {\r\n\t\r\n\t\t\t\tif ( min === undefined ) {\r\n\t\r\n\t\t\t\t\tmin = new THREE.Vector3();\r\n\t\t\t\t\tmax = new THREE.Vector3();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tmin.set( minVal, minVal, minVal );\r\n\t\t\t\tmax.set( maxVal, maxVal, maxVal );\r\n\t\r\n\t\t\t\treturn this.clamp( min, max );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclampLength: function ( min, max ) {\r\n\t\r\n\t\t\tvar length = this.length();\r\n\t\r\n\t\t\tthis.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfloor: function () {\r\n\t\r\n\t\t\tthis.x = Math.floor( this.x );\r\n\t\t\tthis.y = Math.floor( this.y );\r\n\t\t\tthis.z = Math.floor( this.z );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tceil: function () {\r\n\t\r\n\t\t\tthis.x = Math.ceil( this.x );\r\n\t\t\tthis.y = Math.ceil( this.y );\r\n\t\t\tthis.z = Math.ceil( this.z );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tround: function () {\r\n\t\r\n\t\t\tthis.x = Math.round( this.x );\r\n\t\t\tthis.y = Math.round( this.y );\r\n\t\t\tthis.z = Math.round( this.z );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\troundToZero: function () {\r\n\t\r\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnegate: function () {\r\n\t\r\n\t\t\tthis.x = - this.x;\r\n\t\t\tthis.y = - this.y;\r\n\t\t\tthis.z = - this.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdot: function ( v ) {\r\n\t\r\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthSq: function () {\r\n\t\r\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlength: function () {\r\n\t\r\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthManhattan: function () {\r\n\t\r\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\treturn this.divideScalar( this.length() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetLength: function ( length ) {\r\n\t\r\n\t\t\treturn this.multiplyScalar( length / this.length() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerp: function ( v, alpha ) {\r\n\t\r\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerpVectors: function ( v1, v2, alpha ) {\r\n\t\r\n\t\t\tthis.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcross: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.crossVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\r\n\t\t\tthis.x = y * v.z - z * v.y;\r\n\t\t\tthis.y = z * v.x - x * v.z;\r\n\t\t\tthis.z = x * v.y - y * v.x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcrossVectors: function ( a, b ) {\r\n\t\r\n\t\t\tvar ax = a.x, ay = a.y, az = a.z;\r\n\t\t\tvar bx = b.x, by = b.y, bz = b.z;\r\n\t\r\n\t\t\tthis.x = ay * bz - az * by;\r\n\t\t\tthis.y = az * bx - ax * bz;\r\n\t\t\tthis.z = ax * by - ay * bx;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tprojectOnVector: function () {\r\n\t\r\n\t\t\tvar v1, dot;\r\n\t\r\n\t\t\treturn function projectOnVector( vector ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\r\n\t\t\t\tv1.copy( vector ).normalize();\r\n\t\r\n\t\t\t\tdot = this.dot( v1 );\r\n\t\r\n\t\t\t\treturn this.copy( v1 ).multiplyScalar( dot );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tprojectOnPlane: function () {\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function projectOnPlane( planeNormal ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\r\n\t\t\t\tv1.copy( this ).projectOnVector( planeNormal );\r\n\t\r\n\t\t\t\treturn this.sub( v1 );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\treflect: function () {\r\n\t\r\n\t\t\t// reflect incident vector off plane orthogonal to normal\r\n\t\t\t// normal is assumed to have unit length\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function reflect( normal ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\r\n\t\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tangleTo: function ( v ) {\r\n\t\r\n\t\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\r\n\t\r\n\t\t\t// clamp, to handle numerical problems\r\n\t\r\n\t\t\treturn Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceTo: function ( v ) {\r\n\t\r\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToSquared: function ( v ) {\r\n\t\r\n\t\t\tvar dx = this.x - v.x;\r\n\t\t\tvar dy = this.y - v.y;\r\n\t\t\tvar dz = this.z - v.z;\r\n\t\r\n\t\t\treturn dx * dx + dy * dy + dz * dz;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromSpherical: function( s ) {\r\n\t\r\n\t\t\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\r\n\t\r\n\t\t\tthis.x = sinPhiRadius * Math.sin( s.theta );\r\n\t\t\tthis.y = Math.cos( s.phi ) * s.radius;\r\n\t\t\tthis.z = sinPhiRadius * Math.cos( s.theta );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromMatrixPosition: function ( m ) {\r\n\t\r\n\t\t\treturn this.setFromMatrixColumn( m, 3 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromMatrixScale: function ( m ) {\r\n\t\r\n\t\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\r\n\t\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\r\n\t\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\r\n\t\r\n\t\t\tthis.x = sx;\r\n\t\t\tthis.y = sy;\r\n\t\t\tthis.z = sz;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromMatrixColumn: function ( m, index ) {\r\n\t\r\n\t\t\tif ( typeof m === 'number' ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );\r\n\t\r\n\t\t\t\tm = arguments[ 1 ];\r\n\t\t\t\tindex = arguments[ 0 ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.fromArray( m.elements, index * 4 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( v ) {\r\n\t\r\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis.x = array[ offset ];\r\n\t\t\tthis.y = array[ offset + 1 ];\r\n\t\t\tthis.z = array[ offset + 2 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this.x;\r\n\t\t\tarray[ offset + 1 ] = this.y;\r\n\t\t\tarray[ offset + 2 ] = this.z;\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromAttribute: function ( attribute, index, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tindex = index * attribute.itemSize + offset;\r\n\t\r\n\t\t\tthis.x = attribute.array[ index ];\r\n\t\t\tthis.y = attribute.array[ index + 1 ];\r\n\t\t\tthis.z = attribute.array[ index + 2 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Vector4.js\r\n\t\r\n\t/**\r\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\r\n\t * @author philogb / http://blog.thejit.org/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author egraether / http://egraether.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.Vector4 = function ( x, y, z, w ) {\r\n\t\r\n\t\tthis.x = x || 0;\r\n\t\tthis.y = y || 0;\r\n\t\tthis.z = z || 0;\r\n\t\tthis.w = ( w !== undefined ) ? w : 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Vector4.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Vector4,\r\n\t\r\n\t\tset: function ( x, y, z, w ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t\tthis.z = z;\r\n\t\t\tthis.w = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetScalar: function ( scalar ) {\r\n\t\r\n\t\t\tthis.x = scalar;\r\n\t\t\tthis.y = scalar;\r\n\t\t\tthis.z = scalar;\r\n\t\t\tthis.w = scalar;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetX: function ( x ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetY: function ( y ) {\r\n\t\r\n\t\t\tthis.y = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetZ: function ( z ) {\r\n\t\r\n\t\t\tthis.z = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetW: function ( w ) {\r\n\t\r\n\t\t\tthis.w = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetComponent: function ( index, value ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: this.x = value; break;\r\n\t\t\t\tcase 1: this.y = value; break;\r\n\t\t\t\tcase 2: this.z = value; break;\r\n\t\t\t\tcase 3: this.w = value; break;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetComponent: function ( index ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: return this.x;\r\n\t\t\t\tcase 1: return this.y;\r\n\t\t\t\tcase 2: return this.z;\r\n\t\t\t\tcase 3: return this.w;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( v ) {\r\n\t\r\n\t\t\tthis.x = v.x;\r\n\t\t\tthis.y = v.y;\r\n\t\t\tthis.z = v.z;\r\n\t\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tadd: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.addVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x += v.x;\r\n\t\t\tthis.y += v.y;\r\n\t\t\tthis.z += v.z;\r\n\t\t\tthis.w += v.w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x += s;\r\n\t\t\tthis.y += s;\r\n\t\t\tthis.z += s;\r\n\t\t\tthis.w += s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x + b.x;\r\n\t\t\tthis.y = a.y + b.y;\r\n\t\t\tthis.z = a.z + b.z;\r\n\t\t\tthis.w = a.w + b.w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScaledVector: function ( v, s ) {\r\n\t\r\n\t\t\tthis.x += v.x * s;\r\n\t\t\tthis.y += v.y * s;\r\n\t\t\tthis.z += v.z * s;\r\n\t\t\tthis.w += v.w * s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsub: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.subVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x -= v.x;\r\n\t\t\tthis.y -= v.y;\r\n\t\t\tthis.z -= v.z;\r\n\t\t\tthis.w -= v.w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x -= s;\r\n\t\t\tthis.y -= s;\r\n\t\t\tthis.z -= s;\r\n\t\t\tthis.w -= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x - b.x;\r\n\t\t\tthis.y = a.y - b.y;\r\n\t\t\tthis.z = a.z - b.z;\r\n\t\t\tthis.w = a.w - b.w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyScalar: function ( scalar ) {\r\n\t\r\n\t\t\tif ( isFinite( scalar ) ) {\r\n\t\r\n\t\t\t\tthis.x *= scalar;\r\n\t\t\t\tthis.y *= scalar;\r\n\t\t\t\tthis.z *= scalar;\r\n\t\t\t\tthis.w *= scalar;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.x = 0;\r\n\t\t\t\tthis.y = 0;\r\n\t\t\t\tthis.z = 0;\r\n\t\t\t\tthis.w = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function ( m ) {\r\n\t\r\n\t\t\tvar x = this.x;\r\n\t\t\tvar y = this.y;\r\n\t\t\tvar z = this.z;\r\n\t\t\tvar w = this.w;\r\n\t\r\n\t\t\tvar e = m.elements;\r\n\t\r\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\r\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\r\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\r\n\t\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdivideScalar: function ( scalar ) {\r\n\t\r\n\t\t\treturn this.multiplyScalar( 1 / scalar );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetAxisAngleFromQuaternion: function ( q ) {\r\n\t\r\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\r\n\t\r\n\t\t\t// q is assumed to be normalized\r\n\t\r\n\t\t\tthis.w = 2 * Math.acos( q.w );\r\n\t\r\n\t\t\tvar s = Math.sqrt( 1 - q.w * q.w );\r\n\t\r\n\t\t\tif ( s < 0.0001 ) {\r\n\t\r\n\t\t\t\t this.x = 1;\r\n\t\t\t\t this.y = 0;\r\n\t\t\t\t this.z = 0;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t this.x = q.x / s;\r\n\t\t\t\t this.y = q.y / s;\r\n\t\t\t\t this.z = q.z / s;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetAxisAngleFromRotationMatrix: function ( m ) {\r\n\t\r\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\r\n\t\r\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\t\r\n\t\t\tvar angle, x, y, z,\t\t// variables for result\r\n\t\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\r\n\t\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\r\n\t\r\n\t\t\t\tte = m.elements,\r\n\t\r\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\t\r\n\t\t\tif ( ( Math.abs( m12 - m21 ) < epsilon )\r\n\t\t\t   && ( Math.abs( m13 - m31 ) < epsilon )\r\n\t\t\t   && ( Math.abs( m23 - m32 ) < epsilon ) ) {\r\n\t\r\n\t\t\t\t// singularity found\r\n\t\t\t\t// first check for identity matrix which must have +1 for all terms\r\n\t\t\t\t// in leading diagonal and zero in other terms\r\n\t\r\n\t\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 )\r\n\t\t\t\t   && ( Math.abs( m13 + m31 ) < epsilon2 )\r\n\t\t\t\t   && ( Math.abs( m23 + m32 ) < epsilon2 )\r\n\t\t\t\t   && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\r\n\t\r\n\t\t\t\t\t// this singularity is identity matrix so angle = 0\r\n\t\r\n\t\t\t\t\tthis.set( 1, 0, 0, 0 );\r\n\t\r\n\t\t\t\t\treturn this; // zero angle, arbitrary axis\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// otherwise this singularity is angle = 180\r\n\t\r\n\t\t\t\tangle = Math.PI;\r\n\t\r\n\t\t\t\tvar xx = ( m11 + 1 ) / 2;\r\n\t\t\t\tvar yy = ( m22 + 1 ) / 2;\r\n\t\t\t\tvar zz = ( m33 + 1 ) / 2;\r\n\t\t\t\tvar xy = ( m12 + m21 ) / 4;\r\n\t\t\t\tvar xz = ( m13 + m31 ) / 4;\r\n\t\t\t\tvar yz = ( m23 + m32 ) / 4;\r\n\t\r\n\t\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\r\n\t\r\n\t\t\t\t\t// m11 is the largest diagonal term\r\n\t\r\n\t\t\t\t\tif ( xx < epsilon ) {\r\n\t\r\n\t\t\t\t\t\tx = 0;\r\n\t\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\t\tz = 0.707106781;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tx = Math.sqrt( xx );\r\n\t\t\t\t\t\ty = xy / x;\r\n\t\t\t\t\t\tz = xz / x;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( yy > zz ) {\r\n\t\r\n\t\t\t\t\t// m22 is the largest diagonal term\r\n\t\r\n\t\t\t\t\tif ( yy < epsilon ) {\r\n\t\r\n\t\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\t\ty = 0;\r\n\t\t\t\t\t\tz = 0.707106781;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\ty = Math.sqrt( yy );\r\n\t\t\t\t\t\tx = xy / y;\r\n\t\t\t\t\t\tz = yz / y;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// m33 is the largest diagonal term so base result on this\r\n\t\r\n\t\t\t\t\tif ( zz < epsilon ) {\r\n\t\r\n\t\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\t\tz = 0;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tz = Math.sqrt( zz );\r\n\t\t\t\t\t\tx = xz / z;\r\n\t\t\t\t\t\ty = yz / z;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.set( x, y, z, angle );\r\n\t\r\n\t\t\t\treturn this; // return 180 deg rotation\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// as we have reached here there are no singularities so we can handle normally\r\n\t\r\n\t\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )\r\n\t\t\t\t\t\t\t  + ( m13 - m31 ) * ( m13 - m31 )\r\n\t\t\t\t\t\t\t  + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\r\n\t\r\n\t\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\r\n\t\r\n\t\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\r\n\t\t\t// caught by singularity test above, but I've left it in just in case\r\n\t\r\n\t\t\tthis.x = ( m32 - m23 ) / s;\r\n\t\t\tthis.y = ( m13 - m31 ) / s;\r\n\t\t\tthis.z = ( m21 - m12 ) / s;\r\n\t\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmin: function ( v ) {\r\n\t\r\n\t\t\tthis.x = Math.min( this.x, v.x );\r\n\t\t\tthis.y = Math.min( this.y, v.y );\r\n\t\t\tthis.z = Math.min( this.z, v.z );\r\n\t\t\tthis.w = Math.min( this.w, v.w );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmax: function ( v ) {\r\n\t\r\n\t\t\tthis.x = Math.max( this.x, v.x );\r\n\t\t\tthis.y = Math.max( this.y, v.y );\r\n\t\t\tthis.z = Math.max( this.z, v.z );\r\n\t\t\tthis.w = Math.max( this.w, v.w );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclamp: function ( min, max ) {\r\n\t\r\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\t\r\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\r\n\t\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampScalar: function () {\r\n\t\r\n\t\t\tvar min, max;\r\n\t\r\n\t\t\treturn function clampScalar( minVal, maxVal ) {\r\n\t\r\n\t\t\t\tif ( min === undefined ) {\r\n\t\r\n\t\t\t\t\tmin = new THREE.Vector4();\r\n\t\t\t\t\tmax = new THREE.Vector4();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tmin.set( minVal, minVal, minVal, minVal );\r\n\t\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\r\n\t\r\n\t\t\t\treturn this.clamp( min, max );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tfloor: function () {\r\n\t\r\n\t\t\tthis.x = Math.floor( this.x );\r\n\t\t\tthis.y = Math.floor( this.y );\r\n\t\t\tthis.z = Math.floor( this.z );\r\n\t\t\tthis.w = Math.floor( this.w );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tceil: function () {\r\n\t\r\n\t\t\tthis.x = Math.ceil( this.x );\r\n\t\t\tthis.y = Math.ceil( this.y );\r\n\t\t\tthis.z = Math.ceil( this.z );\r\n\t\t\tthis.w = Math.ceil( this.w );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tround: function () {\r\n\t\r\n\t\t\tthis.x = Math.round( this.x );\r\n\t\t\tthis.y = Math.round( this.y );\r\n\t\t\tthis.z = Math.round( this.z );\r\n\t\t\tthis.w = Math.round( this.w );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\troundToZero: function () {\r\n\t\r\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\t\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnegate: function () {\r\n\t\r\n\t\t\tthis.x = - this.x;\r\n\t\t\tthis.y = - this.y;\r\n\t\t\tthis.z = - this.z;\r\n\t\t\tthis.w = - this.w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdot: function ( v ) {\r\n\t\r\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthSq: function () {\r\n\t\r\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlength: function () {\r\n\t\r\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthManhattan: function () {\r\n\t\r\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\treturn this.divideScalar( this.length() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetLength: function ( length ) {\r\n\t\r\n\t\t\treturn this.multiplyScalar( length / this.length() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerp: function ( v, alpha ) {\r\n\t\r\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\t\t\tthis.w += ( v.w - this.w ) * alpha;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerpVectors: function ( v1, v2, alpha ) {\r\n\t\r\n\t\t\tthis.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( v ) {\r\n\t\r\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis.x = array[ offset ];\r\n\t\t\tthis.y = array[ offset + 1 ];\r\n\t\t\tthis.z = array[ offset + 2 ];\r\n\t\t\tthis.w = array[ offset + 3 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this.x;\r\n\t\t\tarray[ offset + 1 ] = this.y;\r\n\t\t\tarray[ offset + 2 ] = this.z;\r\n\t\t\tarray[ offset + 3 ] = this.w;\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromAttribute: function ( attribute, index, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tindex = index * attribute.itemSize + offset;\r\n\t\r\n\t\t\tthis.x = attribute.array[ index ];\r\n\t\t\tthis.y = attribute.array[ index + 1 ];\r\n\t\t\tthis.z = attribute.array[ index + 2 ];\r\n\t\t\tthis.w = attribute.array[ index + 3 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Euler.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @author bhouston / http://clara.io\r\n\t */\r\n\t\r\n\tTHREE.Euler = function ( x, y, z, order ) {\r\n\t\r\n\t\tthis._x = x || 0;\r\n\t\tthis._y = y || 0;\r\n\t\tthis._z = z || 0;\r\n\t\tthis._order = order || THREE.Euler.DefaultOrder;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\r\n\t\r\n\tTHREE.Euler.DefaultOrder = 'XYZ';\r\n\t\r\n\tTHREE.Euler.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Euler,\r\n\t\r\n\t\tget x () {\r\n\t\r\n\t\t\treturn this._x;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset x ( value ) {\r\n\t\r\n\t\t\tthis._x = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget y () {\r\n\t\r\n\t\t\treturn this._y;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset y ( value ) {\r\n\t\r\n\t\t\tthis._y = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget z () {\r\n\t\r\n\t\t\treturn this._z;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset z ( value ) {\r\n\t\r\n\t\t\tthis._z = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget order () {\r\n\t\r\n\t\t\treturn this._order;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset order ( value ) {\r\n\t\r\n\t\t\tthis._order = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset: function ( x, y, z, order ) {\r\n\t\r\n\t\t\tthis._x = x;\r\n\t\t\tthis._y = y;\r\n\t\t\tthis._z = z;\r\n\t\t\tthis._order = order || this._order;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( euler ) {\r\n\t\r\n\t\t\tthis._x = euler._x;\r\n\t\t\tthis._y = euler._y;\r\n\t\t\tthis._z = euler._z;\r\n\t\t\tthis._order = euler._order;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromRotationMatrix: function ( m, order, update ) {\r\n\t\r\n\t\t\tvar clamp = THREE.Math.clamp;\r\n\t\r\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\t\r\n\t\t\tvar te = m.elements;\r\n\t\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\r\n\t\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\r\n\t\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\t\r\n\t\t\torder = order || this._order;\r\n\t\r\n\t\t\tif ( order === 'XYZ' ) {\r\n\t\r\n\t\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\t\tthis._z = Math.atan2( - m12, m11 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\t\tthis._z = 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( order === 'YXZ' ) {\r\n\t\r\n\t\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\t\t\t\t\tthis._z = Math.atan2( m21, m22 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\t\t\t\t\tthis._z = 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( order === 'ZXY' ) {\r\n\t\r\n\t\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._y = Math.atan2( - m31, m33 );\r\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._y = 0;\r\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( order === 'ZYX' ) {\r\n\t\r\n\t\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( m32, m33 );\r\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._x = 0;\r\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( order === 'YZX' ) {\r\n\t\r\n\t\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( - m23, m22 );\r\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._x = 0;\r\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( order === 'XZY' ) {\r\n\t\r\n\t\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\t\tthis._y = Math.atan2( m13, m11 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\t\tthis._y = 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._order = order;\r\n\t\r\n\t\t\tif ( update !== false ) this.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromQuaternion: function () {\r\n\t\r\n\t\t\tvar matrix;\r\n\t\r\n\t\t\treturn function ( q, order, update ) {\r\n\t\r\n\t\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\t\t\t\tmatrix.makeRotationFromQuaternion( q );\r\n\t\t\t\tthis.setFromRotationMatrix( matrix, order, update );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tsetFromVector3: function ( v, order ) {\r\n\t\r\n\t\t\treturn this.set( v.x, v.y, v.z, order || this._order );\r\n\t\r\n\t\t},\r\n\t\r\n\t\treorder: function () {\r\n\t\r\n\t\t\t// WARNING: this discards revolution information -bhouston\r\n\t\r\n\t\t\tvar q = new THREE.Quaternion();\r\n\t\r\n\t\t\treturn function ( newOrder ) {\r\n\t\r\n\t\t\t\tq.setFromEuler( this );\r\n\t\t\t\tthis.setFromQuaternion( q, newOrder );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tequals: function ( euler ) {\r\n\t\r\n\t\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array ) {\r\n\t\r\n\t\t\tthis._x = array[ 0 ];\r\n\t\t\tthis._y = array[ 1 ];\r\n\t\t\tthis._z = array[ 2 ];\r\n\t\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this._x;\r\n\t\t\tarray[ offset + 1 ] = this._y;\r\n\t\t\tarray[ offset + 2 ] = this._z;\r\n\t\t\tarray[ offset + 3 ] = this._order;\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoVector3: function ( optionalResult ) {\r\n\t\r\n\t\t\tif ( optionalResult ) {\r\n\t\r\n\t\t\t\treturn optionalResult.set( this._x, this._y, this._z );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\treturn new THREE.Vector3( this._x, this._y, this._z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tonChange: function ( callback ) {\r\n\t\r\n\t\t\tthis.onChangeCallback = callback;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tonChangeCallback: function () {}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Line3.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://clara.io\r\n\t */\r\n\t\r\n\tTHREE.Line3 = function ( start, end ) {\r\n\t\r\n\t\tthis.start = ( start !== undefined ) ? start : new THREE.Vector3();\r\n\t\tthis.end = ( end !== undefined ) ? end : new THREE.Vector3();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Line3.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Line3,\r\n\t\r\n\t\tset: function ( start, end ) {\r\n\t\r\n\t\t\tthis.start.copy( start );\r\n\t\t\tthis.end.copy( end );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( line ) {\r\n\t\r\n\t\t\tthis.start.copy( line.start );\r\n\t\t\tthis.end.copy( line.end );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcenter: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdelta: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.subVectors( this.end, this.start );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceSq: function () {\r\n\t\r\n\t\t\treturn this.start.distanceToSquared( this.end );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistance: function () {\r\n\t\r\n\t\t\treturn this.start.distanceTo( this.end );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tat: function ( t, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclosestPointToPointParameter: function () {\r\n\t\r\n\t\t\tvar startP = new THREE.Vector3();\r\n\t\t\tvar startEnd = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( point, clampToLine ) {\r\n\t\r\n\t\t\t\tstartP.subVectors( point, this.start );\r\n\t\t\t\tstartEnd.subVectors( this.end, this.start );\r\n\t\r\n\t\t\t\tvar startEnd2 = startEnd.dot( startEnd );\r\n\t\t\t\tvar startEnd_startP = startEnd.dot( startP );\r\n\t\r\n\t\t\t\tvar t = startEnd_startP / startEnd2;\r\n\t\r\n\t\t\t\tif ( clampToLine ) {\r\n\t\r\n\t\t\t\t\tt = THREE.Math.clamp( t, 0, 1 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn t;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\r\n\t\r\n\t\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function ( matrix ) {\r\n\t\r\n\t\t\tthis.start.applyMatrix4( matrix );\r\n\t\t\tthis.end.applyMatrix4( matrix );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( line ) {\r\n\t\r\n\t\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Box2.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://clara.io\r\n\t */\r\n\t\r\n\tTHREE.Box2 = function ( min, max ) {\r\n\t\r\n\t\tthis.min = ( min !== undefined ) ? min : new THREE.Vector2( + Infinity, + Infinity );\r\n\t\tthis.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Box2.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Box2,\r\n\t\r\n\t\tset: function ( min, max ) {\r\n\t\r\n\t\t\tthis.min.copy( min );\r\n\t\t\tthis.max.copy( max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromPoints: function ( points ) {\r\n\t\r\n\t\t\tthis.makeEmpty();\r\n\t\r\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tthis.expandByPoint( points[ i ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromCenterAndSize: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector2();\r\n\t\r\n\t\t\treturn function ( center, size ) {\r\n\t\r\n\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\t\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\t\tthis.max.copy( center ).add( halfSize );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( box ) {\r\n\t\r\n\t\t\tthis.min.copy( box.min );\r\n\t\t\tthis.max.copy( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeEmpty: function () {\r\n\t\r\n\t\t\tthis.min.x = this.min.y = + Infinity;\r\n\t\t\tthis.max.x = this.max.y = - Infinity;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tisEmpty: function () {\r\n\t\r\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\t\r\n\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcenter: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsize: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\t\treturn result.subVectors( this.max, this.min );\r\n\t\r\n\t\t},\r\n\t\r\n\t\texpandByPoint: function ( point ) {\r\n\t\r\n\t\t\tthis.min.min( point );\r\n\t\t\tthis.max.max( point );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\texpandByVector: function ( vector ) {\r\n\t\r\n\t\t\tthis.min.sub( vector );\r\n\t\t\tthis.max.add( vector );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\texpandByScalar: function ( scalar ) {\r\n\t\r\n\t\t\tthis.min.addScalar( - scalar );\r\n\t\t\tthis.max.addScalar( scalar );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsPoint: function ( point ) {\r\n\t\r\n\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\r\n\t\t\t     point.y < this.min.y || point.y > this.max.y ) {\r\n\t\r\n\t\t\t\treturn false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsBox: function ( box ) {\r\n\t\r\n\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n\t\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetParameter: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\t// This can potentially have a divide by zero if the box\r\n\t\t\t// has a size dimension of 0.\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\r\n\t\t\treturn result.set(\r\n\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\r\n\t\t\t);\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsBox: function ( box ) {\r\n\t\r\n\t\t\t// using 6 splitting planes to rule out intersections.\r\n\t\r\n\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\r\n\t\r\n\t\t\t\treturn false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\t\treturn result.copy( point ).clamp( this.min, this.max );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPoint: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector2();\r\n\t\r\n\t\t\treturn function ( point ) {\r\n\t\r\n\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\t\treturn clampedPoint.sub( point ).length();\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tintersect: function ( box ) {\r\n\t\r\n\t\t\tthis.min.max( box.min );\r\n\t\t\tthis.max.min( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tunion: function ( box ) {\r\n\t\r\n\t\t\tthis.min.min( box.min );\r\n\t\t\tthis.max.max( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttranslate: function ( offset ) {\r\n\t\r\n\t\t\tthis.min.add( offset );\r\n\t\t\tthis.max.add( offset );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( box ) {\r\n\t\r\n\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Box3.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://clara.io\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.Box3 = function ( min, max ) {\r\n\t\r\n\t\tthis.min = ( min !== undefined ) ? min : new THREE.Vector3( + Infinity, + Infinity, + Infinity );\r\n\t\tthis.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Box3.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Box3,\r\n\t\r\n\t\tset: function ( min, max ) {\r\n\t\r\n\t\t\tthis.min.copy( min );\r\n\t\t\tthis.max.copy( max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromArray: function ( array ) {\r\n\t\r\n\t\t\tthis.makeEmpty();\r\n\t\r\n\t\t\tvar minX = + Infinity;\r\n\t\t\tvar minY = + Infinity;\r\n\t\t\tvar minZ = + Infinity;\r\n\t\r\n\t\t\tvar maxX = - Infinity;\r\n\t\t\tvar maxY = - Infinity;\r\n\t\t\tvar maxZ = - Infinity;\r\n\t\r\n\t\t\tfor ( var i = 0, il = array.length; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\tvar x = array[ i ];\r\n\t\t\t\tvar y = array[ i + 1 ];\r\n\t\t\t\tvar z = array[ i + 2 ];\r\n\t\r\n\t\t\t\tif ( x < minX ) minX = x;\r\n\t\t\t\tif ( y < minY ) minY = y;\r\n\t\t\t\tif ( z < minZ ) minZ = z;\r\n\t\r\n\t\t\t\tif ( x > maxX ) maxX = x;\r\n\t\t\t\tif ( y > maxY ) maxY = y;\r\n\t\t\t\tif ( z > maxZ ) maxZ = z;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.min.set( minX, minY, minZ );\r\n\t\t\tthis.max.set( maxX, maxY, maxZ );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromPoints: function ( points ) {\r\n\t\r\n\t\t\tthis.makeEmpty();\r\n\t\r\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tthis.expandByPoint( points[ i ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromCenterAndSize: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( center, size ) {\r\n\t\r\n\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\t\r\n\t\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\t\tthis.max.copy( center ).add( halfSize );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tsetFromObject: function () {\r\n\t\r\n\t\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\r\n\t\t\t// accounting for both the object's, and children's, world transforms\r\n\t\r\n\t\t\tvar box;\r\n\t\r\n\t\t\treturn function ( object ) {\r\n\t\r\n\t\t\t\tif ( box === undefined ) box = new THREE.Box3();\r\n\t\r\n\t\t\t\tvar scope = this;\r\n\t\r\n\t\t\t\tthis.makeEmpty();\r\n\t\r\n\t\t\t\tobject.updateMatrixWorld( true );\r\n\t\r\n\t\t\t\tobject.traverse( function ( node ) {\r\n\t\r\n\t\t\t\t\tvar geometry = node.geometry;\r\n\t\r\n\t\t\t\t\tif ( geometry !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tif ( geometry.boundingBox === null ) {\r\n\t\r\n\t\t\t\t\t\t\tgeometry.computeBoundingBox();\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( geometry.boundingBox.isEmpty() === false ) {\r\n\t\r\n\t\t\t\t\t\t\tbox.copy( geometry.boundingBox );\r\n\t\t\t\t\t\t\tbox.applyMatrix4( node.matrixWorld );\r\n\t\t\t\t\t\t\tscope.union( box );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( box ) {\r\n\t\r\n\t\t\tthis.min.copy( box.min );\r\n\t\t\tthis.max.copy( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeEmpty: function () {\r\n\t\r\n\t\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\r\n\t\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tisEmpty: function () {\r\n\t\r\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\t\r\n\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcenter: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsize: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.subVectors( this.max, this.min );\r\n\t\r\n\t\t},\r\n\t\r\n\t\texpandByPoint: function ( point ) {\r\n\t\r\n\t\t\tthis.min.min( point );\r\n\t\t\tthis.max.max( point );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\texpandByVector: function ( vector ) {\r\n\t\r\n\t\t\tthis.min.sub( vector );\r\n\t\t\tthis.max.add( vector );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\texpandByScalar: function ( scalar ) {\r\n\t\r\n\t\t\tthis.min.addScalar( - scalar );\r\n\t\t\tthis.max.addScalar( scalar );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsPoint: function ( point ) {\r\n\t\r\n\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\r\n\t\t\t\t\t point.y < this.min.y || point.y > this.max.y ||\r\n\t\t\t\t\t point.z < this.min.z || point.z > this.max.z ) {\r\n\t\r\n\t\t\t\treturn false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsBox: function ( box ) {\r\n\t\r\n\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n\t\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\r\n\t\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetParameter: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\t// This can potentially have a divide by zero if the box\r\n\t\t\t// has a size dimension of 0.\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\treturn result.set(\r\n\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\r\n\t\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\r\n\t\t\t);\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsBox: function ( box ) {\r\n\t\r\n\t\t\t// using 6 splitting planes to rule out intersections.\r\n\t\r\n\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t\t\t\t box.max.y < this.min.y || box.min.y > this.max.y ||\r\n\t\t\t\t\t box.max.z < this.min.z || box.min.z > this.max.z ) {\r\n\t\r\n\t\t\t\treturn false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsSphere: ( function () {\r\n\t\r\n\t\t\tvar closestPoint;\r\n\t\r\n\t\t\treturn function intersectsSphere( sphere ) {\r\n\t\r\n\t\t\t\tif ( closestPoint === undefined ) closestPoint = new THREE.Vector3();\r\n\t\r\n\t\t\t\t// Find the point on the AABB closest to the sphere center.\r\n\t\t\t\tthis.clampPoint( sphere.center, closestPoint );\r\n\t\r\n\t\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\r\n\t\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )(),\r\n\t\r\n\t\tintersectsPlane: function ( plane ) {\r\n\t\r\n\t\t\t// We compute the minimum and maximum dot product values. If those values\r\n\t\t\t// are on the same side (back or front) of the plane, then there is no intersection.\r\n\t\r\n\t\t\tvar min, max;\r\n\t\r\n\t\t\tif ( plane.normal.x > 0 ) {\r\n\t\r\n\t\t\t\tmin = plane.normal.x * this.min.x;\r\n\t\t\t\tmax = plane.normal.x * this.max.x;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tmin = plane.normal.x * this.max.x;\r\n\t\t\t\tmax = plane.normal.x * this.min.x;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( plane.normal.y > 0 ) {\r\n\t\r\n\t\t\t\tmin += plane.normal.y * this.min.y;\r\n\t\t\t\tmax += plane.normal.y * this.max.y;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tmin += plane.normal.y * this.max.y;\r\n\t\t\t\tmax += plane.normal.y * this.min.y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( plane.normal.z > 0 ) {\r\n\t\r\n\t\t\t\tmin += plane.normal.z * this.min.z;\r\n\t\t\t\tmax += plane.normal.z * this.max.z;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tmin += plane.normal.z * this.max.z;\r\n\t\t\t\tmax += plane.normal.z * this.min.z;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn ( min <= plane.constant && max >= plane.constant );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.copy( point ).clamp( this.min, this.max );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPoint: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( point ) {\r\n\t\r\n\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\t\treturn clampedPoint.sub( point ).length();\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tgetBoundingSphere: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Sphere();\r\n\t\r\n\t\t\t\tresult.center = this.center();\r\n\t\t\t\tresult.radius = this.size( v1 ).length() * 0.5;\r\n\t\r\n\t\t\t\treturn result;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tintersect: function ( box ) {\r\n\t\r\n\t\t\tthis.min.max( box.min );\r\n\t\t\tthis.max.min( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tunion: function ( box ) {\r\n\t\r\n\t\t\tthis.min.min( box.min );\r\n\t\t\tthis.max.max( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function () {\r\n\t\r\n\t\t\tvar points = [\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3()\r\n\t\t\t];\r\n\t\r\n\t\t\treturn function ( matrix ) {\r\n\t\r\n\t\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\r\n\t\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\r\n\t\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\r\n\t\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\r\n\t\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\r\n\t\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\r\n\t\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\r\n\t\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\r\n\t\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\t// 111\r\n\t\r\n\t\t\t\tthis.makeEmpty();\r\n\t\t\t\tthis.setFromPoints( points );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslate: function ( offset ) {\r\n\t\r\n\t\t\tthis.min.add( offset );\r\n\t\t\tthis.max.add( offset );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( box ) {\r\n\t\r\n\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Matrix3.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @author bhouston / http://clara.io\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.Matrix3 = function () {\r\n\t\r\n\t\tthis.elements = new Float32Array( [\r\n\t\r\n\t\t\t1, 0, 0,\r\n\t\t\t0, 1, 0,\r\n\t\t\t0, 0, 1\r\n\t\r\n\t\t] );\r\n\t\r\n\t\tif ( arguments.length > 0 ) {\r\n\t\r\n\t\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Matrix3.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Matrix3,\r\n\t\r\n\t\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\r\n\t\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\r\n\t\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tidentity: function () {\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\t1, 0, 0,\r\n\t\t\t\t0, 1, 0,\r\n\t\t\t\t0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().fromArray( this.elements );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( m ) {\r\n\t\r\n\t\t\tvar me = m.elements;\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\tme[ 0 ], me[ 3 ], me[ 6 ],\r\n\t\t\t\tme[ 1 ], me[ 4 ], me[ 7 ],\r\n\t\t\t\tme[ 2 ], me[ 5 ], me[ 8 ]\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromMatrix4: function( m ) {\r\n\t\r\n\t\t\tvar me = m.elements;\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\tme[ 0 ], me[ 4 ], me[  8 ],\r\n\t\t\t\tme[ 1 ], me[ 5 ], me[  9 ],\r\n\t\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyToVector3Array: function () {\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function ( array, offset, length ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\t\tif ( length === undefined ) length = array.length;\r\n\t\r\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\r\n\t\r\n\t\t\t\t\tv1.fromArray( array, j );\r\n\t\t\t\t\tv1.applyMatrix3( this );\r\n\t\t\t\t\tv1.toArray( array, j );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn array;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tapplyToBuffer: function () {\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function applyToBuffer( buffer, offset, length ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\r\n\t\r\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\r\n\t\r\n\t\t\t\t\tv1.x = buffer.getX( j );\r\n\t\t\t\t\tv1.y = buffer.getY( j );\r\n\t\t\t\t\tv1.z = buffer.getZ( j );\r\n\t\r\n\t\t\t\t\tv1.applyMatrix3( this );\r\n\t\r\n\t\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn buffer;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tmultiplyScalar: function ( s ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\r\n\t\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\r\n\t\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdeterminant: function () {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\r\n\t\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\r\n\t\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\r\n\t\r\n\t\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetInverse: function ( matrix, throwOnDegenerate ) {\r\n\t\r\n\t\t\tif ( matrix instanceof THREE.Matrix4 ) {\r\n\t\r\n\t\t\t\tconsole.warn( \"THREE.Matrix3.getInverse no longer takes a Matrix4 argument.\" );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar me = matrix.elements,\r\n\t\t\t\tte = this.elements,\r\n\t\r\n\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\r\n\t\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\r\n\t\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\r\n\t\r\n\t\t\t\tt11 = n33 * n22 - n32 * n23,\r\n\t\t\t\tt12 = n32 * n13 - n33 * n12,\r\n\t\t\t\tt13 = n23 * n12 - n22 * n13,\r\n\t\r\n\t\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\r\n\t\r\n\t\t\tif ( det === 0 ) {\r\n\t\r\n\t\t\t\tvar msg = \"THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0\";\r\n\t\r\n\t\t\t\tif ( throwOnDegenerate || false ) {\r\n\t\r\n\t\t\t\t\tthrow new Error( msg );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tconsole.warn( msg );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn this.identity();\r\n\t\t\t}\r\n\t\r\n\t\t\tte[ 0 ] = t11;\r\n\t\t\tte[ 1 ] = n31 * n23 - n33 * n21;\r\n\t\t\tte[ 2 ] = n32 * n21 - n31 * n22;\r\n\t\r\n\t\t\tte[ 3 ] = t12;\r\n\t\t\tte[ 4 ] = n33 * n11 - n31 * n13;\r\n\t\t\tte[ 5 ] = n31 * n12 - n32 * n11;\r\n\t\r\n\t\t\tte[ 6 ] = t13;\r\n\t\t\tte[ 7 ] = n21 * n13 - n23 * n11;\r\n\t\t\tte[ 8 ] = n22 * n11 - n21 * n12;\r\n\t\r\n\t\t\treturn this.multiplyScalar( 1 / det );\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttranspose: function () {\r\n\t\r\n\t\t\tvar tmp, m = this.elements;\r\n\t\r\n\t\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\r\n\t\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\r\n\t\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tflattenToArrayOffset: function ( array, offset ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tarray[ offset ] = te[ 0 ];\r\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\t\r\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\t\r\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\t\t\tarray[ offset + 8 ]  = te[ 8 ];\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetNormalMatrix: function ( matrix4 ) {\r\n\t\r\n\t\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttransposeIntoArray: function ( r ) {\r\n\t\r\n\t\t\tvar m = this.elements;\r\n\t\r\n\t\t\tr[ 0 ] = m[ 0 ];\r\n\t\t\tr[ 1 ] = m[ 3 ];\r\n\t\t\tr[ 2 ] = m[ 6 ];\r\n\t\t\tr[ 3 ] = m[ 1 ];\r\n\t\t\tr[ 4 ] = m[ 4 ];\r\n\t\t\tr[ 5 ] = m[ 7 ];\r\n\t\t\tr[ 6 ] = m[ 2 ];\r\n\t\t\tr[ 7 ] = m[ 5 ];\r\n\t\t\tr[ 8 ] = m[ 8 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array ) {\r\n\t\r\n\t\t\tthis.elements.set( array );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function () {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\treturn [\r\n\t\t\t\tte[ 0 ], te[ 1 ], te[ 2 ],\r\n\t\t\t\tte[ 3 ], te[ 4 ], te[ 5 ],\r\n\t\t\t\tte[ 6 ], te[ 7 ], te[ 8 ]\r\n\t\t\t];\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Matrix4.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\r\n\t * @author philogb / http://blog.thejit.org/\r\n\t * @author jordi_ros / http://plattsoft.com\r\n\t * @author D1plo1d / http://github.com/D1plo1d\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author timknip / http://www.floorplanner.com/\r\n\t * @author bhouston / http://clara.io\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.Matrix4 = function () {\r\n\t\r\n\t\tthis.elements = new Float32Array( [\r\n\t\r\n\t\t\t1, 0, 0, 0,\r\n\t\t\t0, 1, 0, 0,\r\n\t\t\t0, 0, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\t\r\n\t\t] );\r\n\t\r\n\t\tif ( arguments.length > 0 ) {\r\n\t\r\n\t\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Matrix4.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Matrix4,\r\n\t\r\n\t\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\r\n\t\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\r\n\t\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\r\n\t\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tidentity: function () {\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\t1, 0, 0, 0,\r\n\t\t\t\t0, 1, 0, 0,\r\n\t\t\t\t0, 0, 1, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Matrix4().fromArray( this.elements );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( m ) {\r\n\t\r\n\t\t\tthis.elements.set( m.elements );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyPosition: function ( m ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar me = m.elements;\r\n\t\r\n\t\t\tte[ 12 ] = me[ 12 ];\r\n\t\t\tte[ 13 ] = me[ 13 ];\r\n\t\t\tte[ 14 ] = me[ 14 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\textractBasis: function ( xAxis, yAxis, zAxis ) {\r\n\t\r\n\t\t\txAxis.setFromMatrixColumn( this, 0 );\r\n\t\t\tyAxis.setFromMatrixColumn( this, 1 );\r\n\t\t\tzAxis.setFromMatrixColumn( this, 2 );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\r\n\t\r\n\t\t\tthis.set(\r\n\t\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\r\n\t\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\r\n\t\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\r\n\t\t\t\t0,       0,       0,       1\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\textractRotation: function () {\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function ( m ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\r\n\t\t\t\tvar te = this.elements;\r\n\t\t\t\tvar me = m.elements;\r\n\t\r\n\t\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\r\n\t\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\r\n\t\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\r\n\t\r\n\t\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\r\n\t\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\r\n\t\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\r\n\t\r\n\t\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\r\n\t\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\r\n\t\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\r\n\t\r\n\t\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\r\n\t\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\r\n\t\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tmakeRotationFromEuler: function ( euler ) {\r\n\t\r\n\t\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar x = euler.x, y = euler.y, z = euler.z;\r\n\t\t\tvar a = Math.cos( x ), b = Math.sin( x );\r\n\t\t\tvar c = Math.cos( y ), d = Math.sin( y );\r\n\t\t\tvar e = Math.cos( z ), f = Math.sin( z );\r\n\t\r\n\t\t\tif ( euler.order === 'XYZ' ) {\r\n\t\r\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\t\r\n\t\t\t\tte[ 0 ] = c * e;\r\n\t\t\t\tte[ 4 ] = - c * f;\r\n\t\t\t\tte[ 8 ] = d;\r\n\t\r\n\t\t\t\tte[ 1 ] = af + be * d;\r\n\t\t\t\tte[ 5 ] = ae - bf * d;\r\n\t\t\t\tte[ 9 ] = - b * c;\r\n\t\r\n\t\t\t\tte[ 2 ] = bf - ae * d;\r\n\t\t\t\tte[ 6 ] = be + af * d;\r\n\t\t\t\tte[ 10 ] = a * c;\r\n\t\r\n\t\t\t} else if ( euler.order === 'YXZ' ) {\r\n\t\r\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\t\r\n\t\t\t\tte[ 0 ] = ce + df * b;\r\n\t\t\t\tte[ 4 ] = de * b - cf;\r\n\t\t\t\tte[ 8 ] = a * d;\r\n\t\r\n\t\t\t\tte[ 1 ] = a * f;\r\n\t\t\t\tte[ 5 ] = a * e;\r\n\t\t\t\tte[ 9 ] = - b;\r\n\t\r\n\t\t\t\tte[ 2 ] = cf * b - de;\r\n\t\t\t\tte[ 6 ] = df + ce * b;\r\n\t\t\t\tte[ 10 ] = a * c;\r\n\t\r\n\t\t\t} else if ( euler.order === 'ZXY' ) {\r\n\t\r\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\t\r\n\t\t\t\tte[ 0 ] = ce - df * b;\r\n\t\t\t\tte[ 4 ] = - a * f;\r\n\t\t\t\tte[ 8 ] = de + cf * b;\r\n\t\r\n\t\t\t\tte[ 1 ] = cf + de * b;\r\n\t\t\t\tte[ 5 ] = a * e;\r\n\t\t\t\tte[ 9 ] = df - ce * b;\r\n\t\r\n\t\t\t\tte[ 2 ] = - a * d;\r\n\t\t\t\tte[ 6 ] = b;\r\n\t\t\t\tte[ 10 ] = a * c;\r\n\t\r\n\t\t\t} else if ( euler.order === 'ZYX' ) {\r\n\t\r\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\t\r\n\t\t\t\tte[ 0 ] = c * e;\r\n\t\t\t\tte[ 4 ] = be * d - af;\r\n\t\t\t\tte[ 8 ] = ae * d + bf;\r\n\t\r\n\t\t\t\tte[ 1 ] = c * f;\r\n\t\t\t\tte[ 5 ] = bf * d + ae;\r\n\t\t\t\tte[ 9 ] = af * d - be;\r\n\t\r\n\t\t\t\tte[ 2 ] = - d;\r\n\t\t\t\tte[ 6 ] = b * c;\r\n\t\t\t\tte[ 10 ] = a * c;\r\n\t\r\n\t\t\t} else if ( euler.order === 'YZX' ) {\r\n\t\r\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\t\r\n\t\t\t\tte[ 0 ] = c * e;\r\n\t\t\t\tte[ 4 ] = bd - ac * f;\r\n\t\t\t\tte[ 8 ] = bc * f + ad;\r\n\t\r\n\t\t\t\tte[ 1 ] = f;\r\n\t\t\t\tte[ 5 ] = a * e;\r\n\t\t\t\tte[ 9 ] = - b * e;\r\n\t\r\n\t\t\t\tte[ 2 ] = - d * e;\r\n\t\t\t\tte[ 6 ] = ad * f + bc;\r\n\t\t\t\tte[ 10 ] = ac - bd * f;\r\n\t\r\n\t\t\t} else if ( euler.order === 'XZY' ) {\r\n\t\r\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\t\r\n\t\t\t\tte[ 0 ] = c * e;\r\n\t\t\t\tte[ 4 ] = - f;\r\n\t\t\t\tte[ 8 ] = d * e;\r\n\t\r\n\t\t\t\tte[ 1 ] = ac * f + bd;\r\n\t\t\t\tte[ 5 ] = a * e;\r\n\t\t\t\tte[ 9 ] = ad * f - bc;\r\n\t\r\n\t\t\t\tte[ 2 ] = bc * f - ad;\r\n\t\t\t\tte[ 6 ] = b * e;\r\n\t\t\t\tte[ 10 ] = bd * f + ac;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// last column\r\n\t\t\tte[ 3 ] = 0;\r\n\t\t\tte[ 7 ] = 0;\r\n\t\t\tte[ 11 ] = 0;\r\n\t\r\n\t\t\t// bottom row\r\n\t\t\tte[ 12 ] = 0;\r\n\t\t\tte[ 13 ] = 0;\r\n\t\t\tte[ 14 ] = 0;\r\n\t\t\tte[ 15 ] = 1;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeRotationFromQuaternion: function ( q ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\r\n\t\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\r\n\t\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\r\n\t\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\r\n\t\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\r\n\t\r\n\t\t\tte[ 0 ] = 1 - ( yy + zz );\r\n\t\t\tte[ 4 ] = xy - wz;\r\n\t\t\tte[ 8 ] = xz + wy;\r\n\t\r\n\t\t\tte[ 1 ] = xy + wz;\r\n\t\t\tte[ 5 ] = 1 - ( xx + zz );\r\n\t\t\tte[ 9 ] = yz - wx;\r\n\t\r\n\t\t\tte[ 2 ] = xz - wy;\r\n\t\t\tte[ 6 ] = yz + wx;\r\n\t\t\tte[ 10 ] = 1 - ( xx + yy );\r\n\t\r\n\t\t\t// last column\r\n\t\t\tte[ 3 ] = 0;\r\n\t\t\tte[ 7 ] = 0;\r\n\t\t\tte[ 11 ] = 0;\r\n\t\r\n\t\t\t// bottom row\r\n\t\t\tte[ 12 ] = 0;\r\n\t\t\tte[ 13 ] = 0;\r\n\t\t\tte[ 14 ] = 0;\r\n\t\t\tte[ 15 ] = 1;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlookAt: function () {\r\n\t\r\n\t\t\tvar x, y, z;\r\n\t\r\n\t\t\treturn function ( eye, target, up ) {\r\n\t\r\n\t\t\t\tif ( x === undefined ) x = new THREE.Vector3();\r\n\t\t\t\tif ( y === undefined ) y = new THREE.Vector3();\r\n\t\t\t\tif ( z === undefined ) z = new THREE.Vector3();\r\n\t\r\n\t\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\t\tz.subVectors( eye, target ).normalize();\r\n\t\r\n\t\t\t\tif ( z.lengthSq() === 0 ) {\r\n\t\r\n\t\t\t\t\tz.z = 1;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tx.crossVectors( up, z ).normalize();\r\n\t\r\n\t\t\t\tif ( x.lengthSq() === 0 ) {\r\n\t\r\n\t\t\t\t\tz.x += 0.0001;\r\n\t\t\t\t\tx.crossVectors( up, z ).normalize();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\ty.crossVectors( z, x );\r\n\t\r\n\t\r\n\t\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\r\n\t\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\r\n\t\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tmultiply: function ( m, n ) {\r\n\t\r\n\t\t\tif ( n !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\r\n\t\t\t\treturn this.multiplyMatrices( m, n );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.multiplyMatrices( this, m );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyMatrices: function ( a, b ) {\r\n\t\r\n\t\t\tvar ae = a.elements;\r\n\t\t\tvar be = b.elements;\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\r\n\t\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\r\n\t\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\r\n\t\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\r\n\t\r\n\t\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\r\n\t\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\r\n\t\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\r\n\t\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\r\n\t\r\n\t\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\r\n\t\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\r\n\t\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\r\n\t\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\r\n\t\r\n\t\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\r\n\t\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\r\n\t\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\r\n\t\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\r\n\t\r\n\t\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\r\n\t\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\r\n\t\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\r\n\t\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\r\n\t\r\n\t\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\r\n\t\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\r\n\t\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\r\n\t\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyToArray: function ( a, b, r ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tthis.multiplyMatrices( a, b );\r\n\t\r\n\t\t\tr[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\r\n\t\t\tr[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\r\n\t\t\tr[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\r\n\t\t\tr[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyScalar: function ( s ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\r\n\t\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\r\n\t\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\r\n\t\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyToVector3Array: function () {\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function ( array, offset, length ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\t\tif ( length === undefined ) length = array.length;\r\n\t\r\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\r\n\t\r\n\t\t\t\t\tv1.fromArray( array, j );\r\n\t\t\t\t\tv1.applyMatrix4( this );\r\n\t\t\t\t\tv1.toArray( array, j );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn array;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tapplyToBuffer: function () {\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function applyToBuffer( buffer, offset, length ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\r\n\t\r\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\r\n\t\r\n\t\t\t\t\tv1.x = buffer.getX( j );\r\n\t\t\t\t\tv1.y = buffer.getY( j );\r\n\t\t\t\t\tv1.z = buffer.getZ( j );\r\n\t\r\n\t\t\t\t\tv1.applyMatrix4( this );\r\n\t\r\n\t\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn buffer;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tdeterminant: function () {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\r\n\t\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\r\n\t\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\r\n\t\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\r\n\t\r\n\t\t\t//TODO: make this more efficient\r\n\t\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\r\n\t\r\n\t\t\treturn (\r\n\t\t\t\tn41 * (\r\n\t\t\t\t\t+ n14 * n23 * n32\r\n\t\t\t\t\t - n13 * n24 * n32\r\n\t\t\t\t\t - n14 * n22 * n33\r\n\t\t\t\t\t + n12 * n24 * n33\r\n\t\t\t\t\t + n13 * n22 * n34\r\n\t\t\t\t\t - n12 * n23 * n34\r\n\t\t\t\t) +\r\n\t\t\t\tn42 * (\r\n\t\t\t\t\t+ n11 * n23 * n34\r\n\t\t\t\t\t - n11 * n24 * n33\r\n\t\t\t\t\t + n14 * n21 * n33\r\n\t\t\t\t\t - n13 * n21 * n34\r\n\t\t\t\t\t + n13 * n24 * n31\r\n\t\t\t\t\t - n14 * n23 * n31\r\n\t\t\t\t) +\r\n\t\t\t\tn43 * (\r\n\t\t\t\t\t+ n11 * n24 * n32\r\n\t\t\t\t\t - n11 * n22 * n34\r\n\t\t\t\t\t - n14 * n21 * n32\r\n\t\t\t\t\t + n12 * n21 * n34\r\n\t\t\t\t\t + n14 * n22 * n31\r\n\t\t\t\t\t - n12 * n24 * n31\r\n\t\t\t\t) +\r\n\t\t\t\tn44 * (\r\n\t\t\t\t\t- n13 * n22 * n31\r\n\t\t\t\t\t - n11 * n23 * n32\r\n\t\t\t\t\t + n11 * n22 * n33\r\n\t\t\t\t\t + n13 * n21 * n32\r\n\t\t\t\t\t - n12 * n21 * n33\r\n\t\t\t\t\t + n12 * n23 * n31\r\n\t\t\t\t)\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttranspose: function () {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar tmp;\r\n\t\r\n\t\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\r\n\t\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\r\n\t\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\r\n\t\r\n\t\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\r\n\t\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\r\n\t\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tflattenToArrayOffset: function ( array, offset ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tarray[ offset ] = te[ 0 ];\r\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\t\r\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\t\r\n\t\t\tarray[ offset + 8 ]  = te[ 8 ];\r\n\t\t\tarray[ offset + 9 ]  = te[ 9 ];\r\n\t\t\tarray[ offset + 10 ] = te[ 10 ];\r\n\t\t\tarray[ offset + 11 ] = te[ 11 ];\r\n\t\r\n\t\t\tarray[ offset + 12 ] = te[ 12 ];\r\n\t\t\tarray[ offset + 13 ] = te[ 13 ];\r\n\t\t\tarray[ offset + 14 ] = te[ 14 ];\r\n\t\t\tarray[ offset + 15 ] = te[ 15 ];\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetPosition: function () {\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\r\n\t\r\n\t\t\t\treturn v1.setFromMatrixColumn( this, 3 );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tsetPosition: function ( v ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tte[ 12 ] = v.x;\r\n\t\t\tte[ 13 ] = v.y;\r\n\t\t\tte[ 14 ] = v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetInverse: function ( m, throwOnDegenerate ) {\r\n\t\r\n\t\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n\t\t\tvar te = this.elements,\r\n\t\t\t\tme = m.elements,\r\n\t\r\n\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\r\n\t\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\r\n\t\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\r\n\t\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\r\n\t\r\n\t\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\r\n\t\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\r\n\t\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\r\n\t\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\r\n\t\r\n\t\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\r\n\t\r\n\t\t\tif ( det === 0 ) {\r\n\t\r\n\t\t\t\tvar msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\r\n\t\r\n\t\t\t\tif ( throwOnDegenerate || false ) {\r\n\t\r\n\t\t\t\t\tthrow new Error( msg );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tconsole.warn( msg );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn this.identity();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tte[ 0 ] = t11;\r\n\t\t\tte[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;\r\n\t\t\tte[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;\r\n\t\t\tte[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;\r\n\t\r\n\t\t\tte[ 4 ] = t12;\r\n\t\t\tte[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;\r\n\t\t\tte[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;\r\n\t\t\tte[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;\r\n\t\r\n\t\t\tte[ 8 ] = t13;\r\n\t\t\tte[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;\r\n\t\t\tte[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;\r\n\t\t\tte[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;\r\n\t\r\n\t\t\tte[ 12 ] = t14;\r\n\t\t\tte[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;\r\n\t\t\tte[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;\r\n\t\t\tte[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;\r\n\t\r\n\t\t\treturn this.multiplyScalar( 1 / det );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tscale: function ( v ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar x = v.x, y = v.y, z = v.z;\r\n\t\r\n\t\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\r\n\t\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\r\n\t\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\r\n\t\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetMaxScaleOnAxis: function () {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\r\n\t\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\r\n\t\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\r\n\t\r\n\t\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeTranslation: function ( x, y, z ) {\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\t1, 0, 0, x,\r\n\t\t\t\t0, 1, 0, y,\r\n\t\t\t\t0, 0, 1, z,\r\n\t\t\t\t0, 0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeRotationX: function ( theta ) {\r\n\t\r\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\t1, 0,  0, 0,\r\n\t\t\t\t0, c, - s, 0,\r\n\t\t\t\t0, s,  c, 0,\r\n\t\t\t\t0, 0,  0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeRotationY: function ( theta ) {\r\n\t\r\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\t c, 0, s, 0,\r\n\t\t\t\t 0, 1, 0, 0,\r\n\t\t\t\t- s, 0, c, 0,\r\n\t\t\t\t 0, 0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeRotationZ: function ( theta ) {\r\n\t\r\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\tc, - s, 0, 0,\r\n\t\t\t\ts,  c, 0, 0,\r\n\t\t\t\t0,  0, 1, 0,\r\n\t\t\t\t0,  0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeRotationAxis: function ( axis, angle ) {\r\n\t\r\n\t\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\r\n\t\r\n\t\t\tvar c = Math.cos( angle );\r\n\t\t\tvar s = Math.sin( angle );\r\n\t\t\tvar t = 1 - c;\r\n\t\t\tvar x = axis.x, y = axis.y, z = axis.z;\r\n\t\t\tvar tx = t * x, ty = t * y;\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\r\n\t\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\r\n\t\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\t return this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeScale: function ( x, y, z ) {\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\tx, 0, 0, 0,\r\n\t\t\t\t0, y, 0, 0,\r\n\t\t\t\t0, 0, z, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcompose: function ( position, quaternion, scale ) {\r\n\t\r\n\t\t\tthis.makeRotationFromQuaternion( quaternion );\r\n\t\t\tthis.scale( scale );\r\n\t\t\tthis.setPosition( position );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdecompose: function () {\r\n\t\r\n\t\t\tvar vector, matrix;\r\n\t\r\n\t\t\treturn function ( position, quaternion, scale ) {\r\n\t\r\n\t\t\t\tif ( vector === undefined ) vector = new THREE.Vector3();\r\n\t\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\r\n\t\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\r\n\t\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\r\n\t\r\n\t\t\t\t// if determine is negative, we need to invert one scale\r\n\t\t\t\tvar det = this.determinant();\r\n\t\t\t\tif ( det < 0 ) {\r\n\t\r\n\t\t\t\t\tsx = - sx;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tposition.x = te[ 12 ];\r\n\t\t\t\tposition.y = te[ 13 ];\r\n\t\t\t\tposition.z = te[ 14 ];\r\n\t\r\n\t\t\t\t// scale the rotation part\r\n\t\r\n\t\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\r\n\t\r\n\t\t\t\tvar invSX = 1 / sx;\r\n\t\t\t\tvar invSY = 1 / sy;\r\n\t\t\t\tvar invSZ = 1 / sz;\r\n\t\r\n\t\t\t\tmatrix.elements[ 0 ] *= invSX;\r\n\t\t\t\tmatrix.elements[ 1 ] *= invSX;\r\n\t\t\t\tmatrix.elements[ 2 ] *= invSX;\r\n\t\r\n\t\t\t\tmatrix.elements[ 4 ] *= invSY;\r\n\t\t\t\tmatrix.elements[ 5 ] *= invSY;\r\n\t\t\t\tmatrix.elements[ 6 ] *= invSY;\r\n\t\r\n\t\t\t\tmatrix.elements[ 8 ] *= invSZ;\r\n\t\t\t\tmatrix.elements[ 9 ] *= invSZ;\r\n\t\t\t\tmatrix.elements[ 10 ] *= invSZ;\r\n\t\r\n\t\t\t\tquaternion.setFromRotationMatrix( matrix );\r\n\t\r\n\t\t\t\tscale.x = sx;\r\n\t\t\t\tscale.y = sy;\r\n\t\t\t\tscale.z = sz;\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar x = 2 * near / ( right - left );\r\n\t\t\tvar y = 2 * near / ( top - bottom );\r\n\t\r\n\t\t\tvar a = ( right + left ) / ( right - left );\r\n\t\t\tvar b = ( top + bottom ) / ( top - bottom );\r\n\t\t\tvar c = - ( far + near ) / ( far - near );\r\n\t\t\tvar d = - 2 * far * near / ( far - near );\r\n\t\r\n\t\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\r\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\r\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\r\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakePerspective: function ( fov, aspect, near, far ) {\r\n\t\r\n\t\t\tvar ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );\r\n\t\t\tvar ymin = - ymax;\r\n\t\t\tvar xmin = ymin * aspect;\r\n\t\t\tvar xmax = ymax * aspect;\r\n\t\r\n\t\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar w = 1.0 / ( right - left );\r\n\t\t\tvar h = 1.0 / ( top - bottom );\r\n\t\t\tvar p = 1.0 / ( far - near );\r\n\t\r\n\t\t\tvar x = ( right + left ) * w;\r\n\t\t\tvar y = ( top + bottom ) * h;\r\n\t\t\tvar z = ( far + near ) * p;\r\n\t\r\n\t\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\r\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\r\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\r\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( matrix ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar me = matrix.elements;\r\n\t\r\n\t\t\tfor ( var i = 0; i < 16; i ++ ) {\r\n\t\r\n\t\t\t\tif ( te[ i ] !== me[ i ] ) return false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array ) {\r\n\t\r\n\t\t\tthis.elements.set( array );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function () {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\treturn [\r\n\t\t\t\tte[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],\r\n\t\t\t\tte[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],\r\n\t\t\t\tte[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],\r\n\t\t\t\tte[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]\r\n\t\t\t];\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Ray.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://clara.io\r\n\t */\r\n\t\r\n\tTHREE.Ray = function ( origin, direction ) {\r\n\t\r\n\t\tthis.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\r\n\t\tthis.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Ray.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Ray,\r\n\t\r\n\t\tset: function ( origin, direction ) {\r\n\t\r\n\t\t\tthis.origin.copy( origin );\r\n\t\t\tthis.direction.copy( direction );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( ray ) {\r\n\t\r\n\t\t\tthis.origin.copy( ray.origin );\r\n\t\t\tthis.direction.copy( ray.direction );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tat: function ( t, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlookAt: function ( v ) {\r\n\t\r\n\t\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\r\n\t\r\n\t\t},\r\n\t\r\n\t\trecast: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( t ) {\r\n\t\r\n\t\t\t\tthis.origin.copy( this.at( t, v1 ) );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclosestPointToPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\tresult.subVectors( point, this.origin );\r\n\t\t\tvar directionDistance = result.dot( this.direction );\r\n\t\r\n\t\t\tif ( directionDistance < 0 ) {\r\n\t\r\n\t\t\t\treturn result.copy( this.origin );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPoint: function ( point ) {\r\n\t\r\n\t\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceSqToPoint: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( point ) {\r\n\t\r\n\t\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\r\n\t\r\n\t\t\t\t// point behind the ray\r\n\t\r\n\t\t\t\tif ( directionDistance < 0 ) {\r\n\t\r\n\t\t\t\t\treturn this.origin.distanceToSquared( point );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\t\r\n\t\t\t\treturn v1.distanceToSquared( point );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tdistanceSqToSegment: function () {\r\n\t\r\n\t\t\tvar segCenter = new THREE.Vector3();\r\n\t\t\tvar segDir = new THREE.Vector3();\r\n\t\t\tvar diff = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\r\n\t\r\n\t\t\t\t// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp\r\n\t\t\t\t// It returns the min distance between the ray and the segment\r\n\t\t\t\t// defined by v0 and v1\r\n\t\t\t\t// It can also set two optional targets :\r\n\t\t\t\t// - The closest point on the ray\r\n\t\t\t\t// - The closest point on the segment\r\n\t\r\n\t\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\r\n\t\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\r\n\t\t\t\tdiff.copy( this.origin ).sub( segCenter );\r\n\t\r\n\t\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\r\n\t\t\t\tvar a01 = - this.direction.dot( segDir );\r\n\t\t\t\tvar b0 = diff.dot( this.direction );\r\n\t\t\t\tvar b1 = - diff.dot( segDir );\r\n\t\t\t\tvar c = diff.lengthSq();\r\n\t\t\t\tvar det = Math.abs( 1 - a01 * a01 );\r\n\t\t\t\tvar s0, s1, sqrDist, extDet;\r\n\t\r\n\t\t\t\tif ( det > 0 ) {\r\n\t\r\n\t\t\t\t\t// The ray and segment are not parallel.\r\n\t\r\n\t\t\t\t\ts0 = a01 * b1 - b0;\r\n\t\t\t\t\ts1 = a01 * b0 - b1;\r\n\t\t\t\t\textDet = segExtent * det;\r\n\t\r\n\t\t\t\t\tif ( s0 >= 0 ) {\r\n\t\r\n\t\t\t\t\t\tif ( s1 >= - extDet ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( s1 <= extDet ) {\r\n\t\r\n\t\t\t\t\t\t\t\t// region 0\r\n\t\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\r\n\t\r\n\t\t\t\t\t\t\t\tvar invDet = 1 / det;\r\n\t\t\t\t\t\t\t\ts0 *= invDet;\r\n\t\t\t\t\t\t\t\ts1 *= invDet;\r\n\t\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\t// region 1\r\n\t\r\n\t\t\t\t\t\t\t\ts1 = segExtent;\r\n\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t// region 5\r\n\t\r\n\t\t\t\t\t\t\ts1 = - segExtent;\r\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tif ( s1 <= - extDet ) {\r\n\t\r\n\t\t\t\t\t\t\t// region 4\r\n\t\r\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\r\n\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t} else if ( s1 <= extDet ) {\r\n\t\r\n\t\t\t\t\t\t\t// region 3\r\n\t\r\n\t\t\t\t\t\t\ts0 = 0;\r\n\t\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t// region 2\r\n\t\r\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\r\n\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// Ray and segment are parallel.\r\n\t\r\n\t\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\r\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( optionalPointOnRay ) {\r\n\t\r\n\t\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( optionalPointOnSegment ) {\r\n\t\r\n\t\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn sqrDist;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tintersectSphere: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( sphere, optionalTarget ) {\r\n\t\r\n\t\t\t\tv1.subVectors( sphere.center, this.origin );\r\n\t\t\t\tvar tca = v1.dot( this.direction );\r\n\t\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\r\n\t\t\t\tvar radius2 = sphere.radius * sphere.radius;\r\n\t\r\n\t\t\t\tif ( d2 > radius2 ) return null;\r\n\t\r\n\t\t\t\tvar thc = Math.sqrt( radius2 - d2 );\r\n\t\r\n\t\t\t\t// t0 = first intersect point - entrance on front of sphere\r\n\t\t\t\tvar t0 = tca - thc;\r\n\t\r\n\t\t\t\t// t1 = second intersect point - exit point on back of sphere\r\n\t\t\t\tvar t1 = tca + thc;\r\n\t\r\n\t\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\r\n\t\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\r\n\t\r\n\t\t\t\t// test to see if t0 is behind the ray:\r\n\t\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\r\n\t\t\t\t// in order to always return an intersect point that is in front of the ray.\r\n\t\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\r\n\t\r\n\t\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\r\n\t\t\t\treturn this.at( t0, optionalTarget );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tintersectsSphere: function ( sphere ) {\r\n\t\r\n\t\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPlane: function ( plane ) {\r\n\t\r\n\t\t\tvar denominator = plane.normal.dot( this.direction );\r\n\t\r\n\t\t\tif ( denominator === 0 ) {\r\n\t\r\n\t\t\t\t// line is coplanar, return origin\r\n\t\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\r\n\t\r\n\t\t\t\t\treturn 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\r\n\t\r\n\t\t\t\treturn null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\r\n\t\r\n\t\t\t// Return if the ray never intersects the plane\r\n\t\r\n\t\t\treturn t >= 0 ? t :  null;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectPlane: function ( plane, optionalTarget ) {\r\n\t\r\n\t\t\tvar t = this.distanceToPlane( plane );\r\n\t\r\n\t\t\tif ( t === null ) {\r\n\t\r\n\t\t\t\treturn null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.at( t, optionalTarget );\r\n\t\r\n\t\t},\r\n\t\r\n\t\r\n\t\r\n\t\tintersectsPlane: function ( plane ) {\r\n\t\r\n\t\t\t// check if the ray lies on the plane first\r\n\t\r\n\t\t\tvar distToPoint = plane.distanceToPoint( this.origin );\r\n\t\r\n\t\t\tif ( distToPoint === 0 ) {\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar denominator = plane.normal.dot( this.direction );\r\n\t\r\n\t\t\tif ( denominator * distToPoint < 0 ) {\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// ray origin is behind the plane (and is pointing behind it)\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectBox: function ( box, optionalTarget ) {\r\n\t\r\n\t\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\r\n\t\r\n\t\t\tvar invdirx = 1 / this.direction.x,\r\n\t\t\t\tinvdiry = 1 / this.direction.y,\r\n\t\t\t\tinvdirz = 1 / this.direction.z;\r\n\t\r\n\t\t\tvar origin = this.origin;\r\n\t\r\n\t\t\tif ( invdirx >= 0 ) {\r\n\t\r\n\t\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\r\n\t\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\r\n\t\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( invdiry >= 0 ) {\r\n\t\r\n\t\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\r\n\t\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\r\n\t\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\r\n\t\r\n\t\t\t// These lines also handle the case where tmin or tmax is NaN\r\n\t\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\r\n\t\r\n\t\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\r\n\t\r\n\t\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\r\n\t\r\n\t\t\tif ( invdirz >= 0 ) {\r\n\t\r\n\t\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\r\n\t\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\r\n\t\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\r\n\t\r\n\t\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\r\n\t\r\n\t\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\r\n\t\r\n\t\t\t//return point closest to the ray (positive side)\r\n\t\r\n\t\t\tif ( tmax < 0 ) return null;\r\n\t\r\n\t\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsBox: ( function () {\r\n\t\r\n\t\t\tvar v = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( box ) {\r\n\t\r\n\t\t\t\treturn this.intersectBox( box, v ) !== null;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )(),\r\n\t\r\n\t\tintersectTriangle: function () {\r\n\t\r\n\t\t\t// Compute the offset origin, edges, and normal.\r\n\t\t\tvar diff = new THREE.Vector3();\r\n\t\t\tvar edge1 = new THREE.Vector3();\r\n\t\t\tvar edge2 = new THREE.Vector3();\r\n\t\t\tvar normal = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( a, b, c, backfaceCulling, optionalTarget ) {\r\n\t\r\n\t\t\t\t// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp\r\n\t\r\n\t\t\t\tedge1.subVectors( b, a );\r\n\t\t\t\tedge2.subVectors( c, a );\r\n\t\t\t\tnormal.crossVectors( edge1, edge2 );\r\n\t\r\n\t\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\r\n\t\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\r\n\t\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\r\n\t\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\r\n\t\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\r\n\t\t\t\tvar DdN = this.direction.dot( normal );\r\n\t\t\t\tvar sign;\r\n\t\r\n\t\t\t\tif ( DdN > 0 ) {\r\n\t\r\n\t\t\t\t\tif ( backfaceCulling ) return null;\r\n\t\t\t\t\tsign = 1;\r\n\t\r\n\t\t\t\t} else if ( DdN < 0 ) {\r\n\t\r\n\t\t\t\t\tsign = - 1;\r\n\t\t\t\t\tDdN = - DdN;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\treturn null;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tdiff.subVectors( this.origin, a );\r\n\t\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\r\n\t\r\n\t\t\t\t// b1 < 0, no intersection\r\n\t\t\t\tif ( DdQxE2 < 0 ) {\r\n\t\r\n\t\t\t\t\treturn null;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\r\n\t\r\n\t\t\t\t// b2 < 0, no intersection\r\n\t\t\t\tif ( DdE1xQ < 0 ) {\r\n\t\r\n\t\t\t\t\treturn null;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// b1+b2 > 1, no intersection\r\n\t\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\r\n\t\r\n\t\t\t\t\treturn null;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// Line intersects triangle, check if ray does.\r\n\t\t\t\tvar QdN = - sign * diff.dot( normal );\r\n\t\r\n\t\t\t\t// t < 0, no intersection\r\n\t\t\t\tif ( QdN < 0 ) {\r\n\t\r\n\t\t\t\t\treturn null;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// Ray intersects triangle.\r\n\t\t\t\treturn this.at( QdN / DdN, optionalTarget );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tapplyMatrix4: function ( matrix4 ) {\r\n\t\r\n\t\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\r\n\t\t\tthis.origin.applyMatrix4( matrix4 );\r\n\t\t\tthis.direction.sub( this.origin );\r\n\t\t\tthis.direction.normalize();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( ray ) {\r\n\t\r\n\t\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Sphere.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://clara.io\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Sphere = function ( center, radius ) {\r\n\t\r\n\t\tthis.center = ( center !== undefined ) ? center : new THREE.Vector3();\r\n\t\tthis.radius = ( radius !== undefined ) ? radius : 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Sphere.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Sphere,\r\n\t\r\n\t\tset: function ( center, radius ) {\r\n\t\r\n\t\t\tthis.center.copy( center );\r\n\t\t\tthis.radius = radius;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromPoints: function () {\r\n\t\r\n\t\t\tvar box = new THREE.Box3();\r\n\t\r\n\t\t\treturn function ( points, optionalCenter ) {\r\n\t\r\n\t\t\t\tvar center = this.center;\r\n\t\r\n\t\t\t\tif ( optionalCenter !== undefined ) {\r\n\t\r\n\t\t\t\t\tcenter.copy( optionalCenter );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tbox.setFromPoints( points ).center( center );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar maxRadiusSq = 0;\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( sphere ) {\r\n\t\r\n\t\t\tthis.center.copy( sphere.center );\r\n\t\t\tthis.radius = sphere.radius;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tempty: function () {\r\n\t\r\n\t\t\treturn ( this.radius <= 0 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsPoint: function ( point ) {\r\n\t\r\n\t\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPoint: function ( point ) {\r\n\t\r\n\t\t\treturn ( point.distanceTo( this.center ) - this.radius );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsSphere: function ( sphere ) {\r\n\t\r\n\t\t\tvar radiusSum = this.radius + sphere.radius;\r\n\t\r\n\t\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsBox: function ( box ) {\r\n\t\r\n\t\t\treturn box.intersectsSphere( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsPlane: function ( plane ) {\r\n\t\r\n\t\t\t// We use the following equation to compute the signed distance from\r\n\t\t\t// the center of the sphere to the plane.\r\n\t\t\t//\r\n\t\t\t// distance = q * n - d\r\n\t\t\t//\r\n\t\t\t// If this distance is greater than the radius of the sphere,\r\n\t\t\t// then there is no intersection.\r\n\t\r\n\t\t\treturn Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\tresult.copy( point );\r\n\t\r\n\t\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\r\n\t\r\n\t\t\t\tresult.sub( this.center ).normalize();\r\n\t\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetBoundingBox: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar box = optionalTarget || new THREE.Box3();\r\n\t\r\n\t\t\tbox.set( this.center, this.center );\r\n\t\t\tbox.expandByScalar( this.radius );\r\n\t\r\n\t\t\treturn box;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function ( matrix ) {\r\n\t\r\n\t\t\tthis.center.applyMatrix4( matrix );\r\n\t\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttranslate: function ( offset ) {\r\n\t\r\n\t\t\tthis.center.add( offset );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( sphere ) {\r\n\t\r\n\t\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Frustum.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author bhouston / http://clara.io\r\n\t */\r\n\t\r\n\tTHREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\r\n\t\r\n\t\tthis.planes = [\r\n\t\r\n\t\t\t( p0 !== undefined ) ? p0 : new THREE.Plane(),\r\n\t\t\t( p1 !== undefined ) ? p1 : new THREE.Plane(),\r\n\t\t\t( p2 !== undefined ) ? p2 : new THREE.Plane(),\r\n\t\t\t( p3 !== undefined ) ? p3 : new THREE.Plane(),\r\n\t\t\t( p4 !== undefined ) ? p4 : new THREE.Plane(),\r\n\t\t\t( p5 !== undefined ) ? p5 : new THREE.Plane()\r\n\t\r\n\t\t];\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Frustum.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Frustum,\r\n\t\r\n\t\tset: function ( p0, p1, p2, p3, p4, p5 ) {\r\n\t\r\n\t\t\tvar planes = this.planes;\r\n\t\r\n\t\t\tplanes[ 0 ].copy( p0 );\r\n\t\t\tplanes[ 1 ].copy( p1 );\r\n\t\t\tplanes[ 2 ].copy( p2 );\r\n\t\t\tplanes[ 3 ].copy( p3 );\r\n\t\t\tplanes[ 4 ].copy( p4 );\r\n\t\t\tplanes[ 5 ].copy( p5 );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( frustum ) {\r\n\t\r\n\t\t\tvar planes = this.planes;\r\n\t\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromMatrix: function ( m ) {\r\n\t\r\n\t\t\tvar planes = this.planes;\r\n\t\t\tvar me = m.elements;\r\n\t\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\r\n\t\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\r\n\t\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\r\n\t\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\r\n\t\r\n\t\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\r\n\t\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\r\n\t\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\r\n\t\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\r\n\t\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\r\n\t\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsObject: function () {\r\n\t\r\n\t\t\tvar sphere = new THREE.Sphere();\r\n\t\r\n\t\t\treturn function ( object ) {\r\n\t\r\n\t\t\t\tvar geometry = object.geometry;\r\n\t\r\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\t\r\n\t\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\t\tsphere.applyMatrix4( object.matrixWorld );\r\n\t\r\n\t\t\t\treturn this.intersectsSphere( sphere );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tintersectsSphere: function ( sphere ) {\r\n\t\r\n\t\t\tvar planes = this.planes;\r\n\t\t\tvar center = sphere.center;\r\n\t\t\tvar negRadius = - sphere.radius;\r\n\t\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\tvar distance = planes[ i ].distanceToPoint( center );\r\n\t\r\n\t\t\t\tif ( distance < negRadius ) {\r\n\t\r\n\t\t\t\t\treturn false;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsBox: function () {\r\n\t\r\n\t\t\tvar p1 = new THREE.Vector3(),\r\n\t\t\t\tp2 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( box ) {\r\n\t\r\n\t\t\t\tvar planes = this.planes;\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar plane = planes[ i ];\r\n\t\r\n\t\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\r\n\t\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\r\n\t\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\r\n\t\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\r\n\t\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\r\n\t\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\r\n\t\r\n\t\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\r\n\t\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\r\n\t\r\n\t\t\t\t\t// if both outside plane, no intersection\r\n\t\r\n\t\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\r\n\t\r\n\t\t\t\t\t\treturn false;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\r\n\t\tcontainsPoint: function ( point ) {\r\n\t\r\n\t\t\tvar planes = this.planes;\r\n\t\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\r\n\t\r\n\t\t\t\t\treturn false;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Plane.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://clara.io\r\n\t */\r\n\t\r\n\tTHREE.Plane = function ( normal, constant ) {\r\n\t\r\n\t\tthis.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\r\n\t\tthis.constant = ( constant !== undefined ) ? constant : 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Plane.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Plane,\r\n\t\r\n\t\tset: function ( normal, constant ) {\r\n\t\r\n\t\t\tthis.normal.copy( normal );\r\n\t\t\tthis.constant = constant;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetComponents: function ( x, y, z, w ) {\r\n\t\r\n\t\t\tthis.normal.set( x, y, z );\r\n\t\t\tthis.constant = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\r\n\t\r\n\t\t\tthis.normal.copy( normal );\r\n\t\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromCoplanarPoints: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\t\tvar v2 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( a, b, c ) {\r\n\t\r\n\t\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\r\n\t\r\n\t\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\r\n\t\r\n\t\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( plane ) {\r\n\t\r\n\t\t\tthis.normal.copy( plane.normal );\r\n\t\t\tthis.constant = plane.constant;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\t// Note: will lead to a divide by zero if the plane is invalid.\r\n\t\r\n\t\t\tvar inverseNormalLength = 1.0 / this.normal.length();\r\n\t\t\tthis.normal.multiplyScalar( inverseNormalLength );\r\n\t\t\tthis.constant *= inverseNormalLength;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnegate: function () {\r\n\t\r\n\t\t\tthis.constant *= - 1;\r\n\t\t\tthis.normal.negate();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPoint: function ( point ) {\r\n\t\r\n\t\t\treturn this.normal.dot( point ) + this.constant;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToSphere: function ( sphere ) {\r\n\t\r\n\t\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tprojectPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\r\n\t\r\n\t\t},\r\n\t\r\n\t\torthoPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectLine: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( line, optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\t\tvar direction = line.delta( v1 );\r\n\t\r\n\t\t\t\tvar denominator = this.normal.dot( direction );\r\n\t\r\n\t\t\t\tif ( denominator === 0 ) {\r\n\t\r\n\t\t\t\t\t// line is coplanar, return origin\r\n\t\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\r\n\t\r\n\t\t\t\t\t\treturn result.copy( line.start );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// Unsure if this is the correct method to handle this case.\r\n\t\t\t\t\treturn undefined;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\r\n\t\r\n\t\t\t\tif ( t < 0 || t > 1 ) {\r\n\t\r\n\t\t\t\t\treturn undefined;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tintersectsLine: function ( line ) {\r\n\t\r\n\t\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\r\n\t\r\n\t\t\tvar startSign = this.distanceToPoint( line.start );\r\n\t\t\tvar endSign = this.distanceToPoint( line.end );\r\n\t\r\n\t\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsBox: function ( box ) {\r\n\t\r\n\t\t\treturn box.intersectsPlane( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsSphere: function ( sphere ) {\r\n\t\r\n\t\t\treturn sphere.intersectsPlane( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcoplanarPoint: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\t\tvar v2 = new THREE.Vector3();\r\n\t\t\tvar m1 = new THREE.Matrix3();\r\n\t\r\n\t\t\treturn function ( matrix, optionalNormalMatrix ) {\r\n\t\r\n\t\t\t\t// compute new normal based on theory here:\r\n\t\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\r\n\t\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\r\n\t\t\t\tvar newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );\r\n\t\r\n\t\t\t\tvar newCoplanarPoint = this.coplanarPoint( v2 );\r\n\t\t\t\tnewCoplanarPoint.applyMatrix4( matrix );\r\n\t\r\n\t\t\t\tthis.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslate: function ( offset ) {\r\n\t\r\n\t\t\tthis.constant = this.constant - offset.dot( this.normal );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( plane ) {\r\n\t\r\n\t\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Spherical.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://clara.io\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t *\r\n\t * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\r\n\t *\r\n\t * The poles (phi) are at the positive and negative y axis.\r\n\t * The equator starts at positive z.\r\n\t */\r\n\t\r\n\tTHREE.Spherical = function ( radius, phi, theta ) {\r\n\t\r\n\t\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\r\n\t\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\r\n\t\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Spherical.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Spherical,\r\n\t\r\n\t\tset: function ( radius, phi, theta ) {\r\n\t\r\n\t\t\tthis.radius = radius;\r\n\t\t\tthis.phi = phi;\r\n\t\t\tthis.theta = theta;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( other ) {\r\n\t\r\n\t\t\tthis.radius.copy( other.radius );\r\n\t\t\tthis.phi.copy( other.phi );\r\n\t\t\tthis.theta.copy( other.theta );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// restrict phi to be betwee EPS and PI-EPS\r\n\t\tmakeSafe: function() {\r\n\t\r\n\t\t\tvar EPS = 0.000001;\r\n\t\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromVector3: function( vec3 ) {\r\n\t\r\n\t\t\tthis.radius = vec3.length();\r\n\t\r\n\t\t\tif ( this.radius === 0 ) {\r\n\t\r\n\t\t\t\tthis.theta = 0;\r\n\t\t\t\tthis.phi = 0;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\r\n\t\t\t\tthis.phi = Math.acos( THREE.Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Math.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Math = {\r\n\t\r\n\t\tgenerateUUID: function () {\r\n\t\r\n\t\t\t// http://www.broofa.com/Tools/Math.uuid.htm\r\n\t\r\n\t\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\r\n\t\t\tvar uuid = new Array( 36 );\r\n\t\t\tvar rnd = 0, r;\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < 36; i ++ ) {\r\n\t\r\n\t\t\t\t\tif ( i === 8 || i === 13 || i === 18 || i === 23 ) {\r\n\t\r\n\t\t\t\t\t\tuuid[ i ] = '-';\r\n\t\r\n\t\t\t\t\t} else if ( i === 14 ) {\r\n\t\r\n\t\t\t\t\t\tuuid[ i ] = '4';\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tif ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\r\n\t\t\t\t\t\tr = rnd & 0xf;\r\n\t\t\t\t\t\trnd = rnd >> 4;\r\n\t\t\t\t\t\tuuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn uuid.join( '' );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclamp: function ( value, min, max ) {\r\n\t\r\n\t\t\treturn Math.max( min, Math.min( max, value ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// compute euclidian modulo of m % n\r\n\t\t// https://en.wikipedia.org/wiki/Modulo_operation\r\n\t\r\n\t\teuclideanModulo: function ( n, m ) {\r\n\t\r\n\t\t\treturn ( ( n % m ) + m ) % m;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Linear mapping from range <a1, a2> to range <b1, b2>\r\n\t\r\n\t\tmapLinear: function ( x, a1, a2, b1, b2 ) {\r\n\t\r\n\t\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// http://en.wikipedia.org/wiki/Smoothstep\r\n\t\r\n\t\tsmoothstep: function ( x, min, max ) {\r\n\t\r\n\t\t\tif ( x <= min ) return 0;\r\n\t\t\tif ( x >= max ) return 1;\r\n\t\r\n\t\t\tx = ( x - min ) / ( max - min );\r\n\t\r\n\t\t\treturn x * x * ( 3 - 2 * x );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsmootherstep: function ( x, min, max ) {\r\n\t\r\n\t\t\tif ( x <= min ) return 0;\r\n\t\t\tif ( x >= max ) return 1;\r\n\t\r\n\t\t\tx = ( x - min ) / ( max - min );\r\n\t\r\n\t\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\trandom16: function () {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );\r\n\t\t\treturn Math.random();\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Random integer from <low, high> interval\r\n\t\r\n\t\trandInt: function ( low, high ) {\r\n\t\r\n\t\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Random float from <low, high> interval\r\n\t\r\n\t\trandFloat: function ( low, high ) {\r\n\t\r\n\t\t\treturn low + Math.random() * ( high - low );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Random float from <-range/2, range/2> interval\r\n\t\r\n\t\trandFloatSpread: function ( range ) {\r\n\t\r\n\t\t\treturn range * ( 0.5 - Math.random() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdegToRad: function () {\r\n\t\r\n\t\t\tvar degreeToRadiansFactor = Math.PI / 180;\r\n\t\r\n\t\t\treturn function ( degrees ) {\r\n\t\r\n\t\t\t\treturn degrees * degreeToRadiansFactor;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tradToDeg: function () {\r\n\t\r\n\t\t\tvar radianToDegreesFactor = 180 / Math.PI;\r\n\t\r\n\t\t\treturn function ( radians ) {\r\n\t\r\n\t\t\t\treturn radians * radianToDegreesFactor;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tisPowerOfTwo: function ( value ) {\r\n\t\r\n\t\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnearestPowerOfTwo: function ( value ) {\r\n\t\r\n\t\t\treturn Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnextPowerOfTwo: function ( value ) {\r\n\t\r\n\t\t\tvalue --;\r\n\t\t\tvalue |= value >> 1;\r\n\t\t\tvalue |= value >> 2;\r\n\t\t\tvalue |= value >> 4;\r\n\t\t\tvalue |= value >> 8;\r\n\t\t\tvalue |= value >> 16;\r\n\t\t\tvalue ++;\r\n\t\r\n\t\t\treturn value;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Spline.js\r\n\t\r\n\t/**\r\n\t * Spline from Tween.js, slightly optimized (and trashed)\r\n\t * http://sole.github.com/tween.js/examples/05_spline.html\r\n\t *\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Spline = function ( points ) {\r\n\t\r\n\t\tthis.points = points;\r\n\t\r\n\t\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\r\n\t\tpoint, intPoint, weight, w2, w3,\r\n\t\tpa, pb, pc, pd;\r\n\t\r\n\t\tthis.initFromArray = function ( a ) {\r\n\t\r\n\t\t\tthis.points = [];\r\n\t\r\n\t\t\tfor ( var i = 0; i < a.length; i ++ ) {\r\n\t\r\n\t\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getPoint = function ( k ) {\r\n\t\r\n\t\t\tpoint = ( this.points.length - 1 ) * k;\r\n\t\t\tintPoint = Math.floor( point );\r\n\t\t\tweight = point - intPoint;\r\n\t\r\n\t\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\r\n\t\t\tc[ 1 ] = intPoint;\r\n\t\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\r\n\t\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\r\n\t\r\n\t\t\tpa = this.points[ c[ 0 ] ];\r\n\t\t\tpb = this.points[ c[ 1 ] ];\r\n\t\t\tpc = this.points[ c[ 2 ] ];\r\n\t\t\tpd = this.points[ c[ 3 ] ];\r\n\t\r\n\t\t\tw2 = weight * weight;\r\n\t\t\tw3 = weight * w2;\r\n\t\r\n\t\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\r\n\t\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\r\n\t\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\r\n\t\r\n\t\t\treturn v3;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getControlPointsArray = function () {\r\n\t\r\n\t\t\tvar i, p, l = this.points.length,\r\n\t\t\t\tcoords = [];\r\n\t\r\n\t\t\tfor ( i = 0; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tp = this.points[ i ];\r\n\t\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn coords;\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// approximate length by summing linear segments\r\n\t\r\n\t\tthis.getLength = function ( nSubDivisions ) {\r\n\t\r\n\t\t\tvar i, index, nSamples, position,\r\n\t\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\r\n\t\t\t\toldPosition = new THREE.Vector3(),\r\n\t\t\t\ttmpVec = new THREE.Vector3(),\r\n\t\t\t\tchunkLengths = [],\r\n\t\t\t\ttotalLength = 0;\r\n\t\r\n\t\t\t// first point has 0 length\r\n\t\r\n\t\t\tchunkLengths[ 0 ] = 0;\r\n\t\r\n\t\t\tif ( ! nSubDivisions ) nSubDivisions = 100;\r\n\t\r\n\t\t\tnSamples = this.points.length * nSubDivisions;\r\n\t\r\n\t\t\toldPosition.copy( this.points[ 0 ] );\r\n\t\r\n\t\t\tfor ( i = 1; i < nSamples; i ++ ) {\r\n\t\r\n\t\t\t\tindex = i / nSamples;\r\n\t\r\n\t\t\t\tposition = this.getPoint( index );\r\n\t\t\t\ttmpVec.copy( position );\r\n\t\r\n\t\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\r\n\t\r\n\t\t\t\toldPosition.copy( position );\r\n\t\r\n\t\t\t\tpoint = ( this.points.length - 1 ) * index;\r\n\t\t\t\tintPoint = Math.floor( point );\r\n\t\r\n\t\t\t\tif ( intPoint !== oldIntPoint ) {\r\n\t\r\n\t\t\t\t\tchunkLengths[ intPoint ] = totalLength;\r\n\t\t\t\t\toldIntPoint = intPoint;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// last point ends with total length\r\n\t\r\n\t\t\tchunkLengths[ chunkLengths.length ] = totalLength;\r\n\t\r\n\t\t\treturn { chunks: chunkLengths, total: totalLength };\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\r\n\t\r\n\t\t\tvar i, j,\r\n\t\t\t\tindex, indexCurrent, indexNext,\r\n\t\t\t\trealDistance,\r\n\t\t\t\tsampling, position,\r\n\t\t\t\tnewpoints = [],\r\n\t\t\t\ttmpVec = new THREE.Vector3(),\r\n\t\t\t\tsl = this.getLength();\r\n\t\r\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\r\n\t\r\n\t\t\tfor ( i = 1; i < this.points.length; i ++ ) {\r\n\t\r\n\t\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\r\n\t\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\r\n\t\r\n\t\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\r\n\t\r\n\t\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\r\n\t\r\n\t\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\r\n\t\t\t\tindexNext = i / ( this.points.length - 1 );\r\n\t\r\n\t\t\t\tfor ( j = 1; j < sampling - 1; j ++ ) {\r\n\t\r\n\t\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\r\n\t\r\n\t\t\t\t\tposition = this.getPoint( index );\r\n\t\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.points = newpoints;\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Catmull-Rom\r\n\t\r\n\t\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\r\n\t\r\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5,\r\n\t\t\t\tv1 = ( p3 - p1 ) * 0.5;\r\n\t\r\n\t\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Triangle.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://clara.io\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Triangle = function ( a, b, c ) {\r\n\t\r\n\t\tthis.a = ( a !== undefined ) ? a : new THREE.Vector3();\r\n\t\tthis.b = ( b !== undefined ) ? b : new THREE.Vector3();\r\n\t\tthis.c = ( c !== undefined ) ? c : new THREE.Vector3();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Triangle.normal = function () {\r\n\t\r\n\t\tvar v0 = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( a, b, c, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\tresult.subVectors( c, b );\r\n\t\t\tv0.subVectors( a, b );\r\n\t\t\tresult.cross( v0 );\r\n\t\r\n\t\t\tvar resultLengthSq = result.lengthSq();\r\n\t\t\tif ( resultLengthSq > 0 ) {\r\n\t\r\n\t\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result.set( 0, 0, 0 );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\t// static/instance method to calculate barycentric coordinates\r\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\r\n\tTHREE.Triangle.barycoordFromPoint = function () {\r\n\t\r\n\t\tvar v0 = new THREE.Vector3();\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( point, a, b, c, optionalTarget ) {\r\n\t\r\n\t\t\tv0.subVectors( c, a );\r\n\t\t\tv1.subVectors( b, a );\r\n\t\t\tv2.subVectors( point, a );\r\n\t\r\n\t\t\tvar dot00 = v0.dot( v0 );\r\n\t\t\tvar dot01 = v0.dot( v1 );\r\n\t\t\tvar dot02 = v0.dot( v2 );\r\n\t\t\tvar dot11 = v1.dot( v1 );\r\n\t\t\tvar dot12 = v1.dot( v2 );\r\n\t\r\n\t\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\t// collinear or singular triangle\r\n\t\t\tif ( denom === 0 ) {\r\n\t\r\n\t\t\t\t// arbitrary location outside of triangle?\r\n\t\t\t\t// not sure if this is the best idea, maybe should be returning undefined\r\n\t\t\t\treturn result.set( - 2, - 1, - 1 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar invDenom = 1 / denom;\r\n\t\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\r\n\t\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\r\n\t\r\n\t\t\t// barycentric coordinates must always sum to 1\r\n\t\t\treturn result.set( 1 - u - v, v, u );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\tTHREE.Triangle.containsPoint = function () {\r\n\t\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( point, a, b, c ) {\r\n\t\r\n\t\t\tvar result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\r\n\t\r\n\t\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\tTHREE.Triangle.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Triangle,\r\n\t\r\n\t\tset: function ( a, b, c ) {\r\n\t\r\n\t\t\tthis.a.copy( a );\r\n\t\t\tthis.b.copy( b );\r\n\t\t\tthis.c.copy( c );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\r\n\t\r\n\t\t\tthis.a.copy( points[ i0 ] );\r\n\t\t\tthis.b.copy( points[ i1 ] );\r\n\t\t\tthis.c.copy( points[ i2 ] );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( triangle ) {\r\n\t\r\n\t\t\tthis.a.copy( triangle.a );\r\n\t\t\tthis.b.copy( triangle.b );\r\n\t\t\tthis.c.copy( triangle.c );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tarea: function () {\r\n\t\r\n\t\t\tvar v0 = new THREE.Vector3();\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tv0.subVectors( this.c, this.b );\r\n\t\t\t\tv1.subVectors( this.a, this.b );\r\n\t\r\n\t\t\t\treturn v0.cross( v1 ).length() * 0.5;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tmidpoint: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormal: function ( optionalTarget ) {\r\n\t\r\n\t\t\treturn THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tplane: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Plane();\r\n\t\r\n\t\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tbarycoordFromPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\treturn THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsPoint: function ( point ) {\r\n\t\r\n\t\t\treturn THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( triangle ) {\r\n\t\r\n\t\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Interpolant.js\r\n\t\r\n\t/**\r\n\t * Abstract base class of interpolants over parametric samples.\r\n\t *\r\n\t * The parameter domain is one dimensional, typically the time or a path\r\n\t * along a curve defined by the data.\r\n\t *\r\n\t * The sample values can have any dimensionality and derived classes may\r\n\t * apply special interpretations to the data.\r\n\t *\r\n\t * This class provides the interval seek in a Template Method, deferring\r\n\t * the actual interpolation to derived classes.\r\n\t *\r\n\t * Time complexity is O(1) for linear access crossing at most two points\r\n\t * and O(log N) for random access, where N is the number of positions.\r\n\t *\r\n\t * References:\r\n\t *\r\n\t * \t\thttp://www.oodesign.com/template-method-pattern.html\r\n\t *\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.Interpolant = function(\r\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\t\r\n\t\tthis.parameterPositions = parameterPositions;\r\n\t\tthis._cachedIndex = 0;\r\n\t\r\n\t\tthis.resultBuffer = resultBuffer !== undefined ?\r\n\t\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\r\n\t\tthis.sampleValues = sampleValues;\r\n\t\tthis.valueSize = sampleSize;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Interpolant.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Interpolant,\r\n\t\r\n\t\tevaluate: function( t ) {\r\n\t\r\n\t\t\tvar pp = this.parameterPositions,\r\n\t\t\t\ti1 = this._cachedIndex,\r\n\t\r\n\t\t\t\tt1 = pp[   i1   ],\r\n\t\t\t\tt0 = pp[ i1 - 1 ];\r\n\t\r\n\t\t\tvalidate_interval: {\r\n\t\r\n\t\t\t\tseek: {\r\n\t\r\n\t\t\t\t\tvar right;\r\n\t\r\n\t\t\t\t\tlinear_scan: {\r\n\t//- See http://jsperf.com/comparison-to-undefined/3\r\n\t//- slower code:\r\n\t//-\r\n\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\r\n\t\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ;) {\r\n\t\r\n\t\t\t\t\t\t\t\tif ( t1 === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\r\n\t\r\n\t\t\t\t\t\t\t\t\t// after end\r\n\t\r\n\t\t\t\t\t\t\t\t\ti1 = pp.length;\r\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\r\n\t\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\r\n\t\r\n\t\t\t\t\t\t\t\tt0 = t1;\r\n\t\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\r\n\t\r\n\t\t\t\t\t\t\t\tif ( t < t1 ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\r\n\t\t\t\t\t\t\t\t\tbreak seek;\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t// prepare binary search on the right side of the index\r\n\t\t\t\t\t\t\tright = pp.length;\r\n\t\t\t\t\t\t\tbreak linear_scan;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t//- slower code:\r\n\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\r\n\t\t\t\t\t\tif ( ! ( t >= t0 ) ) {\r\n\t\r\n\t\t\t\t\t\t\t// looping?\r\n\t\r\n\t\t\t\t\t\t\tvar t1global = pp[ 1 ];\r\n\t\r\n\t\t\t\t\t\t\tif ( t < t1global ) {\r\n\t\r\n\t\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\r\n\t\t\t\t\t\t\t\tt0 = t1global;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t// linear reverse scan\r\n\t\r\n\t\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ;) {\r\n\t\r\n\t\t\t\t\t\t\t\tif ( t0 === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\t// before start\r\n\t\r\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\r\n\t\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\r\n\t\r\n\t\t\t\t\t\t\t\tt1 = t0;\r\n\t\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\r\n\t\r\n\t\t\t\t\t\t\t\tif ( t >= t0 ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\r\n\t\t\t\t\t\t\t\t\tbreak seek;\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t// prepare binary search on the left side of the index\r\n\t\t\t\t\t\t\tright = i1;\r\n\t\t\t\t\t\t\ti1 = 0;\r\n\t\t\t\t\t\t\tbreak linear_scan;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t// the interval is valid\r\n\t\r\n\t\t\t\t\t\tbreak validate_interval;\r\n\t\r\n\t\t\t\t\t} // linear scan\r\n\t\r\n\t\t\t\t\t// binary search\r\n\t\r\n\t\t\t\t\twhile ( i1 < right ) {\r\n\t\r\n\t\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\r\n\t\r\n\t\t\t\t\t\tif ( t < pp[ mid ] ) {\r\n\t\r\n\t\t\t\t\t\t\tright = mid;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\ti1 = mid + 1;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tt1 = pp[   i1   ];\r\n\t\t\t\t\tt0 = pp[ i1 - 1 ];\r\n\t\r\n\t\t\t\t\t// check boundary cases, again\r\n\t\r\n\t\t\t\t\tif ( t0 === undefined ) {\r\n\t\r\n\t\t\t\t\t\tthis._cachedIndex = 0;\r\n\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( t1 === undefined ) {\r\n\t\r\n\t\t\t\t\t\ti1 = pp.length;\r\n\t\t\t\t\t\tthis._cachedIndex = i1;\r\n\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} // seek\r\n\t\r\n\t\t\t\tthis._cachedIndex = i1;\r\n\t\r\n\t\t\t\tthis.intervalChanged_( i1, t0, t1 );\r\n\t\r\n\t\t\t} // validate_interval\r\n\t\r\n\t\t\treturn this.interpolate_( i1, t0, t, t1 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsettings: null, // optional, subclass-specific settings structure\r\n\t\t// Note: The indirection allows central control of many interpolants.\r\n\t\r\n\t\t// --- Protected interface\r\n\t\r\n\t\tDefaultSettings_: {},\r\n\t\r\n\t\tgetSettings_: function() {\r\n\t\r\n\t\t\treturn this.settings || this.DefaultSettings_;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopySampleValue_: function( index ) {\r\n\t\r\n\t\t\t// copies a sample value to the result buffer\r\n\t\r\n\t\t\tvar result = this.resultBuffer,\r\n\t\t\t\tvalues = this.sampleValues,\r\n\t\t\t\tstride = this.valueSize,\r\n\t\t\t\toffset = index * stride;\r\n\t\r\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\t\r\n\t\t\t\tresult[ i ] = values[ offset + i ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Template methods for derived classes:\r\n\t\r\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\t\r\n\t\t\tthrow new Error( \"call to abstract method\" );\r\n\t\t\t// implementations shall return this.resultBuffer\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintervalChanged_: function( i1, t0, t1 ) {\r\n\t\r\n\t\t\t// empty\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tObject.assign( THREE.Interpolant.prototype, {\r\n\t\r\n\t\tbeforeStart_: //( 0, t, t0 ), returns this.resultBuffer\r\n\t\t\tTHREE.Interpolant.prototype.copySampleValue_,\r\n\t\r\n\t\tafterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer\r\n\t\t\tTHREE.Interpolant.prototype.copySampleValue_\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/math/interpolants/CubicInterpolant.js\r\n\t\r\n\t/**\r\n\t * Fast and simple cubic spline interpolant.\r\n\t *\r\n\t * It was derived from a Hermitian construction setting the first derivative\r\n\t * at each sample position to the linear slope between neighboring positions\r\n\t * over their parameter interval.\r\n\t *\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.CubicInterpolant = function(\r\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\t\r\n\t\tTHREE.Interpolant.call(\r\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\t\r\n\t\tthis._weightPrev = -0;\r\n\t\tthis._offsetPrev = -0;\r\n\t\tthis._weightNext = -0;\r\n\t\tthis._offsetNext = -0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CubicInterpolant.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.CubicInterpolant,\r\n\t\r\n\t\tDefaultSettings_: {\r\n\t\r\n\t\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\r\n\t\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintervalChanged_: function( i1, t0, t1 ) {\r\n\t\r\n\t\t\tvar pp = this.parameterPositions,\r\n\t\t\t\tiPrev = i1 - 2,\r\n\t\t\t\tiNext = i1 + 1,\r\n\t\r\n\t\t\t\ttPrev = pp[ iPrev ],\r\n\t\t\t\ttNext = pp[ iNext ];\r\n\t\r\n\t\t\tif ( tPrev === undefined ) {\r\n\t\r\n\t\t\t\tswitch ( this.getSettings_().endingStart ) {\r\n\t\r\n\t\t\t\t\tcase THREE.ZeroSlopeEnding:\r\n\t\r\n\t\t\t\t\t\t// f'(t0) = 0\r\n\t\t\t\t\t\tiPrev = i1;\r\n\t\t\t\t\t\ttPrev = 2 * t0 - t1;\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.WrapAroundEnding:\r\n\t\r\n\t\t\t\t\t\t// use the other end of the curve\r\n\t\t\t\t\t\tiPrev = pp.length - 2;\r\n\t\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tdefault: // ZeroCurvatureEnding\r\n\t\r\n\t\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\r\n\t\t\t\t\t\tiPrev = i1;\r\n\t\t\t\t\t\ttPrev = t1;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( tNext === undefined ) {\r\n\t\r\n\t\t\t\tswitch ( this.getSettings_().endingEnd ) {\r\n\t\r\n\t\t\t\t\tcase THREE.ZeroSlopeEnding:\r\n\t\r\n\t\t\t\t\t\t// f'(tN) = 0\r\n\t\t\t\t\t\tiNext = i1;\r\n\t\t\t\t\t\ttNext = 2 * t1 - t0;\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.WrapAroundEnding:\r\n\t\r\n\t\t\t\t\t\t// use the other end of the curve\r\n\t\t\t\t\t\tiNext = 1;\r\n\t\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tdefault: // ZeroCurvatureEnding\r\n\t\r\n\t\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\r\n\t\t\t\t\t\tiNext = i1 - 1;\r\n\t\t\t\t\t\ttNext = t0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar halfDt = ( t1 - t0 ) * 0.5,\r\n\t\t\t\tstride = this.valueSize;\r\n\t\r\n\t\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\r\n\t\t\tthis._weightNext = halfDt / ( tNext - t1 );\r\n\t\t\tthis._offsetPrev = iPrev * stride;\r\n\t\t\tthis._offsetNext = iNext * stride;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\t\r\n\t\t\tvar result = this.resultBuffer,\r\n\t\t\t\tvalues = this.sampleValues,\r\n\t\t\t\tstride = this.valueSize,\r\n\t\r\n\t\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\r\n\t\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\r\n\t\t\t\twP = this._weightPrev,\twN = this._weightNext,\r\n\t\r\n\t\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\r\n\t\t\t\tpp = p * p,\r\n\t\t\t\tppp = pp * p;\r\n\t\r\n\t\t\t// evaluate polynomials\r\n\t\r\n\t\t\tvar sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;\r\n\t\t\tvar s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;\r\n\t\t\tvar s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;\r\n\t\t\tvar sN =       wN   * ppp   -           wN      * pp;\r\n\t\r\n\t\t\t// combine data linearly\r\n\t\r\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\t\r\n\t\t\t\tresult[ i ] =\r\n\t\t\t\t\t\tsP * values[ oP + i ] +\r\n\t\t\t\t\t\ts0 * values[ o0 + i ] +\r\n\t\t\t\t\t\ts1 * values[ o1 + i ] +\r\n\t\t\t\t\t\tsN * values[ oN + i ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/math/interpolants/DiscreteInterpolant.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * Interpolant that evaluates to the sample value at the position preceeding\r\n\t * the parameter.\r\n\t *\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.DiscreteInterpolant = function(\r\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\t\r\n\t\tTHREE.Interpolant.call(\r\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DiscreteInterpolant.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.DiscreteInterpolant,\r\n\t\r\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\t\r\n\t\t\treturn this.copySampleValue_( i1 - 1 );\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/math/interpolants/LinearInterpolant.js\r\n\t\r\n\t/**\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.LinearInterpolant = function(\r\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\t\r\n\t\tTHREE.Interpolant.call(\r\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LinearInterpolant.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.LinearInterpolant,\r\n\t\r\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\t\r\n\t\t\tvar result = this.resultBuffer,\r\n\t\t\t\tvalues = this.sampleValues,\r\n\t\t\t\tstride = this.valueSize,\r\n\t\r\n\t\t\t\toffset1 = i1 * stride,\r\n\t\t\t\toffset0 = offset1 - stride,\r\n\t\r\n\t\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\r\n\t\t\t\tweight0 = 1 - weight1;\r\n\t\r\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\t\r\n\t\t\t\tresult[ i ] =\r\n\t\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\r\n\t\t\t\t\t\tvalues[ offset1 + i ] * weight1;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/math/interpolants/QuaternionLinearInterpolant.js\r\n\t\r\n\t/**\r\n\t * Spherical linear unit quaternion interpolant.\r\n\t *\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.QuaternionLinearInterpolant = function(\r\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\t\r\n\t\tTHREE.Interpolant.call(\r\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.QuaternionLinearInterpolant.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.QuaternionLinearInterpolant,\r\n\t\r\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\t\r\n\t\t\tvar result = this.resultBuffer,\r\n\t\t\t\tvalues = this.sampleValues,\r\n\t\t\t\tstride = this.valueSize,\r\n\t\r\n\t\t\t\toffset = i1 * stride,\r\n\t\r\n\t\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\r\n\t\r\n\t\t\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\r\n\t\r\n\t\t\t\tTHREE.Quaternion.slerpFlat( result, 0,\r\n\t\t\t\t\t\tvalues, offset - stride, values, offset, alpha );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/core/Clock.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Clock = function ( autoStart ) {\r\n\t\r\n\t\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\r\n\t\r\n\t\tthis.startTime = 0;\r\n\t\tthis.oldTime = 0;\r\n\t\tthis.elapsedTime = 0;\r\n\t\r\n\t\tthis.running = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Clock.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Clock,\r\n\t\r\n\t\tstart: function () {\r\n\t\r\n\t\t\tthis.startTime = performance.now();\r\n\t\r\n\t\t\tthis.oldTime = this.startTime;\r\n\t\t\tthis.running = true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tstop: function () {\r\n\t\r\n\t\t\tthis.getElapsedTime();\r\n\t\t\tthis.running = false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetElapsedTime: function () {\r\n\t\r\n\t\t\tthis.getDelta();\r\n\t\t\treturn this.elapsedTime;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetDelta: function () {\r\n\t\r\n\t\t\tvar diff = 0;\r\n\t\r\n\t\t\tif ( this.autoStart && ! this.running ) {\r\n\t\r\n\t\t\t\tthis.start();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.running ) {\r\n\t\r\n\t\t\t\tvar newTime = performance.now();\r\n\t\r\n\t\t\t\tdiff = 0.001 * ( newTime - this.oldTime );\r\n\t\t\t\tthis.oldTime = newTime;\r\n\t\r\n\t\t\t\tthis.elapsedTime += diff;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn diff;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/EventDispatcher.js\r\n\t\r\n\t/**\r\n\t * https://github.com/mrdoob/eventdispatcher.js/\r\n\t */\r\n\t\r\n\tTHREE.EventDispatcher = function () {};\r\n\t\r\n\tTHREE.EventDispatcher.prototype = {\r\n\t\r\n\t\tconstructor: THREE.EventDispatcher,\r\n\t\r\n\t\tapply: function ( object ) {\r\n\t\r\n\t\t\tobject.addEventListener = THREE.EventDispatcher.prototype.addEventListener;\r\n\t\t\tobject.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;\r\n\t\t\tobject.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;\r\n\t\t\tobject.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddEventListener: function ( type, listener ) {\r\n\t\r\n\t\t\tif ( this._listeners === undefined ) this._listeners = {};\r\n\t\r\n\t\t\tvar listeners = this._listeners;\r\n\t\r\n\t\t\tif ( listeners[ type ] === undefined ) {\r\n\t\r\n\t\t\t\tlisteners[ type ] = [];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\r\n\t\r\n\t\t\t\tlisteners[ type ].push( listener );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\thasEventListener: function ( type, listener ) {\r\n\t\r\n\t\t\tif ( this._listeners === undefined ) return false;\r\n\t\r\n\t\t\tvar listeners = this._listeners;\r\n\t\r\n\t\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tremoveEventListener: function ( type, listener ) {\r\n\t\r\n\t\t\tif ( this._listeners === undefined ) return;\r\n\t\r\n\t\t\tvar listeners = this._listeners;\r\n\t\t\tvar listenerArray = listeners[ type ];\r\n\t\r\n\t\t\tif ( listenerArray !== undefined ) {\r\n\t\r\n\t\t\t\tvar index = listenerArray.indexOf( listener );\r\n\t\r\n\t\t\t\tif ( index !== - 1 ) {\r\n\t\r\n\t\t\t\t\tlistenerArray.splice( index, 1 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispatchEvent: function ( event ) {\r\n\t\r\n\t\t\tif ( this._listeners === undefined ) return;\r\n\t\r\n\t\t\tvar listeners = this._listeners;\r\n\t\t\tvar listenerArray = listeners[ event.type ];\r\n\t\r\n\t\t\tif ( listenerArray !== undefined ) {\r\n\t\r\n\t\t\t\tevent.target = this;\r\n\t\r\n\t\t\t\tvar array = [];\r\n\t\t\t\tvar length = listenerArray.length;\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\t\r\n\t\t\t\t\tarray[ i ] = listenerArray[ i ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\t\r\n\t\t\t\t\tarray[ i ].call( this, event );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/Layers.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Layers = function () {\r\n\t\r\n\t\tthis.mask = 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Layers.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Layers,\r\n\t\r\n\t\tset: function ( channel ) {\r\n\t\r\n\t\t\tthis.mask = 1 << channel;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tenable: function ( channel ) {\r\n\t\r\n\t\t\tthis.mask |= 1 << channel;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoggle: function ( channel ) {\r\n\t\r\n\t\t\tthis.mask ^= 1 << channel;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdisable: function ( channel ) {\r\n\t\r\n\t\t\tthis.mask &= ~ ( 1 << channel );\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttest: function ( layers ) {\r\n\t\r\n\t\t\treturn ( this.mask & layers.mask ) !== 0;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/Raycaster.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author bhouston / http://clara.io/\r\n\t * @author stephomi / http://stephaneginier.com/\r\n\t */\r\n\t\r\n\t( function ( THREE ) {\r\n\t\r\n\t\tTHREE.Raycaster = function ( origin, direction, near, far ) {\r\n\t\r\n\t\t\tthis.ray = new THREE.Ray( origin, direction );\r\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\t\r\n\t\t\tthis.near = near || 0;\r\n\t\t\tthis.far = far || Infinity;\r\n\t\r\n\t\t\tthis.params = {\r\n\t\t\t\tMesh: {},\r\n\t\t\t\tLine: {},\r\n\t\t\t\tLOD: {},\r\n\t\t\t\tPoints: { threshold: 1 },\r\n\t\t\t\tSprite: {}\r\n\t\t\t};\r\n\t\r\n\t\t\tObject.defineProperties( this.params, {\r\n\t\t\t\tPointCloud: {\r\n\t\t\t\t\tget: function () {\r\n\t\t\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\r\n\t\t\t\t\t\treturn this.Points;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction ascSort( a, b ) {\r\n\t\r\n\t\t\treturn a.distance - b.distance;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction intersectObject( object, raycaster, intersects, recursive ) {\r\n\t\r\n\t\t\tif ( object.visible === false ) return;\r\n\t\r\n\t\t\tobject.raycast( raycaster, intersects );\r\n\t\r\n\t\t\tif ( recursive === true ) {\r\n\t\r\n\t\t\t\tvar children = object.children;\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t//\r\n\t\r\n\t\tTHREE.Raycaster.prototype = {\r\n\t\r\n\t\t\tconstructor: THREE.Raycaster,\r\n\t\r\n\t\t\tlinePrecision: 1,\r\n\t\r\n\t\t\tset: function ( origin, direction ) {\r\n\t\r\n\t\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\t\r\n\t\t\t\tthis.ray.set( origin, direction );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tsetFromCamera: function ( coords, camera ) {\r\n\t\r\n\t\t\t\tif ( camera instanceof THREE.PerspectiveCamera ) {\r\n\t\r\n\t\t\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\r\n\t\r\n\t\t\t\t} else if ( camera instanceof THREE.OrthographicCamera ) {\r\n\t\r\n\t\t\t\t\tthis.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );\r\n\t\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tintersectObject: function ( object, recursive ) {\r\n\t\r\n\t\t\t\tvar intersects = [];\r\n\t\r\n\t\t\t\tintersectObject( object, this, intersects, recursive );\r\n\t\r\n\t\t\t\tintersects.sort( ascSort );\r\n\t\r\n\t\t\t\treturn intersects;\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tintersectObjects: function ( objects, recursive ) {\r\n\t\r\n\t\t\t\tvar intersects = [];\r\n\t\r\n\t\t\t\tif ( Array.isArray( objects ) === false ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\r\n\t\t\t\t\treturn intersects;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tintersects.sort( ascSort );\r\n\t\r\n\t\t\t\treturn intersects;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t}( THREE ) );\r\n\t\r\n\t// File:src/core/Object3D.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @author elephantatwork / www.elephantatwork.ch\r\n\t */\r\n\t\r\n\tTHREE.Object3D = function () {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.type = 'Object3D';\r\n\t\r\n\t\tthis.parent = null;\r\n\t\tthis.children = [];\r\n\t\r\n\t\tthis.up = THREE.Object3D.DefaultUp.clone();\r\n\t\r\n\t\tvar position = new THREE.Vector3();\r\n\t\tvar rotation = new THREE.Euler();\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\t\tvar scale = new THREE.Vector3( 1, 1, 1 );\r\n\t\r\n\t\tfunction onRotationChange() {\r\n\t\r\n\t\t\tquaternion.setFromEuler( rotation, false );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction onQuaternionChange() {\r\n\t\r\n\t\t\trotation.setFromQuaternion( quaternion, undefined, false );\r\n\t\r\n\t\t}\r\n\t\r\n\t\trotation.onChange( onRotationChange );\r\n\t\tquaternion.onChange( onQuaternionChange );\r\n\t\r\n\t\tObject.defineProperties( this, {\r\n\t\t\tposition: {\r\n\t\t\t\tenumerable: true,\r\n\t\t\t\tvalue: position\r\n\t\t\t},\r\n\t\t\trotation: {\r\n\t\t\t\tenumerable: true,\r\n\t\t\t\tvalue: rotation\r\n\t\t\t},\r\n\t\t\tquaternion: {\r\n\t\t\t\tenumerable: true,\r\n\t\t\t\tvalue: quaternion\r\n\t\t\t},\r\n\t\t\tscale: {\r\n\t\t\t\tenumerable: true,\r\n\t\t\t\tvalue: scale\r\n\t\t\t},\r\n\t\t\tmodelViewMatrix: {\r\n\t\t\t\tvalue: new THREE.Matrix4()\r\n\t\t\t},\r\n\t\t\tnormalMatrix: {\r\n\t\t\t\tvalue: new THREE.Matrix3()\r\n\t\t\t}\r\n\t\t} );\r\n\t\r\n\t\tthis.rotationAutoUpdate = true;\r\n\t\r\n\t\tthis.matrix = new THREE.Matrix4();\r\n\t\tthis.matrixWorld = new THREE.Matrix4();\r\n\t\r\n\t\tthis.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;\r\n\t\tthis.matrixWorldNeedsUpdate = false;\r\n\t\r\n\t\tthis.layers = new THREE.Layers();\r\n\t\tthis.visible = true;\r\n\t\r\n\t\tthis.castShadow = false;\r\n\t\tthis.receiveShadow = false;\r\n\t\r\n\t\tthis.frustumCulled = true;\r\n\t\tthis.renderOrder = 0;\r\n\t\r\n\t\tthis.userData = {};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );\r\n\tTHREE.Object3D.DefaultMatrixAutoUpdate = true;\r\n\t\r\n\tTHREE.Object3D.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Object3D,\r\n\t\r\n\t\tapplyMatrix: function ( matrix ) {\r\n\t\r\n\t\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\r\n\t\r\n\t\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRotationFromAxisAngle: function ( axis, angle ) {\r\n\t\r\n\t\t\t// assumes axis is normalized\r\n\t\r\n\t\t\tthis.quaternion.setFromAxisAngle( axis, angle );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRotationFromEuler: function ( euler ) {\r\n\t\r\n\t\t\tthis.quaternion.setFromEuler( euler, true );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRotationFromMatrix: function ( m ) {\r\n\t\r\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\t\r\n\t\t\tthis.quaternion.setFromRotationMatrix( m );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRotationFromQuaternion: function ( q ) {\r\n\t\r\n\t\t\t// assumes q is normalized\r\n\t\r\n\t\t\tthis.quaternion.copy( q );\r\n\t\r\n\t\t},\r\n\t\r\n\t\trotateOnAxis: function () {\r\n\t\r\n\t\t\t// rotate object on axis in object space\r\n\t\t\t// axis is assumed to be normalized\r\n\t\r\n\t\t\tvar q1 = new THREE.Quaternion();\r\n\t\r\n\t\t\treturn function ( axis, angle ) {\r\n\t\r\n\t\t\t\tq1.setFromAxisAngle( axis, angle );\r\n\t\r\n\t\t\t\tthis.quaternion.multiply( q1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateX: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\r\n\t\r\n\t\t\treturn function ( angle ) {\r\n\t\r\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateY: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\r\n\t\r\n\t\t\treturn function ( angle ) {\r\n\t\r\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateZ: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\r\n\t\r\n\t\t\treturn function ( angle ) {\r\n\t\r\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslateOnAxis: function () {\r\n\t\r\n\t\t\t// translate object by distance along axis in object space\r\n\t\t\t// axis is assumed to be normalized\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( axis, distance ) {\r\n\t\r\n\t\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\r\n\t\r\n\t\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslateX: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\r\n\t\r\n\t\t\treturn function ( distance ) {\r\n\t\r\n\t\t\t\treturn this.translateOnAxis( v1, distance );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslateY: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\r\n\t\r\n\t\t\treturn function ( distance ) {\r\n\t\r\n\t\t\t\treturn this.translateOnAxis( v1, distance );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslateZ: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\r\n\t\r\n\t\t\treturn function ( distance ) {\r\n\t\r\n\t\t\t\treturn this.translateOnAxis( v1, distance );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tlocalToWorld: function ( vector ) {\r\n\t\r\n\t\t\treturn vector.applyMatrix4( this.matrixWorld );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tworldToLocal: function () {\r\n\t\r\n\t\t\tvar m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\treturn function ( vector ) {\r\n\t\r\n\t\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tlookAt: function () {\r\n\t\r\n\t\t\t// This routine does not support objects with rotated and/or translated parent(s)\r\n\t\r\n\t\t\tvar m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\treturn function ( vector ) {\r\n\t\r\n\t\t\t\tm1.lookAt( vector, this.position, this.up );\r\n\t\r\n\t\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tadd: function ( object ) {\r\n\t\r\n\t\t\tif ( arguments.length > 1 ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tthis.add( arguments[ i ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object === this ) {\r\n\t\r\n\t\t\t\tconsole.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object instanceof THREE.Object3D ) {\r\n\t\r\n\t\t\t\tif ( object.parent !== null ) {\r\n\t\r\n\t\t\t\t\tobject.parent.remove( object );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tobject.parent = this;\r\n\t\t\t\tobject.dispatchEvent( { type: 'added' } );\r\n\t\r\n\t\t\t\tthis.children.push( object );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tconsole.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tremove: function ( object ) {\r\n\t\r\n\t\t\tif ( arguments.length > 1 ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tthis.remove( arguments[ i ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar index = this.children.indexOf( object );\r\n\t\r\n\t\t\tif ( index !== - 1 ) {\r\n\t\r\n\t\t\t\tobject.parent = null;\r\n\t\r\n\t\t\t\tobject.dispatchEvent( { type: 'removed' } );\r\n\t\r\n\t\t\t\tthis.children.splice( index, 1 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetObjectById: function ( id ) {\r\n\t\r\n\t\t\treturn this.getObjectByProperty( 'id', id );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetObjectByName: function ( name ) {\r\n\t\r\n\t\t\treturn this.getObjectByProperty( 'name', name );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetObjectByProperty: function ( name, value ) {\r\n\t\r\n\t\t\tif ( this[ name ] === value ) return this;\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar child = this.children[ i ];\r\n\t\t\t\tvar object = child.getObjectByProperty( name, value );\r\n\t\r\n\t\t\t\tif ( object !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn object;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn undefined;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetWorldPosition: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\t\r\n\t\t\treturn result.setFromMatrixPosition( this.matrixWorld );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetWorldQuaternion: function () {\r\n\t\r\n\t\t\tvar position = new THREE.Vector3();\r\n\t\t\tvar scale = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Quaternion();\r\n\t\r\n\t\t\t\tthis.updateMatrixWorld( true );\r\n\t\r\n\t\t\t\tthis.matrixWorld.decompose( position, result, scale );\r\n\t\r\n\t\t\t\treturn result;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tgetWorldRotation: function () {\r\n\t\r\n\t\t\tvar quaternion = new THREE.Quaternion();\r\n\t\r\n\t\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Euler();\r\n\t\r\n\t\t\t\tthis.getWorldQuaternion( quaternion );\r\n\t\r\n\t\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tgetWorldScale: function () {\r\n\t\r\n\t\t\tvar position = new THREE.Vector3();\r\n\t\t\tvar quaternion = new THREE.Quaternion();\r\n\t\r\n\t\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\t\tthis.updateMatrixWorld( true );\r\n\t\r\n\t\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\r\n\t\r\n\t\t\t\treturn result;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tgetWorldDirection: function () {\r\n\t\r\n\t\t\tvar quaternion = new THREE.Quaternion();\r\n\t\r\n\t\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\t\tthis.getWorldQuaternion( quaternion );\r\n\t\r\n\t\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\traycast: function () {},\r\n\t\r\n\t\ttraverse: function ( callback ) {\r\n\t\r\n\t\t\tcallback( this );\r\n\t\r\n\t\t\tvar children = this.children;\r\n\t\r\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tchildren[ i ].traverse( callback );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttraverseVisible: function ( callback ) {\r\n\t\r\n\t\t\tif ( this.visible === false ) return;\r\n\t\r\n\t\t\tcallback( this );\r\n\t\r\n\t\t\tvar children = this.children;\r\n\t\r\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tchildren[ i ].traverseVisible( callback );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttraverseAncestors: function ( callback ) {\r\n\t\r\n\t\t\tvar parent = this.parent;\r\n\t\r\n\t\t\tif ( parent !== null ) {\r\n\t\r\n\t\t\t\tcallback( parent );\r\n\t\r\n\t\t\t\tparent.traverseAncestors( callback );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdateMatrix: function () {\r\n\t\r\n\t\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\r\n\t\r\n\t\t\tthis.matrixWorldNeedsUpdate = true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdateMatrixWorld: function ( force ) {\r\n\t\r\n\t\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\r\n\t\r\n\t\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\r\n\t\r\n\t\t\t\tif ( this.parent === null ) {\r\n\t\r\n\t\t\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.matrixWorldNeedsUpdate = false;\r\n\t\r\n\t\t\t\tforce = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// update children\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tthis.children[ i ].updateMatrixWorld( force );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function ( meta ) {\r\n\t\r\n\t\t\tvar isRootObject = ( meta === undefined );\r\n\t\r\n\t\t\tvar output = {};\r\n\t\r\n\t\t\t// meta is a hash used to collect geometries, materials.\r\n\t\t\t// not providing it implies that this is the root object\r\n\t\t\t// being serialized.\r\n\t\t\tif ( isRootObject ) {\r\n\t\r\n\t\t\t\t// initialize meta obj\r\n\t\t\t\tmeta = {\r\n\t\t\t\t\tgeometries: {},\r\n\t\t\t\t\tmaterials: {},\r\n\t\t\t\t\ttextures: {},\r\n\t\t\t\t\timages: {}\r\n\t\t\t\t};\r\n\t\r\n\t\t\t\toutput.metadata = {\r\n\t\t\t\t\tversion: 4.4,\r\n\t\t\t\t\ttype: 'Object',\r\n\t\t\t\t\tgenerator: 'Object3D.toJSON'\r\n\t\t\t\t};\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// standard Object3D serialization\r\n\t\r\n\t\t\tvar object = {};\r\n\t\r\n\t\t\tobject.uuid = this.uuid;\r\n\t\t\tobject.type = this.type;\r\n\t\r\n\t\t\tif ( this.name !== '' ) object.name = this.name;\r\n\t\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\r\n\t\t\tif ( this.castShadow === true ) object.castShadow = true;\r\n\t\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\r\n\t\t\tif ( this.visible === false ) object.visible = false;\r\n\t\r\n\t\t\tobject.matrix = this.matrix.toArray();\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tif ( this.geometry !== undefined ) {\r\n\t\r\n\t\t\t\tif ( meta.geometries[ this.geometry.uuid ] === undefined ) {\r\n\t\r\n\t\t\t\t\tmeta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tobject.geometry = this.geometry.uuid;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.material !== undefined ) {\r\n\t\r\n\t\t\t\tif ( meta.materials[ this.material.uuid ] === undefined ) {\r\n\t\r\n\t\t\t\t\tmeta.materials[ this.material.uuid ] = this.material.toJSON( meta );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tobject.material = this.material.uuid;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tif ( this.children.length > 0 ) {\r\n\t\r\n\t\t\t\tobject.children = [];\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( isRootObject ) {\r\n\t\r\n\t\t\t\tvar geometries = extractFromCache( meta.geometries );\r\n\t\t\t\tvar materials = extractFromCache( meta.materials );\r\n\t\t\t\tvar textures = extractFromCache( meta.textures );\r\n\t\t\t\tvar images = extractFromCache( meta.images );\r\n\t\r\n\t\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\r\n\t\t\t\tif ( materials.length > 0 ) output.materials = materials;\r\n\t\t\t\tif ( textures.length > 0 ) output.textures = textures;\r\n\t\t\t\tif ( images.length > 0 ) output.images = images;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\toutput.object = object;\r\n\t\r\n\t\t\treturn output;\r\n\t\r\n\t\t\t// extract data from the cache hash\r\n\t\t\t// remove metadata on each item\r\n\t\t\t// and return as array\r\n\t\t\tfunction extractFromCache ( cache ) {\r\n\t\r\n\t\t\t\tvar values = [];\r\n\t\t\t\tfor ( var key in cache ) {\r\n\t\r\n\t\t\t\t\tvar data = cache[ key ];\r\n\t\t\t\t\tdelete data.metadata;\r\n\t\t\t\t\tvalues.push( data );\r\n\t\r\n\t\t\t\t}\r\n\t\t\t\treturn values;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function ( recursive ) {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this, recursive );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( source, recursive ) {\r\n\t\r\n\t\t\tif ( recursive === undefined ) recursive = true;\r\n\t\r\n\t\t\tthis.name = source.name;\r\n\t\r\n\t\t\tthis.up.copy( source.up );\r\n\t\r\n\t\t\tthis.position.copy( source.position );\r\n\t\t\tthis.quaternion.copy( source.quaternion );\r\n\t\t\tthis.scale.copy( source.scale );\r\n\t\r\n\t\t\tthis.rotationAutoUpdate = source.rotationAutoUpdate;\r\n\t\r\n\t\t\tthis.matrix.copy( source.matrix );\r\n\t\t\tthis.matrixWorld.copy( source.matrixWorld );\r\n\t\r\n\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\r\n\t\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\r\n\t\r\n\t\t\tthis.visible = source.visible;\r\n\t\r\n\t\t\tthis.castShadow = source.castShadow;\r\n\t\t\tthis.receiveShadow = source.receiveShadow;\r\n\t\r\n\t\t\tthis.frustumCulled = source.frustumCulled;\r\n\t\t\tthis.renderOrder = source.renderOrder;\r\n\t\r\n\t\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\r\n\t\r\n\t\t\tif ( recursive === true ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar child = source.children[ i ];\r\n\t\t\t\t\tthis.add( child.clone() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );\r\n\t\r\n\tTHREE.Object3DIdCount = 0;\r\n\t\r\n\t// File:src/core/Face3.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\r\n\t\r\n\t\tthis.a = a;\r\n\t\tthis.b = b;\r\n\t\tthis.c = c;\r\n\t\r\n\t\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\r\n\t\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\r\n\t\r\n\t\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\r\n\t\tthis.vertexColors = Array.isArray( color ) ? color : [];\r\n\t\r\n\t\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Face3.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Face3,\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tthis.a = source.a;\r\n\t\t\tthis.b = source.b;\r\n\t\t\tthis.c = source.c;\r\n\t\r\n\t\t\tthis.normal.copy( source.normal );\r\n\t\t\tthis.color.copy( source.color );\r\n\t\r\n\t\t\tthis.materialIndex = source.materialIndex;\r\n\t\r\n\t\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/BufferAttribute.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.BufferAttribute = function ( array, itemSize ) {\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.array = array;\r\n\t\tthis.itemSize = itemSize;\r\n\t\r\n\t\tthis.dynamic = false;\r\n\t\tthis.updateRange = { offset: 0, count: - 1 };\r\n\t\r\n\t\tthis.version = 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BufferAttribute.prototype = {\r\n\t\r\n\t\tconstructor: THREE.BufferAttribute,\r\n\t\r\n\t\tget count() {\r\n\t\r\n\t\t\treturn this.array.length / this.itemSize;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset needsUpdate( value ) {\r\n\t\r\n\t\t\tif ( value === true ) this.version ++;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetDynamic: function ( value ) {\r\n\t\r\n\t\t\tthis.dynamic = value;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tthis.array = new source.array.constructor( source.array );\r\n\t\t\tthis.itemSize = source.itemSize;\r\n\t\r\n\t\t\tthis.dynamic = source.dynamic;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyAt: function ( index1, attribute, index2 ) {\r\n\t\r\n\t\t\tindex1 *= this.itemSize;\r\n\t\t\tindex2 *= attribute.itemSize;\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyArray: function ( array ) {\r\n\t\r\n\t\t\tthis.array.set( array );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyColorsArray: function ( colors ) {\r\n\t\r\n\t\t\tvar array = this.array, offset = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar color = colors[ i ];\r\n\t\r\n\t\t\t\tif ( color === undefined ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\r\n\t\t\t\t\tcolor = new THREE.Color();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tarray[ offset ++ ] = color.r;\r\n\t\t\t\tarray[ offset ++ ] = color.g;\r\n\t\t\t\tarray[ offset ++ ] = color.b;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyIndicesArray: function ( indices ) {\r\n\t\r\n\t\t\tvar array = this.array, offset = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar index = indices[ i ];\r\n\t\r\n\t\t\t\tarray[ offset ++ ] = index.a;\r\n\t\t\t\tarray[ offset ++ ] = index.b;\r\n\t\t\t\tarray[ offset ++ ] = index.c;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyVector2sArray: function ( vectors ) {\r\n\t\r\n\t\t\tvar array = this.array, offset = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar vector = vectors[ i ];\r\n\t\r\n\t\t\t\tif ( vector === undefined ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\r\n\t\t\t\t\tvector = new THREE.Vector2();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tarray[ offset ++ ] = vector.x;\r\n\t\t\t\tarray[ offset ++ ] = vector.y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyVector3sArray: function ( vectors ) {\r\n\t\r\n\t\t\tvar array = this.array, offset = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar vector = vectors[ i ];\r\n\t\r\n\t\t\t\tif ( vector === undefined ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\r\n\t\t\t\t\tvector = new THREE.Vector3();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tarray[ offset ++ ] = vector.x;\r\n\t\t\t\tarray[ offset ++ ] = vector.y;\r\n\t\t\t\tarray[ offset ++ ] = vector.z;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyVector4sArray: function ( vectors ) {\r\n\t\r\n\t\t\tvar array = this.array, offset = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar vector = vectors[ i ];\r\n\t\r\n\t\t\t\tif ( vector === undefined ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\r\n\t\t\t\t\tvector = new THREE.Vector4();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tarray[ offset ++ ] = vector.x;\r\n\t\t\t\tarray[ offset ++ ] = vector.y;\r\n\t\t\t\tarray[ offset ++ ] = vector.z;\r\n\t\t\t\tarray[ offset ++ ] = vector.w;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset: function ( value, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis.array.set( value, offset );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetX: function ( index ) {\r\n\t\r\n\t\t\treturn this.array[ index * this.itemSize ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetX: function ( index, x ) {\r\n\t\r\n\t\t\tthis.array[ index * this.itemSize ] = x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetY: function ( index ) {\r\n\t\r\n\t\t\treturn this.array[ index * this.itemSize + 1 ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetY: function ( index, y ) {\r\n\t\r\n\t\t\tthis.array[ index * this.itemSize + 1 ] = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetZ: function ( index ) {\r\n\t\r\n\t\t\treturn this.array[ index * this.itemSize + 2 ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetZ: function ( index, z ) {\r\n\t\r\n\t\t\tthis.array[ index * this.itemSize + 2 ] = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetW: function ( index ) {\r\n\t\r\n\t\t\treturn this.array[ index * this.itemSize + 3 ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetW: function ( index, w ) {\r\n\t\r\n\t\t\tthis.array[ index * this.itemSize + 3 ] = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetXY: function ( index, x, y ) {\r\n\t\r\n\t\t\tindex *= this.itemSize;\r\n\t\r\n\t\t\tthis.array[ index + 0 ] = x;\r\n\t\t\tthis.array[ index + 1 ] = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetXYZ: function ( index, x, y, z ) {\r\n\t\r\n\t\t\tindex *= this.itemSize;\r\n\t\r\n\t\t\tthis.array[ index + 0 ] = x;\r\n\t\t\tthis.array[ index + 1 ] = y;\r\n\t\t\tthis.array[ index + 2 ] = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetXYZW: function ( index, x, y, z, w ) {\r\n\t\r\n\t\t\tindex *= this.itemSize;\r\n\t\r\n\t\t\tthis.array[ index + 0 ] = x;\r\n\t\t\tthis.array[ index + 1 ] = y;\r\n\t\t\tthis.array[ index + 2 ] = z;\r\n\t\t\tthis.array[ index + 3 ] = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t//\r\n\t\r\n\tTHREE.Int8Attribute = function ( array, itemSize ) {\r\n\t\r\n\t\treturn new THREE.BufferAttribute( new Int8Array( array ), itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Uint8Attribute = function ( array, itemSize ) {\r\n\t\r\n\t\treturn new THREE.BufferAttribute( new Uint8Array( array ), itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Uint8ClampedAttribute = function ( array, itemSize ) {\r\n\t\r\n\t\treturn new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Int16Attribute = function ( array, itemSize ) {\r\n\t\r\n\t\treturn new THREE.BufferAttribute( new Int16Array( array ), itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Uint16Attribute = function ( array, itemSize ) {\r\n\t\r\n\t\treturn new THREE.BufferAttribute( new Uint16Array( array ), itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Int32Attribute = function ( array, itemSize ) {\r\n\t\r\n\t\treturn new THREE.BufferAttribute( new Int32Array( array ), itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Uint32Attribute = function ( array, itemSize ) {\r\n\t\r\n\t\treturn new THREE.BufferAttribute( new Uint32Array( array ), itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Float32Attribute = function ( array, itemSize ) {\r\n\t\r\n\t\treturn new THREE.BufferAttribute( new Float32Array( array ), itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Float64Attribute = function ( array, itemSize ) {\r\n\t\r\n\t\treturn new THREE.BufferAttribute( new Float64Array( array ), itemSize );\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// Deprecated\r\n\t\r\n\tTHREE.DynamicBufferAttribute = function ( array, itemSize ) {\r\n\t\r\n\t\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\r\n\t\treturn new THREE.BufferAttribute( array, itemSize ).setDynamic( true );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/InstancedBufferAttribute.js\r\n\t\r\n\t/**\r\n\t * @author benaadams / https://twitter.com/ben_a_adams\r\n\t */\r\n\t\r\n\tTHREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {\r\n\t\r\n\t\tTHREE.BufferAttribute.call( this, array, itemSize );\r\n\t\r\n\t\tthis.meshPerAttribute = meshPerAttribute || 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );\r\n\tTHREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;\r\n\t\r\n\tTHREE.InstancedBufferAttribute.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.BufferAttribute.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/InterleavedBuffer.js\r\n\t\r\n\t/**\r\n\t * @author benaadams / https://twitter.com/ben_a_adams\r\n\t */\r\n\t\r\n\tTHREE.InterleavedBuffer = function ( array, stride ) {\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.array = array;\r\n\t\tthis.stride = stride;\r\n\t\r\n\t\tthis.dynamic = false;\r\n\t\tthis.updateRange = { offset: 0, count: - 1 };\r\n\t\r\n\t\tthis.version = 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.InterleavedBuffer.prototype = {\r\n\t\r\n\t\tconstructor: THREE.InterleavedBuffer,\r\n\t\r\n\t\tget length () {\r\n\t\r\n\t\t\treturn this.array.length;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget count () {\r\n\t\r\n\t\t\treturn this.array.length / this.stride;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset needsUpdate( value ) {\r\n\t\r\n\t\t\tif ( value === true ) this.version ++;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetDynamic: function ( value ) {\r\n\t\r\n\t\t\tthis.dynamic = value;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tthis.array = new source.array.constructor( source.array );\r\n\t\t\tthis.stride = source.stride;\r\n\t\t\tthis.dynamic = source.dynamic;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyAt: function ( index1, attribute, index2 ) {\r\n\t\r\n\t\t\tindex1 *= this.stride;\r\n\t\t\tindex2 *= attribute.stride;\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset: function ( value, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis.array.set( value, offset );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/InstancedInterleavedBuffer.js\r\n\t\r\n\t/**\r\n\t * @author benaadams / https://twitter.com/ben_a_adams\r\n\t */\r\n\t\r\n\tTHREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {\r\n\t\r\n\t\tTHREE.InterleavedBuffer.call( this, array, stride );\r\n\t\r\n\t\tthis.meshPerAttribute = meshPerAttribute || 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );\r\n\tTHREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;\r\n\t\r\n\tTHREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.InterleavedBuffer.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/InterleavedBufferAttribute.js\r\n\t\r\n\t/**\r\n\t * @author benaadams / https://twitter.com/ben_a_adams\r\n\t */\r\n\t\r\n\tTHREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.data = interleavedBuffer;\r\n\t\tthis.itemSize = itemSize;\r\n\t\tthis.offset = offset;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.InterleavedBufferAttribute.prototype = {\r\n\t\r\n\t\tconstructor: THREE.InterleavedBufferAttribute,\r\n\t\r\n\t\tget length() {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\r\n\t\t\treturn this.array.length;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget count() {\r\n\t\r\n\t\t\treturn this.data.count;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetX: function ( index, x ) {\r\n\t\r\n\t\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetY: function ( index, y ) {\r\n\t\r\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetZ: function ( index, z ) {\r\n\t\r\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetW: function ( index, w ) {\r\n\t\r\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetX: function ( index ) {\r\n\t\r\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetY: function ( index ) {\r\n\t\r\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetZ: function ( index ) {\r\n\t\r\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetW: function ( index ) {\r\n\t\r\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetXY: function ( index, x, y ) {\r\n\t\r\n\t\t\tindex = index * this.data.stride + this.offset;\r\n\t\r\n\t\t\tthis.data.array[ index + 0 ] = x;\r\n\t\t\tthis.data.array[ index + 1 ] = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetXYZ: function ( index, x, y, z ) {\r\n\t\r\n\t\t\tindex = index * this.data.stride + this.offset;\r\n\t\r\n\t\t\tthis.data.array[ index + 0 ] = x;\r\n\t\t\tthis.data.array[ index + 1 ] = y;\r\n\t\t\tthis.data.array[ index + 2 ] = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetXYZW: function ( index, x, y, z, w ) {\r\n\t\r\n\t\t\tindex = index * this.data.stride + this.offset;\r\n\t\r\n\t\t\tthis.data.array[ index + 0 ] = x;\r\n\t\t\tthis.data.array[ index + 1 ] = y;\r\n\t\t\tthis.data.array[ index + 2 ] = z;\r\n\t\t\tthis.data.array[ index + 3 ] = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/Geometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author kile / http://kile.stravaganza.org/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * @author bhouston / http://clara.io\r\n\t */\r\n\t\r\n\tTHREE.Geometry = function () {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.type = 'Geometry';\r\n\t\r\n\t\tthis.vertices = [];\r\n\t\tthis.colors = [];\r\n\t\tthis.faces = [];\r\n\t\tthis.faceVertexUvs = [ [] ];\r\n\t\r\n\t\tthis.morphTargets = [];\r\n\t\tthis.morphNormals = [];\r\n\t\r\n\t\tthis.skinWeights = [];\r\n\t\tthis.skinIndices = [];\r\n\t\r\n\t\tthis.lineDistances = [];\r\n\t\r\n\t\tthis.boundingBox = null;\r\n\t\tthis.boundingSphere = null;\r\n\t\r\n\t\t// update flags\r\n\t\r\n\t\tthis.verticesNeedUpdate = false;\r\n\t\tthis.elementsNeedUpdate = false;\r\n\t\tthis.uvsNeedUpdate = false;\r\n\t\tthis.normalsNeedUpdate = false;\r\n\t\tthis.colorsNeedUpdate = false;\r\n\t\tthis.lineDistancesNeedUpdate = false;\r\n\t\tthis.groupsNeedUpdate = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Geometry.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Geometry,\r\n\t\r\n\t\tapplyMatrix: function ( matrix ) {\r\n\t\r\n\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\t\r\n\t\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\t\tvertex.applyMatrix4( matrix );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = this.faces[ i ];\r\n\t\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.boundingBox !== null ) {\r\n\t\r\n\t\t\t\tthis.computeBoundingBox();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.boundingSphere !== null ) {\r\n\t\r\n\t\t\t\tthis.computeBoundingSphere();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.verticesNeedUpdate = true;\r\n\t\t\tthis.normalsNeedUpdate = true;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\trotateX: function () {\r\n\t\r\n\t\t\t// rotate geometry around world x-axis\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function rotateX( angle ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeRotationX( angle );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateY: function () {\r\n\t\r\n\t\t\t// rotate geometry around world y-axis\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function rotateY( angle ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeRotationY( angle );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateZ: function () {\r\n\t\r\n\t\t\t// rotate geometry around world z-axis\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function rotateZ( angle ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeRotationZ( angle );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslate: function () {\r\n\t\r\n\t\t\t// translate geometry\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function translate( x, y, z ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeTranslation( x, y, z );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tscale: function () {\r\n\t\r\n\t\t\t// scale geometry\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function scale( x, y, z ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeScale( x, y, z );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tlookAt: function () {\r\n\t\r\n\t\t\tvar obj;\r\n\t\r\n\t\t\treturn function lookAt( vector ) {\r\n\t\r\n\t\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\r\n\t\r\n\t\t\t\tobj.lookAt( vector );\r\n\t\r\n\t\t\t\tobj.updateMatrix();\r\n\t\r\n\t\t\t\tthis.applyMatrix( obj.matrix );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tfromBufferGeometry: function ( geometry ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\r\n\t\t\tvar attributes = geometry.attributes;\r\n\t\r\n\t\t\tvar positions = attributes.position.array;\r\n\t\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\r\n\t\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\r\n\t\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\r\n\t\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\r\n\t\r\n\t\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\r\n\t\r\n\t\t\tvar tempNormals = [];\r\n\t\t\tvar tempUVs = [];\r\n\t\t\tvar tempUVs2 = [];\r\n\t\r\n\t\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\r\n\t\r\n\t\t\t\tscope.vertices.push( new THREE.Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\r\n\t\r\n\t\t\t\tif ( normals !== undefined ) {\r\n\t\r\n\t\t\t\t\ttempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( colors !== undefined ) {\r\n\t\r\n\t\t\t\t\tscope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( uvs !== undefined ) {\r\n\t\r\n\t\t\t\t\ttempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( uvs2 !== undefined ) {\r\n\t\r\n\t\t\t\t\ttempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction addFace( a, b, c, materialIndex ) {\r\n\t\r\n\t\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\r\n\t\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\r\n\t\r\n\t\t\t\tvar face = new THREE.Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\r\n\t\r\n\t\t\t\tscope.faces.push( face );\r\n\t\r\n\t\t\t\tif ( uvs !== undefined ) {\r\n\t\r\n\t\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( uvs2 !== undefined ) {\r\n\t\r\n\t\t\t\t\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( indices !== undefined ) {\r\n\t\r\n\t\t\t\tvar groups = geometry.groups;\r\n\t\r\n\t\t\t\tif ( groups.length > 0 ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar group = groups[ i ];\r\n\t\r\n\t\t\t\t\t\tvar start = group.start;\r\n\t\t\t\t\t\tvar count = group.count;\r\n\t\r\n\t\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\r\n\t\r\n\t\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\r\n\t\r\n\t\t\t\t\taddFace( i, i + 1, i + 2 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.computeFaceNormals();\r\n\t\r\n\t\t\tif ( geometry.boundingBox !== null ) {\r\n\t\r\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.boundingSphere !== null ) {\r\n\t\r\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcenter: function () {\r\n\t\r\n\t\t\tthis.computeBoundingBox();\r\n\t\r\n\t\t\tvar offset = this.boundingBox.center().negate();\r\n\t\r\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\r\n\t\r\n\t\t\treturn offset;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\tthis.computeBoundingSphere();\r\n\t\r\n\t\t\tvar center = this.boundingSphere.center;\r\n\t\t\tvar radius = this.boundingSphere.radius;\r\n\t\r\n\t\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\r\n\t\r\n\t\t\tvar matrix = new THREE.Matrix4();\r\n\t\t\tmatrix.set(\r\n\t\t\t\ts, 0, 0, - s * center.x,\r\n\t\t\t\t0, s, 0, - s * center.y,\r\n\t\t\t\t0, 0, s, - s * center.z,\r\n\t\t\t\t0, 0, 0, 1\r\n\t\t\t);\r\n\t\r\n\t\t\tthis.applyMatrix( matrix );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeFaceNormals: function () {\r\n\t\r\n\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\t\r\n\t\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\tvar face = this.faces[ f ];\r\n\t\r\n\t\t\t\tvar vA = this.vertices[ face.a ];\r\n\t\t\t\tvar vB = this.vertices[ face.b ];\r\n\t\t\t\tvar vC = this.vertices[ face.c ];\r\n\t\r\n\t\t\t\tcb.subVectors( vC, vB );\r\n\t\t\t\tab.subVectors( vA, vB );\r\n\t\t\t\tcb.cross( ab );\r\n\t\r\n\t\t\t\tcb.normalize();\r\n\t\r\n\t\t\t\tface.normal.copy( cb );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeVertexNormals: function ( areaWeighted ) {\r\n\t\r\n\t\t\tif ( areaWeighted === undefined ) areaWeighted = true;\r\n\t\r\n\t\t\tvar v, vl, f, fl, face, vertices;\r\n\t\r\n\t\t\tvertices = new Array( this.vertices.length );\r\n\t\r\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\t\r\n\t\t\t\tvertices[ v ] = new THREE.Vector3();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( areaWeighted ) {\r\n\t\r\n\t\t\t\t// vertex normals weighted by triangle areas\r\n\t\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\r\n\t\r\n\t\t\t\tvar vA, vB, vC;\r\n\t\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\t\tvA = this.vertices[ face.a ];\r\n\t\t\t\t\tvB = this.vertices[ face.b ];\r\n\t\t\t\t\tvC = this.vertices[ face.c ];\r\n\t\r\n\t\t\t\t\tcb.subVectors( vC, vB );\r\n\t\t\t\t\tab.subVectors( vA, vB );\r\n\t\t\t\t\tcb.cross( ab );\r\n\t\r\n\t\t\t\t\tvertices[ face.a ].add( cb );\r\n\t\t\t\t\tvertices[ face.b ].add( cb );\r\n\t\t\t\t\tvertices[ face.c ].add( cb );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\t\tvertices[ face.a ].add( face.normal );\r\n\t\t\t\t\tvertices[ face.b ].add( face.normal );\r\n\t\t\t\t\tvertices[ face.c ].add( face.normal );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\t\r\n\t\t\t\tvertices[ v ].normalize();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\tvar vertexNormals = face.vertexNormals;\r\n\t\r\n\t\t\t\tif ( vertexNormals.length === 3 ) {\r\n\t\r\n\t\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\r\n\t\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\r\n\t\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\r\n\t\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\r\n\t\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.faces.length > 0 ) {\r\n\t\r\n\t\t\t\tthis.normalsNeedUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeMorphNormals: function () {\r\n\t\r\n\t\t\tvar i, il, f, fl, face;\r\n\t\r\n\t\t\t// save original normals\r\n\t\t\t// - create temp variables on first access\r\n\t\t\t//   otherwise just copy (for faster repeated calls)\r\n\t\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\tif ( ! face.__originalFaceNormal ) {\r\n\t\r\n\t\t\t\t\tface.__originalFaceNormal = face.normal.clone();\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tface.__originalFaceNormal.copy( face.normal );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\r\n\t\r\n\t\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\r\n\t\r\n\t\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// use temp geometry to compute face and vertex normals for each morph\r\n\t\r\n\t\t\tvar tmpGeo = new THREE.Geometry();\r\n\t\t\ttmpGeo.faces = this.faces;\r\n\t\r\n\t\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t// create on first access\r\n\t\r\n\t\t\t\tif ( ! this.morphNormals[ i ] ) {\r\n\t\r\n\t\t\t\t\tthis.morphNormals[ i ] = {};\r\n\t\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\r\n\t\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\r\n\t\r\n\t\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\r\n\t\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\r\n\t\r\n\t\t\t\t\tvar faceNormal, vertexNormals;\r\n\t\r\n\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\tfaceNormal = new THREE.Vector3();\r\n\t\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\r\n\t\r\n\t\t\t\t\t\tdstNormalsFace.push( faceNormal );\r\n\t\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar morphNormals = this.morphNormals[ i ];\r\n\t\r\n\t\t\t\t// set vertices to morph target\r\n\t\r\n\t\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\r\n\t\r\n\t\t\t\t// compute morph normals\r\n\t\r\n\t\t\t\ttmpGeo.computeFaceNormals();\r\n\t\t\t\ttmpGeo.computeVertexNormals();\r\n\t\r\n\t\t\t\t// store morph normals\r\n\t\r\n\t\t\t\tvar faceNormal, vertexNormals;\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\r\n\t\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\r\n\t\r\n\t\t\t\t\tfaceNormal.copy( face.normal );\r\n\t\r\n\t\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\r\n\t\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\r\n\t\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// restore original normals\r\n\t\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\tface.normal = face.__originalFaceNormal;\r\n\t\t\t\tface.vertexNormals = face.__originalVertexNormals;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeTangents: function () {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeLineDistances: function () {\r\n\t\r\n\t\t\tvar d = 0;\r\n\t\t\tvar vertices = this.vertices;\r\n\t\r\n\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tif ( i > 0 ) {\r\n\t\r\n\t\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.lineDistances[ i ] = d;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeBoundingBox: function () {\r\n\t\r\n\t\t\tif ( this.boundingBox === null ) {\r\n\t\r\n\t\t\t\tthis.boundingBox = new THREE.Box3();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.boundingBox.setFromPoints( this.vertices );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeBoundingSphere: function () {\r\n\t\r\n\t\t\tif ( this.boundingSphere === null ) {\r\n\t\r\n\t\t\t\tthis.boundingSphere = new THREE.Sphere();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.boundingSphere.setFromPoints( this.vertices );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmerge: function ( geometry, matrix, materialIndexOffset ) {\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.Geometry === false ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar normalMatrix,\r\n\t\t\tvertexOffset = this.vertices.length,\r\n\t\t\tvertices1 = this.vertices,\r\n\t\t\tvertices2 = geometry.vertices,\r\n\t\t\tfaces1 = this.faces,\r\n\t\t\tfaces2 = geometry.faces,\r\n\t\t\tuvs1 = this.faceVertexUvs[ 0 ],\r\n\t\t\tuvs2 = geometry.faceVertexUvs[ 0 ];\r\n\t\r\n\t\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\r\n\t\r\n\t\t\tif ( matrix !== undefined ) {\r\n\t\r\n\t\t\t\tnormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// vertices\r\n\t\r\n\t\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar vertex = vertices2[ i ];\r\n\t\r\n\t\t\t\tvar vertexCopy = vertex.clone();\r\n\t\r\n\t\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\r\n\t\r\n\t\t\t\tvertices1.push( vertexCopy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// faces\r\n\t\r\n\t\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\r\n\t\t\t\tfaceVertexNormals = face.vertexNormals,\r\n\t\t\t\tfaceVertexColors = face.vertexColors;\r\n\t\r\n\t\t\t\tfaceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\r\n\t\t\t\tfaceCopy.normal.copy( face.normal );\r\n\t\r\n\t\t\t\tif ( normalMatrix !== undefined ) {\r\n\t\r\n\t\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tnormal = faceVertexNormals[ j ].clone();\r\n\t\r\n\t\t\t\t\tif ( normalMatrix !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tfaceCopy.vertexNormals.push( normal );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfaceCopy.color.copy( face.color );\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tcolor = faceVertexColors[ j ];\r\n\t\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\r\n\t\r\n\t\t\t\tfaces1.push( faceCopy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// uvs\r\n\t\r\n\t\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar uv = uvs2[ i ], uvCopy = [];\r\n\t\r\n\t\t\t\tif ( uv === undefined ) {\r\n\t\r\n\t\t\t\t\tcontinue;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tuvCopy.push( uv[ j ].clone() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tuvs1.push( uvCopy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmergeMesh: function ( mesh ) {\r\n\t\r\n\t\t\tif ( mesh instanceof THREE.Mesh === false ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\r\n\t\r\n\t\t\tthis.merge( mesh.geometry, mesh.matrix );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t/*\r\n\t\t * Checks for duplicate vertices with hashmap.\r\n\t\t * Duplicated vertices are removed\r\n\t\t * and faces' vertices are updated.\r\n\t\t */\r\n\t\r\n\t\tmergeVertices: function () {\r\n\t\r\n\t\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\r\n\t\t\tvar unique = [], changes = [];\r\n\t\r\n\t\t\tvar v, key;\r\n\t\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\r\n\t\t\tvar precision = Math.pow( 10, precisionPoints );\r\n\t\t\tvar i, il, face;\r\n\t\t\tvar indices, j, jl;\r\n\t\r\n\t\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tv = this.vertices[ i ];\r\n\t\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\r\n\t\r\n\t\t\t\tif ( verticesMap[ key ] === undefined ) {\r\n\t\r\n\t\t\t\t\tverticesMap[ key ] = i;\r\n\t\t\t\t\tunique.push( this.vertices[ i ] );\r\n\t\t\t\t\tchanges[ i ] = unique.length - 1;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\r\n\t\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\t// if faces are completely degenerate after merging vertices, we\r\n\t\t\t// have to remove them from the geometry.\r\n\t\t\tvar faceIndicesToRemove = [];\r\n\t\r\n\t\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tface = this.faces[ i ];\r\n\t\r\n\t\t\t\tface.a = changes[ face.a ];\r\n\t\t\t\tface.b = changes[ face.b ];\r\n\t\t\t\tface.c = changes[ face.c ];\r\n\t\r\n\t\t\t\tindices = [ face.a, face.b, face.c ];\r\n\t\r\n\t\t\t\tvar dupIndex = - 1;\r\n\t\r\n\t\t\t\t// if any duplicate vertices are found in a Face3\r\n\t\t\t\t// we have to remove the face as nothing can be saved\r\n\t\t\t\tfor ( var n = 0; n < 3; n ++ ) {\r\n\t\r\n\t\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\r\n\t\r\n\t\t\t\t\t\tdupIndex = n;\r\n\t\t\t\t\t\tfaceIndicesToRemove.push( i );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\r\n\t\r\n\t\t\t\tvar idx = faceIndicesToRemove[ i ];\r\n\t\r\n\t\t\t\tthis.faces.splice( idx, 1 );\r\n\t\r\n\t\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Use unique set of vertices\r\n\t\r\n\t\t\tvar diff = this.vertices.length - unique.length;\r\n\t\t\tthis.vertices = unique;\r\n\t\t\treturn diff;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsortFacesByMaterialIndex: function () {\r\n\t\r\n\t\t\tvar faces = this.faces;\r\n\t\t\tvar length = faces.length;\r\n\t\r\n\t\t\t// tag faces\r\n\t\r\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\t\r\n\t\t\t\tfaces[ i ]._id = i;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// sort faces\r\n\t\r\n\t\t\tfunction materialIndexSort( a, b ) {\r\n\t\r\n\t\t\t\treturn a.materialIndex - b.materialIndex;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfaces.sort( materialIndexSort );\r\n\t\r\n\t\t\t// sort uvs\r\n\t\r\n\t\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\r\n\t\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\r\n\t\r\n\t\t\tvar newUvs1, newUvs2;\r\n\t\r\n\t\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\r\n\t\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\r\n\t\r\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\t\r\n\t\t\t\tvar id = faces[ i ]._id;\r\n\t\r\n\t\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\r\n\t\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\r\n\t\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function () {\r\n\t\r\n\t\t\tvar data = {\r\n\t\t\t\tmetadata: {\r\n\t\t\t\t\tversion: 4.4,\r\n\t\t\t\t\ttype: 'Geometry',\r\n\t\t\t\t\tgenerator: 'Geometry.toJSON'\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\r\n\t\t\t// standard Geometry serialization\r\n\t\r\n\t\t\tdata.uuid = this.uuid;\r\n\t\t\tdata.type = this.type;\r\n\t\t\tif ( this.name !== '' ) data.name = this.name;\r\n\t\r\n\t\t\tif ( this.parameters !== undefined ) {\r\n\t\r\n\t\t\t\tvar parameters = this.parameters;\r\n\t\r\n\t\t\t\tfor ( var key in parameters ) {\r\n\t\r\n\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn data;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar vertices = [];\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\r\n\t\r\n\t\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar faces = [];\r\n\t\t\tvar normals = [];\r\n\t\t\tvar normalsHash = {};\r\n\t\t\tvar colors = [];\r\n\t\t\tvar colorsHash = {};\r\n\t\t\tvar uvs = [];\r\n\t\t\tvar uvsHash = {};\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = this.faces[ i ];\r\n\t\r\n\t\t\t\tvar hasMaterial = true;\r\n\t\t\t\tvar hasFaceUv = false; // deprecated\r\n\t\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\r\n\t\t\t\tvar hasFaceNormal = face.normal.length() > 0;\r\n\t\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\r\n\t\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\r\n\t\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\r\n\t\r\n\t\t\t\tvar faceType = 0;\r\n\t\r\n\t\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\r\n\t\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\r\n\t\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\r\n\t\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\r\n\t\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\r\n\t\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\r\n\t\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\r\n\t\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\r\n\t\r\n\t\t\t\tfaces.push( faceType );\r\n\t\t\t\tfaces.push( face.a, face.b, face.c );\r\n\t\t\t\tfaces.push( face.materialIndex );\r\n\t\r\n\t\t\t\tif ( hasFaceVertexUv ) {\r\n\t\r\n\t\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\r\n\t\r\n\t\t\t\t\tfaces.push(\r\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\r\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\r\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\r\n\t\t\t\t\t);\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceNormal ) {\r\n\t\r\n\t\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\t\r\n\t\t\t\t\tvar vertexNormals = face.vertexNormals;\r\n\t\r\n\t\t\t\t\tfaces.push(\r\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\r\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\r\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\r\n\t\t\t\t\t);\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceColor ) {\r\n\t\r\n\t\t\t\t\tfaces.push( getColorIndex( face.color ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceVertexColor ) {\r\n\t\r\n\t\t\t\t\tvar vertexColors = face.vertexColors;\r\n\t\r\n\t\t\t\t\tfaces.push(\r\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\r\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\r\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\r\n\t\t\t\t\t);\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction setBit( value, position, enabled ) {\r\n\t\r\n\t\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction getNormalIndex( normal ) {\r\n\t\r\n\t\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\r\n\t\r\n\t\t\t\tif ( normalsHash[ hash ] !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn normalsHash[ hash ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tnormalsHash[ hash ] = normals.length / 3;\r\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\t\r\n\t\t\t\treturn normalsHash[ hash ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction getColorIndex( color ) {\r\n\t\r\n\t\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\r\n\t\r\n\t\t\t\tif ( colorsHash[ hash ] !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn colorsHash[ hash ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcolorsHash[ hash ] = colors.length;\r\n\t\t\t\tcolors.push( color.getHex() );\r\n\t\r\n\t\t\t\treturn colorsHash[ hash ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction getUvIndex( uv ) {\r\n\t\r\n\t\t\t\tvar hash = uv.x.toString() + uv.y.toString();\r\n\t\r\n\t\t\t\tif ( uvsHash[ hash ] !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn uvsHash[ hash ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tuvsHash[ hash ] = uvs.length / 2;\r\n\t\t\t\tuvs.push( uv.x, uv.y );\r\n\t\r\n\t\t\t\treturn uvsHash[ hash ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tdata.data = {};\r\n\t\r\n\t\t\tdata.data.vertices = vertices;\r\n\t\t\tdata.data.normals = normals;\r\n\t\t\tif ( colors.length > 0 ) data.data.colors = colors;\r\n\t\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\r\n\t\t\tdata.data.faces = faces;\r\n\t\r\n\t\t\treturn data;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\t/*\r\n\t\t\t// Handle primitives\r\n\t\r\n\t\t\tvar parameters = this.parameters;\r\n\t\r\n\t\t\tif ( parameters !== undefined ) {\r\n\t\r\n\t\t\t\tvar values = [];\r\n\t\r\n\t\t\t\tfor ( var key in parameters ) {\r\n\t\r\n\t\t\t\t\tvalues.push( parameters[ key ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\r\n\t\t\t\tthis.constructor.apply( geometry, values );\r\n\t\t\t\treturn geometry;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\t\t*/\r\n\t\r\n\t\t\treturn new THREE.Geometry().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tthis.vertices = [];\r\n\t\t\tthis.faces = [];\r\n\t\t\tthis.faceVertexUvs = [ [] ];\r\n\t\r\n\t\t\tvar vertices = source.vertices;\r\n\t\r\n\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tthis.vertices.push( vertices[ i ].clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar faces = source.faces;\r\n\t\r\n\t\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tthis.faces.push( faces[ i ].clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\r\n\t\r\n\t\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\r\n\t\r\n\t\t\t\t\tthis.faceVertexUvs[ i ] = [];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\r\n\t\r\n\t\t\t\t\tfor ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar uv = uvs[ k ];\r\n\t\r\n\t\t\t\t\t\tuvsCopy.push( uv.clone() );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );\r\n\t\r\n\tTHREE.GeometryIdCount = 0;\r\n\t\r\n\t// File:src/core/DirectGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.DirectGeometry = function () {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.type = 'DirectGeometry';\r\n\t\r\n\t\tthis.indices = [];\r\n\t\tthis.vertices = [];\r\n\t\tthis.normals = [];\r\n\t\tthis.colors = [];\r\n\t\tthis.uvs = [];\r\n\t\tthis.uvs2 = [];\r\n\t\r\n\t\tthis.groups = [];\r\n\t\r\n\t\tthis.morphTargets = {};\r\n\t\r\n\t\tthis.skinWeights = [];\r\n\t\tthis.skinIndices = [];\r\n\t\r\n\t\t// this.lineDistances = [];\r\n\t\r\n\t\tthis.boundingBox = null;\r\n\t\tthis.boundingSphere = null;\r\n\t\r\n\t\t// update flags\r\n\t\r\n\t\tthis.verticesNeedUpdate = false;\r\n\t\tthis.normalsNeedUpdate = false;\r\n\t\tthis.colorsNeedUpdate = false;\r\n\t\tthis.uvsNeedUpdate = false;\r\n\t\tthis.groupsNeedUpdate = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DirectGeometry.prototype = {\r\n\t\r\n\t\tconstructor: THREE.DirectGeometry,\r\n\t\r\n\t\tcomputeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,\r\n\t\tcomputeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,\r\n\t\r\n\t\tcomputeFaceNormals: function () {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeVertexNormals: function () {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeGroups: function ( geometry ) {\r\n\t\r\n\t\t\tvar group;\r\n\t\t\tvar groups = [];\r\n\t\t\tvar materialIndex;\r\n\t\r\n\t\t\tvar faces = geometry.faces;\r\n\t\r\n\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\t\t// materials\r\n\t\r\n\t\t\t\tif ( face.materialIndex !== materialIndex ) {\r\n\t\r\n\t\t\t\t\tmaterialIndex = face.materialIndex;\r\n\t\r\n\t\t\t\t\tif ( group !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\r\n\t\t\t\t\t\tgroups.push( group );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tgroup = {\r\n\t\t\t\t\t\tstart: i * 3,\r\n\t\t\t\t\t\tmaterialIndex: materialIndex\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( group !== undefined ) {\r\n\t\r\n\t\t\t\tgroup.count = ( i * 3 ) - group.start;\r\n\t\t\t\tgroups.push( group );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.groups = groups;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromGeometry: function ( geometry ) {\r\n\t\r\n\t\t\tvar faces = geometry.faces;\r\n\t\t\tvar vertices = geometry.vertices;\r\n\t\t\tvar faceVertexUvs = geometry.faceVertexUvs;\r\n\t\r\n\t\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\r\n\t\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\r\n\t\r\n\t\t\t// morphs\r\n\t\r\n\t\t\tvar morphTargets = geometry.morphTargets;\r\n\t\t\tvar morphTargetsLength = morphTargets.length;\r\n\t\r\n\t\t\tvar morphTargetsPosition;\r\n\t\r\n\t\t\tif ( morphTargetsLength > 0 ) {\r\n\t\r\n\t\t\t\tmorphTargetsPosition = [];\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\r\n\t\r\n\t\t\t\t\tmorphTargetsPosition[ i ] = [];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.morphTargets.position = morphTargetsPosition;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar morphNormals = geometry.morphNormals;\r\n\t\t\tvar morphNormalsLength = morphNormals.length;\r\n\t\r\n\t\t\tvar morphTargetsNormal;\r\n\t\r\n\t\t\tif ( morphNormalsLength > 0 ) {\r\n\t\r\n\t\t\t\tmorphTargetsNormal = [];\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\r\n\t\r\n\t\t\t\t\tmorphTargetsNormal[ i ] = [];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.morphTargets.normal = morphTargetsNormal;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// skins\r\n\t\r\n\t\t\tvar skinIndices = geometry.skinIndices;\r\n\t\t\tvar skinWeights = geometry.skinWeights;\r\n\t\r\n\t\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\r\n\t\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\r\n\t\r\n\t\t\t\tvar vertexNormals = face.vertexNormals;\r\n\t\r\n\t\t\t\tif ( vertexNormals.length === 3 ) {\r\n\t\r\n\t\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvar normal = face.normal;\r\n\t\r\n\t\t\t\t\tthis.normals.push( normal, normal, normal );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar vertexColors = face.vertexColors;\r\n\t\r\n\t\t\t\tif ( vertexColors.length === 3 ) {\r\n\t\r\n\t\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvar color = face.color;\r\n\t\r\n\t\t\t\t\tthis.colors.push( color, color, color );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceVertexUv === true ) {\r\n\t\r\n\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\r\n\t\r\n\t\t\t\t\tif ( vertexUvs !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\r\n\t\r\n\t\t\t\t\t\tthis.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceVertexUv2 === true ) {\r\n\t\r\n\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\r\n\t\r\n\t\t\t\t\tif ( vertexUvs !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\r\n\t\r\n\t\t\t\t\t\tthis.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// morphs\r\n\t\r\n\t\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\r\n\t\r\n\t\t\t\t\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\r\n\t\r\n\t\t\t\t\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// skins\r\n\t\r\n\t\t\t\tif ( hasSkinIndices ) {\r\n\t\r\n\t\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasSkinWeights ) {\r\n\t\r\n\t\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.computeGroups( geometry );\r\n\t\r\n\t\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\r\n\t\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\r\n\t\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\r\n\t\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\r\n\t\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.DirectGeometry.prototype );\r\n\t\r\n\t// File:src/core/BufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.BufferGeometry = function () {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.type = 'BufferGeometry';\r\n\t\r\n\t\tthis.index = null;\r\n\t\tthis.attributes = {};\r\n\t\r\n\t\tthis.morphAttributes = {};\r\n\t\r\n\t\tthis.groups = [];\r\n\t\r\n\t\tthis.boundingBox = null;\r\n\t\tthis.boundingSphere = null;\r\n\t\r\n\t\tthis.drawRange = { start: 0, count: Infinity };\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BufferGeometry.prototype = {\r\n\t\r\n\t\tconstructor: THREE.BufferGeometry,\r\n\t\r\n\t\tgetIndex: function () {\r\n\t\r\n\t\t\treturn this.index;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetIndex: function ( index ) {\r\n\t\r\n\t\t\tthis.index = index;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddAttribute: function ( name, attribute ) {\r\n\t\r\n\t\t\tif ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\r\n\t\r\n\t\t\t\tthis.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\r\n\t\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( name === 'index' ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\r\n\t\t\t\tthis.setIndex( attribute );\r\n\t\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.attributes[ name ] = attribute;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetAttribute: function ( name ) {\r\n\t\r\n\t\t\treturn this.attributes[ name ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tremoveAttribute: function ( name ) {\r\n\t\r\n\t\t\tdelete this.attributes[ name ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddGroup: function ( start, count, materialIndex ) {\r\n\t\r\n\t\t\tthis.groups.push( {\r\n\t\r\n\t\t\t\tstart: start,\r\n\t\t\t\tcount: count,\r\n\t\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\r\n\t\r\n\t\t\t} );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclearGroups: function () {\r\n\t\r\n\t\t\tthis.groups = [];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetDrawRange: function ( start, count ) {\r\n\t\r\n\t\t\tthis.drawRange.start = start;\r\n\t\t\tthis.drawRange.count = count;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix: function ( matrix ) {\r\n\t\r\n\t\t\tvar position = this.attributes.position;\r\n\t\r\n\t\t\tif ( position !== undefined ) {\r\n\t\r\n\t\t\t\tmatrix.applyToVector3Array( position.array );\r\n\t\t\t\tposition.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar normal = this.attributes.normal;\r\n\t\r\n\t\t\tif ( normal !== undefined ) {\r\n\t\r\n\t\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\t\r\n\t\t\t\tnormalMatrix.applyToVector3Array( normal.array );\r\n\t\t\t\tnormal.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.boundingBox !== null ) {\r\n\t\r\n\t\t\t\tthis.computeBoundingBox();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.boundingSphere !== null ) {\r\n\t\r\n\t\t\t\tthis.computeBoundingSphere();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\trotateX: function () {\r\n\t\r\n\t\t\t// rotate geometry around world x-axis\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function rotateX( angle ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeRotationX( angle );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateY: function () {\r\n\t\r\n\t\t\t// rotate geometry around world y-axis\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function rotateY( angle ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeRotationY( angle );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateZ: function () {\r\n\t\r\n\t\t\t// rotate geometry around world z-axis\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function rotateZ( angle ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeRotationZ( angle );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslate: function () {\r\n\t\r\n\t\t\t// translate geometry\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function translate( x, y, z ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeTranslation( x, y, z );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tscale: function () {\r\n\t\r\n\t\t\t// scale geometry\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function scale( x, y, z ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeScale( x, y, z );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tlookAt: function () {\r\n\t\r\n\t\t\tvar obj;\r\n\t\r\n\t\t\treturn function lookAt( vector ) {\r\n\t\r\n\t\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\r\n\t\r\n\t\t\t\tobj.lookAt( vector );\r\n\t\r\n\t\t\t\tobj.updateMatrix();\r\n\t\r\n\t\t\t\tthis.applyMatrix( obj.matrix );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tcenter: function () {\r\n\t\r\n\t\t\tthis.computeBoundingBox();\r\n\t\r\n\t\t\tvar offset = this.boundingBox.center().negate();\r\n\t\r\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\r\n\t\r\n\t\t\treturn offset;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromObject: function ( object ) {\r\n\t\r\n\t\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\r\n\t\r\n\t\t\tvar geometry = object.geometry;\r\n\t\r\n\t\t\tif ( object instanceof THREE.Points || object instanceof THREE.Line ) {\r\n\t\r\n\t\t\t\tvar positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );\r\n\t\t\t\tvar colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );\r\n\t\r\n\t\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\r\n\t\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\r\n\t\r\n\t\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\r\n\t\r\n\t\t\t\t\tvar lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );\r\n\t\r\n\t\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( geometry.boundingSphere !== null ) {\r\n\t\r\n\t\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( geometry.boundingBox !== null ) {\r\n\t\r\n\t\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( object instanceof THREE.Mesh ) {\r\n\t\r\n\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\t\tthis.fromGeometry( geometry );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdateFromObject: function ( object ) {\r\n\t\r\n\t\t\tvar geometry = object.geometry;\r\n\t\r\n\t\t\tif ( object instanceof THREE.Mesh ) {\r\n\t\r\n\t\t\t\tvar direct = geometry.__directGeometry;\r\n\t\r\n\t\t\t\tif ( direct === undefined ) {\r\n\t\r\n\t\t\t\t\treturn this.fromGeometry( geometry );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\r\n\t\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\r\n\t\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\r\n\t\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\r\n\t\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\r\n\t\r\n\t\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\t\tgeometry.normalsNeedUpdate = false;\r\n\t\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\t\t\tgeometry.uvsNeedUpdate = false;\r\n\t\t\t\tgeometry.groupsNeedUpdate = false;\r\n\t\r\n\t\t\t\tgeometry = direct;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.verticesNeedUpdate === true ) {\r\n\t\r\n\t\t\t\tvar attribute = this.attributes.position;\r\n\t\r\n\t\t\t\tif ( attribute !== undefined ) {\r\n\t\r\n\t\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\r\n\t\t\t\t\tattribute.needsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.normalsNeedUpdate === true ) {\r\n\t\r\n\t\t\t\tvar attribute = this.attributes.normal;\r\n\t\r\n\t\t\t\tif ( attribute !== undefined ) {\r\n\t\r\n\t\t\t\t\tattribute.copyVector3sArray( geometry.normals );\r\n\t\t\t\t\tattribute.needsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.normalsNeedUpdate = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.colorsNeedUpdate === true ) {\r\n\t\r\n\t\t\t\tvar attribute = this.attributes.color;\r\n\t\r\n\t\t\t\tif ( attribute !== undefined ) {\r\n\t\r\n\t\t\t\t\tattribute.copyColorsArray( geometry.colors );\r\n\t\t\t\t\tattribute.needsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.uvsNeedUpdate ) {\r\n\t\r\n\t\t\t\tvar attribute = this.attributes.uv;\r\n\t\r\n\t\t\t\tif ( attribute !== undefined ) {\r\n\t\r\n\t\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\r\n\t\t\t\t\tattribute.needsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.uvsNeedUpdate = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.lineDistancesNeedUpdate ) {\r\n\t\r\n\t\t\t\tvar attribute = this.attributes.lineDistance;\r\n\t\r\n\t\t\t\tif ( attribute !== undefined ) {\r\n\t\r\n\t\t\t\t\tattribute.copyArray( geometry.lineDistances );\r\n\t\t\t\t\tattribute.needsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.lineDistancesNeedUpdate = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.groupsNeedUpdate ) {\r\n\t\r\n\t\t\t\tgeometry.computeGroups( object.geometry );\r\n\t\t\t\tthis.groups = geometry.groups;\r\n\t\r\n\t\t\t\tgeometry.groupsNeedUpdate = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromGeometry: function ( geometry ) {\r\n\t\r\n\t\t\tgeometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );\r\n\t\r\n\t\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromDirectGeometry: function ( geometry ) {\r\n\t\r\n\t\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\r\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\r\n\t\r\n\t\t\tif ( geometry.normals.length > 0 ) {\r\n\t\r\n\t\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\r\n\t\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.colors.length > 0 ) {\r\n\t\r\n\t\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\r\n\t\t\t\tthis.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.uvs.length > 0 ) {\r\n\t\r\n\t\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\r\n\t\t\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.uvs2.length > 0 ) {\r\n\t\r\n\t\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\r\n\t\t\t\tthis.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.indices.length > 0 ) {\r\n\t\r\n\t\t\t\tvar TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;\r\n\t\t\t\tvar indices = new TypeArray( geometry.indices.length * 3 );\r\n\t\t\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// groups\r\n\t\r\n\t\t\tthis.groups = geometry.groups;\r\n\t\r\n\t\t\t// morphs\r\n\t\r\n\t\t\tfor ( var name in geometry.morphTargets ) {\r\n\t\r\n\t\t\t\tvar array = [];\r\n\t\t\t\tvar morphTargets = geometry.morphTargets[ name ];\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar morphTarget = morphTargets[ i ];\r\n\t\r\n\t\t\t\t\tvar attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );\r\n\t\r\n\t\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.morphAttributes[ name ] = array;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// skinning\r\n\t\r\n\t\t\tif ( geometry.skinIndices.length > 0 ) {\r\n\t\r\n\t\t\t\tvar skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );\r\n\t\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.skinWeights.length > 0 ) {\r\n\t\r\n\t\t\t\tvar skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );\r\n\t\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tif ( geometry.boundingSphere !== null ) {\r\n\t\r\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.boundingBox !== null ) {\r\n\t\r\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeBoundingBox: function () {\r\n\t\r\n\t\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tif ( this.boundingBox === null ) {\r\n\t\r\n\t\t\t\t\tthis.boundingBox = new THREE.Box3();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar positions = this.attributes.position.array;\r\n\t\r\n\t\t\t\tif ( positions ) {\r\n\t\r\n\t\t\t\t\tthis.boundingBox.setFromArray( positions );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( positions === undefined || positions.length === 0 ) {\r\n\t\r\n\t\t\t\t\tthis.boundingBox.min.set( 0, 0, 0 );\r\n\t\t\t\t\tthis.boundingBox.max.set( 0, 0, 0 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\r\n\t\r\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tcomputeBoundingSphere: function () {\r\n\t\r\n\t\t\tvar box = new THREE.Box3();\r\n\t\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tif ( this.boundingSphere === null ) {\r\n\t\r\n\t\t\t\t\tthis.boundingSphere = new THREE.Sphere();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar positions = this.attributes.position.array;\r\n\t\r\n\t\t\t\tif ( positions ) {\r\n\t\r\n\t\t\t\t\tvar center = this.boundingSphere.center;\r\n\t\r\n\t\t\t\t\tbox.setFromArray( positions );\r\n\t\t\t\t\tbox.center( center );\r\n\t\r\n\t\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\r\n\t\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\r\n\t\r\n\t\t\t\t\tvar maxRadiusSq = 0;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\tvector.fromArray( positions, i );\r\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\r\n\t\r\n\t\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\r\n\t\r\n\t\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tcomputeFaceNormals: function () {\r\n\t\r\n\t\t\t// backwards compatibility\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeVertexNormals: function () {\r\n\t\r\n\t\t\tvar index = this.index;\r\n\t\t\tvar attributes = this.attributes;\r\n\t\t\tvar groups = this.groups;\r\n\t\r\n\t\t\tif ( attributes.position ) {\r\n\t\r\n\t\t\t\tvar positions = attributes.position.array;\r\n\t\r\n\t\t\t\tif ( attributes.normal === undefined ) {\r\n\t\r\n\t\t\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// reset existing normals to zero\r\n\t\r\n\t\t\t\t\tvar array = attributes.normal.array;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tarray[ i ] = 0;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar normals = attributes.normal.array;\r\n\t\r\n\t\t\t\tvar vA, vB, vC,\r\n\t\r\n\t\t\t\tpA = new THREE.Vector3(),\r\n\t\t\t\tpB = new THREE.Vector3(),\r\n\t\t\t\tpC = new THREE.Vector3(),\r\n\t\r\n\t\t\t\tcb = new THREE.Vector3(),\r\n\t\t\t\tab = new THREE.Vector3();\r\n\t\r\n\t\t\t\t// indexed elements\r\n\t\r\n\t\t\t\tif ( index ) {\r\n\t\r\n\t\t\t\t\tvar indices = index.array;\r\n\t\r\n\t\t\t\t\tif ( groups.length === 0 ) {\r\n\t\r\n\t\t\t\t\t\tthis.addGroup( 0, indices.length );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\r\n\t\r\n\t\t\t\t\t\tvar group = groups[ j ];\r\n\t\r\n\t\t\t\t\t\tvar start = group.start;\r\n\t\t\t\t\t\tvar count = group.count;\r\n\t\r\n\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\t\tvA = indices[ i + 0 ] * 3;\r\n\t\t\t\t\t\t\tvB = indices[ i + 1 ] * 3;\r\n\t\t\t\t\t\t\tvC = indices[ i + 2 ] * 3;\r\n\t\r\n\t\t\t\t\t\t\tpA.fromArray( positions, vA );\r\n\t\t\t\t\t\t\tpB.fromArray( positions, vB );\r\n\t\t\t\t\t\t\tpC.fromArray( positions, vC );\r\n\t\r\n\t\t\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\t\t\tcb.cross( ab );\r\n\t\r\n\t\t\t\t\t\t\tnormals[ vA ] += cb.x;\r\n\t\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\r\n\t\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\r\n\t\r\n\t\t\t\t\t\t\tnormals[ vB ] += cb.x;\r\n\t\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\r\n\t\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\r\n\t\r\n\t\t\t\t\t\t\tnormals[ vC ] += cb.x;\r\n\t\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\r\n\t\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// non-indexed elements (unconnected triangle soup)\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\r\n\t\r\n\t\t\t\t\t\tpA.fromArray( positions, i );\r\n\t\t\t\t\t\tpB.fromArray( positions, i + 3 );\r\n\t\t\t\t\t\tpC.fromArray( positions, i + 6 );\r\n\t\r\n\t\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\t\tcb.cross( ab );\r\n\t\r\n\t\t\t\t\t\tnormals[ i ] = cb.x;\r\n\t\t\t\t\t\tnormals[ i + 1 ] = cb.y;\r\n\t\t\t\t\t\tnormals[ i + 2 ] = cb.z;\r\n\t\r\n\t\t\t\t\t\tnormals[ i + 3 ] = cb.x;\r\n\t\t\t\t\t\tnormals[ i + 4 ] = cb.y;\r\n\t\t\t\t\t\tnormals[ i + 5 ] = cb.z;\r\n\t\r\n\t\t\t\t\t\tnormals[ i + 6 ] = cb.x;\r\n\t\t\t\t\t\tnormals[ i + 7 ] = cb.y;\r\n\t\t\t\t\t\tnormals[ i + 8 ] = cb.z;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.normalizeNormals();\r\n\t\r\n\t\t\t\tattributes.normal.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmerge: function ( geometry, offset ) {\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry === false ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tvar attributes = this.attributes;\r\n\t\r\n\t\t\tfor ( var key in attributes ) {\r\n\t\r\n\t\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\r\n\t\r\n\t\t\t\tvar attribute1 = attributes[ key ];\r\n\t\t\t\tvar attributeArray1 = attribute1.array;\r\n\t\r\n\t\t\t\tvar attribute2 = geometry.attributes[ key ];\r\n\t\t\t\tvar attributeArray2 = attribute2.array;\r\n\t\r\n\t\t\t\tvar attributeSize = attribute2.itemSize;\r\n\t\r\n\t\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\r\n\t\r\n\t\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalizeNormals: function () {\r\n\t\r\n\t\t\tvar normals = this.attributes.normal.array;\r\n\t\r\n\t\t\tvar x, y, z, n;\r\n\t\r\n\t\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\tx = normals[ i ];\r\n\t\t\t\ty = normals[ i + 1 ];\r\n\t\t\t\tz = normals[ i + 2 ];\r\n\t\r\n\t\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\r\n\t\r\n\t\t\t\tnormals[ i ] *= n;\r\n\t\t\t\tnormals[ i + 1 ] *= n;\r\n\t\t\t\tnormals[ i + 2 ] *= n;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoNonIndexed: function () {\r\n\t\r\n\t\t\tif ( this.index === null ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar geometry2 = new THREE.BufferGeometry();\r\n\t\r\n\t\t\tvar indices = this.index.array;\r\n\t\t\tvar attributes = this.attributes;\r\n\t\r\n\t\t\tfor ( var name in attributes ) {\r\n\t\r\n\t\t\t\tvar attribute = attributes[ name ];\r\n\t\r\n\t\t\t\tvar array = attribute.array;\r\n\t\t\t\tvar itemSize = attribute.itemSize;\r\n\t\r\n\t\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\r\n\t\r\n\t\t\t\tvar index = 0, index2 = 0;\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tindex = indices[ i ] * itemSize;\r\n\t\r\n\t\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry2.addAttribute( name, new THREE.BufferAttribute( array2, itemSize ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn geometry2;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function () {\r\n\t\r\n\t\t\tvar data = {\r\n\t\t\t\tmetadata: {\r\n\t\t\t\t\tversion: 4.4,\r\n\t\t\t\t\ttype: 'BufferGeometry',\r\n\t\t\t\t\tgenerator: 'BufferGeometry.toJSON'\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\r\n\t\t\t// standard BufferGeometry serialization\r\n\t\r\n\t\t\tdata.uuid = this.uuid;\r\n\t\t\tdata.type = this.type;\r\n\t\t\tif ( this.name !== '' ) data.name = this.name;\r\n\t\r\n\t\t\tif ( this.parameters !== undefined ) {\r\n\t\r\n\t\t\t\tvar parameters = this.parameters;\r\n\t\r\n\t\t\t\tfor ( var key in parameters ) {\r\n\t\r\n\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn data;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tdata.data = { attributes: {} };\r\n\t\r\n\t\t\tvar index = this.index;\r\n\t\r\n\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\tvar array = Array.prototype.slice.call( index.array );\r\n\t\r\n\t\t\t\tdata.data.index = {\r\n\t\t\t\t\ttype: index.array.constructor.name,\r\n\t\t\t\t\tarray: array\r\n\t\t\t\t};\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar attributes = this.attributes;\r\n\t\r\n\t\t\tfor ( var key in attributes ) {\r\n\t\r\n\t\t\t\tvar attribute = attributes[ key ];\r\n\t\r\n\t\t\t\tvar array = Array.prototype.slice.call( attribute.array );\r\n\t\r\n\t\t\t\tdata.data.attributes[ key ] = {\r\n\t\t\t\t\titemSize: attribute.itemSize,\r\n\t\t\t\t\ttype: attribute.array.constructor.name,\r\n\t\t\t\t\tarray: array\r\n\t\t\t\t};\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar groups = this.groups;\r\n\t\r\n\t\t\tif ( groups.length > 0 ) {\r\n\t\r\n\t\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar boundingSphere = this.boundingSphere;\r\n\t\r\n\t\t\tif ( boundingSphere !== null ) {\r\n\t\r\n\t\t\t\tdata.data.boundingSphere = {\r\n\t\t\t\t\tcenter: boundingSphere.center.toArray(),\r\n\t\t\t\t\tradius: boundingSphere.radius\r\n\t\t\t\t};\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn data;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\t/*\r\n\t\t\t// Handle primitives\r\n\t\r\n\t\t\tvar parameters = this.parameters;\r\n\t\r\n\t\t\tif ( parameters !== undefined ) {\r\n\t\r\n\t\t\t\tvar values = [];\r\n\t\r\n\t\t\t\tfor ( var key in parameters ) {\r\n\t\r\n\t\t\t\t\tvalues.push( parameters[ key ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\r\n\t\t\t\tthis.constructor.apply( geometry, values );\r\n\t\t\t\treturn geometry;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\t\t*/\r\n\t\r\n\t\t\treturn new THREE.BufferGeometry().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tvar index = source.index;\r\n\t\r\n\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\tthis.setIndex( index.clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar attributes = source.attributes;\r\n\t\r\n\t\t\tfor ( var name in attributes ) {\r\n\t\r\n\t\t\t\tvar attribute = attributes[ name ];\r\n\t\t\t\tthis.addAttribute( name, attribute.clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar groups = source.groups;\r\n\t\r\n\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar group = groups[ i ];\r\n\t\t\t\tthis.addGroup( group.start, group.count );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );\r\n\t\r\n\tTHREE.BufferGeometry.MaxIndex = 65535;\r\n\t\r\n\t// File:src/core/InstancedBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author benaadams / https://twitter.com/ben_a_adams\r\n\t */\r\n\t\r\n\tTHREE.InstancedBufferGeometry = function () {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'InstancedBufferGeometry';\r\n\t\tthis.maxInstancedCount = undefined;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;\r\n\t\r\n\tTHREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {\r\n\t\r\n\t\tthis.groups.push( {\r\n\t\r\n\t\t\tstart: start,\r\n\t\t\tcount: count,\r\n\t\t\tinstances: instances\r\n\t\r\n\t\t} );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.InstancedBufferGeometry.prototype.copy = function ( source ) {\r\n\t\r\n\t\tvar index = source.index;\r\n\t\r\n\t\tif ( index !== null ) {\r\n\t\r\n\t\t\tthis.setIndex( index.clone() );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar attributes = source.attributes;\r\n\t\r\n\t\tfor ( var name in attributes ) {\r\n\t\r\n\t\t\tvar attribute = attributes[ name ];\r\n\t\t\tthis.addAttribute( name, attribute.clone() );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar groups = source.groups;\r\n\t\r\n\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tvar group = groups[ i ];\r\n\t\t\tthis.addGroup( group.start, group.count, group.instances );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.InstancedBufferGeometry.prototype );\r\n\t\r\n\t// File:src/core/Uniform.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Uniform = function ( type, value ) {\r\n\t\r\n\t\tthis.type = type;\r\n\t\tthis.value = value;\r\n\t\r\n\t\tthis.dynamic = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Uniform.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Uniform,\r\n\t\r\n\t\tonUpdate: function ( callback ) {\r\n\t\r\n\t\t\tthis.dynamic = true;\r\n\t\t\tthis.onUpdateCallback = callback;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/animation/AnimationClip.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * Reusable set of Tracks that represent an animation.\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t */\r\n\t\r\n\tTHREE.AnimationClip = function ( name, duration, tracks ) {\r\n\t\r\n\t\tthis.name = name || THREE.Math.generateUUID();\r\n\t\tthis.tracks = tracks;\r\n\t\tthis.duration = ( duration !== undefined ) ? duration : -1;\r\n\t\r\n\t\t// this means it should figure out its duration by scanning the tracks\r\n\t\tif ( this.duration < 0 ) {\r\n\t\r\n\t\t\tthis.resetDuration();\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// maybe only do these on demand, as doing them here could potentially slow down loading\r\n\t\t// but leaving these here during development as this ensures a lot of testing of these functions\r\n\t\tthis.trim();\r\n\t\tthis.optimize();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AnimationClip.prototype = {\r\n\t\r\n\t\tconstructor: THREE.AnimationClip,\r\n\t\r\n\t\tresetDuration: function() {\r\n\t\r\n\t\t\tvar tracks = this.tracks,\r\n\t\t\t\tduration = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar track = this.tracks[ i ];\r\n\t\r\n\t\t\t\tduration = Math.max(\r\n\t\t\t\t\t\tduration, track.times[ track.times.length - 1 ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.duration = duration;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttrim: function() {\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\r\n\t\r\n\t\t\t\tthis.tracks[ i ].trim( 0, this.duration );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\toptimize: function() {\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\r\n\t\r\n\t\t\t\tthis.tracks[ i ].optimize();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// Static methods:\r\n\t\r\n\tObject.assign( THREE.AnimationClip, {\r\n\t\r\n\t\tparse: function( json ) {\r\n\t\r\n\t\t\tvar tracks = [],\r\n\t\t\t\tjsonTracks = json.tracks,\r\n\t\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\r\n\t\r\n\t\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\ttracks.push( THREE.KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn new THREE.AnimationClip( json.name, json.duration, tracks );\r\n\t\r\n\t\t},\r\n\t\r\n\t\r\n\t\ttoJSON: function( clip ) {\r\n\t\r\n\t\t\tvar tracks = [],\r\n\t\t\t\tclipTracks = clip.tracks;\r\n\t\r\n\t\t\tvar json = {\r\n\t\r\n\t\t\t\t'name': clip.name,\r\n\t\t\t\t'duration': clip.duration,\r\n\t\t\t\t'tracks': tracks\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\ttracks.push( THREE.KeyframeTrack.toJSON( clipTracks[ i ] ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn json;\r\n\t\r\n\t\t},\r\n\t\r\n\t\r\n\t\tCreateFromMorphTargetSequence: function( name, morphTargetSequence, fps ) {\r\n\t\r\n\t\t\tvar numMorphTargets = morphTargetSequence.length;\r\n\t\t\tvar tracks = [];\r\n\t\r\n\t\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\r\n\t\r\n\t\t\t\tvar times = [];\r\n\t\t\t\tvar values = [];\r\n\t\r\n\t\t\t\ttimes.push(\r\n\t\t\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\r\n\t\t\t\t\t\ti,\r\n\t\t\t\t\t\t( i + 1 ) % numMorphTargets );\r\n\t\r\n\t\t\t\tvalues.push( 0, 1, 0 );\r\n\t\r\n\t\t\t\tvar order = THREE.AnimationUtils.getKeyframeOrder( times );\r\n\t\t\t\ttimes = THREE.AnimationUtils.sortedArray( times, 1, order );\r\n\t\t\t\tvalues = THREE.AnimationUtils.sortedArray( values, 1, order );\r\n\t\r\n\t\t\t\t// if there is a key at the first frame, duplicate it as the\r\n\t\t\t\t// last frame as well for perfect loop.\r\n\t\t\t\tif ( times[ 0 ] === 0 ) {\r\n\t\r\n\t\t\t\t\ttimes.push( numMorphTargets );\r\n\t\t\t\t\tvalues.push( values[ 0 ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\ttracks.push(\r\n\t\t\t\t\t\tnew THREE.NumberKeyframeTrack(\r\n\t\t\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\r\n\t\t\t\t\t\t\ttimes, values\r\n\t\t\t\t\t\t).scale( 1.0 / fps ) );\r\n\t\t\t}\r\n\t\r\n\t\t\treturn new THREE.AnimationClip( name, -1, tracks );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfindByName: function( clipArray, name ) {\r\n\t\r\n\t\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\r\n\t\r\n\t\t\t\tif ( clipArray[ i ].name === name ) {\r\n\t\r\n\t\t\t\t\treturn clipArray[ i ];\r\n\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\treturn null;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tCreateClipsFromMorphTargetSequences: function( morphTargets, fps ) {\r\n\t\r\n\t\t\tvar animationToMorphTargets = {};\r\n\t\r\n\t\t\t// tested with https://regex101.com/ on trick sequences\r\n\t\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\r\n\t\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\r\n\t\r\n\t\t\t// sort morph target names into animation groups based\r\n\t\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\r\n\t\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar morphTarget = morphTargets[ i ];\r\n\t\t\t\tvar parts = morphTarget.name.match( pattern );\r\n\t\r\n\t\t\t\tif ( parts && parts.length > 1 ) {\r\n\t\r\n\t\t\t\t\tvar name = parts[ 1 ];\r\n\t\r\n\t\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\r\n\t\t\t\t\tif ( ! animationMorphTargets ) {\r\n\t\r\n\t\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tanimationMorphTargets.push( morphTarget );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar clips = [];\r\n\t\r\n\t\t\tfor ( var name in animationToMorphTargets ) {\r\n\t\r\n\t\t\t\tclips.push( THREE.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn clips;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// parse the animation.hierarchy format\r\n\t\tparseAnimation: function( animation, bones, nodeName ) {\r\n\t\r\n\t\t\tif ( ! animation ) {\r\n\t\r\n\t\t\t\tconsole.error( \"  no animation in JSONLoader data\" );\r\n\t\t\t\treturn null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar addNonemptyTrack = function(\r\n\t\t\t\t\ttrackType, trackName, animationKeys, propertyName, destTracks ) {\r\n\t\r\n\t\t\t\t// only return track if there are actually keys.\r\n\t\t\t\tif ( animationKeys.length !== 0 ) {\r\n\t\r\n\t\t\t\t\tvar times = [];\r\n\t\t\t\t\tvar values = [];\r\n\t\r\n\t\t\t\t\tTHREE.AnimationUtils.flattenJSON(\r\n\t\t\t\t\t\t\tanimationKeys, times, values, propertyName );\r\n\t\r\n\t\t\t\t\t// empty keys are filtered out, so check again\r\n\t\t\t\t\tif ( times.length !== 0 ) {\r\n\t\r\n\t\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tvar tracks = [];\r\n\t\r\n\t\t\tvar clipName = animation.name || 'default';\r\n\t\t\t// automatic length determination in AnimationClip.\r\n\t\t\tvar duration = animation.length || -1;\r\n\t\t\tvar fps = animation.fps || 30;\r\n\t\r\n\t\t\tvar hierarchyTracks = animation.hierarchy || [];\r\n\t\r\n\t\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\r\n\t\r\n\t\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\r\n\t\r\n\t\t\t\t// skip empty tracks\r\n\t\t\t\tif ( ! animationKeys || animationKeys.length == 0 ) continue;\r\n\t\r\n\t\t\t\t// process morph targets in a way exactly compatible\r\n\t\t\t\t// with AnimationHandler.init( animation )\r\n\t\t\t\tif ( animationKeys[0].morphTargets ) {\r\n\t\r\n\t\t\t\t\t// figure out all morph targets used in this track\r\n\t\t\t\t\tvar morphTargetNames = {};\r\n\t\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\r\n\t\r\n\t\t\t\t\t\tif ( animationKeys[k].morphTargets ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// create a track for each morph target with all zero\r\n\t\t\t\t\t// morphTargetInfluences except for the keys in which\r\n\t\t\t\t\t// the morphTarget is named.\r\n\t\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\r\n\t\r\n\t\t\t\t\t\tvar times = [];\r\n\t\t\t\t\t\tvar values = [];\r\n\t\r\n\t\t\t\t\t\tfor ( var m = 0;\r\n\t\t\t\t\t\t\t\tm !== animationKeys[k].morphTargets.length; ++ m ) {\r\n\t\r\n\t\t\t\t\t\t\tvar animationKey = animationKeys[k];\r\n\t\r\n\t\t\t\t\t\t\ttimes.push( animationKey.time );\r\n\t\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 )\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\ttracks.push( new THREE.NumberKeyframeTrack(\r\n\t\t\t\t\t\t\t\t'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// ...assume skeletal animation\r\n\t\r\n\t\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\r\n\t\r\n\t\t\t\t\taddNonemptyTrack(\r\n\t\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.position',\r\n\t\t\t\t\t\t\tanimationKeys, 'pos', tracks );\r\n\t\r\n\t\t\t\t\taddNonemptyTrack(\r\n\t\t\t\t\t\t\tTHREE.QuaternionKeyframeTrack, boneName + '.quaternion',\r\n\t\t\t\t\t\t\tanimationKeys, 'rot', tracks );\r\n\t\r\n\t\t\t\t\taddNonemptyTrack(\r\n\t\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.scale',\r\n\t\t\t\t\t\t\tanimationKeys, 'scl', tracks );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( tracks.length === 0 ) {\r\n\t\r\n\t\t\t\treturn null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar clip = new THREE.AnimationClip( clipName, duration, tracks );\r\n\t\r\n\t\t\treturn clip;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t\r\n\t// File:src/animation/AnimationMixer.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * Player for AnimationClips.\r\n\t *\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.AnimationMixer = function( root ) {\r\n\t\r\n\t\tthis._root = root;\r\n\t\tthis._initMemoryManager();\r\n\t\tthis._accuIndex = 0;\r\n\t\r\n\t\tthis.time = 0;\r\n\t\r\n\t\tthis.timeScale = 1.0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AnimationMixer.prototype = {\r\n\t\r\n\t\tconstructor: THREE.AnimationMixer,\r\n\t\r\n\t\t// return an action for a clip optionally using a custom root target\r\n\t\t// object (this method allocates a lot of dynamic memory in case a\r\n\t\t// previously unknown clip/root combination is specified)\r\n\t\tclipAction: function( clip, optionalRoot ) {\r\n\t\r\n\t\t\tvar root = optionalRoot || this._root,\r\n\t\t\t\trootUuid = root.uuid,\r\n\t\t\t\tclipName = ( typeof clip === 'string' ) ? clip : clip.name,\r\n\t\t\t\tclipObject = ( clip !== clipName ) ? clip : null,\r\n\t\r\n\t\t\t\tactionsForClip = this._actionsByClip[ clipName ],\r\n\t\t\t\tprototypeAction;\r\n\t\r\n\t\t\tif ( actionsForClip !== undefined ) {\r\n\t\r\n\t\t\t\tvar existingAction =\r\n\t\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\r\n\t\r\n\t\t\t\tif ( existingAction !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn existingAction;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// we know the clip, so we don't have to parse all\r\n\t\t\t\t// the bindings again but can just copy\r\n\t\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\r\n\t\r\n\t\t\t\t// also, take the clip from the prototype action\r\n\t\t\t\tclipObject = prototypeAction._clip;\r\n\t\r\n\t\t\t\tif ( clip !== clipName && clip !== clipObject ) {\r\n\t\r\n\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t\t\"Different clips with the same name detected!\" );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// clip must be known when specified via string\r\n\t\t\tif ( clipObject === null ) return null;\r\n\t\r\n\t\t\t// allocate all resources required to run it\r\n\t\t\tvar newAction = new THREE.\r\n\t\t\t\t\tAnimationMixer._Action( this, clipObject, optionalRoot );\r\n\t\r\n\t\t\tthis._bindAction( newAction, prototypeAction );\r\n\t\r\n\t\t\t// and make the action known to the memory manager\r\n\t\t\tthis._addInactiveAction( newAction, clipName, rootUuid );\r\n\t\r\n\t\t\treturn newAction;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// get an existing action\r\n\t\texistingAction: function( clip, optionalRoot ) {\r\n\t\r\n\t\t\tvar root = optionalRoot || this._root,\r\n\t\t\t\trootUuid = root.uuid,\r\n\t\t\t\tclipName = ( typeof clip === 'string' ) ? clip : clip.name,\r\n\t\t\t\tactionsForClip = this._actionsByClip[ clipName ];\r\n\t\r\n\t\t\tif ( actionsForClip !== undefined ) {\r\n\t\r\n\t\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn null;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// deactivates all previously scheduled actions\r\n\t\tstopAllAction: function() {\r\n\t\r\n\t\t\tvar actions = this._actions,\r\n\t\t\t\tnActions = this._nActiveActions,\r\n\t\t\t\tbindings = this._bindings,\r\n\t\t\t\tnBindings = this._nActiveBindings;\r\n\t\r\n\t\t\tthis._nActiveActions = 0;\r\n\t\t\tthis._nActiveBindings = 0;\r\n\t\r\n\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\r\n\t\r\n\t\t\t\tactions[ i ].reset();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\r\n\t\r\n\t\t\t\tbindings[ i ].useCount = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// advance the time and update apply the animation\r\n\t\tupdate: function( deltaTime ) {\r\n\t\r\n\t\t\tdeltaTime *= this.timeScale;\r\n\t\r\n\t\t\tvar actions = this._actions,\r\n\t\t\t\tnActions = this._nActiveActions,\r\n\t\r\n\t\t\t\ttime = this.time += deltaTime,\r\n\t\t\t\ttimeDirection = Math.sign( deltaTime ),\r\n\t\r\n\t\t\t\taccuIndex = this._accuIndex ^= 1;\r\n\t\r\n\t\t\t// run active actions\r\n\t\r\n\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\r\n\t\r\n\t\t\t\tvar action = actions[ i ];\r\n\t\r\n\t\t\t\tif ( action.enabled ) {\r\n\t\r\n\t\t\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// update scene graph\r\n\t\r\n\t\t\tvar bindings = this._bindings,\r\n\t\t\t\tnBindings = this._nActiveBindings;\r\n\t\r\n\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\r\n\t\r\n\t\t\t\tbindings[ i ].apply( accuIndex );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// return this mixer's root target object\r\n\t\tgetRoot: function() {\r\n\t\r\n\t\t\treturn this._root;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// free all resources specific to a particular clip\r\n\t\tuncacheClip: function( clip ) {\r\n\t\r\n\t\t\tvar actions = this._actions,\r\n\t\t\t\tclipName = clip.name,\r\n\t\t\t\tactionsByClip = this._actionsByClip,\r\n\t\t\t\tactionsForClip = actionsByClip[ clipName ];\r\n\t\r\n\t\t\tif ( actionsForClip !== undefined ) {\r\n\t\r\n\t\t\t\t// note: just calling _removeInactiveAction would mess up the\r\n\t\t\t\t// iteration state and also require updating the state we can\r\n\t\t\t\t// just throw away\r\n\t\r\n\t\t\t\tvar actionsToRemove = actionsForClip.knownActions;\r\n\t\r\n\t\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\tvar action = actionsToRemove[ i ];\r\n\t\r\n\t\t\t\t\tthis._deactivateAction( action );\r\n\t\r\n\t\t\t\t\tvar cacheIndex = action._cacheIndex,\r\n\t\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\r\n\t\r\n\t\t\t\t\taction._cacheIndex = null;\r\n\t\t\t\t\taction._byClipCacheIndex = null;\r\n\t\r\n\t\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\r\n\t\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\r\n\t\t\t\t\tactions.pop();\r\n\t\r\n\t\t\t\t\tthis._removeInactiveBindingsForAction( action );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tdelete actionsByClip[ clipName ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// free all resources specific to a particular root target object\r\n\t\tuncacheRoot: function( root ) {\r\n\t\r\n\t\t\tvar rootUuid = root.uuid,\r\n\t\t\t\tactionsByClip = this._actionsByClip;\r\n\t\r\n\t\t\tfor ( var clipName in actionsByClip ) {\r\n\t\r\n\t\t\t\tvar actionByRoot = actionsByClip[ clipName ].actionByRoot,\r\n\t\t\t\t\taction = actionByRoot[ rootUuid ];\r\n\t\r\n\t\t\t\tif ( action !== undefined ) {\r\n\t\r\n\t\t\t\t\tthis._deactivateAction( action );\r\n\t\t\t\t\tthis._removeInactiveAction( action );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\r\n\t\r\n\t\t\tif ( bindingByName !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var trackName in bindingByName ) {\r\n\t\r\n\t\t\t\t\tvar binding = bindingByName[ trackName ];\r\n\t\t\t\t\tbinding.restoreOriginalState();\r\n\t\t\t\t\tthis._removeInactiveBinding( binding );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// remove a targeted clip from the cache\r\n\t\tuncacheAction: function( clip, optionalRoot ) {\r\n\t\r\n\t\t\tvar action = this.existingAction( clip, optionalRoot );\r\n\t\r\n\t\t\tif ( action !== null ) {\r\n\t\r\n\t\t\t\tthis._deactivateAction( action );\r\n\t\t\t\tthis._removeInactiveAction( action );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.AnimationMixer.prototype );\r\n\t\r\n\tTHREE.AnimationMixer._Action =\r\n\t\t\tfunction( mixer, clip, localRoot ) {\r\n\t\r\n\t\tthis._mixer = mixer;\r\n\t\tthis._clip = clip;\r\n\t\tthis._localRoot = localRoot || null;\r\n\t\r\n\t\tvar tracks = clip.tracks,\r\n\t\t\tnTracks = tracks.length,\r\n\t\t\tinterpolants = new Array( nTracks );\r\n\t\r\n\t\tvar interpolantSettings = {\r\n\t\t\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\r\n\t\t\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\r\n\t\t};\r\n\t\r\n\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\r\n\t\r\n\t\t\tvar interpolant = tracks[ i ].createInterpolant( null );\r\n\t\t\tinterpolants[ i ] = interpolant;\r\n\t\t\tinterpolant.settings = interpolantSettings\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis._interpolantSettings = interpolantSettings;\r\n\t\r\n\t\tthis._interpolants = interpolants;\t// bound by the mixer\r\n\t\r\n\t\t// inside: PropertyMixer (managed by the mixer)\r\n\t\tthis._propertyBindings = new Array( nTracks );\r\n\t\r\n\t\tthis._cacheIndex = null;\t\t\t// for the memory manager\r\n\t\tthis._byClipCacheIndex = null;\t\t// for the memory manager\r\n\t\r\n\t\tthis._timeScaleInterpolant = null;\r\n\t\tthis._weightInterpolant = null;\r\n\t\r\n\t\tthis.loop = THREE.LoopRepeat;\r\n\t\tthis._loopCount = -1;\r\n\t\r\n\t\t// global mixer time when the action is to be started\r\n\t\t// it's set back to 'null' upon start of the action\r\n\t\tthis._startTime = null;\r\n\t\r\n\t\t// scaled local time of the action\r\n\t\t// gets clamped or wrapped to 0..clip.duration according to loop\r\n\t\tthis.time = 0;\r\n\t\r\n\t\tthis.timeScale = 1;\r\n\t\tthis._effectiveTimeScale = 1;\r\n\t\r\n\t\tthis.weight = 1;\r\n\t\tthis._effectiveWeight = 1;\r\n\t\r\n\t\tthis.repetitions = Infinity; \t\t// no. of repetitions when looping\r\n\t\r\n\t\tthis.paused = false;\t\t\t\t// false -> zero effective time scale\r\n\t\tthis.enabled = true;\t\t\t\t// true -> zero effective weight\r\n\t\r\n\t\tthis.clampWhenFinished \t= false;\t// keep feeding the last frame?\r\n\t\r\n\t\tthis.zeroSlopeAtStart \t= true;\t\t// for smooth interpolation w/o separate\r\n\t\tthis.zeroSlopeAtEnd\t\t= true;\t\t// clips for start, loop and end\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AnimationMixer._Action.prototype = {\r\n\t\r\n\t\tconstructor: THREE.AnimationMixer._Action,\r\n\t\r\n\t\t// State & Scheduling\r\n\t\r\n\t\tplay: function() {\r\n\t\r\n\t\t\tthis._mixer._activateAction( this );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tstop: function() {\r\n\t\r\n\t\t\tthis._mixer._deactivateAction( this );\r\n\t\r\n\t\t\treturn this.reset();\r\n\t\r\n\t\t},\r\n\t\r\n\t\treset: function() {\r\n\t\r\n\t\t\tthis.paused = false;\r\n\t\t\tthis.enabled = true;\r\n\t\r\n\t\t\tthis.time = 0;\t\t\t// restart clip\r\n\t\t\tthis._loopCount = -1;\t// forget previous loops\r\n\t\t\tthis._startTime = null;\t// forget scheduling\r\n\t\r\n\t\t\treturn this.stopFading().stopWarping();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tisRunning: function() {\r\n\t\r\n\t\t\tvar start = this._startTime;\r\n\t\r\n\t\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\r\n\t\t\t\t\tthis._startTime === null && this._mixer._isActiveAction( this )\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// return true when play has been called\r\n\t\tisScheduled: function() {\r\n\t\r\n\t\t\treturn this._mixer._isActiveAction( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tstartAt: function( time ) {\r\n\t\r\n\t\t\tthis._startTime = time;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetLoop: function( mode, repetitions ) {\r\n\t\r\n\t\t\tthis.loop = mode;\r\n\t\t\tthis.repetitions = repetitions;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Weight\r\n\t\r\n\t\t// set the weight stopping any scheduled fading\r\n\t\t// although .enabled = false yields an effective weight of zero, this\r\n\t\t// method does *not* change .enabled, because it would be confusing\r\n\t\tsetEffectiveWeight: function( weight ) {\r\n\t\r\n\t\t\tthis.weight = weight;\r\n\t\r\n\t\t\t// note: same logic as when updated at runtime\r\n\t\t\tthis._effectiveWeight = this.enabled ? weight : 0;\r\n\t\r\n\t\t\treturn this.stopFading();\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// return the weight considering fading and .enabled\r\n\t\tgetEffectiveWeight: function() {\r\n\t\r\n\t\t\treturn this._effectiveWeight;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfadeIn: function( duration ) {\r\n\t\r\n\t\t\treturn this._scheduleFading( duration, 0, 1 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfadeOut: function( duration ) {\r\n\t\r\n\t\t\treturn this._scheduleFading( duration, 1, 0 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcrossFadeFrom: function( fadeOutAction, duration, warp ) {\r\n\t\r\n\t\t\tvar mixer = this._mixer;\r\n\t\r\n\t\t\tfadeOutAction.fadeOut( duration );\r\n\t\t\tthis.fadeIn( duration );\r\n\t\r\n\t\t\tif( warp ) {\r\n\t\r\n\t\t\t\tvar fadeInDuration = this._clip.duration,\r\n\t\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\r\n\t\r\n\t\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\r\n\t\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\r\n\t\r\n\t\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\r\n\t\t\t\tthis.warp( endStartRatio, 1.0, duration );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcrossFadeTo: function( fadeInAction, duration, warp ) {\r\n\t\r\n\t\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tstopFading: function() {\r\n\t\r\n\t\t\tvar weightInterpolant = this._weightInterpolant;\r\n\t\r\n\t\t\tif ( weightInterpolant !== null ) {\r\n\t\r\n\t\t\t\tthis._weightInterpolant = null;\r\n\t\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Time Scale Control\r\n\t\r\n\t\t// set the weight stopping any scheduled warping\r\n\t\t// although .paused = true yields an effective time scale of zero, this\r\n\t\t// method does *not* change .paused, because it would be confusing\r\n\t\tsetEffectiveTimeScale: function( timeScale ) {\r\n\t\r\n\t\t\tthis.timeScale = timeScale;\r\n\t\t\tthis._effectiveTimeScale = this.paused ? 0 :timeScale;\r\n\t\r\n\t\t\treturn this.stopWarping();\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// return the time scale considering warping and .paused\r\n\t\tgetEffectiveTimeScale: function() {\r\n\t\r\n\t\t\treturn this._effectiveTimeScale;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetDuration: function( duration ) {\r\n\t\r\n\t\t\tthis.timeScale = this._clip.duration / duration;\r\n\t\r\n\t\t\treturn this.stopWarping();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsyncWith: function( action ) {\r\n\t\r\n\t\t\tthis.time = action.time;\r\n\t\t\tthis.timeScale = action.timeScale;\r\n\t\r\n\t\t\treturn this.stopWarping();\r\n\t\r\n\t\t},\r\n\t\r\n\t\thalt: function( duration ) {\r\n\t\r\n\t\t\treturn this.warp( this._currentTimeScale, 0, duration );\r\n\t\r\n\t\t},\r\n\t\r\n\t\twarp: function( startTimeScale, endTimeScale, duration ) {\r\n\t\r\n\t\t\tvar mixer = this._mixer, now = mixer.time,\r\n\t\t\t\tinterpolant = this._timeScaleInterpolant,\r\n\t\r\n\t\t\t\ttimeScale = this.timeScale;\r\n\t\r\n\t\t\tif ( interpolant === null ) {\r\n\t\r\n\t\t\t\tinterpolant = mixer._lendControlInterpolant(),\r\n\t\t\t\tthis._timeScaleInterpolant = interpolant;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar times = interpolant.parameterPositions,\r\n\t\t\t\tvalues = interpolant.sampleValues;\r\n\t\r\n\t\t\ttimes[ 0 ] = now;\r\n\t\t\ttimes[ 1 ] = now + duration;\r\n\t\r\n\t\t\tvalues[ 0 ] = startTimeScale / timeScale;\r\n\t\t\tvalues[ 1 ] = endTimeScale / timeScale;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tstopWarping: function() {\r\n\t\r\n\t\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\r\n\t\r\n\t\t\tif ( timeScaleInterpolant !== null ) {\r\n\t\r\n\t\t\t\tthis._timeScaleInterpolant = null;\r\n\t\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Object Accessors\r\n\t\r\n\t\tgetMixer: function() {\r\n\t\r\n\t\t\treturn this._mixer;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetClip: function() {\r\n\t\r\n\t\t\treturn this._clip;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetRoot: function() {\r\n\t\r\n\t\t\treturn this._localRoot || this._mixer._root;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Interna\r\n\t\r\n\t\t_update: function( time, deltaTime, timeDirection, accuIndex ) {\r\n\t\t\t// called by the mixer\r\n\t\r\n\t\t\tvar startTime = this._startTime;\r\n\t\r\n\t\t\tif ( startTime !== null ) {\r\n\t\r\n\t\t\t\t// check for scheduled start of action\r\n\t\r\n\t\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\r\n\t\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\r\n\t\r\n\t\t\t\t\treturn; // yet to come / don't decide when delta = 0\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// start\r\n\t\r\n\t\t\t\tthis._startTime = null; // unschedule\r\n\t\t\t\tdeltaTime = timeDirection * timeRunning;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// apply time scale and advance time\r\n\t\r\n\t\t\tdeltaTime *= this._updateTimeScale( time );\r\n\t\t\tvar clipTime = this._updateTime( deltaTime );\r\n\t\r\n\t\t\t// note: _updateTime may disable the action resulting in\r\n\t\t\t// an effective weight of 0\r\n\t\r\n\t\t\tvar weight = this._updateWeight( time );\r\n\t\r\n\t\t\tif ( weight > 0 ) {\r\n\t\r\n\t\t\t\tvar interpolants = this._interpolants;\r\n\t\t\t\tvar propertyMixers = this._propertyBindings;\r\n\t\r\n\t\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\r\n\t\r\n\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\r\n\t\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_updateWeight: function( time ) {\r\n\t\r\n\t\t\tvar weight = 0;\r\n\t\r\n\t\t\tif ( this.enabled ) {\r\n\t\r\n\t\t\t\tweight = this.weight;\r\n\t\t\t\tvar interpolant = this._weightInterpolant;\r\n\t\r\n\t\t\t\tif ( interpolant !== null ) {\r\n\t\r\n\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\r\n\t\r\n\t\t\t\t\tweight *= interpolantValue;\r\n\t\r\n\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\r\n\t\r\n\t\t\t\t\t\tthis.stopFading();\r\n\t\r\n\t\t\t\t\t\tif ( interpolantValue === 0 ) {\r\n\t\r\n\t\t\t\t\t\t\t// faded out, disable\r\n\t\t\t\t\t\t\tthis.enabled = false;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._effectiveWeight = weight;\r\n\t\t\treturn weight;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_updateTimeScale: function( time ) {\r\n\t\r\n\t\t\tvar timeScale = 0;\r\n\t\r\n\t\t\tif ( ! this.paused ) {\r\n\t\r\n\t\t\t\ttimeScale = this.timeScale;\r\n\t\r\n\t\t\t\tvar interpolant = this._timeScaleInterpolant;\r\n\t\r\n\t\t\t\tif ( interpolant !== null ) {\r\n\t\r\n\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\r\n\t\r\n\t\t\t\t\ttimeScale *= interpolantValue;\r\n\t\r\n\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\r\n\t\r\n\t\t\t\t\t\tthis.stopWarping();\r\n\t\r\n\t\t\t\t\t\tif ( timeScale === 0 ) {\r\n\t\r\n\t\t\t\t\t\t\t// motion has halted, pause\r\n\t\t\t\t\t\t\tthis.pause = true;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t// warp done - apply final time scale\r\n\t\t\t\t\t\t\tthis.timeScale = timeScale;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._effectiveTimeScale = timeScale;\r\n\t\t\treturn timeScale;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_updateTime: function( deltaTime ) {\r\n\t\r\n\t\t\tvar time = this.time + deltaTime;\r\n\t\r\n\t\t\tif ( deltaTime === 0 ) return time;\r\n\t\r\n\t\t\tvar duration = this._clip.duration,\r\n\t\r\n\t\t\t\tloop = this.loop,\r\n\t\t\t\tloopCount = this._loopCount,\r\n\t\r\n\t\t\t\tpingPong = false;\r\n\t\r\n\t\t\tswitch ( loop ) {\r\n\t\r\n\t\t\t\tcase THREE.LoopOnce:\r\n\t\r\n\t\t\t\t\tif ( loopCount === -1 ) {\r\n\t\r\n\t\t\t\t\t\t// just started\r\n\t\r\n\t\t\t\t\t\tthis.loopCount = 0;\r\n\t\t\t\t\t\tthis._setEndings( true, true, false );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( time >= duration ) {\r\n\t\r\n\t\t\t\t\t\ttime = duration;\r\n\t\r\n\t\t\t\t\t} else if ( time < 0 ) {\r\n\t\r\n\t\t\t\t\t\ttime = 0;\r\n\t\r\n\t\t\t\t\t} else break;\r\n\t\r\n\t\t\t\t\t// reached the end\r\n\t\r\n\t\t\t\t\tif ( this.clampWhenFinished ) this.pause = true;\r\n\t\t\t\t\telse this.enabled = false;\r\n\t\r\n\t\t\t\t\tthis._mixer.dispatchEvent( {\r\n\t\t\t\t\t\ttype: 'finished', action: this,\r\n\t\t\t\t\t\tdirection: deltaTime < 0 ? -1 : 1\r\n\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase THREE.LoopPingPong:\r\n\t\r\n\t\t\t\t\tpingPong = true;\r\n\t\r\n\t\t\t\tcase THREE.LoopRepeat:\r\n\t\r\n\t\t\t\t\tif ( loopCount === -1 ) {\r\n\t\r\n\t\t\t\t\t\t// just started\r\n\t\r\n\t\t\t\t\t\tif ( deltaTime > 0 ) {\r\n\t\r\n\t\t\t\t\t\t\tloopCount = 0;\r\n\t\r\n\t\t\t\t\t\t\tthis._setEndings(\r\n\t\t\t\t\t\t\t\t\ttrue, this.repetitions === 0, pingPong );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t// when looping in reverse direction, the initial\r\n\t\t\t\t\t\t\t// transition through zero counts as a repetition,\r\n\t\t\t\t\t\t\t// so leave loopCount at -1\r\n\t\r\n\t\t\t\t\t\t\tthis._setEndings(\r\n\t\t\t\t\t\t\t\t\tthis.repetitions === 0, true, pingPong );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( time >= duration || time < 0 ) {\r\n\t\r\n\t\t\t\t\t\t// wrap around\r\n\t\r\n\t\t\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\r\n\t\t\t\t\t\ttime -= duration * loopDelta;\r\n\t\r\n\t\t\t\t\t\tloopCount += Math.abs( loopDelta );\r\n\t\r\n\t\t\t\t\t\tvar pending = this.repetitions - loopCount;\r\n\t\r\n\t\t\t\t\t\tif ( pending < 0 ) {\r\n\t\r\n\t\t\t\t\t\t\t// stop (switch state, clamp time, fire event)\r\n\t\r\n\t\t\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\r\n\t\t\t\t\t\t\telse this.enabled = false;\r\n\t\r\n\t\t\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\r\n\t\r\n\t\t\t\t\t\t\tthis._mixer.dispatchEvent( {\r\n\t\t\t\t\t\t\t\ttype: 'finished', action: this,\r\n\t\t\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : -1\r\n\t\t\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t} else if ( pending === 0 ) {\r\n\t\r\n\t\t\t\t\t\t\t// transition to last round\r\n\t\r\n\t\t\t\t\t\t\tvar atStart = deltaTime < 0;\r\n\t\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tthis._loopCount = loopCount;\r\n\t\r\n\t\t\t\t\t\tthis._mixer.dispatchEvent( {\r\n\t\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\r\n\t\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( loop === THREE.LoopPingPong && ( loopCount & 1 ) === 1 ) {\r\n\t\r\n\t\t\t\t\t\t// invert time for the \"pong round\"\r\n\t\r\n\t\t\t\t\t\tthis.time = time;\r\n\t\r\n\t\t\t\t\t\treturn duration - time;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.time = time;\r\n\t\r\n\t\t\treturn time;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_setEndings: function( atStart, atEnd, pingPong ) {\r\n\t\r\n\t\t\tvar settings = this._interpolantSettings;\r\n\t\r\n\t\t\tif ( pingPong ) {\r\n\t\r\n\t\t\t\tsettings.endingStart \t= THREE.ZeroSlopeEnding;\r\n\t\t\t\tsettings.endingEnd\t\t= THREE.ZeroSlopeEnding;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// assuming for LoopOnce atStart == atEnd == true\r\n\t\r\n\t\t\t\tif ( atStart ) {\r\n\t\r\n\t\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ?\r\n\t\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tsettings.endingStart = THREE.WrapAroundEnding;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( atEnd ) {\r\n\t\r\n\t\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ?\r\n\t\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tsettings.endingEnd \t = THREE.WrapAroundEnding;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_scheduleFading: function( duration, weightNow, weightThen ) {\r\n\t\r\n\t\t\tvar mixer = this._mixer, now = mixer.time,\r\n\t\t\t\tinterpolant = this._weightInterpolant;\r\n\t\r\n\t\t\tif ( interpolant === null ) {\r\n\t\r\n\t\t\t\tinterpolant = mixer._lendControlInterpolant(),\r\n\t\t\t\tthis._weightInterpolant = interpolant;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar times = interpolant.parameterPositions,\r\n\t\t\t\tvalues = interpolant.sampleValues;\r\n\t\r\n\t\t\ttimes[ 0 ] = now; \t\t\t\tvalues[ 0 ] = weightNow;\r\n\t\t\ttimes[ 1 ] = now + duration;\tvalues[ 1 ] = weightThen;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// Implementation details:\r\n\t\r\n\tObject.assign( THREE.AnimationMixer.prototype, {\r\n\t\r\n\t\t_bindAction: function( action, prototypeAction ) {\r\n\t\r\n\t\t\tvar root = action._localRoot || this._root,\r\n\t\t\t\ttracks = action._clip.tracks,\r\n\t\t\t\tnTracks = tracks.length,\r\n\t\t\t\tbindings = action._propertyBindings,\r\n\t\t\t\tinterpolants = action._interpolants,\r\n\t\t\t\trootUuid = root.uuid,\r\n\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\r\n\t\r\n\t\t\tif ( bindingsByName === undefined ) {\r\n\t\r\n\t\t\t\tbindingsByName = {};\r\n\t\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\r\n\t\r\n\t\t\t\tvar track = tracks[ i ],\r\n\t\t\t\t\ttrackName = track.name,\r\n\t\t\t\t\tbinding = bindingsByName[ trackName ];\r\n\t\r\n\t\t\t\tif ( binding !== undefined ) {\r\n\t\r\n\t\t\t\t\tbindings[ i ] = binding;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tbinding = bindings[ i ];\r\n\t\r\n\t\t\t\t\tif ( binding !== undefined ) {\r\n\t\r\n\t\t\t\t\t\t// existing binding, make sure the cache knows\r\n\t\r\n\t\t\t\t\t\tif ( binding._cacheIndex === null ) {\r\n\t\r\n\t\t\t\t\t\t\t++ binding.referenceCount;\r\n\t\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tcontinue;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar path = prototypeAction && prototypeAction.\r\n\t\t\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\r\n\t\r\n\t\t\t\t\tbinding = new THREE.PropertyMixer(\r\n\t\t\t\t\t\t\tTHREE.PropertyBinding.create( root, trackName, path ),\r\n\t\t\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\r\n\t\r\n\t\t\t\t\t++ binding.referenceCount;\r\n\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\r\n\t\r\n\t\t\t\t\tbindings[ i ] = binding;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_activateAction: function( action ) {\r\n\t\r\n\t\t\tif ( ! this._isActiveAction( action ) ) {\r\n\t\r\n\t\t\t\tif ( action._cacheIndex === null ) {\r\n\t\r\n\t\t\t\t\t// this action has been forgotten by the cache, but the user\r\n\t\t\t\t\t// appears to be still using it -> rebind\r\n\t\r\n\t\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\r\n\t\t\t\t\t\tclipName = action._clip.name,\r\n\t\t\t\t\t\tactionsForClip = this._actionsByClip[ clipName ];\r\n\t\r\n\t\t\t\t\tthis._bindAction( action,\r\n\t\t\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\r\n\t\r\n\t\t\t\t\tthis._addInactiveAction( action, clipName, rootUuid );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar bindings = action._propertyBindings;\r\n\t\r\n\t\t\t\t// increment reference counts / sort out state\r\n\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\tvar binding = bindings[ i ];\r\n\t\r\n\t\t\t\t\tif ( binding.useCount ++ === 0 ) {\r\n\t\r\n\t\t\t\t\t\tthis._lendBinding( binding );\r\n\t\t\t\t\t\tbinding.saveOriginalState();\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis._lendAction( action );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_deactivateAction: function( action ) {\r\n\t\r\n\t\t\tif ( this._isActiveAction( action ) ) {\r\n\t\r\n\t\t\t\tvar bindings = action._propertyBindings;\r\n\t\r\n\t\t\t\t// decrement reference counts / sort out state\r\n\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\tvar binding = bindings[ i ];\r\n\t\r\n\t\t\t\t\tif ( -- binding.useCount === 0 ) {\r\n\t\r\n\t\t\t\t\t\tbinding.restoreOriginalState();\r\n\t\t\t\t\t\tthis._takeBackBinding( binding );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis._takeBackAction( action );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Memory manager\r\n\t\r\n\t\t_initMemoryManager: function() {\r\n\t\r\n\t\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\r\n\t\t\tthis._nActiveActions = 0;\r\n\t\r\n\t\t\tthis._actionsByClip = {};\r\n\t\t\t// inside:\r\n\t\t\t// {\r\n\t\t\t// \t\tknownActions: Array< _Action >\t- used as prototypes\r\n\t\t\t// \t\tactionByRoot: _Action\t\t\t- lookup\r\n\t\t\t// }\r\n\t\r\n\t\r\n\t\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\r\n\t\t\tthis._nActiveBindings = 0;\r\n\t\r\n\t\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\r\n\t\r\n\t\r\n\t\t\tthis._controlInterpolants = []; // same game as above\r\n\t\t\tthis._nActiveControlInterpolants = 0;\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tthis.stats = {\r\n\t\r\n\t\t\t\tactions: {\r\n\t\t\t\t\tget total() { return scope._actions.length; },\r\n\t\t\t\t\tget inUse() { return scope._nActiveActions; }\r\n\t\t\t\t},\r\n\t\t\t\tbindings: {\r\n\t\t\t\t\tget total() { return scope._bindings.length; },\r\n\t\t\t\t\tget inUse() { return scope._nActiveBindings; }\r\n\t\t\t\t},\r\n\t\t\t\tcontrolInterpolants: {\r\n\t\t\t\t\tget total() { return scope._controlInterpolants.length; },\r\n\t\t\t\t\tget inUse() { return scope._nActiveControlInterpolants; }\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Memory management for _Action objects\r\n\t\r\n\t\t_isActiveAction: function( action ) {\r\n\t\r\n\t\t\tvar index = action._cacheIndex;\r\n\t\t\treturn index !== null && index < this._nActiveActions;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_addInactiveAction: function( action, clipName, rootUuid ) {\r\n\t\r\n\t\t\tvar actions = this._actions,\r\n\t\t\t\tactionsByClip = this._actionsByClip,\r\n\t\t\t\tactionsForClip = actionsByClip[ clipName ];\r\n\t\r\n\t\t\tif ( actionsForClip === undefined ) {\r\n\t\r\n\t\t\t\tactionsForClip = {\r\n\t\r\n\t\t\t\t\tknownActions: [ action ],\r\n\t\t\t\t\tactionByRoot: {}\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t\taction._byClipCacheIndex = 0;\r\n\t\r\n\t\t\t\tactionsByClip[ clipName ] = actionsForClip;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tvar knownActions = actionsForClip.knownActions;\r\n\t\r\n\t\t\t\taction._byClipCacheIndex = knownActions.length;\r\n\t\t\t\tknownActions.push( action );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\taction._cacheIndex = actions.length;\r\n\t\t\tactions.push( action );\r\n\t\r\n\t\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_removeInactiveAction: function( action ) {\r\n\t\r\n\t\t\tvar actions = this._actions,\r\n\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\r\n\t\t\t\tcacheIndex = action._cacheIndex;\r\n\t\r\n\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\r\n\t\t\tactions[ cacheIndex ] = lastInactiveAction;\r\n\t\t\tactions.pop();\r\n\t\r\n\t\t\taction._cacheIndex = null;\r\n\t\r\n\t\r\n\t\t\tvar clipName = action._clip.name,\r\n\t\t\t\tactionsByClip = this._actionsByClip,\r\n\t\t\t\tactionsForClip = actionsByClip[ clipName ],\r\n\t\t\t\tknownActionsForClip = actionsForClip.knownActions,\r\n\t\r\n\t\t\t\tlastKnownAction =\r\n\t\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\r\n\t\r\n\t\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\r\n\t\r\n\t\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\r\n\t\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\r\n\t\t\tknownActionsForClip.pop();\r\n\t\r\n\t\t\taction._byClipCacheIndex = null;\r\n\t\r\n\t\r\n\t\t\tvar actionByRoot = actionsForClip.actionByRoot,\r\n\t\t\t\trootUuid = ( actions._localRoot || this._root ).uuid;\r\n\t\r\n\t\t\tdelete actionByRoot[ rootUuid ];\r\n\t\r\n\t\t\tif ( knownActionsForClip.length === 0 ) {\r\n\t\r\n\t\t\t\tdelete actionsByClip[ clipName ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._removeInactiveBindingsForAction( action );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_removeInactiveBindingsForAction: function( action ) {\r\n\t\r\n\t\t\tvar bindings = action._propertyBindings;\r\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar binding = bindings[ i ];\r\n\t\r\n\t\t\t\tif ( -- binding.referenceCount === 0 ) {\r\n\t\r\n\t\t\t\t\tthis._removeInactiveBinding( binding );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_lendAction: function( action ) {\r\n\t\r\n\t\t\t// [ active actions |  inactive actions  ]\r\n\t\t\t// [  active actions >| inactive actions ]\r\n\t\t\t//                 s        a\r\n\t\t\t//                  <-swap->\r\n\t\t\t//                 a        s\r\n\t\r\n\t\t\tvar actions = this._actions,\r\n\t\t\t\tprevIndex = action._cacheIndex,\r\n\t\r\n\t\t\t\tlastActiveIndex = this._nActiveActions ++,\r\n\t\r\n\t\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\r\n\t\r\n\t\t\taction._cacheIndex = lastActiveIndex;\r\n\t\t\tactions[ lastActiveIndex ] = action;\r\n\t\r\n\t\t\tfirstInactiveAction._cacheIndex = prevIndex;\r\n\t\t\tactions[ prevIndex ] = firstInactiveAction;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_takeBackAction: function( action ) {\r\n\t\r\n\t\t\t// [  active actions  | inactive actions ]\r\n\t\t\t// [ active actions |< inactive actions  ]\r\n\t\t\t//        a        s\r\n\t\t\t//         <-swap->\r\n\t\t\t//        s        a\r\n\t\r\n\t\t\tvar actions = this._actions,\r\n\t\t\t\tprevIndex = action._cacheIndex,\r\n\t\r\n\t\t\t\tfirstInactiveIndex = -- this._nActiveActions,\r\n\t\r\n\t\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\r\n\t\r\n\t\t\taction._cacheIndex = firstInactiveIndex;\r\n\t\t\tactions[ firstInactiveIndex ] = action;\r\n\t\r\n\t\t\tlastActiveAction._cacheIndex = prevIndex;\r\n\t\t\tactions[ prevIndex ] = lastActiveAction;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Memory management for PropertyMixer objects\r\n\t\r\n\t\t_addInactiveBinding: function( binding, rootUuid, trackName ) {\r\n\t\r\n\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\r\n\t\r\n\t\t\t\tbindings = this._bindings;\r\n\t\r\n\t\t\tif ( bindingByName === undefined ) {\r\n\t\r\n\t\t\t\tbindingByName = {};\r\n\t\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tbindingByName[ trackName ] = binding;\r\n\t\r\n\t\t\tbinding._cacheIndex = bindings.length;\r\n\t\t\tbindings.push( binding );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_removeInactiveBinding: function( binding ) {\r\n\t\r\n\t\t\tvar bindings = this._bindings,\r\n\t\t\t\tpropBinding = binding.binding,\r\n\t\t\t\trootUuid = propBinding.rootNode.uuid,\r\n\t\t\t\ttrackName = propBinding.path,\r\n\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\r\n\t\r\n\t\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\r\n\t\t\t\tcacheIndex = binding._cacheIndex;\r\n\t\r\n\t\t\tlastInactiveBinding._cacheIndex = cacheIndex;\r\n\t\t\tbindings[ cacheIndex ] = lastInactiveBinding;\r\n\t\t\tbindings.pop();\r\n\t\r\n\t\t\tdelete bindingByName[ trackName ];\r\n\t\r\n\t\t\tremove_empty_map: {\r\n\t\r\n\t\t\t\tfor ( var _ in bindingByName ) break remove_empty_map;\r\n\t\r\n\t\t\t\tdelete bindingsByRoot[ rootUuid ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_lendBinding: function( binding ) {\r\n\t\r\n\t\t\tvar bindings = this._bindings,\r\n\t\t\t\tprevIndex = binding._cacheIndex,\r\n\t\r\n\t\t\t\tlastActiveIndex = this._nActiveBindings ++,\r\n\t\r\n\t\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\r\n\t\r\n\t\t\tbinding._cacheIndex = lastActiveIndex;\r\n\t\t\tbindings[ lastActiveIndex ] = binding;\r\n\t\r\n\t\t\tfirstInactiveBinding._cacheIndex = prevIndex;\r\n\t\t\tbindings[ prevIndex ] = firstInactiveBinding;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_takeBackBinding: function( binding ) {\r\n\t\r\n\t\t\tvar bindings = this._bindings,\r\n\t\t\t\tprevIndex = binding._cacheIndex,\r\n\t\r\n\t\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\r\n\t\r\n\t\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\r\n\t\r\n\t\t\tbinding._cacheIndex = firstInactiveIndex;\r\n\t\t\tbindings[ firstInactiveIndex ] = binding;\r\n\t\r\n\t\t\tlastActiveBinding._cacheIndex = prevIndex;\r\n\t\t\tbindings[ prevIndex ] = lastActiveBinding;\r\n\t\r\n\t\t},\r\n\t\r\n\t\r\n\t\t// Memory management of Interpolants for weight and time scale\r\n\t\r\n\t\t_lendControlInterpolant: function() {\r\n\t\r\n\t\t\tvar interpolants = this._controlInterpolants,\r\n\t\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\r\n\t\t\t\tinterpolant = interpolants[ lastActiveIndex ];\r\n\t\r\n\t\t\tif ( interpolant === undefined ) {\r\n\t\r\n\t\t\t\tinterpolant = new THREE.LinearInterpolant(\r\n\t\t\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\r\n\t\t\t\t\t\t\t1, this._controlInterpolantsResultBuffer );\r\n\t\r\n\t\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\r\n\t\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn interpolant;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_takeBackControlInterpolant: function( interpolant ) {\r\n\t\r\n\t\t\tvar interpolants = this._controlInterpolants,\r\n\t\t\t\tprevIndex = interpolant.__cacheIndex,\r\n\t\r\n\t\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\r\n\t\r\n\t\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\r\n\t\r\n\t\t\tinterpolant.__cacheIndex = firstInactiveIndex;\r\n\t\t\tinterpolants[ firstInactiveIndex ] = interpolant;\r\n\t\r\n\t\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\r\n\t\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_controlInterpolantsResultBuffer: new Float32Array( 1 )\r\n\t\r\n\t} );\r\n\t\r\n\t\r\n\t// File:src/animation/AnimationObjectGroup.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * A group of objects that receives a shared animation state.\r\n\t *\r\n\t * Usage:\r\n\t *\r\n\t * \t-\tAdd objects you would otherwise pass as 'root' to the\r\n\t * \t\tconstructor or the .clipAction method of AnimationMixer.\r\n\t *\r\n\t * \t-\tInstead pass this object as 'root'.\r\n\t *\r\n\t * \t-\tYou can also add and remove objects later when the mixer\r\n\t * \t\tis running.\r\n\t *\r\n\t * Note:\r\n\t *\r\n\t *  \tObjects of this class appear as one object to the mixer,\r\n\t *  \tso cache control of the individual objects must be done\r\n\t *  \ton the group.\r\n\t *\r\n\t * Limitation:\r\n\t *\r\n\t * \t- \tThe animated properties must be compatible among the\r\n\t * \t\tall objects in the group.\r\n\t *\r\n\t *  -\tA single property can either be controlled through a\r\n\t *  \ttarget group or directly, but not both.\r\n\t *\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.AnimationObjectGroup = function( var_args ) {\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\t// cached objects followed by the active ones\r\n\t\tthis._objects = Array.prototype.slice.call( arguments );\r\n\t\r\n\t\tthis.nCachedObjects_ = 0;\t\t\t// threshold\r\n\t\t// note: read by PropertyBinding.Composite\r\n\t\r\n\t\tvar indices = {};\r\n\t\tthis._indicesByUUID = indices;\t\t// for bookkeeping\r\n\t\r\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\tindices[ arguments[ i ].uuid ] = i;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis._paths = [];\t\t\t\t\t// inside: string\r\n\t\tthis._parsedPaths = [];\t\t\t\t// inside: { we don't care, here }\r\n\t\tthis._bindings = []; \t\t\t\t// inside: Array< PropertyBinding >\r\n\t\tthis._bindingsIndicesByPath = {}; \t// inside: indices in these arrays\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\tthis.stats = {\r\n\t\r\n\t\t\tobjects: {\r\n\t\t\t\tget total() { return scope._objects.length; },\r\n\t\t\t\tget inUse() { return this.total - scope.nCachedObjects_;  }\r\n\t\t\t},\r\n\t\r\n\t\t\tget bindingsPerObject() { return scope._bindings.length; }\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AnimationObjectGroup.prototype = {\r\n\t\r\n\t\tconstructor: THREE.AnimationObjectGroup,\r\n\t\r\n\t\tadd: function( var_args ) {\r\n\t\r\n\t\t\tvar objects = this._objects,\r\n\t\t\t\tnObjects = objects.length,\r\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\t\tindicesByUUID = this._indicesByUUID,\r\n\t\t\t\tpaths = this._paths,\r\n\t\t\t\tparsedPaths = this._parsedPaths,\r\n\t\t\t\tbindings = this._bindings,\r\n\t\t\t\tnBindings = bindings.length;\r\n\t\r\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar object = arguments[ i ],\r\n\t\t\t\t\tuuid = object.uuid,\r\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\r\n\t\r\n\t\t\t\tif ( index === undefined ) {\r\n\t\r\n\t\t\t\t\t// unknown object -> add it to the ACTIVE region\r\n\t\r\n\t\t\t\t\tindex = nObjects ++;\r\n\t\t\t\t\tindicesByUUID[ uuid ] = index;\r\n\t\t\t\t\tobjects.push( object );\r\n\t\r\n\t\t\t\t\t// accounting is done, now do the same for all bindings\r\n\t\r\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\t\r\n\t\t\t\t\t\tbindings[ j ].push(\r\n\t\t\t\t\t\t\t\tnew THREE.PropertyBinding(\r\n\t\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( index < nCachedObjects ) {\r\n\t\r\n\t\t\t\t\tvar knownObject = objects[ index ];\r\n\t\r\n\t\t\t\t\t// move existing object to the ACTIVE region\r\n\t\r\n\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\r\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\r\n\t\r\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\r\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\r\n\t\r\n\t\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\r\n\t\t\t\t\tobjects[ firstActiveIndex ] = object;\r\n\t\r\n\t\t\t\t\t// accounting is done, now do the same for all bindings\r\n\t\r\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\t\r\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\r\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\r\n\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\r\n\t\r\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\r\n\t\r\n\t\t\t\t\t\tif ( binding === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\t// since we do not bother to create new bindings\r\n\t\t\t\t\t\t\t// for objects that are cached, the binding may\r\n\t\t\t\t\t\t\t// or may not exist\r\n\t\r\n\t\t\t\t\t\t\tbinding = new THREE.PropertyBinding(\r\n\t\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( objects[ index ] !== knownObject) {\r\n\t\r\n\t\t\t\t\tconsole.error( \"Different objects with the same UUID \" +\r\n\t\t\t\t\t\t\t\"detected. Clean the caches or recreate your \" +\r\n\t\t\t\t\t\t\t\"infrastructure when reloading scenes...\" );\r\n\t\r\n\t\t\t\t} // else the object is already where we want it to be\r\n\t\r\n\t\t\t} // for arguments\r\n\t\r\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tremove: function( var_args ) {\r\n\t\r\n\t\t\tvar objects = this._objects,\r\n\t\t\t\tnObjects = objects.length,\r\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\t\tindicesByUUID = this._indicesByUUID,\r\n\t\t\t\tbindings = this._bindings,\r\n\t\t\t\tnBindings = bindings.length;\r\n\t\r\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar object = arguments[ i ],\r\n\t\t\t\t\tuuid = object.uuid,\r\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\r\n\t\r\n\t\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\r\n\t\r\n\t\t\t\t\t// move existing object into the CACHED region\r\n\t\r\n\t\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\r\n\t\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\r\n\t\r\n\t\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\r\n\t\t\t\t\tobjects[ index ] = firstActiveObject;\r\n\t\r\n\t\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\r\n\t\t\t\t\tobjects[ lastCachedIndex ] = object;\r\n\t\r\n\t\t\t\t\t// accounting is done, now do the same for all bindings\r\n\t\r\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\t\r\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\r\n\t\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\r\n\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\r\n\t\r\n\t\t\t\t\t\tbindingsForPath[ index ] = firstActive;\r\n\t\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} // for arguments\r\n\t\r\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// remove & forget\r\n\t\tuncache: function( var_args ) {\r\n\t\r\n\t\t\tvar objects = this._objects,\r\n\t\t\t\tnObjects = objects.length,\r\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\t\tindicesByUUID = this._indicesByUUID,\r\n\t\t\t\tbindings = this._bindings,\r\n\t\t\t\tnBindings = bindings.length;\r\n\t\r\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar object = arguments[ i ],\r\n\t\t\t\t\tuuid = object.uuid,\r\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\r\n\t\r\n\t\t\t\tif ( index !== undefined ) {\r\n\t\r\n\t\t\t\t\tdelete indicesByUUID[ uuid ];\r\n\t\r\n\t\t\t\t\tif ( index < nCachedObjects ) {\r\n\t\r\n\t\t\t\t\t\t// object is cached, shrink the CACHED region\r\n\t\r\n\t\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\r\n\t\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\r\n\t\t\t\t\t\t\tlastIndex = -- nObjects,\r\n\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\r\n\t\r\n\t\t\t\t\t\t// last cached object takes this object's place\r\n\t\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\r\n\t\t\t\t\t\tobjects[ index ] = lastCachedObject;\r\n\t\r\n\t\t\t\t\t\t// last object goes to the activated slot and pop\r\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\r\n\t\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\r\n\t\t\t\t\t\tobjects.pop();\r\n\t\r\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\r\n\t\r\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\t\r\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\r\n\t\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\r\n\t\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\r\n\t\r\n\t\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\r\n\t\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\r\n\t\t\t\t\t\t\tbindingsForPath.pop();\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t// object is active, just swap with the last and pop\r\n\t\r\n\t\t\t\t\t\tvar lastIndex = -- nObjects,\r\n\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\r\n\t\r\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\r\n\t\t\t\t\t\tobjects[ index ] = lastObject;\r\n\t\t\t\t\t\tobjects.pop();\r\n\t\r\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\r\n\t\r\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\t\r\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\r\n\t\r\n\t\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\r\n\t\t\t\t\t\t\tbindingsForPath.pop();\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} // cached or active\r\n\t\r\n\t\t\t\t} // if object is known\r\n\t\r\n\t\t\t} // for arguments\r\n\t\r\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Internal interface used by befriended PropertyBinding.Composite:\r\n\t\r\n\t\tsubscribe_: function( path, parsedPath ) {\r\n\t\t\t// returns an array of bindings for the given path that is changed\r\n\t\t\t// according to the contained objects in the group\r\n\t\r\n\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\r\n\t\t\t\tindex = indicesByPath[ path ],\r\n\t\t\t\tbindings = this._bindings;\r\n\t\r\n\t\t\tif ( index !== undefined ) return bindings[ index ];\r\n\t\r\n\t\t\tvar paths = this._paths,\r\n\t\t\t\tparsedPaths = this._parsedPaths,\r\n\t\t\t\tobjects = this._objects,\r\n\t\t\t\tnObjects = objects.length,\r\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\t\tbindingsForPath = new Array( nObjects );\r\n\t\r\n\t\t\tindex = bindings.length;\r\n\t\r\n\t\t\tindicesByPath[ path ] = index;\r\n\t\r\n\t\t\tpaths.push( path );\r\n\t\t\tparsedPaths.push( parsedPath );\r\n\t\t\tbindings.push( bindingsForPath );\r\n\t\r\n\t\t\tfor ( var i = nCachedObjects,\r\n\t\t\t\t\tn = objects.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar object = objects[ i ];\r\n\t\r\n\t\t\t\tbindingsForPath[ i ] =\r\n\t\t\t\t\t\tnew THREE.PropertyBinding( object, path, parsedPath );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn bindingsForPath;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tunsubscribe_: function( path ) {\r\n\t\t\t// tells the group to forget about a property path and no longer\r\n\t\t\t// update the array previously obtained with 'subscribe_'\r\n\t\r\n\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\r\n\t\t\t\tindex = indicesByPath[ path ];\r\n\t\r\n\t\t\tif ( index !== undefined ) {\r\n\t\r\n\t\t\t\tvar paths = this._paths,\r\n\t\t\t\t\tparsedPaths = this._parsedPaths,\r\n\t\t\t\t\tbindings = this._bindings,\r\n\t\t\t\t\tlastBindingsIndex = bindings.length - 1,\r\n\t\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\r\n\t\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\r\n\t\r\n\t\t\t\tindicesByPath[ lastBindingsPath ] = index;\r\n\t\r\n\t\t\t\tbindings[ index ] = lastBindings;\r\n\t\t\t\tbindings.pop();\r\n\t\r\n\t\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\r\n\t\t\t\tparsedPaths.pop();\r\n\t\r\n\t\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\r\n\t\t\t\tpaths.pop();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// File:src/animation/AnimationUtils.js\r\n\t\r\n\t/**\r\n\t * @author tschw\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t */\r\n\t\r\n\tTHREE.AnimationUtils = {\r\n\t\r\n\t\t// same as Array.prototype.slice, but also works on typed arrays\r\n\t\tarraySlice: function( array, from, to ) {\r\n\t\r\n\t\t\tif ( THREE.AnimationUtils.isTypedArray( array ) ) {\r\n\t\r\n\t\t\t\treturn new array.constructor( array.subarray( from, to ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn array.slice( from, to );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// converts an array to a specific type\r\n\t\tconvertArray: function( array, type, forceClone ) {\r\n\t\r\n\t\t\tif ( ! array || // let 'undefined' and 'null' pass\r\n\t\t\t\t\t! forceClone && array.constructor === type ) return array;\r\n\t\r\n\t\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\r\n\t\r\n\t\t\t\treturn new type( array ); // create typed array\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn Array.prototype.slice.call( array ); // create Array\r\n\t\r\n\t\t},\r\n\t\r\n\t\tisTypedArray: function( object ) {\r\n\t\r\n\t\t\treturn ArrayBuffer.isView( object ) &&\r\n\t\t\t\t\t! ( object instanceof DataView );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// returns an array by which times and values can be sorted\r\n\t\tgetKeyframeOrder: function( times ) {\r\n\t\r\n\t\t\tfunction compareTime( i, j ) {\r\n\t\r\n\t\t\t\treturn times[ i ] - times[ j ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar n = times.length;\r\n\t\t\tvar result = new Array( n );\r\n\t\t\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\r\n\t\r\n\t\t\tresult.sort( compareTime );\r\n\t\r\n\t\t\treturn result;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// uses the array previously returned by 'getKeyframeOrder' to sort data\r\n\t\tsortedArray: function( values, stride, order ) {\r\n\t\r\n\t\t\tvar nValues = values.length;\r\n\t\t\tvar result = new values.constructor( nValues );\r\n\t\r\n\t\t\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\r\n\t\r\n\t\t\t\tvar srcOffset = order[ i ] * stride;\r\n\t\r\n\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\r\n\t\r\n\t\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// function for parsing AOS keyframe formats\r\n\t\tflattenJSON: function( jsonKeys, times, values, valuePropertyName ) {\r\n\t\r\n\t\t\tvar i = 1, key = jsonKeys[ 0 ];\r\n\t\r\n\t\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\r\n\t\r\n\t\t\t\tkey = jsonKeys[ i ++ ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( key === undefined ) return; // no data\r\n\t\r\n\t\t\tvar value = key[ valuePropertyName ];\r\n\t\t\tif ( value === undefined ) return; // no data\r\n\t\r\n\t\t\tif ( Array.isArray( value ) ) {\r\n\t\r\n\t\t\t\tdo {\r\n\t\r\n\t\t\t\t\tvalue = key[ valuePropertyName ];\r\n\t\r\n\t\t\t\t\tif ( value !== undefined ) {\r\n\t\r\n\t\t\t\t\t\ttimes.push( key.time );\r\n\t\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\r\n\t\r\n\t\t\t\t} while ( key !== undefined );\r\n\t\r\n\t\t\t} else if ( value.toArray !== undefined ) {\r\n\t\t\t\t// ...assume THREE.Math-ish\r\n\t\r\n\t\t\t\tdo {\r\n\t\r\n\t\t\t\t\tvalue = key[ valuePropertyName ];\r\n\t\r\n\t\t\t\t\tif ( value !== undefined ) {\r\n\t\r\n\t\t\t\t\t\ttimes.push( key.time );\r\n\t\t\t\t\t\tvalue.toArray( values, values.length );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\r\n\t\r\n\t\t\t\t} while ( key !== undefined );\r\n\t\r\n\t\t\t} else {\r\n\t\t\t\t// otherwise push as-is\r\n\t\r\n\t\t\t\tdo {\r\n\t\r\n\t\t\t\t\tvalue = key[ valuePropertyName ];\r\n\t\r\n\t\t\t\t\tif ( value !== undefined ) {\r\n\t\r\n\t\t\t\t\t\ttimes.push( key.time );\r\n\t\t\t\t\t\tvalues.push( value );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\r\n\t\r\n\t\t\t\t} while ( key !== undefined );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/animation/KeyframeTrack.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * A timed sequence of keyframes for a specific property.\r\n\t *\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.KeyframeTrack = function ( name, times, values, interpolation ) {\r\n\t\r\n\t\tif( name === undefined ) throw new Error( \"track name is undefined\" );\r\n\t\r\n\t\tif( times === undefined || times.length === 0 ) {\r\n\t\r\n\t\t\tthrow new Error( \"no keyframes in track named \" + name );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.name = name;\r\n\t\r\n\t\tthis.times = THREE.AnimationUtils.convertArray( times, this.TimeBufferType );\r\n\t\tthis.values = THREE.AnimationUtils.convertArray( values, this.ValueBufferType );\r\n\t\r\n\t\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\r\n\t\r\n\t\tthis.validate();\r\n\t\tthis.optimize();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.KeyframeTrack.prototype = {\r\n\t\r\n\t\tconstructor: THREE.KeyframeTrack,\r\n\t\r\n\t\tTimeBufferType: Float32Array,\r\n\t\tValueBufferType: Float32Array,\r\n\t\r\n\t\tDefaultInterpolation: THREE.InterpolateLinear,\r\n\t\r\n\t\tInterpolantFactoryMethodDiscrete: function( result ) {\r\n\t\r\n\t\t\treturn new THREE.DiscreteInterpolant(\r\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tInterpolantFactoryMethodLinear: function( result ) {\r\n\t\r\n\t\t\treturn new THREE.LinearInterpolant(\r\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tInterpolantFactoryMethodSmooth: function( result ) {\r\n\t\r\n\t\t\treturn new THREE.CubicInterpolant(\r\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetInterpolation: function( interpolation ) {\r\n\t\r\n\t\t\tvar factoryMethod = undefined;\r\n\t\r\n\t\t\tswitch ( interpolation ) {\r\n\t\r\n\t\t\t\tcase THREE.InterpolateDiscrete:\r\n\t\r\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase THREE.InterpolateLinear:\r\n\t\r\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase THREE.InterpolateSmooth:\r\n\t\r\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( factoryMethod === undefined ) {\r\n\t\r\n\t\t\t\tvar message = \"unsupported interpolation for \" +\r\n\t\t\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\r\n\t\r\n\t\t\t\tif ( this.createInterpolant === undefined ) {\r\n\t\r\n\t\t\t\t\t// fall back to default, unless the default itself is messed up\r\n\t\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\r\n\t\r\n\t\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tthrow new Error( message ); // fatal, in this case\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tconsole.warn( message );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.createInterpolant = factoryMethod;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetInterpolation: function() {\r\n\t\r\n\t\t\tswitch ( this.createInterpolant ) {\r\n\t\r\n\t\t\t\tcase this.InterpolantFactoryMethodDiscrete:\r\n\t\r\n\t\t\t\t\treturn THREE.InterpolateDiscrete;\r\n\t\r\n\t\t\t\tcase this.InterpolantFactoryMethodLinear:\r\n\t\r\n\t\t\t\t\treturn THREE.InterpolateLinear;\r\n\t\r\n\t\t\t\tcase this.InterpolantFactoryMethodSmooth:\r\n\t\r\n\t\t\t\t\treturn THREE.InterpolateSmooth;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetValueSize: function() {\r\n\t\r\n\t\t\treturn this.values.length / this.times.length;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// move all keyframes either forwards or backwards in time\r\n\t\tshift: function( timeOffset ) {\r\n\t\r\n\t\t\tif( timeOffset !== 0.0 ) {\r\n\t\r\n\t\t\t\tvar times = this.times;\r\n\t\r\n\t\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\ttimes[ i ] += timeOffset;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\r\n\t\tscale: function( timeScale ) {\r\n\t\r\n\t\t\tif( timeScale !== 1.0 ) {\r\n\t\r\n\t\t\t\tvar times = this.times;\r\n\t\r\n\t\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\ttimes[ i ] *= timeScale;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\r\n\t\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\r\n\t\ttrim: function( startTime, endTime ) {\r\n\t\r\n\t\t\tvar times = this.times,\r\n\t\t\t\tnKeys = times.length,\r\n\t\t\t\tfrom = 0,\r\n\t\t\t\tto = nKeys - 1;\r\n\t\r\n\t\t\twhile ( from !== nKeys && times[ from ] < startTime ) ++ from;\r\n\t\t\twhile ( to !== -1 && times[ to ] > endTime ) -- to;\r\n\t\r\n\t\t\t++ to; // inclusive -> exclusive bound\r\n\t\r\n\t\t\tif( from !== 0 || to !== nKeys ) {\r\n\t\r\n\t\t\t\t// empty tracks are forbidden, so keep at least one keyframe\r\n\t\t\t\tif ( from >= to ) to = Math.max( to , 1 ), from = to - 1;\r\n\t\r\n\t\t\t\tvar stride = this.getValueSize();\r\n\t\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, from, to );\r\n\t\t\t\tthis.values = THREE.AnimationUtils.\r\n\t\t\t\t\t\tarraySlice( this.values, from * stride, to * stride );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\r\n\t\tvalidate: function() {\r\n\t\r\n\t\t\tvar valid = true;\r\n\t\r\n\t\t\tvar valueSize = this.getValueSize();\r\n\t\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\r\n\t\r\n\t\t\t\tconsole.error( \"invalid value size in track\", this );\r\n\t\t\t\tvalid = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar times = this.times,\r\n\t\t\t\tvalues = this.values,\r\n\t\r\n\t\t\t\tnKeys = times.length;\r\n\t\r\n\t\t\tif( nKeys === 0 ) {\r\n\t\r\n\t\t\t\tconsole.error( \"track is empty\", this );\r\n\t\t\t\tvalid = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar prevTime = null;\r\n\t\r\n\t\t\tfor( var i = 0; i !== nKeys; i ++ ) {\r\n\t\r\n\t\t\t\tvar currTime = times[ i ];\r\n\t\r\n\t\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\r\n\t\r\n\t\t\t\t\tconsole.error( \"time is not a valid number\", this, i, currTime );\r\n\t\t\t\t\tvalid = false;\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif( prevTime !== null && prevTime > currTime ) {\r\n\t\r\n\t\t\t\t\tconsole.error( \"out of order keys\", this, i, currTime, prevTime );\r\n\t\t\t\t\tvalid = false;\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tprevTime = currTime;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( values !== undefined ) {\r\n\t\r\n\t\t\t\tif ( THREE.AnimationUtils.isTypedArray( values ) ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\t\tvar value = values[ i ];\r\n\t\r\n\t\t\t\t\t\tif ( isNaN( value ) ) {\r\n\t\r\n\t\t\t\t\t\t\tconsole.error( \"value is not a valid number\", this, i, value );\r\n\t\t\t\t\t\t\tvalid = false;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn valid;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// removes equivalent sequential keys as common in morph target sequences\r\n\t\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\r\n\t\toptimize: function() {\r\n\t\r\n\t\t\tvar times = this.times,\r\n\t\t\t\tvalues = this.values,\r\n\t\t\t\tstride = this.getValueSize(),\r\n\t\r\n\t\t\t\twriteIndex = 1;\r\n\t\r\n\t\t\tfor( var i = 1, n = times.length - 1; i <= n; ++ i ) {\r\n\t\r\n\t\t\t\tvar keep = false;\r\n\t\r\n\t\t\t\tvar time = times[ i ];\r\n\t\t\t\tvar timeNext = times[ i + 1 ];\r\n\t\r\n\t\t\t\t// remove adjacent keyframes scheduled at the same time\r\n\t\r\n\t\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\r\n\t\r\n\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\r\n\t\t\t\t\tvar offset = i * stride,\r\n\t\t\t\t\t\toffsetP = offset - stride,\r\n\t\t\t\t\t\toffsetN = offset + stride;\r\n\t\r\n\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\r\n\t\r\n\t\t\t\t\t\tvar value = values[ offset + j ];\r\n\t\r\n\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\r\n\t\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\r\n\t\r\n\t\t\t\t\t\t\tkeep = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// in-place compaction\r\n\t\r\n\t\t\t\tif ( keep ) {\r\n\t\r\n\t\t\t\t\tif ( i !== writeIndex ) {\r\n\t\r\n\t\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\r\n\t\r\n\t\t\t\t\t\tvar readOffset = i * stride,\r\n\t\t\t\t\t\t\twriteOffset = writeIndex * stride;\r\n\t\r\n\t\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\r\n\t\r\n\t\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t++ writeIndex;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( writeIndex !== times.length ) {\r\n\t\r\n\t\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, 0, writeIndex );\r\n\t\t\t\tthis.values = THREE.AnimationUtils.arraySlice( values, 0, writeIndex * stride );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// Static methods:\r\n\t\r\n\tObject.assign( THREE.KeyframeTrack, {\r\n\t\r\n\t\t// Serialization (in static context, because of constructor invocation\r\n\t\t// and automatic invocation of .toJSON):\r\n\t\r\n\t\tparse: function( json ) {\r\n\t\r\n\t\t\tif( json.type === undefined ) {\r\n\t\r\n\t\t\t\tthrow new Error( \"track type undefined, can not parse\" );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar trackType = THREE.KeyframeTrack._getTrackTypeForValueTypeName( json.type );\r\n\t\r\n\t\t\tif ( json.times === undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( \"legacy JSON format detected, converting\" );\r\n\t\r\n\t\t\t\tvar times = [], values = [];\r\n\t\r\n\t\t\t\tTHREE.AnimationUtils.flattenJSON( json.keys, times, values, 'value' );\r\n\t\r\n\t\t\t\tjson.times = times;\r\n\t\t\t\tjson.values = values;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// derived classes can define a static parse method\r\n\t\t\tif ( trackType.parse !== undefined ) {\r\n\t\r\n\t\t\t\treturn trackType.parse( json );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// by default, we asssume a constructor compatible with the base\r\n\t\t\t\treturn new trackType(\r\n\t\t\t\t\t\tjson.name, json.times, json.values, json.interpolation );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function( track ) {\r\n\t\r\n\t\t\tvar trackType = track.constructor;\r\n\t\r\n\t\t\tvar json;\r\n\t\r\n\t\t\t// derived classes can define a static toJSON method\r\n\t\t\tif ( trackType.toJSON !== undefined ) {\r\n\t\r\n\t\t\t\tjson = trackType.toJSON( track );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// by default, we assume the data can be serialized as-is\r\n\t\t\t\tjson = {\r\n\t\r\n\t\t\t\t\t'name': track.name,\r\n\t\t\t\t\t'times': THREE.AnimationUtils.convertArray( track.times, Array ),\r\n\t\t\t\t\t'values': THREE.AnimationUtils.convertArray( track.values, Array )\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t\tvar interpolation = track.getInterpolation();\r\n\t\r\n\t\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\r\n\t\r\n\t\t\t\t\tjson.interpolation = interpolation;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tjson.type = track.ValueTypeName; // mandatory\r\n\t\r\n\t\t\treturn json;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_getTrackTypeForValueTypeName: function( typeName ) {\r\n\t\r\n\t\t\tswitch( typeName.toLowerCase() ) {\r\n\t\r\n\t\t\t\tcase \"scalar\":\r\n\t\t\t\tcase \"double\":\r\n\t\t\t\tcase \"float\":\r\n\t\t\t\tcase \"number\":\r\n\t\t\t\tcase \"integer\":\r\n\t\r\n\t\t\t\t\treturn THREE.NumberKeyframeTrack;\r\n\t\r\n\t\t\t\tcase \"vector\":\r\n\t\t\t\tcase \"vector2\":\r\n\t\t\t\tcase \"vector3\":\r\n\t\t\t\tcase \"vector4\":\r\n\t\r\n\t\t\t\t\treturn THREE.VectorKeyframeTrack;\r\n\t\r\n\t\t\t\tcase \"color\":\r\n\t\r\n\t\t\t\t\treturn THREE.ColorKeyframeTrack;\r\n\t\r\n\t\t\t\tcase \"quaternion\":\r\n\t\r\n\t\t\t\t\treturn THREE.QuaternionKeyframeTrack;\r\n\t\r\n\t\t\t\tcase \"bool\":\r\n\t\t\t\tcase \"boolean\":\r\n\t\r\n\t\t\t\t\treturn THREE.BooleanKeyframeTrack;\r\n\t\r\n\t\t\t\tcase \"string\":\r\n\t\r\n\t\t\t\t\treturn THREE.StringKeyframeTrack;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tthrow new Error( \"Unsupported typeName: \" + typeName );\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/animation/PropertyBinding.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * A reference to a real property in the scene graph.\r\n\t *\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.PropertyBinding = function ( rootNode, path, parsedPath ) {\r\n\t\r\n\t\tthis.path = path;\r\n\t\tthis.parsedPath = parsedPath ||\r\n\t\t\t\tTHREE.PropertyBinding.parseTrackName( path );\r\n\t\r\n\t\tthis.node = THREE.PropertyBinding.findNode(\r\n\t\t\t\trootNode, this.parsedPath.nodeName ) || rootNode;\r\n\t\r\n\t\tthis.rootNode = rootNode;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PropertyBinding.prototype = {\r\n\t\r\n\t\tconstructor: THREE.PropertyBinding,\r\n\t\r\n\t\tgetValue: function getValue_unbound( targetArray, offset ) {\r\n\t\r\n\t\t\tthis.bind();\r\n\t\t\tthis.getValue( targetArray, offset );\r\n\t\r\n\t\t\t// Note: This class uses a State pattern on a per-method basis:\r\n\t\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\r\n\t\t\t// prototype version of these methods with one that represents\r\n\t\t\t// the bound state. When the property is not found, the methods\r\n\t\t\t// become no-ops.\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetValue: function getValue_unbound( sourceArray, offset ) {\r\n\t\r\n\t\t\tthis.bind();\r\n\t\t\tthis.setValue( sourceArray, offset );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// create getter / setter pair for a property in the scene graph\r\n\t\tbind: function() {\r\n\t\r\n\t\t\tvar targetObject = this.node,\r\n\t\t\t\tparsedPath = this.parsedPath,\r\n\t\r\n\t\t\t\tobjectName = parsedPath.objectName,\r\n\t\t\t\tpropertyName = parsedPath.propertyName,\r\n\t\t\t\tpropertyIndex = parsedPath.propertyIndex;\r\n\t\r\n\t\t\tif ( ! targetObject ) {\r\n\t\r\n\t\t\t\ttargetObject = THREE.PropertyBinding.findNode(\r\n\t\t\t\t\t\tthis.rootNode, parsedPath.nodeName ) || this.rootNode;\r\n\t\r\n\t\t\t\tthis.node = targetObject;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// set fail state so we can just 'return' on error\r\n\t\t\tthis.getValue = this._getValue_unavailable;\r\n\t\t\tthis.setValue = this._setValue_unavailable;\r\n\t\r\n\t \t\t// ensure there is a value node\r\n\t\t\tif ( ! targetObject ) {\r\n\t\r\n\t\t\t\tconsole.error( \"  trying to update node for track: \" + this.path + \" but it wasn't found.\" );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif( objectName ) {\r\n\t\r\n\t\t\t\tvar objectIndex = parsedPath.objectIndex;\r\n\t\r\n\t\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\r\n\t\t\t\tswitch ( objectName ) {\r\n\t\r\n\t\t\t\t\tcase 'materials':\r\n\t\r\n\t\t\t\t\t\tif( ! targetObject.material ) {\r\n\t\r\n\t\t\t\t\t\t\tconsole.error( '  can not bind to material as node does not have a material', this );\r\n\t\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif( ! targetObject.material.materials ) {\r\n\t\r\n\t\t\t\t\t\t\tconsole.error( '  can not bind to material.materials as node.material does not have a materials array', this );\r\n\t\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\ttargetObject = targetObject.material.materials;\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'bones':\r\n\t\r\n\t\t\t\t\t\tif( ! targetObject.skeleton ) {\r\n\t\r\n\t\t\t\t\t\t\tconsole.error( '  can not bind to bones as node does not have a skeleton', this );\r\n\t\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\r\n\t\t\t\t\t\t// and convert the integer string to a true integer.\r\n\t\r\n\t\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\r\n\t\r\n\t\t\t\t\t\t// support resolving morphTarget names into indices.\r\n\t\t\t\t\t\tfor ( var i = 0; i < targetObject.length; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( targetObject[i].name === objectIndex ) {\r\n\t\r\n\t\t\t\t\t\t\t\tobjectIndex = i;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tdefault:\r\n\t\r\n\t\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tconsole.error( '  can not bind to objectName of node, undefined', this );\r\n\t\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\ttargetObject = targetObject[ objectName ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\tif ( objectIndex !== undefined ) {\r\n\t\r\n\t\t\t\t\tif( targetObject[ objectIndex ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\tconsole.error( \"  trying to bind to objectIndex of objectName, but is undefined:\", this, targetObject );\r\n\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttargetObject = targetObject[ objectIndex ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// resolve property\r\n\t\t\tvar nodeProperty = targetObject[ propertyName ];\r\n\t\r\n\t\t\tif ( ! nodeProperty ) {\r\n\t\r\n\t\t\t\tvar nodeName = parsedPath.nodeName;\r\n\t\r\n\t\t\t\tconsole.error( \"  trying to update property for track: \" + nodeName +\r\n\t\t\t\t\t\t'.' + propertyName + \" but it wasn't found.\", targetObject );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// determine versioning scheme\r\n\t\t\tvar versioning = this.Versioning.None;\r\n\t\r\n\t\t\tif ( targetObject.needsUpdate !== undefined ) { // material\r\n\t\r\n\t\t\t\tversioning = this.Versioning.NeedsUpdate;\r\n\t\t\t\tthis.targetObject = targetObject;\r\n\t\r\n\t\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\r\n\t\r\n\t\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\r\n\t\t\t\tthis.targetObject = targetObject;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// determine how the property gets bound\r\n\t\t\tvar bindingType = this.BindingType.Direct;\r\n\t\r\n\t\t\tif ( propertyIndex !== undefined ) {\r\n\t\t\t\t// access a sub element of the property array (only primitives are supported right now)\r\n\t\r\n\t\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\r\n\t\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\r\n\t\r\n\t\t\t\t\t// support resolving morphTarget names into indices.\r\n\t\t\t\t\tif ( ! targetObject.geometry ) {\r\n\t\r\n\t\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );\r\n\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( ! targetObject.geometry.morphTargets ) {\r\n\t\r\n\t\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );\r\n\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tif ( targetObject.geometry.morphTargets[i].name === propertyIndex ) {\r\n\t\r\n\t\t\t\t\t\t\tpropertyIndex = i;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tbindingType = this.BindingType.ArrayElement;\r\n\t\r\n\t\t\t\tthis.resolvedProperty = nodeProperty;\r\n\t\t\t\tthis.propertyIndex = propertyIndex;\r\n\t\r\n\t\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\r\n\t\t\t\t// must use copy for Object3D.Euler/Quaternion\r\n\t\r\n\t\t\t\tbindingType = this.BindingType.HasFromToArray;\r\n\t\r\n\t\t\t\tthis.resolvedProperty = nodeProperty;\r\n\t\r\n\t\t\t} else if ( nodeProperty.length !== undefined ) {\r\n\t\r\n\t\t\t\tbindingType = this.BindingType.EntireArray;\r\n\t\r\n\t\t\t\tthis.resolvedProperty = nodeProperty;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.propertyName = propertyName;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// select getter / setter\r\n\t\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\r\n\t\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tunbind: function() {\r\n\t\r\n\t\t\tthis.node = null;\r\n\t\r\n\t\t\t// back to the prototype version of getValue / setValue\r\n\t\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\r\n\t\t\tthis.getValue = this._getValue_unbound;\r\n\t\t\tthis.setValue = this._setValue_unbound;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tObject.assign( THREE.PropertyBinding.prototype, { // prototype, continued\r\n\t\r\n\t\t// these are used to \"bind\" a nonexistent property\r\n\t\t_getValue_unavailable: function() {},\r\n\t\t_setValue_unavailable: function() {},\r\n\t\r\n\t\t// initial state of these methods that calls 'bind'\r\n\t\t_getValue_unbound: THREE.PropertyBinding.prototype.getValue,\r\n\t\t_setValue_unbound: THREE.PropertyBinding.prototype.setValue,\r\n\t\r\n\t\tBindingType: {\r\n\t\t\tDirect: 0,\r\n\t\t\tEntireArray: 1,\r\n\t\t\tArrayElement: 2,\r\n\t\t\tHasFromToArray: 3\r\n\t\t},\r\n\t\r\n\t\tVersioning: {\r\n\t\t\tNone: 0,\r\n\t\t\tNeedsUpdate: 1,\r\n\t\t\tMatrixWorldNeedsUpdate: 2\r\n\t\t},\r\n\t\r\n\t\tGetterByBindingType: [\r\n\t\r\n\t\t\tfunction getValue_direct( buffer, offset ) {\r\n\t\r\n\t\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tfunction getValue_array( buffer, offset ) {\r\n\t\r\n\t\t\t\tvar source = this.resolvedProperty;\r\n\t\r\n\t\t\t\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\tbuffer[ offset ++ ] = source[ i ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tfunction getValue_arrayElement( buffer, offset ) {\r\n\t\r\n\t\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tfunction getValue_toArray( buffer, offset ) {\r\n\t\r\n\t\t\t\tthis.resolvedProperty.toArray( buffer, offset );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t],\r\n\t\r\n\t\tSetterByBindingTypeAndVersioning: [\r\n\t\r\n\t\t\t[\r\n\t\t\t\t// Direct\r\n\t\r\n\t\t\t\tfunction setValue_direct( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\r\n\t\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\r\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\t\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\r\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t], [\r\n\t\r\n\t\t\t\t// EntireArray\r\n\t\r\n\t\t\t\tfunction setValue_array( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tvar dest = this.resolvedProperty;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tvar dest = this.resolvedProperty;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\t\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tvar dest = this.resolvedProperty;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t], [\r\n\t\r\n\t\t\t\t// ArrayElement\r\n\t\r\n\t\t\t\tfunction setValue_arrayElement( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\r\n\t\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\r\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\t\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\r\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t], [\r\n\t\r\n\t\t\t\t// HasToFromArray\r\n\t\r\n\t\t\t\tfunction setValue_fromArray( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\r\n\t\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\r\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\t\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\r\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t]\r\n\t\r\n\t\t]\r\n\t\r\n\t} );\r\n\t\r\n\tTHREE.PropertyBinding.Composite =\r\n\t\t\tfunction( targetGroup, path, optionalParsedPath ) {\r\n\t\r\n\t\tvar parsedPath = optionalParsedPath ||\r\n\t\t\t\tTHREE.PropertyBinding.parseTrackName( path );\r\n\t\r\n\t\tthis._targetGroup = targetGroup;\r\n\t\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PropertyBinding.Composite.prototype = {\r\n\t\r\n\t\tconstructor: THREE.PropertyBinding.Composite,\r\n\t\r\n\t\tgetValue: function( array, offset ) {\r\n\t\r\n\t\t\tthis.bind(); // bind all binding\r\n\t\r\n\t\t\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\r\n\t\t\t\tbinding = this._bindings[ firstValidIndex ];\r\n\t\r\n\t\t\t// and only call .getValue on the first\r\n\t\t\tif ( binding !== undefined ) binding.getValue( array, offset );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetValue: function( array, offset ) {\r\n\t\r\n\t\t\tvar bindings = this._bindings;\r\n\t\r\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\r\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tbindings[ i ].setValue( array, offset );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tbind: function() {\r\n\t\r\n\t\t\tvar bindings = this._bindings;\r\n\t\r\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\r\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tbindings[ i ].bind();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tunbind: function() {\r\n\t\r\n\t\t\tvar bindings = this._bindings;\r\n\t\r\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\r\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tbindings[ i ].unbind();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PropertyBinding.create = function( root, path, parsedPath ) {\r\n\t\r\n\t\tif ( ! ( root instanceof THREE.AnimationObjectGroup ) ) {\r\n\t\r\n\t\t\treturn new THREE.PropertyBinding( root, path, parsedPath );\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\treturn new THREE.PropertyBinding.Composite( root, path, parsedPath );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PropertyBinding.parseTrackName = function( trackName ) {\r\n\t\r\n\t\t// matches strings in the form of:\r\n\t\t//    nodeName.property\r\n\t\t//    nodeName.property[accessor]\r\n\t\t//    nodeName.material.property[accessor]\r\n\t\t//    uuid.property[accessor]\r\n\t\t//    uuid.objectName[objectIndex].propertyName[propertyIndex]\r\n\t\t//    parentName/nodeName.property\r\n\t\t//    parentName/parentName/nodeName.property[index]\r\n\t\t//\t  .bone[Armature.DEF_cog].position\r\n\t\t// created and tested via https://regex101.com/#javascript\r\n\t\r\n\t\tvar re = /^(([\\w]+\\/)*)([\\w-\\d]+)?(\\.([\\w]+)(\\[([\\w\\d\\[\\]\\_.:\\- ]+)\\])?)?(\\.([\\w.]+)(\\[([\\w\\d\\[\\]\\_. ]+)\\])?)$/;\r\n\t\tvar matches = re.exec(trackName);\r\n\t\r\n\t\tif( ! matches ) {\r\n\t\t\tthrow new Error( \"cannot parse trackName at all: \" + trackName );\r\n\t\t}\r\n\t\r\n\t    if (matches.index === re.lastIndex) {\r\n\t        re.lastIndex++;\r\n\t    }\r\n\t\r\n\t\tvar results = {\r\n\t\t\t// directoryName: matches[1], // (tschw) currently unused\r\n\t\t\tnodeName: matches[3], \t// allowed to be null, specified root node.\r\n\t\t\tobjectName: matches[5],\r\n\t\t\tobjectIndex: matches[7],\r\n\t\t\tpropertyName: matches[9],\r\n\t\t\tpropertyIndex: matches[11]\t// allowed to be null, specifies that the whole property is set.\r\n\t\t};\r\n\t\r\n\t\tif( results.propertyName === null || results.propertyName.length === 0 ) {\r\n\t\t\tthrow new Error( \"can not parse propertyName from trackName: \" + trackName );\r\n\t\t}\r\n\t\r\n\t\treturn results;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PropertyBinding.findNode = function( root, nodeName ) {\r\n\t\r\n\t\tif( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {\r\n\t\r\n\t\t\treturn root;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// search into skeleton bones.\r\n\t\tif( root.skeleton ) {\r\n\t\r\n\t\t\tvar searchSkeleton = function( skeleton ) {\r\n\t\r\n\t\t\t\tfor( var i = 0; i < skeleton.bones.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar bone = skeleton.bones[i];\r\n\t\r\n\t\t\t\t\tif( bone.name === nodeName ) {\r\n\t\r\n\t\t\t\t\t\treturn bone;\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn null;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tvar bone = searchSkeleton( root.skeleton );\r\n\t\r\n\t\t\tif( bone ) {\r\n\t\r\n\t\t\t\treturn bone;\r\n\t\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\t// search into node subtree.\r\n\t\tif( root.children ) {\r\n\t\r\n\t\t\tvar searchNodeSubtree = function( children ) {\r\n\t\r\n\t\t\t\tfor( var i = 0; i < children.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar childNode = children[i];\r\n\t\r\n\t\t\t\t\tif( childNode.name === nodeName || childNode.uuid === nodeName ) {\r\n\t\r\n\t\t\t\t\t\treturn childNode;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar result = searchNodeSubtree( childNode.children );\r\n\t\r\n\t\t\t\t\tif( result ) return result;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn null;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tvar subTreeNode = searchNodeSubtree( root.children );\r\n\t\r\n\t\t\tif( subTreeNode ) {\r\n\t\r\n\t\t\t\treturn subTreeNode;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn null;\r\n\t\r\n\t}\r\n\t\r\n\t// File:src/animation/PropertyMixer.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * Buffered scene graph property that allows weighted accumulation.\r\n\t *\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.PropertyMixer = function ( binding, typeName, valueSize ) {\r\n\t\r\n\t\tthis.binding = binding;\r\n\t\tthis.valueSize = valueSize;\r\n\t\r\n\t\tvar bufferType = Float64Array,\r\n\t\t\tmixFunction;\r\n\t\r\n\t\tswitch ( typeName ) {\r\n\t\r\n\t\t\tcase 'quaternion':\t\t\tmixFunction = this._slerp;\t\tbreak;\r\n\t\r\n\t\t\tcase 'string':\r\n\t\t\tcase 'bool':\r\n\t\r\n\t\t\t\tbufferType = Array,\t\tmixFunction = this._select;\t\tbreak;\r\n\t\r\n\t\t\tdefault:\t\t\t\t\tmixFunction = this._lerp;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.buffer = new bufferType( valueSize * 4 );\r\n\t\t// layout: [ incoming | accu0 | accu1 | orig ]\r\n\t\t//\r\n\t\t// interpolators can use .buffer as their .result\r\n\t\t// the data then goes to 'incoming'\r\n\t\t//\r\n\t\t// 'accu0' and 'accu1' are used frame-interleaved for\r\n\t\t// the cumulative result and are compared to detect\r\n\t\t// changes\r\n\t\t//\r\n\t\t// 'orig' stores the original state of the property\r\n\t\r\n\t\tthis._mixBufferRegion = mixFunction;\r\n\t\r\n\t\tthis.cumulativeWeight = 0;\r\n\t\r\n\t\tthis.useCount = 0;\r\n\t\tthis.referenceCount = 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PropertyMixer.prototype = {\r\n\t\r\n\t\tconstructor: THREE.PropertyMixer,\r\n\t\r\n\t\t// accumulate data in the 'incoming' region into 'accu<i>'\r\n\t\taccumulate: function( accuIndex, weight ) {\r\n\t\r\n\t\t\t// note: happily accumulating nothing when weight = 0, the caller knows\r\n\t\t\t// the weight and shouldn't have made the call in the first place\r\n\t\r\n\t\t\tvar buffer = this.buffer,\r\n\t\t\t\tstride = this.valueSize,\r\n\t\t\t\toffset = accuIndex * stride + stride,\r\n\t\r\n\t\t\t\tcurrentWeight = this.cumulativeWeight;\r\n\t\r\n\t\t\tif ( currentWeight === 0 ) {\r\n\t\r\n\t\t\t\t// accuN := incoming * weight\r\n\t\r\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\t\r\n\t\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcurrentWeight = weight;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// accuN := accuN + incoming * weight\r\n\t\r\n\t\t\t\tcurrentWeight += weight;\r\n\t\t\t\tvar mix = weight / currentWeight;\r\n\t\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.cumulativeWeight = currentWeight;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// apply the state of 'accu<i>' to the binding when accus differ\r\n\t\tapply: function( accuIndex ) {\r\n\t\r\n\t\t\tvar stride = this.valueSize,\r\n\t\t\t\tbuffer = this.buffer,\r\n\t\t\t\toffset = accuIndex * stride + stride,\r\n\t\r\n\t\t\t\tweight = this.cumulativeWeight,\r\n\t\r\n\t\t\t\tbinding = this.binding;\r\n\t\r\n\t\t\tthis.cumulativeWeight = 0;\r\n\t\r\n\t\t\tif ( weight < 1 ) {\r\n\t\r\n\t\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\r\n\t\r\n\t\t\t\tvar originalValueOffset = stride * 3;\r\n\t\r\n\t\t\t\tthis._mixBufferRegion(\r\n\t\t\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\r\n\t\r\n\t\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\r\n\t\r\n\t\t\t\t\t// value has changed -> update scene graph\r\n\t\r\n\t\t\t\t\tbinding.setValue( buffer, offset );\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// remember the state of the bound property and copy it to both accus\r\n\t\tsaveOriginalState: function() {\r\n\t\r\n\t\t\tvar binding = this.binding;\r\n\t\r\n\t\t\tvar buffer = this.buffer,\r\n\t\t\t\tstride = this.valueSize,\r\n\t\r\n\t\t\t\toriginalValueOffset = stride * 3;\r\n\t\r\n\t\t\tbinding.getValue( buffer, originalValueOffset );\r\n\t\r\n\t\t\t// accu[0..1] := orig -- initially detect changes against the original\r\n\t\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\r\n\t\r\n\t\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.cumulativeWeight = 0;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// apply the state previously taken via 'saveOriginalState' to the binding\r\n\t\trestoreOriginalState: function() {\r\n\t\r\n\t\t\tvar originalValueOffset = this.valueSize * 3;\r\n\t\t\tthis.binding.setValue( this.buffer, originalValueOffset );\r\n\t\r\n\t\t},\r\n\t\r\n\t\r\n\t\t// mix functions\r\n\t\r\n\t\t_select: function( buffer, dstOffset, srcOffset, t, stride ) {\r\n\t\r\n\t\t\tif ( t >= 0.5 ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\t\r\n\t\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {\r\n\t\r\n\t\t\tTHREE.Quaternion.slerpFlat( buffer, dstOffset,\r\n\t\t\t\t\tbuffer, dstOffset, buffer, srcOffset, t );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {\r\n\t\r\n\t\t\tvar s = 1 - t;\r\n\t\r\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\t\r\n\t\t\t\tvar j = dstOffset + i;\r\n\t\r\n\t\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/animation/tracks/BooleanKeyframeTrack.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * A Track of Boolean keyframe values.\r\n\t *\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.BooleanKeyframeTrack = function ( name, times, values ) {\r\n\t\r\n\t\tTHREE.KeyframeTrack.call( this, name, times, values );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BooleanKeyframeTrack.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.BooleanKeyframeTrack,\r\n\t\r\n\t\tValueTypeName: 'bool',\r\n\t\tValueBufferType: Array,\r\n\t\r\n\t\tDefaultInterpolation: THREE.IntepolateDiscrete,\r\n\t\r\n\t\tInterpolantFactoryMethodLinear: undefined,\r\n\t\tInterpolantFactoryMethodSmooth: undefined\r\n\t\r\n\t\t// Note: Actually this track could have a optimized / compressed\r\n\t\t// representation of a single value and a custom interpolant that\r\n\t\t// computes \"firstValue ^ isOdd( index )\".\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/animation/tracks/NumberKeyframeTrack.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * A Track of numeric keyframe values.\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.NumberKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\t\r\n\t\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.NumberKeyframeTrack.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.NumberKeyframeTrack,\r\n\t\r\n\t\tValueTypeName: 'number',\r\n\t\r\n\t\t// ValueBufferType is inherited\r\n\t\r\n\t\t// DefaultInterpolation is inherited\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/animation/tracks/QuaternionKeyframeTrack.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * A Track of quaternion keyframe values.\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.QuaternionKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\t\r\n\t\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.QuaternionKeyframeTrack.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.QuaternionKeyframeTrack,\r\n\t\r\n\t\tValueTypeName: 'quaternion',\r\n\t\r\n\t\t// ValueBufferType is inherited\r\n\t\r\n\t\tDefaultInterpolation: THREE.InterpolateLinear,\r\n\t\r\n\t\tInterpolantFactoryMethodLinear: function( result ) {\r\n\t\r\n\t\t\treturn new THREE.QuaternionLinearInterpolant(\r\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/animation/tracks/StringKeyframeTrack.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * A Track that interpolates Strings\r\n\t *\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.StringKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\t\r\n\t\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.StringKeyframeTrack.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.StringKeyframeTrack,\r\n\t\r\n\t\tValueTypeName: 'string',\r\n\t\tValueBufferType: Array,\r\n\t\r\n\t\tDefaultInterpolation: THREE.IntepolateDiscrete,\r\n\t\r\n\t\tInterpolantFactoryMethodLinear: undefined,\r\n\t\r\n\t\tInterpolantFactoryMethodSmooth: undefined\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/animation/tracks/VectorKeyframeTrack.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * A Track of vectored keyframe values.\r\n\t *\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.VectorKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\t\r\n\t\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.VectorKeyframeTrack.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.VectorKeyframeTrack,\r\n\t\r\n\t\tValueTypeName: 'vector'\r\n\t\r\n\t\t// ValueBufferType is inherited\r\n\t\r\n\t\t// DefaultInterpolation is inherited\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/audio/Audio.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Audio = function ( listener ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Audio';\r\n\t\r\n\t\tthis.context = listener.context;\r\n\t\tthis.source = this.context.createBufferSource();\r\n\t\tthis.source.onended = this.onEnded.bind( this );\r\n\t\r\n\t\tthis.gain = this.context.createGain();\r\n\t\tthis.gain.connect( listener.getInput() );\r\n\t\r\n\t\tthis.autoplay = false;\r\n\t\r\n\t\tthis.startTime = 0;\r\n\t\tthis.playbackRate = 1;\r\n\t\tthis.isPlaying = false;\r\n\t\tthis.hasPlaybackControl = true;\r\n\t\tthis.sourceType = 'empty';\r\n\t\r\n\t\tthis.filter = null;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Audio.prototype.constructor = THREE.Audio;\r\n\t\r\n\tTHREE.Audio.prototype.getOutput = function () {\r\n\t\r\n\t\treturn this.gain;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.load = function ( file ) {\r\n\t\r\n\t\tvar buffer = new THREE.AudioBuffer( this.context );\r\n\t\tbuffer.load( file );\r\n\t\r\n\t\tthis.setBuffer( buffer );\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.setNodeSource = function ( audioNode ) {\r\n\t\r\n\t\tthis.hasPlaybackControl = false;\r\n\t\tthis.sourceType = 'audioNode';\r\n\t\tthis.source = audioNode;\r\n\t\tthis.connect();\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.setBuffer = function ( audioBuffer ) {\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\taudioBuffer.onReady( function( buffer ) {\r\n\t\r\n\t\t\tscope.source.buffer = buffer;\r\n\t\t\tscope.sourceType = 'buffer';\r\n\t\t\tif ( scope.autoplay ) scope.play();\r\n\t\r\n\t\t} );\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.play = function () {\r\n\t\r\n\t\tif ( this.isPlaying === true ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\r\n\t\t\treturn;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tif ( this.hasPlaybackControl === false ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\t\treturn;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar source = this.context.createBufferSource();\r\n\t\r\n\t\tsource.buffer = this.source.buffer;\r\n\t\tsource.loop = this.source.loop;\r\n\t\tsource.onended = this.source.onended;\r\n\t\tsource.start( 0, this.startTime );\r\n\t\tsource.playbackRate.value = this.playbackRate;\r\n\t\r\n\t\tthis.isPlaying = true;\r\n\t\r\n\t\tthis.source = source;\r\n\t\r\n\t\tthis.connect();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.pause = function () {\r\n\t\r\n\t\tif ( this.hasPlaybackControl === false ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\t\treturn;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.source.stop();\r\n\t\tthis.startTime = this.context.currentTime;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.stop = function () {\r\n\t\r\n\t\tif ( this.hasPlaybackControl === false ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\t\treturn;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.source.stop();\r\n\t\tthis.startTime = 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.connect = function () {\r\n\t\r\n\t\tif ( this.filter !== null ) {\r\n\t\r\n\t\t\tthis.source.connect( this.filter );\r\n\t\t\tthis.filter.connect( this.getOutput() );\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.source.connect( this.getOutput() );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.disconnect = function () {\r\n\t\r\n\t\tif ( this.filter !== null ) {\r\n\t\r\n\t\t\tthis.source.disconnect( this.filter );\r\n\t\t\tthis.filter.disconnect( this.getOutput() );\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.source.disconnect( this.getOutput() );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.getFilter = function () {\r\n\t\r\n\t\treturn this.filter;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.setFilter = function ( value ) {\r\n\t\r\n\t\tif ( value === undefined ) value = null;\r\n\t\r\n\t\tif ( this.isPlaying === true ) {\r\n\t\r\n\t\t\tthis.disconnect();\r\n\t\t\tthis.filter = value;\r\n\t\t\tthis.connect();\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.filter = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.setPlaybackRate = function ( value ) {\r\n\t\r\n\t\tif ( this.hasPlaybackControl === false ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\t\treturn;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.playbackRate = value;\r\n\t\r\n\t\tif ( this.isPlaying === true ) {\r\n\t\r\n\t\t\tthis.source.playbackRate.value = this.playbackRate;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.getPlaybackRate = function () {\r\n\t\r\n\t\treturn this.playbackRate;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.onEnded = function() {\r\n\t\r\n\t\tthis.isPlaying = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.setLoop = function ( value ) {\r\n\t\r\n\t\tif ( this.hasPlaybackControl === false ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\t\treturn;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.source.loop = value;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.getLoop = function () {\r\n\t\r\n\t\tif ( this.hasPlaybackControl === false ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\t\treturn false;\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn this.source.loop;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.Audio.prototype.setVolume = function ( value ) {\r\n\t\r\n\t\tthis.gain.gain.value = value;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype.getVolume = function () {\r\n\t\r\n\t\treturn this.gain.gain.value;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/audio/AudioAnalyser.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.AudioAnalyser = function ( audio, fftSize ) {\r\n\t\r\n\t\tthis.analyser = audio.context.createAnalyser();\r\n\t\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\r\n\t\r\n\t\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\r\n\t\r\n\t\taudio.getOutput().connect( this.analyser );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AudioAnalyser.prototype = {\r\n\t\r\n\t\tconstructor: THREE.AudioAnalyser,\r\n\t\r\n\t\tgetData: function () {\r\n\t\r\n\t\t\tthis.analyser.getByteFrequencyData( this.data );\r\n\t\t\treturn this.data;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/audio/AudioBuffer.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.AudioBuffer = function ( context ) {\r\n\t\r\n\t\tthis.context = context;\r\n\t\tthis.ready = false;\r\n\t\tthis.readyCallbacks = [];\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AudioBuffer.prototype.load = function ( file ) {\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\tvar request = new XMLHttpRequest();\r\n\t\trequest.open( 'GET', file, true );\r\n\t\trequest.responseType = 'arraybuffer';\r\n\t\trequest.onload = function ( e ) {\r\n\t\r\n\t\t\tscope.context.decodeAudioData( this.response, function ( buffer ) {\r\n\t\r\n\t\t\t\tscope.buffer = buffer;\r\n\t\t\t\tscope.ready = true;\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < scope.readyCallbacks.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tscope.readyCallbacks[ i ]( scope.buffer );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tscope.readyCallbacks = [];\r\n\t\r\n\t\t\t} );\r\n\t\r\n\t\t};\r\n\t\trequest.send();\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AudioBuffer.prototype.onReady = function ( callback ) {\r\n\t\r\n\t\tif ( this.ready ) {\r\n\t\r\n\t\t\tcallback( this.buffer );\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.readyCallbacks.push( callback );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/audio/PositionalAudio.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.PositionalAudio = function ( listener ) {\r\n\t\r\n\t\tTHREE.Audio.call( this, listener );\r\n\t\r\n\t\tthis.panner = this.context.createPanner();\r\n\t\tthis.panner.connect( this.gain );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PositionalAudio.prototype = Object.create( THREE.Audio.prototype );\r\n\tTHREE.PositionalAudio.prototype.constructor = THREE.PositionalAudio;\r\n\t\r\n\tTHREE.PositionalAudio.prototype.getOutput = function () {\r\n\t\r\n\t\treturn this.panner;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PositionalAudio.prototype.setRefDistance = function ( value ) {\r\n\t\r\n\t\tthis.panner.refDistance = value;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PositionalAudio.prototype.getRefDistance = function () {\r\n\t\r\n\t\treturn this.panner.refDistance;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PositionalAudio.prototype.setRolloffFactor = function ( value ) {\r\n\t\r\n\t\tthis.panner.rolloffFactor = value;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PositionalAudio.prototype.getRolloffFactor = function () {\r\n\t\r\n\t\treturn this.panner.rolloffFactor;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PositionalAudio.prototype.setDistanceModel = function ( value ) {\r\n\t\r\n\t\tthis.panner.distanceModel = value;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PositionalAudio.prototype.getDistanceModel = function () {\r\n\t\r\n\t\treturn this.panner.distanceModel;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PositionalAudio.prototype.setMaxDistance = function ( value ) {\r\n\t\r\n\t\tthis.panner.maxDistance = value;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PositionalAudio.prototype.getMaxDistance = function () {\r\n\t\r\n\t\treturn this.panner.maxDistance;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PositionalAudio.prototype.updateMatrixWorld = ( function () {\r\n\t\r\n\t\tvar position = new THREE.Vector3();\r\n\t\r\n\t\treturn function updateMatrixWorld( force ) {\r\n\t\r\n\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\r\n\t\r\n\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\r\n\t\r\n\t\t\tthis.panner.setPosition( position.x, position.y, position.z );\r\n\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\t// File:src/audio/AudioListener.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.AudioListener = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'AudioListener';\r\n\t\r\n\t\tthis.context = new ( window.AudioContext || window.webkitAudioContext )();\r\n\t\r\n\t\tthis.gain = this.context.createGain();\r\n\t\tthis.gain.connect( this.context.destination );\r\n\t\r\n\t\tthis.filter = null;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.AudioListener.prototype.constructor = THREE.AudioListener;\r\n\t\r\n\tTHREE.AudioListener.prototype.getInput = function () {\r\n\t\r\n\t\treturn this.gain;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AudioListener.prototype.removeFilter = function ( ) {\r\n\t\r\n\t\tif ( this.filter !== null ) {\r\n\t\r\n\t\t\tthis.gain.disconnect( this.filter );\r\n\t\t\tthis.filter.disconnect( this.context.destination );\r\n\t\t\tthis.gain.connect( this.context.destination );\r\n\t\t\tthis.filter = null;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AudioListener.prototype.setFilter = function ( value ) {\r\n\t\r\n\t\tif ( this.filter !== null ) {\r\n\t\r\n\t\t\tthis.gain.disconnect( this.filter );\r\n\t\t\tthis.filter.disconnect( this.context.destination );\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.gain.disconnect( this.context.destination );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.filter = value;\r\n\t\tthis.gain.connect( this.filter );\r\n\t\tthis.filter.connect( this.context.destination );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AudioListener.prototype.getFilter = function () {\r\n\t\r\n\t\treturn this.filter;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AudioListener.prototype.setMasterVolume = function ( value ) {\r\n\t\r\n\t\tthis.gain.gain.value = value;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AudioListener.prototype.getMasterVolume = function () {\r\n\t\r\n\t\treturn this.gain.gain.value;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.AudioListener.prototype.updateMatrixWorld = ( function () {\r\n\t\r\n\t\tvar position = new THREE.Vector3();\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\t\tvar scale = new THREE.Vector3();\r\n\t\r\n\t\tvar orientation = new THREE.Vector3();\r\n\t\r\n\t\treturn function updateMatrixWorld( force ) {\r\n\t\r\n\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\r\n\t\r\n\t\t\tvar listener = this.context.listener;\r\n\t\t\tvar up = this.up;\r\n\t\r\n\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\r\n\t\r\n\t\t\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\r\n\t\r\n\t\t\tlistener.setPosition( position.x, position.y, position.z );\r\n\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\r\n\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\t// File:src/cameras/Camera.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t*/\r\n\t\r\n\tTHREE.Camera = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Camera';\r\n\t\r\n\t\tthis.matrixWorldInverse = new THREE.Matrix4();\r\n\t\tthis.projectionMatrix = new THREE.Matrix4();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Camera.prototype.constructor = THREE.Camera;\r\n\t\r\n\tTHREE.Camera.prototype.getWorldDirection = function () {\r\n\t\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\t\r\n\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\tthis.getWorldQuaternion( quaternion );\r\n\t\r\n\t\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\tTHREE.Camera.prototype.lookAt = function () {\r\n\t\r\n\t\t// This routine does not support cameras with rotated and/or translated parent(s)\r\n\t\r\n\t\tvar m1 = new THREE.Matrix4();\r\n\t\r\n\t\treturn function ( vector ) {\r\n\t\r\n\t\t\tm1.lookAt( this.position, vector, this.up );\r\n\t\r\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\tTHREE.Camera.prototype.clone = function () {\r\n\t\r\n\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Camera.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\r\n\t\tthis.projectionMatrix.copy( source.projectionMatrix );\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/cameras/CubeCamera.js\r\n\t\r\n\t/**\r\n\t * Camera for rendering cube maps\r\n\t *\t- renders scene into axis-aligned cube\r\n\t *\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.CubeCamera = function ( near, far, cubeResolution ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'CubeCamera';\r\n\t\r\n\t\tvar fov = 90, aspect = 1;\r\n\t\r\n\t\tvar cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraPX.up.set( 0, - 1, 0 );\r\n\t\tcameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\r\n\t\tthis.add( cameraPX );\r\n\t\r\n\t\tvar cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraNX.up.set( 0, - 1, 0 );\r\n\t\tcameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );\r\n\t\tthis.add( cameraNX );\r\n\t\r\n\t\tvar cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraPY.up.set( 0, 0, 1 );\r\n\t\tcameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\r\n\t\tthis.add( cameraPY );\r\n\t\r\n\t\tvar cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraNY.up.set( 0, 0, - 1 );\r\n\t\tcameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );\r\n\t\tthis.add( cameraNY );\r\n\t\r\n\t\tvar cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraPZ.up.set( 0, - 1, 0 );\r\n\t\tcameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\r\n\t\tthis.add( cameraPZ );\r\n\t\r\n\t\tvar cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraNZ.up.set( 0, - 1, 0 );\r\n\t\tcameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );\r\n\t\tthis.add( cameraNZ );\r\n\t\r\n\t\tvar options = { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };\r\n\t\r\n\t\tthis.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\r\n\t\r\n\t\tthis.updateCubeMap = function ( renderer, scene ) {\r\n\t\r\n\t\t\tif ( this.parent === null ) this.updateMatrixWorld();\r\n\t\r\n\t\t\tvar renderTarget = this.renderTarget;\r\n\t\t\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\r\n\t\r\n\t\t\trenderTarget.texture.generateMipmaps = false;\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 0;\r\n\t\t\trenderer.render( scene, cameraPX, renderTarget );\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 1;\r\n\t\t\trenderer.render( scene, cameraNX, renderTarget );\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 2;\r\n\t\t\trenderer.render( scene, cameraPY, renderTarget );\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 3;\r\n\t\t\trenderer.render( scene, cameraNY, renderTarget );\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 4;\r\n\t\t\trenderer.render( scene, cameraPZ, renderTarget );\r\n\t\r\n\t\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 5;\r\n\t\t\trenderer.render( scene, cameraNZ, renderTarget );\r\n\t\r\n\t\t\trenderer.setRenderTarget( null );\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.CubeCamera.prototype.constructor = THREE.CubeCamera;\r\n\t\r\n\t// File:src/cameras/OrthographicCamera.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\r\n\t\r\n\t\tTHREE.Camera.call( this );\r\n\t\r\n\t\tthis.type = 'OrthographicCamera';\r\n\t\r\n\t\tthis.zoom = 1;\r\n\t\r\n\t\tthis.left = left;\r\n\t\tthis.right = right;\r\n\t\tthis.top = top;\r\n\t\tthis.bottom = bottom;\r\n\t\r\n\t\tthis.near = ( near !== undefined ) ? near : 0.1;\r\n\t\tthis.far = ( far !== undefined ) ? far : 2000;\r\n\t\r\n\t\tthis.updateProjectionMatrix();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );\r\n\tTHREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;\r\n\t\r\n\tTHREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {\r\n\t\r\n\t\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\r\n\t\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\r\n\t\tvar cx = ( this.right + this.left ) / 2;\r\n\t\tvar cy = ( this.top + this.bottom ) / 2;\r\n\t\r\n\t\tthis.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.OrthographicCamera.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Camera.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.left = source.left;\r\n\t\tthis.right = source.right;\r\n\t\tthis.top = source.top;\r\n\t\tthis.bottom = source.bottom;\r\n\t\tthis.near = source.near;\r\n\t\tthis.far = source.far;\r\n\t\r\n\t\tthis.zoom = source.zoom;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.OrthographicCamera.prototype.toJSON = function ( meta ) {\r\n\t\r\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\t\r\n\t\tdata.object.zoom = this.zoom;\r\n\t\tdata.object.left = this.left;\r\n\t\tdata.object.right = this.right;\r\n\t\tdata.object.top = this.top;\r\n\t\tdata.object.bottom = this.bottom;\r\n\t\tdata.object.near = this.near;\r\n\t\tdata.object.far = this.far;\r\n\t\r\n\t\treturn data;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/cameras/PerspectiveCamera.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author greggman / http://games.greggman.com/\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t */\r\n\t\r\n\tTHREE.PerspectiveCamera = function ( fov, aspect, near, far ) {\r\n\t\r\n\t\tTHREE.Camera.call( this );\r\n\t\r\n\t\tthis.type = 'PerspectiveCamera';\r\n\t\r\n\t\tthis.focalLength = 10;\r\n\t\tthis.zoom = 1;\r\n\t\r\n\t\tthis.fov = fov !== undefined ? fov : 50;\r\n\t\tthis.aspect = aspect !== undefined ? aspect : 1;\r\n\t\tthis.near = near !== undefined ? near : 0.1;\r\n\t\tthis.far = far !== undefined ? far : 2000;\r\n\t\r\n\t\tthis.updateProjectionMatrix();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );\r\n\tTHREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;\r\n\t\r\n\t\r\n\t/**\r\n\t * Uses Focal Length (in mm) to estimate and set FOV\r\n\t * 35mm (full-frame) camera is used if frame size is not specified;\r\n\t * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\r\n\t */\r\n\t\r\n\tTHREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {\r\n\t\r\n\t\tif ( frameHeight === undefined ) frameHeight = 24;\r\n\t\r\n\t\tthis.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );\r\n\t\tthis.updateProjectionMatrix();\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t/**\r\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\r\n\t * multi-monitor/multi-machine setups.\r\n\t *\r\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\r\n\t * the monitors are in grid like this\r\n\t *\r\n\t *   +---+---+---+\r\n\t *   | A | B | C |\r\n\t *   +---+---+---+\r\n\t *   | D | E | F |\r\n\t *   +---+---+---+\r\n\t *\r\n\t * then for each monitor you would call it like this\r\n\t *\r\n\t *   var w = 1920;\r\n\t *   var h = 1080;\r\n\t *   var fullWidth = w * 3;\r\n\t *   var fullHeight = h * 2;\r\n\t *\r\n\t *   --A--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\r\n\t *   --B--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\r\n\t *   --C--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\r\n\t *   --D--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\r\n\t *   --E--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\r\n\t *   --F--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\r\n\t *\r\n\t *   Note there is no reason monitors have to be the same size or in a grid.\r\n\t */\r\n\t\r\n\tTHREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {\r\n\t\r\n\t\tthis.fullWidth = fullWidth;\r\n\t\tthis.fullHeight = fullHeight;\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.width = width;\r\n\t\tthis.height = height;\r\n\t\r\n\t\tthis.updateProjectionMatrix();\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {\r\n\t\r\n\t\tvar fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );\r\n\t\r\n\t\tif ( this.fullWidth ) {\r\n\t\r\n\t\t\tvar aspect = this.fullWidth / this.fullHeight;\r\n\t\t\tvar top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;\r\n\t\t\tvar bottom = - top;\r\n\t\t\tvar left = aspect * bottom;\r\n\t\t\tvar right = aspect * top;\r\n\t\t\tvar width = Math.abs( right - left );\r\n\t\t\tvar height = Math.abs( top - bottom );\r\n\t\r\n\t\t\tthis.projectionMatrix.makeFrustum(\r\n\t\t\t\tleft + this.x * width / this.fullWidth,\r\n\t\t\t\tleft + ( this.x + this.width ) * width / this.fullWidth,\r\n\t\t\t\ttop - ( this.y + this.height ) * height / this.fullHeight,\r\n\t\t\t\ttop - this.y * height / this.fullHeight,\r\n\t\t\t\tthis.near,\r\n\t\t\t\tthis.far\r\n\t\t\t);\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PerspectiveCamera.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Camera.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.focalLength = source.focalLength;\r\n\t\tthis.zoom = source.zoom;\r\n\t\r\n\t\tthis.fov = source.fov;\r\n\t\tthis.aspect = source.aspect;\r\n\t\tthis.near = source.near;\r\n\t\tthis.far = source.far;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PerspectiveCamera.prototype.toJSON = function ( meta ) {\r\n\t\r\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\t\r\n\t\tdata.object.focalLength = this.focalLength;\r\n\t\tdata.object.zoom = this.zoom;\r\n\t\r\n\t\tdata.object.fov = this.fov;\r\n\t\tdata.object.aspect = this.aspect;\r\n\t\tdata.object.near = this.near;\r\n\t\tdata.object.far = this.far;\r\n\t\r\n\t\treturn data;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/cameras/StereoCamera.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.StereoCamera = function () {\r\n\t\r\n\t\tthis.type = 'StereoCamera';\r\n\t\r\n\t\tthis.aspect = 1;\r\n\t\r\n\t\tthis.cameraL = new THREE.PerspectiveCamera();\r\n\t\tthis.cameraL.layers.enable( 1 );\r\n\t\tthis.cameraL.matrixAutoUpdate = false;\r\n\t\r\n\t\tthis.cameraR = new THREE.PerspectiveCamera();\r\n\t\tthis.cameraR.layers.enable( 2 );\r\n\t\tthis.cameraR.matrixAutoUpdate = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.StereoCamera.prototype = {\r\n\t\r\n\t\tconstructor: THREE.StereoCamera,\r\n\t\r\n\t\tupdate: ( function () {\r\n\t\r\n\t\t\tvar focalLength, fov, aspect, near, far;\r\n\t\r\n\t\t\tvar eyeRight = new THREE.Matrix4();\r\n\t\t\tvar eyeLeft = new THREE.Matrix4();\r\n\t\r\n\t\t\treturn function update ( camera ) {\r\n\t\r\n\t\t\t\tvar needsUpdate = focalLength !== camera.focalLength || fov !== camera.fov ||\r\n\t\t\t\t\t\t\t\t\t\t\t\t\taspect !== camera.aspect * this.aspect || near !== camera.near ||\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tfar !== camera.far;\r\n\t\r\n\t\t\t\tif ( needsUpdate ) {\r\n\t\r\n\t\t\t\t\tfocalLength = camera.focalLength;\r\n\t\t\t\t\tfov = camera.fov;\r\n\t\t\t\t\taspect = camera.aspect * this.aspect;\r\n\t\t\t\t\tnear = camera.near;\r\n\t\t\t\t\tfar = camera.far;\r\n\t\r\n\t\t\t\t\t// Off-axis stereoscopic effect based on\r\n\t\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\r\n\t\r\n\t\t\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\r\n\t\t\t\t\tvar eyeSep = 0.064 / 2;\r\n\t\t\t\t\tvar eyeSepOnProjection = eyeSep * near / focalLength;\r\n\t\t\t\t\tvar ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );\r\n\t\t\t\t\tvar xmin, xmax;\r\n\t\r\n\t\t\t\t\t// translate xOffset\r\n\t\r\n\t\t\t\t\teyeLeft.elements[ 12 ] = - eyeSep;\r\n\t\t\t\t\teyeRight.elements[ 12 ] = eyeSep;\r\n\t\r\n\t\t\t\t\t// for left eye\r\n\t\r\n\t\t\t\t\txmin = - ymax * aspect + eyeSepOnProjection;\r\n\t\t\t\t\txmax = ymax * aspect + eyeSepOnProjection;\r\n\t\r\n\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\r\n\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\r\n\t\r\n\t\t\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\r\n\t\r\n\t\t\t\t\t// for right eye\r\n\t\r\n\t\t\t\t\txmin = - ymax * aspect - eyeSepOnProjection;\r\n\t\t\t\t\txmax = ymax * aspect - eyeSepOnProjection;\r\n\t\r\n\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\r\n\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\r\n\t\r\n\t\t\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\r\n\t\t\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )()\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/lights/Light.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Light = function ( color, intensity ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Light';\r\n\t\r\n\t\tthis.color = new THREE.Color( color );\r\n\t\tthis.intensity = intensity !== undefined ? intensity : 1;\r\n\t\r\n\t\tthis.receiveShadow = undefined;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Light.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Light.prototype.constructor = THREE.Light;\r\n\t\r\n\tTHREE.Light.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.color.copy( source.color );\r\n\t\tthis.intensity = source.intensity;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Light.prototype.toJSON = function ( meta ) {\r\n\t\r\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\t\r\n\t\tdata.object.color = this.color.getHex();\r\n\t\tdata.object.intensity = this.intensity;\r\n\t\r\n\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\r\n\t\r\n\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\r\n\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\r\n\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\r\n\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\r\n\t\r\n\t\treturn data;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/lights/LightShadow.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.LightShadow = function ( camera ) {\r\n\t\r\n\t\tthis.camera = camera;\r\n\t\r\n\t\tthis.bias = 0;\r\n\t\tthis.radius = 1;\r\n\t\r\n\t\tthis.mapSize = new THREE.Vector2( 512, 512 );\r\n\t\r\n\t\tthis.map = null;\r\n\t\tthis.matrix = new THREE.Matrix4();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LightShadow.prototype = {\r\n\t\r\n\t\tconstructor: THREE.LightShadow,\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tthis.camera = source.camera.clone();\r\n\t\r\n\t\t\tthis.bias = source.bias;\r\n\t\t\tthis.radius = source.radius;\r\n\t\r\n\t\t\tthis.mapSize.copy( source.mapSize );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/lights/AmbientLight.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.AmbientLight = function ( color, intensity ) {\r\n\t\r\n\t\tTHREE.Light.call( this, color, intensity );\r\n\t\r\n\t\tthis.type = 'AmbientLight';\r\n\t\r\n\t\tthis.castShadow = undefined;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );\r\n\tTHREE.AmbientLight.prototype.constructor = THREE.AmbientLight;\r\n\t\r\n\t// File:src/lights/DirectionalLight.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.DirectionalLight = function ( color, intensity ) {\r\n\t\r\n\t\tTHREE.Light.call( this, color, intensity );\r\n\t\r\n\t\tthis.type = 'DirectionalLight';\r\n\t\r\n\t\tthis.position.set( 0, 1, 0 );\r\n\t\tthis.updateMatrix();\r\n\t\r\n\t\tthis.target = new THREE.Object3D();\r\n\t\r\n\t\tthis.shadow = new THREE.LightShadow( new THREE.OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );\r\n\tTHREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;\r\n\t\r\n\tTHREE.DirectionalLight.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Light.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.target = source.target.clone();\r\n\t\r\n\t\tthis.shadow = source.shadow.clone();\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/lights/HemisphereLight.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {\r\n\t\r\n\t\tTHREE.Light.call( this, skyColor, intensity );\r\n\t\r\n\t\tthis.type = 'HemisphereLight';\r\n\t\r\n\t\tthis.castShadow = undefined;\r\n\t\r\n\t\tthis.position.set( 0, 1, 0 );\r\n\t\tthis.updateMatrix();\r\n\t\r\n\t\tthis.groundColor = new THREE.Color( groundColor );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );\r\n\tTHREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;\r\n\t\r\n\tTHREE.HemisphereLight.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Light.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.groundColor.copy( source.groundColor );\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/lights/PointLight.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\t\r\n\tTHREE.PointLight = function ( color, intensity, distance, decay ) {\r\n\t\r\n\t\tTHREE.Light.call( this, color, intensity );\r\n\t\r\n\t\tthis.type = 'PointLight';\r\n\t\r\n\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\r\n\t\r\n\t\tthis.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PointLight.prototype = Object.create( THREE.Light.prototype );\r\n\tTHREE.PointLight.prototype.constructor = THREE.PointLight;\r\n\t\r\n\tObject.defineProperty( THREE.PointLight.prototype, \"power\", {\r\n\t\r\n\t\tget: function () {\r\n\t\r\n\t\t\t// intensity = power per solid angle.\r\n\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\r\n\t\t\treturn this.intensity * 4 * Math.PI;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset: function ( power ) {\r\n\t\r\n\t\t\t// intensity = power per solid angle.\r\n\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\r\n\t\t\tthis.intensity = power / ( 4 * Math.PI );\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\tTHREE.PointLight.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Light.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.distance = source.distance;\r\n\t\tthis.decay = source.decay;\r\n\t\r\n\t\tthis.shadow = source.shadow.clone();\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/lights/SpotLight.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.SpotLight = function ( color, intensity, distance, angle, penumbra, decay ) {\r\n\t\r\n\t\tTHREE.Light.call( this, color, intensity );\r\n\t\r\n\t\tthis.type = 'SpotLight';\r\n\t\r\n\t\tthis.position.set( 0, 1, 0 );\r\n\t\tthis.updateMatrix();\r\n\t\r\n\t\tthis.target = new THREE.Object3D();\r\n\t\r\n\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\t\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\r\n\t\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\r\n\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\r\n\t\r\n\t\tthis.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 50, 1, 0.5, 500 ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SpotLight.prototype = Object.create( THREE.Light.prototype );\r\n\tTHREE.SpotLight.prototype.constructor = THREE.SpotLight;\r\n\t\r\n\tObject.defineProperty( THREE.SpotLight.prototype, \"power\", {\r\n\t\r\n\t\tget: function () {\r\n\t\r\n\t\t\t// intensity = power per solid angle.\r\n\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\r\n\t\t\treturn this.intensity * Math.PI;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset: function ( power ) {\r\n\t\r\n\t\t\t// intensity = power per solid angle.\r\n\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\r\n\t\t\tthis.intensity = power / Math.PI;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\tTHREE.SpotLight.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Light.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.distance = source.distance;\r\n\t\tthis.angle = source.angle;\r\n\t\tthis.penumbra = source.penumbra;\r\n\t\tthis.decay = source.decay;\r\n\t\r\n\t\tthis.target = source.target.clone();\r\n\t\r\n\t\tthis.shadow = source.shadow.clone();\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/Cache.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Cache = {\r\n\t\r\n\t\tenabled: false,\r\n\t\r\n\t\tfiles: {},\r\n\t\r\n\t\tadd: function ( key, file ) {\r\n\t\r\n\t\t\tif ( this.enabled === false ) return;\r\n\t\r\n\t\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\r\n\t\r\n\t\t\tthis.files[ key ] = file;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget: function ( key ) {\r\n\t\r\n\t\t\tif ( this.enabled === false ) return;\r\n\t\r\n\t\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\r\n\t\r\n\t\t\treturn this.files[ key ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tremove: function ( key ) {\r\n\t\r\n\t\t\tdelete this.files[ key ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclear: function () {\r\n\t\r\n\t\t\tthis.files = {};\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/Loader.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Loader = function () {\r\n\t\r\n\t\tthis.onLoadStart = function () {};\r\n\t\tthis.onLoadProgress = function () {};\r\n\t\tthis.onLoadComplete = function () {};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Loader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Loader,\r\n\t\r\n\t\tcrossOrigin: undefined,\r\n\t\r\n\t\textractUrlBase: function ( url ) {\r\n\t\r\n\t\t\tvar parts = url.split( '/' );\r\n\t\r\n\t\t\tif ( parts.length === 1 ) return './';\r\n\t\r\n\t\t\tparts.pop();\r\n\t\r\n\t\t\treturn parts.join( '/' ) + '/';\r\n\t\r\n\t\t},\r\n\t\r\n\t\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\r\n\t\r\n\t\t\tvar array = [];\r\n\t\r\n\t\t\tfor ( var i = 0; i < materials.length; ++ i ) {\r\n\t\r\n\t\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcreateMaterial: ( function () {\r\n\t\r\n\t\t\tvar color, textureLoader, materialLoader;\r\n\t\r\n\t\t\treturn function ( m, texturePath, crossOrigin ) {\r\n\t\r\n\t\t\t\tif ( color === undefined ) color = new THREE.Color();\r\n\t\t\t\tif ( textureLoader === undefined ) textureLoader = new THREE.TextureLoader();\r\n\t\t\t\tif ( materialLoader === undefined ) materialLoader = new THREE.MaterialLoader();\r\n\t\r\n\t\t\t\t// convert from old material format\r\n\t\r\n\t\t\t\tvar textures = {};\r\n\t\r\n\t\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\r\n\t\r\n\t\t\t\t\tvar fullPath = texturePath + path;\r\n\t\t\t\t\tvar loader = THREE.Loader.Handlers.get( fullPath );\r\n\t\r\n\t\t\t\t\tvar texture;\r\n\t\r\n\t\t\t\t\tif ( loader !== null ) {\r\n\t\r\n\t\t\t\t\t\ttexture = loader.load( fullPath );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\ttextureLoader.setCrossOrigin( crossOrigin );\r\n\t\t\t\t\t\ttexture = textureLoader.load( fullPath );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( repeat !== undefined ) {\r\n\t\r\n\t\t\t\t\t\ttexture.repeat.fromArray( repeat );\r\n\t\r\n\t\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\r\n\t\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( offset !== undefined ) {\r\n\t\r\n\t\t\t\t\t\ttexture.offset.fromArray( offset );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( wrap !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;\r\n\t\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;\r\n\t\r\n\t\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;\r\n\t\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( anisotropy !== undefined ) {\r\n\t\r\n\t\t\t\t\t\ttexture.anisotropy = anisotropy;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\t\t\t\ttextures[ uuid ] = texture;\r\n\t\r\n\t\t\t\t\treturn uuid;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t//\r\n\t\r\n\t\t\t\tvar json = {\r\n\t\t\t\t\tuuid: THREE.Math.generateUUID(),\r\n\t\t\t\t\ttype: 'MeshLambertMaterial'\r\n\t\t\t\t};\r\n\t\r\n\t\t\t\tfor ( var name in m ) {\r\n\t\r\n\t\t\t\t\tvar value = m[ name ];\r\n\t\r\n\t\t\t\t\tswitch ( name ) {\r\n\t\t\t\t\t\tcase 'DbgColor':\r\n\t\t\t\t\t\tcase 'DbgIndex':\r\n\t\t\t\t\t\tcase 'opticalDensity':\r\n\t\t\t\t\t\tcase 'illumination':\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'DbgName':\r\n\t\t\t\t\t\t\tjson.name = value;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'blending':\r\n\t\t\t\t\t\t\tjson.blending = THREE[ value ];\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'colorAmbient':\r\n\t\t\t\t\t\tcase 'mapAmbient':\r\n\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'colorDiffuse':\r\n\t\t\t\t\t\t\tjson.color = color.fromArray( value ).getHex();\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'colorSpecular':\r\n\t\t\t\t\t\t\tjson.specular = color.fromArray( value ).getHex();\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'colorEmissive':\r\n\t\t\t\t\t\t\tjson.emissive = color.fromArray( value ).getHex();\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'specularCoef':\r\n\t\t\t\t\t\t\tjson.shininess = value;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'shading':\r\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\r\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapDiffuse':\r\n\t\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapDiffuseRepeat':\r\n\t\t\t\t\t\tcase 'mapDiffuseOffset':\r\n\t\t\t\t\t\tcase 'mapDiffuseWrap':\r\n\t\t\t\t\t\tcase 'mapDiffuseAnisotropy':\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapLight':\r\n\t\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapLightRepeat':\r\n\t\t\t\t\t\tcase 'mapLightOffset':\r\n\t\t\t\t\t\tcase 'mapLightWrap':\r\n\t\t\t\t\t\tcase 'mapLightAnisotropy':\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapAO':\r\n\t\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapAORepeat':\r\n\t\t\t\t\t\tcase 'mapAOOffset':\r\n\t\t\t\t\t\tcase 'mapAOWrap':\r\n\t\t\t\t\t\tcase 'mapAOAnisotropy':\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapBump':\r\n\t\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapBumpScale':\r\n\t\t\t\t\t\t\tjson.bumpScale = value;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapBumpRepeat':\r\n\t\t\t\t\t\tcase 'mapBumpOffset':\r\n\t\t\t\t\t\tcase 'mapBumpWrap':\r\n\t\t\t\t\t\tcase 'mapBumpAnisotropy':\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapNormal':\r\n\t\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapNormalFactor':\r\n\t\t\t\t\t\t\tjson.normalScale = [ value, value ];\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapNormalRepeat':\r\n\t\t\t\t\t\tcase 'mapNormalOffset':\r\n\t\t\t\t\t\tcase 'mapNormalWrap':\r\n\t\t\t\t\t\tcase 'mapNormalAnisotropy':\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapSpecular':\r\n\t\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapSpecularRepeat':\r\n\t\t\t\t\t\tcase 'mapSpecularOffset':\r\n\t\t\t\t\t\tcase 'mapSpecularWrap':\r\n\t\t\t\t\t\tcase 'mapSpecularAnisotropy':\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapAlpha':\r\n\t\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapAlphaRepeat':\r\n\t\t\t\t\t\tcase 'mapAlphaOffset':\r\n\t\t\t\t\t\tcase 'mapAlphaWrap':\r\n\t\t\t\t\t\tcase 'mapAlphaAnisotropy':\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'flipSided':\r\n\t\t\t\t\t\t\tjson.side = THREE.BackSide;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'doubleSided':\r\n\t\t\t\t\t\t\tjson.side = THREE.DoubleSide;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'transparency':\r\n\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\r\n\t\t\t\t\t\t\tjson.opacity = value;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'depthTest':\r\n\t\t\t\t\t\tcase 'depthWrite':\r\n\t\t\t\t\t\tcase 'colorWrite':\r\n\t\t\t\t\t\tcase 'opacity':\r\n\t\t\t\t\t\tcase 'reflectivity':\r\n\t\t\t\t\t\tcase 'transparent':\r\n\t\t\t\t\t\tcase 'visible':\r\n\t\t\t\t\t\tcase 'wireframe':\r\n\t\t\t\t\t\t\tjson[ name ] = value;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'vertexColors':\r\n\t\t\t\t\t\t\tif ( value === true ) json.vertexColors = THREE.VertexColors;\r\n\t\t\t\t\t\t\tif ( value === 'face' ) json.vertexColors = THREE.FaceColors;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\r\n\t\t\t\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\r\n\t\r\n\t\t\t\tif ( json.opacity < 1 ) json.transparent = true;\r\n\t\r\n\t\t\t\tmaterialLoader.setTextures( textures );\r\n\t\r\n\t\t\t\treturn materialLoader.parse( json );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )()\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Loader.Handlers = {\r\n\t\r\n\t\thandlers: [],\r\n\t\r\n\t\tadd: function ( regex, loader ) {\r\n\t\r\n\t\t\tthis.handlers.push( regex, loader );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget: function ( file ) {\r\n\t\r\n\t\t\tvar handlers = this.handlers;\r\n\t\r\n\t\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\r\n\t\r\n\t\t\t\tvar regex = handlers[ i ];\r\n\t\t\t\tvar loader  = handlers[ i + 1 ];\r\n\t\r\n\t\t\t\tif ( regex.test( file ) ) {\r\n\t\r\n\t\t\t\t\treturn loader;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn null;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/XHRLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.XHRLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.XHRLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.XHRLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tif ( this.path !== undefined ) url = this.path + url;\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar cached = THREE.Cache.get( url );\r\n\t\r\n\t\t\tif ( cached !== undefined ) {\r\n\t\r\n\t\t\t\tif ( onLoad ) {\r\n\t\r\n\t\t\t\t\tsetTimeout( function () {\r\n\t\r\n\t\t\t\t\t\tonLoad( cached );\r\n\t\r\n\t\t\t\t\t}, 0 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn cached;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar request = new XMLHttpRequest();\r\n\t\t\trequest.overrideMimeType( 'text/plain' );\r\n\t\t\trequest.open( 'GET', url, true );\r\n\t\r\n\t\t\trequest.addEventListener( 'load', function ( event ) {\r\n\t\r\n\t\t\t\tvar response = event.target.response;\r\n\t\r\n\t\t\t\tTHREE.Cache.add( url, response );\r\n\t\r\n\t\t\t\tif ( this.status === 200 ) {\r\n\t\r\n\t\t\t\t\tif ( onLoad ) onLoad( response );\r\n\t\r\n\t\t\t\t\tscope.manager.itemEnd( url );\r\n\t\r\n\t\t\t\t} else if ( this.status === 0 ) {\r\n\t\r\n\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\r\n\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );\r\n\t\r\n\t\t\t\t\tif ( onLoad ) onLoad( response );\r\n\t\r\n\t\t\t\t\tscope.manager.itemEnd( url );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tif ( onError ) onError( event );\r\n\t\r\n\t\t\t\t\tscope.manager.itemError( url );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}, false );\r\n\t\r\n\t\t\tif ( onProgress !== undefined ) {\r\n\t\r\n\t\t\t\trequest.addEventListener( 'progress', function ( event ) {\r\n\t\r\n\t\t\t\t\tonProgress( event );\r\n\t\r\n\t\t\t\t}, false );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\trequest.addEventListener( 'error', function ( event ) {\r\n\t\r\n\t\t\t\tif ( onError ) onError( event );\r\n\t\r\n\t\t\t\tscope.manager.itemError( url );\r\n\t\r\n\t\t\t}, false );\r\n\t\r\n\t\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\r\n\t\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\r\n\t\r\n\t\t\trequest.send( null );\r\n\t\r\n\t\t\tscope.manager.itemStart( url );\r\n\t\r\n\t\t\treturn request;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetPath: function ( value ) {\r\n\t\r\n\t\t\tthis.path = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetResponseType: function ( value ) {\r\n\t\r\n\t\t\tthis.responseType = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetWithCredentials: function ( value ) {\r\n\t\r\n\t\t\tthis.withCredentials = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/FontLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.FontLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.FontLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.FontLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\t\tloader.load( url, function ( text ) {\r\n\t\r\n\t\t\t\tonLoad( new THREE.Font( JSON.parse( text.substring( 65, text.length - 2 ) ) ) );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/ImageLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.ImageLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ImageLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.ImageLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tif ( this.path !== undefined ) url = this.path + url;\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar cached = THREE.Cache.get( url );\r\n\t\r\n\t\t\tif ( cached !== undefined ) {\r\n\t\r\n\t\t\t\tscope.manager.itemStart( url );\r\n\t\r\n\t\t\t\tif ( onLoad ) {\r\n\t\r\n\t\t\t\t\tsetTimeout( function () {\r\n\t\r\n\t\t\t\t\t\tonLoad( cached );\r\n\t\r\n\t\t\t\t\t\tscope.manager.itemEnd( url );\r\n\t\r\n\t\t\t\t\t}, 0 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tscope.manager.itemEnd( url );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn cached;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar image = document.createElement( 'img' );\r\n\t\r\n\t\t\timage.addEventListener( 'load', function ( event ) {\r\n\t\r\n\t\t\t\tTHREE.Cache.add( url, this );\r\n\t\r\n\t\t\t\tif ( onLoad ) onLoad( this );\r\n\t\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\t\r\n\t\t\t}, false );\r\n\t\r\n\t\t\tif ( onProgress !== undefined ) {\r\n\t\r\n\t\t\t\timage.addEventListener( 'progress', function ( event ) {\r\n\t\r\n\t\t\t\t\tonProgress( event );\r\n\t\r\n\t\t\t\t}, false );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\timage.addEventListener( 'error', function ( event ) {\r\n\t\r\n\t\t\t\tif ( onError ) onError( event );\r\n\t\r\n\t\t\t\tscope.manager.itemError( url );\r\n\t\r\n\t\t\t}, false );\r\n\t\r\n\t\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\r\n\t\r\n\t\t\tscope.manager.itemStart( url );\r\n\t\r\n\t\t\timage.src = url;\r\n\t\r\n\t\t\treturn image;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\t\r\n\t\t\tthis.crossOrigin = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetPath: function ( value ) {\r\n\t\r\n\t\t\tthis.path = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/JSONLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.JSONLoader = function ( manager ) {\r\n\t\r\n\t\tif ( typeof manager === 'boolean' ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\r\n\t\t\tmanager = undefined;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t\tthis.withCredentials = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.JSONLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.JSONLoader,\r\n\t\r\n\t\t// Deprecated\r\n\t\r\n\t\tget statusDomElement () {\r\n\t\r\n\t\t\tif ( this._statusDomElement === undefined ) {\r\n\t\r\n\t\t\t\tthis._statusDomElement = document.createElement( 'div' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tconsole.warn( 'THREE.JSONLoader: .statusDomElement has been removed.' );\r\n\t\t\treturn this._statusDomElement;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tload: function( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar texturePath = this.texturePath && ( typeof this.texturePath === \"string\" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\t\tloader.setWithCredentials( this.withCredentials );\r\n\t\t\tloader.load( url, function ( text ) {\r\n\t\r\n\t\t\t\tvar json = JSON.parse( text );\r\n\t\t\t\tvar metadata = json.metadata;\r\n\t\r\n\t\t\t\tif ( metadata !== undefined ) {\r\n\t\r\n\t\t\t\t\tvar type = metadata.type;\r\n\t\r\n\t\t\t\t\tif ( type !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tif ( type.toLowerCase() === 'object' ) {\r\n\t\r\n\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\r\n\t\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( type.toLowerCase() === 'scene' ) {\r\n\t\r\n\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\r\n\t\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar object = scope.parse( json, texturePath );\r\n\t\t\t\tonLoad( object.geometry, object.materials );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetTexturePath: function ( value ) {\r\n\t\r\n\t\t\tthis.texturePath = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparse: function ( json, texturePath ) {\r\n\t\r\n\t\t\tvar geometry = new THREE.Geometry(),\r\n\t\t\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\r\n\t\r\n\t\t\tparseModel( scale );\r\n\t\r\n\t\t\tparseSkin();\r\n\t\t\tparseMorphing( scale );\r\n\t\t\tparseAnimations();\r\n\t\r\n\t\t\tgeometry.computeFaceNormals();\r\n\t\t\tgeometry.computeBoundingSphere();\r\n\t\r\n\t\t\tfunction parseModel( scale ) {\r\n\t\r\n\t\t\t\tfunction isBitSet( value, position ) {\r\n\t\r\n\t\t\t\t\treturn value & ( 1 << position );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar i, j, fi,\r\n\t\r\n\t\t\t\toffset, zLength,\r\n\t\r\n\t\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\r\n\t\r\n\t\t\t\ttype,\r\n\t\t\t\tisQuad,\r\n\t\t\t\thasMaterial,\r\n\t\t\t\thasFaceVertexUv,\r\n\t\t\t\thasFaceNormal, hasFaceVertexNormal,\r\n\t\t\t\thasFaceColor, hasFaceVertexColor,\r\n\t\r\n\t\t\tvertex, face, faceA, faceB, hex, normal,\r\n\t\r\n\t\t\t\tuvLayer, uv, u, v,\r\n\t\r\n\t\t\t\tfaces = json.faces,\r\n\t\t\t\tvertices = json.vertices,\r\n\t\t\t\tnormals = json.normals,\r\n\t\t\t\tcolors = json.colors,\r\n\t\r\n\t\t\t\tnUvLayers = 0;\r\n\t\r\n\t\t\t\tif ( json.uvs !== undefined ) {\r\n\t\r\n\t\t\t\t\t// disregard empty arrays\r\n\t\r\n\t\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\toffset = 0;\r\n\t\t\t\tzLength = vertices.length;\r\n\t\r\n\t\t\t\twhile ( offset < zLength ) {\r\n\t\r\n\t\t\t\t\tvertex = new THREE.Vector3();\r\n\t\r\n\t\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\r\n\t\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\r\n\t\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\r\n\t\r\n\t\t\t\t\tgeometry.vertices.push( vertex );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\toffset = 0;\r\n\t\t\t\tzLength = faces.length;\r\n\t\r\n\t\t\t\twhile ( offset < zLength ) {\r\n\t\r\n\t\t\t\t\ttype = faces[ offset ++ ];\r\n\t\r\n\t\r\n\t\t\t\t\tisQuad              = isBitSet( type, 0 );\r\n\t\t\t\t\thasMaterial         = isBitSet( type, 1 );\r\n\t\t\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\r\n\t\t\t\t\thasFaceNormal       = isBitSet( type, 4 );\r\n\t\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\r\n\t\t\t\t\thasFaceColor\t     = isBitSet( type, 6 );\r\n\t\t\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\r\n\t\r\n\t\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\r\n\t\r\n\t\t\t\t\tif ( isQuad ) {\r\n\t\r\n\t\t\t\t\t\tfaceA = new THREE.Face3();\r\n\t\t\t\t\t\tfaceA.a = faces[ offset ];\r\n\t\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\r\n\t\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\r\n\t\r\n\t\t\t\t\t\tfaceB = new THREE.Face3();\r\n\t\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\r\n\t\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\r\n\t\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\r\n\t\r\n\t\t\t\t\t\toffset += 4;\r\n\t\r\n\t\t\t\t\t\tif ( hasMaterial ) {\r\n\t\r\n\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\r\n\t\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t// to get face <=> uv index correspondence\r\n\t\r\n\t\t\t\t\t\tfi = geometry.faces.length;\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceVertexUv ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\t\r\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\r\n\t\r\n\t\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\t\r\n\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\t\r\n\t\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\r\n\t\r\n\t\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\t\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceNormal ) {\r\n\t\r\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\t\r\n\t\t\t\t\t\t\tfaceA.normal.set(\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\t\r\n\t\t\t\t\t\t\t\tnormal = new THREE.Vector3(\r\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t\t\t);\r\n\t\r\n\t\r\n\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\r\n\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceColor ) {\r\n\t\r\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\thex = colors[ colorIndex ];\r\n\t\r\n\t\t\t\t\t\t\tfaceA.color.setHex( hex );\r\n\t\t\t\t\t\t\tfaceB.color.setHex( hex );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceVertexColor ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\t\thex = colors[ colorIndex ];\r\n\t\r\n\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );\r\n\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tgeometry.faces.push( faceA );\r\n\t\t\t\t\t\tgeometry.faces.push( faceB );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tface = new THREE.Face3();\r\n\t\t\t\t\t\tface.a = faces[ offset ++ ];\r\n\t\t\t\t\t\tface.b = faces[ offset ++ ];\r\n\t\t\t\t\t\tface.c = faces[ offset ++ ];\r\n\t\r\n\t\t\t\t\t\tif ( hasMaterial ) {\r\n\t\r\n\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\tface.materialIndex = materialIndex;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t// to get face <=> uv index correspondence\r\n\t\r\n\t\t\t\t\t\tfi = geometry.faces.length;\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceVertexUv ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\t\r\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\t\r\n\t\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\t\r\n\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\t\r\n\t\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\r\n\t\r\n\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceNormal ) {\r\n\t\r\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\t\r\n\t\t\t\t\t\t\tface.normal.set(\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\t\r\n\t\t\t\t\t\t\t\tnormal = new THREE.Vector3(\r\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\t\tface.vertexNormals.push( normal );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceColor ) {\r\n\t\r\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceVertexColor ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\t\tface.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tgeometry.faces.push( face );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tfunction parseSkin() {\r\n\t\r\n\t\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\r\n\t\r\n\t\t\t\tif ( json.skinWeights ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\r\n\t\r\n\t\t\t\t\t\tvar x =                               json.skinWeights[ i ];\r\n\t\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\r\n\t\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\r\n\t\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\r\n\t\r\n\t\t\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( json.skinIndices ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\r\n\t\r\n\t\t\t\t\t\tvar a =                               json.skinIndices[ i ];\r\n\t\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\r\n\t\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\r\n\t\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\r\n\t\r\n\t\t\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.bones = json.bones;\r\n\t\r\n\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\r\n\t\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tfunction parseMorphing( scale ) {\r\n\t\r\n\t\t\t\tif ( json.morphTargets !== undefined ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tgeometry.morphTargets[ i ] = {};\r\n\t\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\r\n\t\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\r\n\t\r\n\t\t\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\r\n\t\t\t\t\t\tvar srcVertices = json.morphTargets[ i ].vertices;\r\n\t\r\n\t\t\t\t\t\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\r\n\t\r\n\t\t\t\t\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\r\n\t\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\r\n\t\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\r\n\t\r\n\t\t\t\t\t\t\tdstVertices.push( vertex );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\r\n\t\r\n\t\t\t\t\tvar faces = geometry.faces;\r\n\t\t\t\t\tvar morphColors = json.morphColors[ 0 ].colors;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tfaces[ i ].color.fromArray( morphColors, i * 3 );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction parseAnimations() {\r\n\t\r\n\t\t\t\tvar outputAnimations = [];\r\n\t\r\n\t\t\t\t// parse old style Bone/Hierarchy animations\r\n\t\t\t\tvar animations = [];\r\n\t\r\n\t\t\t\tif ( json.animation !== undefined ) {\r\n\t\r\n\t\t\t\t\tanimations.push( json.animation );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( json.animations !== undefined ) {\r\n\t\r\n\t\t\t\t\tif ( json.animations.length ) {\r\n\t\r\n\t\t\t\t\t\tanimations = animations.concat( json.animations );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tanimations.push( json.animations );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < animations.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar clip = THREE.AnimationClip.parseAnimation( animations[ i ], geometry.bones );\r\n\t\t\t\t\tif ( clip ) outputAnimations.push( clip );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// parse implicit morph animations\r\n\t\t\t\tif ( geometry.morphTargets ) {\r\n\t\r\n\t\t\t\t\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\r\n\t\t\t\t\tvar morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\r\n\t\t\t\t\toutputAnimations = outputAnimations.concat( morphAnimationClips );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\r\n\t\r\n\t\t\t\treturn { geometry: geometry };\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tvar materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\r\n\t\r\n\t\t\t\treturn { geometry: geometry, materials: materials };\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/LoadingManager.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.LoadingManager = function ( onLoad, onProgress, onError ) {\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\tvar isLoading = false, itemsLoaded = 0, itemsTotal = 0;\r\n\t\r\n\t\tthis.onStart = undefined;\r\n\t\tthis.onLoad = onLoad;\r\n\t\tthis.onProgress = onProgress;\r\n\t\tthis.onError = onError;\r\n\t\r\n\t\tthis.itemStart = function ( url ) {\r\n\t\r\n\t\t\titemsTotal ++;\r\n\t\r\n\t\t\tif ( isLoading === false ) {\r\n\t\r\n\t\t\t\tif ( scope.onStart !== undefined ) {\r\n\t\r\n\t\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tisLoading = true;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.itemEnd = function ( url ) {\r\n\t\r\n\t\t\titemsLoaded ++;\r\n\t\r\n\t\t\tif ( scope.onProgress !== undefined ) {\r\n\t\r\n\t\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( itemsLoaded === itemsTotal ) {\r\n\t\r\n\t\t\t\tisLoading = false;\r\n\t\r\n\t\t\t\tif ( scope.onLoad !== undefined ) {\r\n\t\r\n\t\t\t\t\tscope.onLoad();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.itemError = function ( url ) {\r\n\t\r\n\t\t\tif ( scope.onError !== undefined ) {\r\n\t\r\n\t\t\t\tscope.onError( url );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DefaultLoadingManager = new THREE.LoadingManager();\r\n\t\r\n\t// File:src/loaders/BufferGeometryLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.BufferGeometryLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BufferGeometryLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.BufferGeometryLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\t\tloader.load( url, function ( text ) {\r\n\t\r\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparse: function ( json ) {\r\n\t\r\n\t\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\r\n\t\t\tvar index = json.data.index;\r\n\t\r\n\t\t\tvar TYPED_ARRAYS = {\r\n\t\t\t\t'Int8Array': Int8Array,\r\n\t\t\t\t'Uint8Array': Uint8Array,\r\n\t\t\t\t'Uint8ClampedArray': Uint8ClampedArray,\r\n\t\t\t\t'Int16Array': Int16Array,\r\n\t\t\t\t'Uint16Array': Uint16Array,\r\n\t\t\t\t'Int32Array': Int32Array,\r\n\t\t\t\t'Uint32Array': Uint32Array,\r\n\t\t\t\t'Float32Array': Float32Array,\r\n\t\t\t\t'Float64Array': Float64Array\r\n\t\t\t};\r\n\t\r\n\t\t\tif ( index !== undefined ) {\r\n\t\r\n\t\t\t\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\r\n\t\t\t\tgeometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar attributes = json.data.attributes;\r\n\t\r\n\t\t\tfor ( var key in attributes ) {\r\n\t\r\n\t\t\t\tvar attribute = attributes[ key ];\r\n\t\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\r\n\t\r\n\t\t\t\tgeometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\r\n\t\r\n\t\t\tif ( groups !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\tvar group = groups[ i ];\r\n\t\r\n\t\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar boundingSphere = json.data.boundingSphere;\r\n\t\r\n\t\t\tif ( boundingSphere !== undefined ) {\r\n\t\r\n\t\t\t\tvar center = new THREE.Vector3();\r\n\t\r\n\t\t\t\tif ( boundingSphere.center !== undefined ) {\r\n\t\r\n\t\t\t\t\tcenter.fromArray( boundingSphere.center );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn geometry;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/MaterialLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.MaterialLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\tthis.textures = {};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MaterialLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.MaterialLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\t\tloader.load( url, function ( text ) {\r\n\t\r\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetTextures: function ( value ) {\r\n\t\r\n\t\t\tthis.textures = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetTexture: function ( name ) {\r\n\t\r\n\t\t\tvar textures = this.textures;\r\n\t\r\n\t\t\tif ( textures[ name ] === undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn textures[ name ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparse: function ( json ) {\r\n\t\r\n\t\t\tvar material = new THREE[ json.type ];\r\n\t\r\n\t\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\r\n\t\t\tif ( json.name !== undefined ) material.name = json.name;\r\n\t\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\r\n\t\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\r\n\t\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\r\n\t\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\r\n\t\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\r\n\t\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\r\n\t\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\r\n\t\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\r\n\t\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\r\n\t\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\r\n\t\t\tif ( json.shading !== undefined ) material.shading = json.shading;\r\n\t\t\tif ( json.blending !== undefined ) material.blending = json.blending;\r\n\t\t\tif ( json.side !== undefined ) material.side = json.side;\r\n\t\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\r\n\t\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\r\n\t\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\r\n\t\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\r\n\t\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\r\n\t\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\r\n\t\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\r\n\t\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\r\n\t\r\n\t\t\t// for PointsMaterial\r\n\t\t\tif ( json.size !== undefined ) material.size = json.size;\r\n\t\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\r\n\t\r\n\t\t\t// maps\r\n\t\r\n\t\t\tif ( json.map !== undefined ) material.map = this.getTexture( json.map );\r\n\t\r\n\t\t\tif ( json.alphaMap !== undefined ) {\r\n\t\r\n\t\t\t\tmaterial.alphaMap = this.getTexture( json.alphaMap );\r\n\t\t\t\tmaterial.transparent = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );\r\n\t\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\r\n\t\r\n\t\t\tif ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );\r\n\t\t\tif ( json.normalScale !== undefined ) {\r\n\t\r\n\t\t\t\tvar normalScale = json.normalScale;\r\n\t\r\n\t\t\t\tif ( Array.isArray( normalScale ) === false ) {\r\n\t\r\n\t\t\t\t\t// Blender exporter used to export a scalar. See #7459\r\n\t\r\n\t\t\t\t\tnormalScale = [ normalScale, normalScale ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tmaterial.normalScale = new THREE.Vector2().fromArray( normalScale );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );\r\n\t\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\r\n\t\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\r\n\t\r\n\t\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = this.getTexture( json.roughnessMap );\r\n\t\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = this.getTexture( json.metalnessMap );\r\n\t\r\n\t\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = this.getTexture( json.emissiveMap );\r\n\t\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\r\n\t\r\n\t\t\tif ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );\r\n\t\r\n\t\t\tif ( json.envMap !== undefined ) {\r\n\t\r\n\t\t\t\tmaterial.envMap = this.getTexture( json.envMap );\r\n\t\t\t\tmaterial.combine = THREE.MultiplyOperation;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( json.reflectivity ) material.reflectivity = json.reflectivity;\r\n\t\r\n\t\t\tif ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );\r\n\t\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\r\n\t\r\n\t\t\tif ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );\r\n\t\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\r\n\t\r\n\t\t\t// MultiMaterial\r\n\t\r\n\t\t\tif ( json.materials !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn material;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/ObjectLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.ObjectLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\tthis.texturePath = '';\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ObjectLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.ObjectLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tif ( this.texturePath === '' ) {\r\n\t\r\n\t\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\t\tloader.load( url, function ( text ) {\r\n\t\r\n\t\t\t\tscope.parse( JSON.parse( text ), onLoad );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetTexturePath: function ( value ) {\r\n\t\r\n\t\t\tthis.texturePath = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\t\r\n\t\t\tthis.crossOrigin = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparse: function ( json, onLoad ) {\r\n\t\r\n\t\t\tvar geometries = this.parseGeometries( json.geometries );\r\n\t\r\n\t\t\tvar images = this.parseImages( json.images, function () {\r\n\t\r\n\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\r\n\t\r\n\t\t\t} );\r\n\t\r\n\t\t\tvar textures  = this.parseTextures( json.textures, images );\r\n\t\t\tvar materials = this.parseMaterials( json.materials, textures );\r\n\t\r\n\t\t\tvar object = this.parseObject( json.object, geometries, materials );\r\n\t\r\n\t\t\tif ( json.animations ) {\r\n\t\r\n\t\t\t\tobject.animations = this.parseAnimations( json.animations );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( json.images === undefined || json.images.length === 0 ) {\r\n\t\r\n\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn object;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseGeometries: function ( json ) {\r\n\t\r\n\t\t\tvar geometries = {};\r\n\t\r\n\t\t\tif ( json !== undefined ) {\r\n\t\r\n\t\t\t\tvar geometryLoader = new THREE.JSONLoader();\r\n\t\t\t\tvar bufferGeometryLoader = new THREE.BufferGeometryLoader();\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar geometry;\r\n\t\t\t\t\tvar data = json[ i ];\r\n\t\r\n\t\t\t\t\tswitch ( data.type ) {\r\n\t\r\n\t\t\t\t\t\tcase 'PlaneGeometry':\r\n\t\t\t\t\t\tcase 'PlaneBufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.width,\r\n\t\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\t\tdata.heightSegments\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'BoxGeometry':\r\n\t\t\t\t\t\tcase 'BoxBufferGeometry':\r\n\t\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.width,\r\n\t\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\t\tdata.depth,\r\n\t\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\t\tdata.depthSegments\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'CircleGeometry':\r\n\t\t\t\t\t\tcase 'CircleBufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.segments,\r\n\t\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'CylinderGeometry':\r\n\t\t\t\t\t\tcase 'CylinderBufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.radiusTop,\r\n\t\t\t\t\t\t\t\tdata.radiusBottom,\r\n\t\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\t\tdata.openEnded,\r\n\t\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'SphereGeometry':\r\n\t\t\t\t\t\tcase 'SphereBufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\t\tdata.phiStart,\r\n\t\t\t\t\t\t\t\tdata.phiLength,\r\n\t\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'DodecahedronGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE.DodecahedronGeometry(\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.detail\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'IcosahedronGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE.IcosahedronGeometry(\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.detail\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'OctahedronGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE.OctahedronGeometry(\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.detail\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'TetrahedronGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE.TetrahedronGeometry(\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.detail\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'RingGeometry':\r\n\t\t\t\t\t\tcase 'RingBufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.innerRadius,\r\n\t\t\t\t\t\t\t\tdata.outerRadius,\r\n\t\t\t\t\t\t\t\tdata.thetaSegments,\r\n\t\t\t\t\t\t\t\tdata.phiSegments,\r\n\t\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'TorusGeometry':\r\n\t\t\t\t\t\tcase 'TorusBufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.tube,\r\n\t\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\t\tdata.tubularSegments,\r\n\t\t\t\t\t\t\t\tdata.arc\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'TorusKnotGeometry':\r\n\t\t\t\t\t\tcase 'TorusKnotBufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.tube,\r\n\t\t\t\t\t\t\t\tdata.tubularSegments,\r\n\t\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\t\tdata.p,\r\n\t\t\t\t\t\t\t\tdata.q\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'LatheGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE.LatheGeometry(\r\n\t\t\t\t\t\t\t\tdata.points,\r\n\t\t\t\t\t\t\t\tdata.segments,\r\n\t\t\t\t\t\t\t\tdata.phiStart,\r\n\t\t\t\t\t\t\t\tdata.phiLength\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'BufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'Geometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data, this.texturePath ).geometry;\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tdefault:\r\n\t\r\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\r\n\t\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tgeometry.uuid = data.uuid;\r\n\t\r\n\t\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\r\n\t\r\n\t\t\t\t\tgeometries[ data.uuid ] = geometry;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn geometries;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseMaterials: function ( json, textures ) {\r\n\t\r\n\t\t\tvar materials = {};\r\n\t\r\n\t\t\tif ( json !== undefined ) {\r\n\t\r\n\t\t\t\tvar loader = new THREE.MaterialLoader();\r\n\t\t\t\tloader.setTextures( textures );\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar material = loader.parse( json[ i ] );\r\n\t\t\t\t\tmaterials[ material.uuid ] = material;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn materials;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseAnimations: function ( json ) {\r\n\t\r\n\t\t\tvar animations = [];\r\n\t\r\n\t\t\tfor ( var i = 0; i < json.length; i ++ ) {\r\n\t\r\n\t\t\t\tvar clip = THREE.AnimationClip.parse( json[ i ] );\r\n\t\r\n\t\t\t\tanimations.push( clip );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn animations;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseImages: function ( json, onLoad ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\t\tvar images = {};\r\n\t\r\n\t\t\tfunction loadImage( url ) {\r\n\t\r\n\t\t\t\tscope.manager.itemStart( url );\r\n\t\r\n\t\t\t\treturn loader.load( url, function () {\r\n\t\r\n\t\t\t\t\tscope.manager.itemEnd( url );\r\n\t\r\n\t\t\t\t} );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( json !== undefined && json.length > 0 ) {\r\n\t\r\n\t\t\t\tvar manager = new THREE.LoadingManager( onLoad );\r\n\t\r\n\t\t\t\tvar loader = new THREE.ImageLoader( manager );\r\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar image = json[ i ];\r\n\t\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\r\n\t\r\n\t\t\t\t\timages[ image.uuid ] = loadImage( path );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn images;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseTextures: function ( json, images ) {\r\n\t\r\n\t\t\tfunction parseConstant( value ) {\r\n\t\r\n\t\t\t\tif ( typeof( value ) === 'number' ) return value;\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\r\n\t\r\n\t\t\t\treturn THREE[ value ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar textures = {};\r\n\t\r\n\t\t\tif ( json !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar data = json[ i ];\r\n\t\r\n\t\t\t\t\tif ( data.image === undefined ) {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( images[ data.image ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar texture = new THREE.Texture( images[ data.image ] );\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\t\ttexture.uuid = data.uuid;\r\n\t\r\n\t\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\r\n\t\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );\r\n\t\t\t\t\tif ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );\r\n\t\t\t\t\tif ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );\r\n\t\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );\r\n\t\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );\r\n\t\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\r\n\t\t\t\t\tif ( Array.isArray( data.wrap ) ) {\r\n\t\r\n\t\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ] );\r\n\t\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ] );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttextures[ data.uuid ] = texture;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn textures;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseObject: function () {\r\n\t\r\n\t\t\tvar matrix = new THREE.Matrix4();\r\n\t\r\n\t\t\treturn function ( data, geometries, materials ) {\r\n\t\r\n\t\t\t\tvar object;\r\n\t\r\n\t\t\t\tfunction getGeometry( name ) {\r\n\t\r\n\t\t\t\t\tif ( geometries[ name ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\treturn geometries[ name ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfunction getMaterial( name ) {\r\n\t\r\n\t\t\t\t\tif ( name === undefined ) return undefined;\r\n\t\r\n\t\t\t\t\tif ( materials[ name ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\treturn materials[ name ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tswitch ( data.type ) {\r\n\t\r\n\t\t\t\t\tcase 'Scene':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Scene();\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'PerspectiveCamera':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'OrthographicCamera':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'AmbientLight':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.AmbientLight( data.color, data.intensity );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'DirectionalLight':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.DirectionalLight( data.color, data.intensity );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'PointLight':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'SpotLight':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'HemisphereLight':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'Mesh':\r\n\t\r\n\t\t\t\t\t\tvar geometry = getGeometry( data.geometry );\r\n\t\t\t\t\t\tvar material = getMaterial( data.material );\r\n\t\r\n\t\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 ) {\r\n\t\r\n\t\t\t\t\t\t\tobject = new THREE.SkinnedMesh( geometry, material );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tobject = new THREE.Mesh( geometry, material );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'LOD':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.LOD();\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'Line':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'PointCloud':\r\n\t\t\t\t\tcase 'Points':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'Sprite':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Sprite( getMaterial( data.material ) );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'Group':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Group();\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tdefault:\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Object3D();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tobject.uuid = data.uuid;\r\n\t\r\n\t\t\t\tif ( data.name !== undefined ) object.name = data.name;\r\n\t\t\t\tif ( data.matrix !== undefined ) {\r\n\t\r\n\t\t\t\t\tmatrix.fromArray( data.matrix );\r\n\t\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\r\n\t\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\r\n\t\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\r\n\t\t\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\r\n\t\r\n\t\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\r\n\t\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\r\n\t\r\n\t\t\t\tif ( data.children !== undefined ) {\r\n\t\r\n\t\t\t\t\tfor ( var child in data.children ) {\r\n\t\r\n\t\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( data.type === 'LOD' ) {\r\n\t\r\n\t\t\t\t\tvar levels = data.levels;\r\n\t\r\n\t\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar level = levels[ l ];\r\n\t\t\t\t\t\tvar child = object.getObjectByProperty( 'uuid', level.object );\r\n\t\r\n\t\t\t\t\t\tif ( child !== undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tobject.addLevel( child, level.distance );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn object;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}()\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/TextureLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.TextureLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TextureLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.TextureLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar texture = new THREE.Texture();\r\n\t\r\n\t\t\tvar loader = new THREE.ImageLoader( this.manager );\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\t\tloader.setPath( this.path );\r\n\t\t\tloader.load( url, function ( image ) {\r\n\t\r\n\t\t\t\ttexture.image = image;\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\tif ( onLoad !== undefined ) {\r\n\t\r\n\t\t\t\t\tonLoad( texture );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\t\r\n\t\t\tthis.crossOrigin = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetPath: function ( value ) {\r\n\t\r\n\t\t\tthis.path = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/CubeTextureLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.CubeTextureLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CubeTextureLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.CubeTextureLoader,\r\n\t\r\n\t\tload: function ( urls, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar texture = new THREE.CubeTexture();\r\n\t\r\n\t\t\tvar loader = new THREE.ImageLoader( this.manager );\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\t\tloader.setPath( this.path );\r\n\t\r\n\t\t\tvar loaded = 0;\r\n\t\r\n\t\t\tfunction loadTexture( i ) {\r\n\t\r\n\t\t\t\tloader.load( urls[ i ], function ( image ) {\r\n\t\r\n\t\t\t\t\ttexture.images[ i ] = image;\r\n\t\r\n\t\t\t\t\tloaded ++;\r\n\t\r\n\t\t\t\t\tif ( loaded === 6 ) {\r\n\t\r\n\t\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}, undefined, onError );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0; i < urls.length; ++ i ) {\r\n\t\r\n\t\t\t\tloadTexture( i );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\t\r\n\t\t\tthis.crossOrigin = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetPath: function ( value ) {\r\n\t\r\n\t\t\tthis.path = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/BinaryTextureLoader.js\r\n\t\r\n\t/**\r\n\t * @author Nikos M. / https://github.com/foo123/\r\n\t *\r\n\t * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\r\n\t */\r\n\t\r\n\tTHREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t\t// override in sub classes\r\n\t\tthis._parser = null;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BinaryTextureLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.BinaryTextureLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar texture = new THREE.DataTexture();\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\r\n\t\t\tloader.load( url, function ( buffer ) {\r\n\t\r\n\t\t\t\tvar texData = scope._parser( buffer );\r\n\t\r\n\t\t\t\tif ( ! texData ) return;\r\n\t\r\n\t\t\t\tif ( undefined !== texData.image ) {\r\n\t\r\n\t\t\t\t\ttexture.image = texData.image;\r\n\t\r\n\t\t\t\t} else if ( undefined !== texData.data ) {\r\n\t\r\n\t\t\t\t\ttexture.image.width = texData.width;\r\n\t\t\t\t\ttexture.image.height = texData.height;\r\n\t\t\t\t\ttexture.image.data = texData.data;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;\r\n\t\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;\r\n\t\r\n\t\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;\r\n\t\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;\r\n\t\r\n\t\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\r\n\t\r\n\t\t\t\tif ( undefined !== texData.format ) {\r\n\t\r\n\t\t\t\t\ttexture.format = texData.format;\r\n\t\r\n\t\t\t\t}\r\n\t\t\t\tif ( undefined !== texData.type ) {\r\n\t\r\n\t\t\t\t\ttexture.type = texData.type;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( undefined !== texData.mipmaps ) {\r\n\t\r\n\t\t\t\t\ttexture.mipmaps = texData.mipmaps;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( 1 === texData.mipmapCount ) {\r\n\t\r\n\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\tif ( onLoad ) onLoad( texture, texData );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/CompressedTextureLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t *\r\n\t * Abstract Base class to block based textures loader (dds, pvr, ...)\r\n\t */\r\n\t\r\n\tTHREE.CompressedTextureLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t\t// override in sub classes\r\n\t\tthis._parser = null;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.CompressedTextureLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.CompressedTextureLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar images = [];\r\n\t\r\n\t\t\tvar texture = new THREE.CompressedTexture();\r\n\t\t\ttexture.image = images;\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\t\tloader.setPath( this.path );\r\n\t\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\r\n\t\t\tfunction loadTexture( i ) {\r\n\t\r\n\t\t\t\tloader.load( url[ i ], function ( buffer ) {\r\n\t\r\n\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\r\n\t\r\n\t\t\t\t\timages[ i ] = {\r\n\t\t\t\t\t\twidth: texDatas.width,\r\n\t\t\t\t\t\theight: texDatas.height,\r\n\t\t\t\t\t\tformat: texDatas.format,\r\n\t\t\t\t\t\tmipmaps: texDatas.mipmaps\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\t\tloaded += 1;\r\n\t\r\n\t\t\t\t\tif ( loaded === 6 ) {\r\n\t\r\n\t\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\r\n\t\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\t\r\n\t\t\t\t\t\ttexture.format = texDatas.format;\r\n\t\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( Array.isArray( url ) ) {\r\n\t\r\n\t\t\t\tvar loaded = 0;\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\r\n\t\r\n\t\t\t\t\tloadTexture( i );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// compressed cubemap texture stored in a single DDS file\r\n\t\r\n\t\t\t\tloader.load( url, function ( buffer ) {\r\n\t\r\n\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\r\n\t\r\n\t\t\t\t\tif ( texDatas.isCubemap ) {\r\n\t\r\n\t\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\r\n\t\r\n\t\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\r\n\t\r\n\t\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\r\n\t\r\n\t\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\r\n\t\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\r\n\t\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\r\n\t\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\ttexture.image.width = texDatas.width;\r\n\t\t\t\t\t\ttexture.image.height = texDatas.height;\r\n\t\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\r\n\t\r\n\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttexture.format = texDatas.format;\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\t\r\n\t\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetPath: function ( value ) {\r\n\t\r\n\t\t\tthis.path = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/Material.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Material = function () {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.type = 'Material';\r\n\t\r\n\t\tthis.side = THREE.FrontSide;\r\n\t\r\n\t\tthis.opacity = 1;\r\n\t\tthis.transparent = false;\r\n\t\r\n\t\tthis.blending = THREE.NormalBlending;\r\n\t\r\n\t\tthis.blendSrc = THREE.SrcAlphaFactor;\r\n\t\tthis.blendDst = THREE.OneMinusSrcAlphaFactor;\r\n\t\tthis.blendEquation = THREE.AddEquation;\r\n\t\tthis.blendSrcAlpha = null;\r\n\t\tthis.blendDstAlpha = null;\r\n\t\tthis.blendEquationAlpha = null;\r\n\t\r\n\t\tthis.depthFunc = THREE.LessEqualDepth;\r\n\t\tthis.depthTest = true;\r\n\t\tthis.depthWrite = true;\r\n\t\r\n\t\tthis.colorWrite = true;\r\n\t\r\n\t\tthis.precision = null; // override the renderer's default precision for this material\r\n\t\r\n\t\tthis.polygonOffset = false;\r\n\t\tthis.polygonOffsetFactor = 0;\r\n\t\tthis.polygonOffsetUnits = 0;\r\n\t\r\n\t\tthis.alphaTest = 0;\r\n\t\tthis.premultipliedAlpha = false;\r\n\t\r\n\t\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\r\n\t\r\n\t\tthis.visible = true;\r\n\t\r\n\t\tthis._needsUpdate = true;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Material.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Material,\r\n\t\r\n\t\tget needsUpdate () {\r\n\t\r\n\t\t\treturn this._needsUpdate;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset needsUpdate ( value ) {\r\n\t\r\n\t\t\tif ( value === true ) this.update();\r\n\t\r\n\t\t\tthis._needsUpdate = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetValues: function ( values ) {\r\n\t\r\n\t\t\tif ( values === undefined ) return;\r\n\t\r\n\t\t\tfor ( var key in values ) {\r\n\t\r\n\t\t\t\tvar newValue = values[ key ];\r\n\t\r\n\t\t\t\tif ( newValue === undefined ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\r\n\t\t\t\t\tcontinue;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar currentValue = this[ key ];\r\n\t\r\n\t\t\t\tif ( currentValue === undefined ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\r\n\t\t\t\t\tcontinue;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( currentValue instanceof THREE.Color ) {\r\n\t\r\n\t\t\t\t\tcurrentValue.set( newValue );\r\n\t\r\n\t\t\t\t} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\r\n\t\r\n\t\t\t\t\tcurrentValue.copy( newValue );\r\n\t\r\n\t\t\t\t} else if ( key === 'overdraw' ) {\r\n\t\r\n\t\t\t\t\t// ensure overdraw is backwards-compatible with legacy boolean type\r\n\t\t\t\t\tthis[ key ] = Number( newValue );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis[ key ] = newValue;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function ( meta ) {\r\n\t\r\n\t\t\tvar isRoot = meta === undefined;\r\n\t\r\n\t\t\tif ( isRoot ) {\r\n\t\r\n\t\t\t\tmeta = {\r\n\t\t\t\t\ttextures: {},\r\n\t\t\t\t\timages: {}\r\n\t\t\t\t};\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar data = {\r\n\t\t\t\tmetadata: {\r\n\t\t\t\t\tversion: 4.4,\r\n\t\t\t\t\ttype: 'Material',\r\n\t\t\t\t\tgenerator: 'Material.toJSON'\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\r\n\t\t\t// standard Material serialization\r\n\t\t\tdata.uuid = this.uuid;\r\n\t\t\tdata.type = this.type;\r\n\t\t\tif ( this.name !== '' ) data.name = this.name;\r\n\t\r\n\t\t\tif ( this.color instanceof THREE.Color ) data.color = this.color.getHex();\r\n\t\r\n\t\t\tif ( this.roughness !== 0.5 ) data.roughness = this.roughness;\r\n\t\t\tif ( this.metalness !== 0.5 ) data.metalness = this.metalness;\r\n\t\r\n\t\t\tif ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();\r\n\t\t\tif ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();\r\n\t\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\r\n\t\r\n\t\t\tif ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;\r\n\t\t\tif ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\r\n\t\t\tif ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\r\n\t\t\tif ( this.bumpMap instanceof THREE.Texture ) {\r\n\t\r\n\t\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\r\n\t\t\t\tdata.bumpScale = this.bumpScale;\r\n\t\r\n\t\t\t}\r\n\t\t\tif ( this.normalMap instanceof THREE.Texture ) {\r\n\t\r\n\t\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\r\n\t\t\t\tdata.normalScale = this.normalScale.toArray();\r\n\t\r\n\t\t\t}\r\n\t\t\tif ( this.displacementMap instanceof THREE.Texture ) {\r\n\t\r\n\t\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\r\n\t\t\t\tdata.displacementScale = this.displacementScale;\r\n\t\t\t\tdata.displacementBias = this.displacementBias;\r\n\t\r\n\t\t\t}\r\n\t\t\tif ( this.roughnessMap instanceof THREE.Texture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\r\n\t\t\tif ( this.metalnessMap instanceof THREE.Texture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\r\n\t\r\n\t\t\tif ( this.emissiveMap instanceof THREE.Texture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\r\n\t\t\tif ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\r\n\t\r\n\t\t\tif ( this.envMap instanceof THREE.Texture ) {\r\n\t\r\n\t\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\r\n\t\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.size !== undefined ) data.size = this.size;\r\n\t\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\r\n\t\r\n\t\t\tif ( this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;\r\n\t\t\tif ( this.shading !== undefined && this.shading !== THREE.SmoothShading ) data.shading = this.shading;\r\n\t\t\tif ( this.blending !== undefined && this.blending !== THREE.NormalBlending ) data.blending = this.blending;\r\n\t\t\tif ( this.side !== undefined && this.side !== THREE.FrontSide ) data.side = this.side;\r\n\t\r\n\t\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\r\n\t\t\tif ( this.transparent === true ) data.transparent = this.transparent;\r\n\t\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\r\n\t\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\r\n\t\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\r\n\t\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\r\n\t\r\n\t\t\t// TODO: Copied from Object3D.toJSON\r\n\t\r\n\t\t\tfunction extractFromCache ( cache ) {\r\n\t\r\n\t\t\t\tvar values = [];\r\n\t\r\n\t\t\t\tfor ( var key in cache ) {\r\n\t\r\n\t\t\t\t\tvar data = cache[ key ];\r\n\t\t\t\t\tdelete data.metadata;\r\n\t\t\t\t\tvalues.push( data );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn values;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( isRoot ) {\r\n\t\r\n\t\t\t\tvar textures = extractFromCache( meta.textures );\r\n\t\t\t\tvar images = extractFromCache( meta.images );\r\n\t\r\n\t\t\t\tif ( textures.length > 0 ) data.textures = textures;\r\n\t\t\t\tif ( images.length > 0 ) data.images = images;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn data;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tthis.name = source.name;\r\n\t\r\n\t\t\tthis.side = source.side;\r\n\t\r\n\t\t\tthis.opacity = source.opacity;\r\n\t\t\tthis.transparent = source.transparent;\r\n\t\r\n\t\t\tthis.blending = source.blending;\r\n\t\r\n\t\t\tthis.blendSrc = source.blendSrc;\r\n\t\t\tthis.blendDst = source.blendDst;\r\n\t\t\tthis.blendEquation = source.blendEquation;\r\n\t\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\r\n\t\t\tthis.blendDstAlpha = source.blendDstAlpha;\r\n\t\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\r\n\t\r\n\t\t\tthis.depthFunc = source.depthFunc;\r\n\t\t\tthis.depthTest = source.depthTest;\r\n\t\t\tthis.depthWrite = source.depthWrite;\r\n\t\r\n\t\t\tthis.colorWrite = source.colorWrite;\r\n\t\r\n\t\t\tthis.precision = source.precision;\r\n\t\r\n\t\t\tthis.polygonOffset = source.polygonOffset;\r\n\t\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\r\n\t\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\r\n\t\r\n\t\t\tthis.alphaTest = source.alphaTest;\r\n\t\r\n\t\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\r\n\t\r\n\t\t\tthis.overdraw = source.overdraw;\r\n\t\r\n\t\t\tthis.visible = source.visible;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdate: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'update' } );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.Material.prototype );\r\n\t\r\n\tTHREE.MaterialIdCount = 0;\r\n\t\r\n\t// File:src/materials/LineBasicMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  linewidth: <float>,\r\n\t *  linecap: \"round\",\r\n\t *  linejoin: \"round\",\r\n\t *\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  vertexColors: <bool>\r\n\t *\r\n\t *  fog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.LineBasicMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'LineBasicMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff );\r\n\t\r\n\t\tthis.linewidth = 1;\r\n\t\tthis.linecap = 'round';\r\n\t\tthis.linejoin = 'round';\r\n\t\r\n\t\tthis.blending = THREE.NormalBlending;\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors;\r\n\t\r\n\t\tthis.fog = true;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;\r\n\t\r\n\tTHREE.LineBasicMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.color.copy( source.color );\r\n\t\r\n\t\tthis.linewidth = source.linewidth;\r\n\t\tthis.linecap = source.linecap;\r\n\t\tthis.linejoin = source.linejoin;\r\n\t\r\n\t\tthis.vertexColors = source.vertexColors;\r\n\t\r\n\t\tthis.fog = source.fog;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/LineDashedMaterial.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  linewidth: <float>,\r\n\t *\r\n\t *  scale: <float>,\r\n\t *  dashSize: <float>,\r\n\t *  gapSize: <float>,\r\n\t *\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  vertexColors: THREE.NoColors / THREE.FaceColors / THREE.VertexColors\r\n\t *\r\n\t *  fog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.LineDashedMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'LineDashedMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff );\r\n\t\r\n\t\tthis.linewidth = 1;\r\n\t\r\n\t\tthis.scale = 1;\r\n\t\tthis.dashSize = 3;\r\n\t\tthis.gapSize = 1;\r\n\t\r\n\t\tthis.blending = THREE.NormalBlending;\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors;\r\n\t\r\n\t\tthis.fog = true;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;\r\n\t\r\n\tTHREE.LineDashedMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.color.copy( source.color );\r\n\t\r\n\t\tthis.linewidth = source.linewidth;\r\n\t\r\n\t\tthis.scale = source.scale;\r\n\t\tthis.dashSize = source.dashSize;\r\n\t\tthis.gapSize = source.gapSize;\r\n\t\r\n\t\tthis.vertexColors = source.vertexColors;\r\n\t\r\n\t\tthis.fog = source.fog;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshBasicMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  aoMap: new THREE.Texture( <Image> ),\r\n\t *  aoMapIntensity: <float>\r\n\t *\r\n\t *  specularMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  alphaMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n\t *  combine: THREE.Multiply,\r\n\t *  reflectivity: <float>,\r\n\t *  refractionRatio: <float>,\r\n\t *\r\n\t *  shading: THREE.SmoothShading,\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>,\r\n\t *\r\n\t *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n\t *\r\n\t *  skinning: <bool>,\r\n\t *  morphTargets: <bool>,\r\n\t *\r\n\t *  fog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshBasicMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'MeshBasicMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff ); // emissive\r\n\t\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.aoMap = null;\r\n\t\tthis.aoMapIntensity = 1.0;\r\n\t\r\n\t\tthis.specularMap = null;\r\n\t\r\n\t\tthis.alphaMap = null;\r\n\t\r\n\t\tthis.envMap = null;\r\n\t\tthis.combine = THREE.MultiplyOperation;\r\n\t\tthis.reflectivity = 1;\r\n\t\tthis.refractionRatio = 0.98;\r\n\t\r\n\t\tthis.fog = true;\r\n\t\r\n\t\tthis.shading = THREE.SmoothShading;\r\n\t\tthis.blending = THREE.NormalBlending;\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\tthis.wireframeLinecap = 'round';\r\n\t\tthis.wireframeLinejoin = 'round';\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors;\r\n\t\r\n\t\tthis.skinning = false;\r\n\t\tthis.morphTargets = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;\r\n\t\r\n\tTHREE.MeshBasicMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.color.copy( source.color );\r\n\t\r\n\t\tthis.map = source.map;\r\n\t\r\n\t\tthis.aoMap = source.aoMap;\r\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\t\r\n\t\tthis.specularMap = source.specularMap;\r\n\t\r\n\t\tthis.alphaMap = source.alphaMap;\r\n\t\r\n\t\tthis.envMap = source.envMap;\r\n\t\tthis.combine = source.combine;\r\n\t\tthis.reflectivity = source.reflectivity;\r\n\t\tthis.refractionRatio = source.refractionRatio;\r\n\t\r\n\t\tthis.fog = source.fog;\r\n\t\r\n\t\tthis.shading = source.shading;\r\n\t\r\n\t\tthis.wireframe = source.wireframe;\r\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\t\r\n\t\tthis.vertexColors = source.vertexColors;\r\n\t\r\n\t\tthis.skinning = source.skinning;\r\n\t\tthis.morphTargets = source.morphTargets;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshLambertMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  lightMap: new THREE.Texture( <Image> ),\r\n\t *  lightMapIntensity: <float>\r\n\t *\r\n\t *  aoMap: new THREE.Texture( <Image> ),\r\n\t *  aoMapIntensity: <float>\r\n\t *\r\n\t *  emissive: <hex>,\r\n\t *  emissiveIntensity: <float>\r\n\t *  emissiveMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  specularMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  alphaMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n\t *  combine: THREE.Multiply,\r\n\t *  reflectivity: <float>,\r\n\t *  refractionRatio: <float>,\r\n\t *\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>,\r\n\t *\r\n\t *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n\t *\r\n\t *  skinning: <bool>,\r\n\t *  morphTargets: <bool>,\r\n\t *  morphNormals: <bool>,\r\n\t *\r\n\t *\tfog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshLambertMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'MeshLambertMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\t\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.lightMap = null;\r\n\t\tthis.lightMapIntensity = 1.0;\r\n\t\r\n\t\tthis.aoMap = null;\r\n\t\tthis.aoMapIntensity = 1.0;\r\n\t\r\n\t\tthis.emissive = new THREE.Color( 0x000000 );\r\n\t\tthis.emissiveIntensity = 1.0;\r\n\t\tthis.emissiveMap = null;\r\n\t\r\n\t\tthis.specularMap = null;\r\n\t\r\n\t\tthis.alphaMap = null;\r\n\t\r\n\t\tthis.envMap = null;\r\n\t\tthis.combine = THREE.MultiplyOperation;\r\n\t\tthis.reflectivity = 1;\r\n\t\tthis.refractionRatio = 0.98;\r\n\t\r\n\t\tthis.fog = true;\r\n\t\r\n\t\tthis.blending = THREE.NormalBlending;\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\tthis.wireframeLinecap = 'round';\r\n\t\tthis.wireframeLinejoin = 'round';\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors;\r\n\t\r\n\t\tthis.skinning = false;\r\n\t\tthis.morphTargets = false;\r\n\t\tthis.morphNormals = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;\r\n\t\r\n\tTHREE.MeshLambertMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.color.copy( source.color );\r\n\t\r\n\t\tthis.map = source.map;\r\n\t\r\n\t\tthis.lightMap = source.lightMap;\r\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\r\n\t\r\n\t\tthis.aoMap = source.aoMap;\r\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\t\r\n\t\tthis.emissive.copy( source.emissive );\r\n\t\tthis.emissiveMap = source.emissiveMap;\r\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\r\n\t\r\n\t\tthis.specularMap = source.specularMap;\r\n\t\r\n\t\tthis.alphaMap = source.alphaMap;\r\n\t\r\n\t\tthis.envMap = source.envMap;\r\n\t\tthis.combine = source.combine;\r\n\t\tthis.reflectivity = source.reflectivity;\r\n\t\tthis.refractionRatio = source.refractionRatio;\r\n\t\r\n\t\tthis.fog = source.fog;\r\n\t\r\n\t\tthis.wireframe = source.wireframe;\r\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\t\r\n\t\tthis.vertexColors = source.vertexColors;\r\n\t\r\n\t\tthis.skinning = source.skinning;\r\n\t\tthis.morphTargets = source.morphTargets;\r\n\t\tthis.morphNormals = source.morphNormals;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshPhongMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  specular: <hex>,\r\n\t *  shininess: <float>,\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  lightMap: new THREE.Texture( <Image> ),\r\n\t *  lightMapIntensity: <float>\r\n\t *\r\n\t *  aoMap: new THREE.Texture( <Image> ),\r\n\t *  aoMapIntensity: <float>\r\n\t *\r\n\t *  emissive: <hex>,\r\n\t *  emissiveIntensity: <float>\r\n\t *  emissiveMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  bumpMap: new THREE.Texture( <Image> ),\r\n\t *  bumpScale: <float>,\r\n\t *\r\n\t *  normalMap: new THREE.Texture( <Image> ),\r\n\t *  normalScale: <Vector2>,\r\n\t *\r\n\t *  displacementMap: new THREE.Texture( <Image> ),\r\n\t *  displacementScale: <float>,\r\n\t *  displacementBias: <float>,\r\n\t *\r\n\t *  specularMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  alphaMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n\t *  combine: THREE.Multiply,\r\n\t *  reflectivity: <float>,\r\n\t *  refractionRatio: <float>,\r\n\t *\r\n\t *  shading: THREE.SmoothShading,\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>,\r\n\t *\r\n\t *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n\t *\r\n\t *  skinning: <bool>,\r\n\t *  morphTargets: <bool>,\r\n\t *  morphNormals: <bool>,\r\n\t *\r\n\t *\tfog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshPhongMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'MeshPhongMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\t\tthis.specular = new THREE.Color( 0x111111 );\r\n\t\tthis.shininess = 30;\r\n\t\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.lightMap = null;\r\n\t\tthis.lightMapIntensity = 1.0;\r\n\t\r\n\t\tthis.aoMap = null;\r\n\t\tthis.aoMapIntensity = 1.0;\r\n\t\r\n\t\tthis.emissive = new THREE.Color( 0x000000 );\r\n\t\tthis.emissiveIntensity = 1.0;\r\n\t\tthis.emissiveMap = null;\r\n\t\r\n\t\tthis.bumpMap = null;\r\n\t\tthis.bumpScale = 1;\r\n\t\r\n\t\tthis.normalMap = null;\r\n\t\tthis.normalScale = new THREE.Vector2( 1, 1 );\r\n\t\r\n\t\tthis.displacementMap = null;\r\n\t\tthis.displacementScale = 1;\r\n\t\tthis.displacementBias = 0;\r\n\t\r\n\t\tthis.specularMap = null;\r\n\t\r\n\t\tthis.alphaMap = null;\r\n\t\r\n\t\tthis.envMap = null;\r\n\t\tthis.combine = THREE.MultiplyOperation;\r\n\t\tthis.reflectivity = 1;\r\n\t\tthis.refractionRatio = 0.98;\r\n\t\r\n\t\tthis.fog = true;\r\n\t\r\n\t\tthis.shading = THREE.SmoothShading;\r\n\t\tthis.blending = THREE.NormalBlending;\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\tthis.wireframeLinecap = 'round';\r\n\t\tthis.wireframeLinejoin = 'round';\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors;\r\n\t\r\n\t\tthis.skinning = false;\r\n\t\tthis.morphTargets = false;\r\n\t\tthis.morphNormals = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;\r\n\t\r\n\tTHREE.MeshPhongMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.color.copy( source.color );\r\n\t\tthis.specular.copy( source.specular );\r\n\t\tthis.shininess = source.shininess;\r\n\t\r\n\t\tthis.map = source.map;\r\n\t\r\n\t\tthis.lightMap = source.lightMap;\r\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\r\n\t\r\n\t\tthis.aoMap = source.aoMap;\r\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\t\r\n\t\tthis.emissive.copy( source.emissive );\r\n\t\tthis.emissiveMap = source.emissiveMap;\r\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\r\n\t\r\n\t\tthis.bumpMap = source.bumpMap;\r\n\t\tthis.bumpScale = source.bumpScale;\r\n\t\r\n\t\tthis.normalMap = source.normalMap;\r\n\t\tthis.normalScale.copy( source.normalScale );\r\n\t\r\n\t\tthis.displacementMap = source.displacementMap;\r\n\t\tthis.displacementScale = source.displacementScale;\r\n\t\tthis.displacementBias = source.displacementBias;\r\n\t\r\n\t\tthis.specularMap = source.specularMap;\r\n\t\r\n\t\tthis.alphaMap = source.alphaMap;\r\n\t\r\n\t\tthis.envMap = source.envMap;\r\n\t\tthis.combine = source.combine;\r\n\t\tthis.reflectivity = source.reflectivity;\r\n\t\tthis.refractionRatio = source.refractionRatio;\r\n\t\r\n\t\tthis.fog = source.fog;\r\n\t\r\n\t\tthis.shading = source.shading;\r\n\t\r\n\t\tthis.wireframe = source.wireframe;\r\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\t\r\n\t\tthis.vertexColors = source.vertexColors;\r\n\t\r\n\t\tthis.skinning = source.skinning;\r\n\t\tthis.morphTargets = source.morphTargets;\r\n\t\tthis.morphNormals = source.morphNormals;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshStandardMaterial.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  roughness: <float>,\r\n\t *  metalness: <float>,\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  lightMap: new THREE.Texture( <Image> ),\r\n\t *  lightMapIntensity: <float>\r\n\t *\r\n\t *  aoMap: new THREE.Texture( <Image> ),\r\n\t *  aoMapIntensity: <float>\r\n\t *\r\n\t *  emissive: <hex>,\r\n\t *  emissiveIntensity: <float>\r\n\t *  emissiveMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  bumpMap: new THREE.Texture( <Image> ),\r\n\t *  bumpScale: <float>,\r\n\t *\r\n\t *  normalMap: new THREE.Texture( <Image> ),\r\n\t *  normalScale: <Vector2>,\r\n\t *\r\n\t *  displacementMap: new THREE.Texture( <Image> ),\r\n\t *  displacementScale: <float>,\r\n\t *  displacementBias: <float>,\r\n\t *\r\n\t *  roughnessMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  metalnessMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  alphaMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\r\n\t *  envMapIntensity: <float>\r\n\t *\r\n\t *  refractionRatio: <float>,\r\n\t *\r\n\t *  shading: THREE.SmoothShading,\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>,\r\n\t *\r\n\t *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n\t *\r\n\t *  skinning: <bool>,\r\n\t *  morphTargets: <bool>,\r\n\t *  morphNormals: <bool>,\r\n\t *\r\n\t *\tfog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshStandardMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'MeshStandardMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\t\tthis.roughness = 0.5;\r\n\t\tthis.metalness = 0.5;\r\n\t\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.lightMap = null;\r\n\t\tthis.lightMapIntensity = 1.0;\r\n\t\r\n\t\tthis.aoMap = null;\r\n\t\tthis.aoMapIntensity = 1.0;\r\n\t\r\n\t\tthis.emissive = new THREE.Color( 0x000000 );\r\n\t\tthis.emissiveIntensity = 1.0;\r\n\t\tthis.emissiveMap = null;\r\n\t\r\n\t\tthis.bumpMap = null;\r\n\t\tthis.bumpScale = 1;\r\n\t\r\n\t\tthis.normalMap = null;\r\n\t\tthis.normalScale = new THREE.Vector2( 1, 1 );\r\n\t\r\n\t\tthis.displacementMap = null;\r\n\t\tthis.displacementScale = 1;\r\n\t\tthis.displacementBias = 0;\r\n\t\r\n\t\tthis.roughnessMap = null;\r\n\t\r\n\t\tthis.metalnessMap = null;\r\n\t\r\n\t\tthis.alphaMap = null;\r\n\t\r\n\t\tthis.envMap = null;\r\n\t\tthis.envMapIntensity = 1.0;\r\n\t\r\n\t\tthis.refractionRatio = 0.98;\r\n\t\r\n\t\tthis.fog = true;\r\n\t\r\n\t\tthis.shading = THREE.SmoothShading;\r\n\t\tthis.blending = THREE.NormalBlending;\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\tthis.wireframeLinecap = 'round';\r\n\t\tthis.wireframeLinejoin = 'round';\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors;\r\n\t\r\n\t\tthis.skinning = false;\r\n\t\tthis.morphTargets = false;\r\n\t\tthis.morphNormals = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshStandardMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial;\r\n\t\r\n\tTHREE.MeshStandardMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.color.copy( source.color );\r\n\t\tthis.roughness = source.roughness;\r\n\t\tthis.metalness = source.metalness;\r\n\t\r\n\t\tthis.map = source.map;\r\n\t\r\n\t\tthis.lightMap = source.lightMap;\r\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\r\n\t\r\n\t\tthis.aoMap = source.aoMap;\r\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\t\r\n\t\tthis.emissive.copy( source.emissive );\r\n\t\tthis.emissiveMap = source.emissiveMap;\r\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\r\n\t\r\n\t\tthis.bumpMap = source.bumpMap;\r\n\t\tthis.bumpScale = source.bumpScale;\r\n\t\r\n\t\tthis.normalMap = source.normalMap;\r\n\t\tthis.normalScale.copy( source.normalScale );\r\n\t\r\n\t\tthis.displacementMap = source.displacementMap;\r\n\t\tthis.displacementScale = source.displacementScale;\r\n\t\tthis.displacementBias = source.displacementBias;\r\n\t\r\n\t\tthis.roughnessMap = source.roughnessMap;\r\n\t\r\n\t\tthis.metalnessMap = source.metalnessMap;\r\n\t\r\n\t\tthis.alphaMap = source.alphaMap;\r\n\t\r\n\t\tthis.envMap = source.envMap;\r\n\t\tthis.envMapIntensity = source.envMapIntensity;\r\n\t\r\n\t\tthis.refractionRatio = source.refractionRatio;\r\n\t\r\n\t\tthis.fog = source.fog;\r\n\t\r\n\t\tthis.shading = source.shading;\r\n\t\r\n\t\tthis.wireframe = source.wireframe;\r\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\t\r\n\t\tthis.vertexColors = source.vertexColors;\r\n\t\r\n\t\tthis.skinning = source.skinning;\r\n\t\tthis.morphTargets = source.morphTargets;\r\n\t\tthis.morphNormals = source.morphNormals;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshDepthMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshDepthMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'MeshDepthMaterial';\r\n\t\r\n\t\tthis.morphTargets = false;\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;\r\n\t\r\n\tTHREE.MeshDepthMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.wireframe = source.wireframe;\r\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshNormalMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshNormalMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this, parameters );\r\n\t\r\n\t\tthis.type = 'MeshNormalMaterial';\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\r\n\t\tthis.morphTargets = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;\r\n\t\r\n\tTHREE.MeshNormalMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.wireframe = source.wireframe;\r\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MultiMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.MultiMaterial = function ( materials ) {\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.type = 'MultiMaterial';\r\n\t\r\n\t\tthis.materials = materials instanceof Array ? materials : [];\r\n\t\r\n\t\tthis.visible = true;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MultiMaterial.prototype = {\r\n\t\r\n\t\tconstructor: THREE.MultiMaterial,\r\n\t\r\n\t\ttoJSON: function ( meta ) {\r\n\t\r\n\t\t\tvar output = {\r\n\t\t\t\tmetadata: {\r\n\t\t\t\t\tversion: 4.2,\r\n\t\t\t\t\ttype: 'material',\r\n\t\t\t\t\tgenerator: 'MaterialExporter'\r\n\t\t\t\t},\r\n\t\t\t\tuuid: this.uuid,\r\n\t\t\t\ttype: this.type,\r\n\t\t\t\tmaterials: []\r\n\t\t\t};\r\n\t\r\n\t\t\tvar materials = this.materials;\r\n\t\r\n\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar material = materials[ i ].toJSON( meta );\r\n\t\t\t\tdelete material.metadata;\r\n\t\r\n\t\t\t\toutput.materials.push( material );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\toutput.visible = this.visible;\r\n\t\r\n\t\t\treturn output;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\tvar material = new this.constructor();\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.materials.length; i ++ ) {\r\n\t\r\n\t\t\t\tmaterial.materials.push( this.materials[ i ].clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tmaterial.visible = this.visible;\r\n\t\r\n\t\t\treturn material;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/PointsMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  size: <float>,\r\n\t *  sizeAttenuation: <bool>,\r\n\t *\r\n\t *  blending: THREE.NormalBlending,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  vertexColors: <bool>,\r\n\t *\r\n\t *  fog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.PointsMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'PointsMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff );\r\n\t\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.size = 1;\r\n\t\tthis.sizeAttenuation = true;\r\n\t\r\n\t\tthis.blending = THREE.NormalBlending;\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors;\r\n\t\r\n\t\tthis.fog = true;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;\r\n\t\r\n\tTHREE.PointsMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.color.copy( source.color );\r\n\t\r\n\t\tthis.map = source.map;\r\n\t\r\n\t\tthis.size = source.size;\r\n\t\tthis.sizeAttenuation = source.sizeAttenuation;\r\n\t\r\n\t\tthis.vertexColors = source.vertexColors;\r\n\t\r\n\t\tthis.fog = source.fog;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/ShaderMaterial.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  defines: { \"label\" : \"value\" },\r\n\t *  uniforms: { \"parameter1\": { type: \"f\", value: 1.0 }, \"parameter2\": { type: \"i\" value2: 2 } },\r\n\t *\r\n\t *  fragmentShader: <string>,\r\n\t *  vertexShader: <string>,\r\n\t *\r\n\t *  shading: THREE.SmoothShading,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>,\r\n\t *\r\n\t *  lights: <bool>,\r\n\t *\r\n\t *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n\t *\r\n\t *  skinning: <bool>,\r\n\t *  morphTargets: <bool>,\r\n\t *  morphNormals: <bool>,\r\n\t *\r\n\t *\tfog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.ShaderMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'ShaderMaterial';\r\n\t\r\n\t\tthis.defines = {};\r\n\t\tthis.uniforms = {};\r\n\t\r\n\t\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\r\n\t\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\r\n\t\r\n\t\tthis.shading = THREE.SmoothShading;\r\n\t\r\n\t\tthis.linewidth = 1;\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\r\n\t\tthis.fog = false; // set to use scene fog\r\n\t\r\n\t\tthis.lights = false; // set to use scene lights\r\n\t\r\n\t\tthis.vertexColors = THREE.NoColors; // set to use \"color\" attribute stream\r\n\t\r\n\t\tthis.skinning = false; // set to use skinning attribute streams\r\n\t\r\n\t\tthis.morphTargets = false; // set to use morph targets\r\n\t\tthis.morphNormals = false; // set to use morph normals\r\n\t\r\n\t\tthis.extensions = {\r\n\t\t\tderivatives: false, // set to use derivatives\r\n\t\t\tfragDepth: false, // set to use fragment depth values\r\n\t\t\tdrawBuffers: false, // set to use draw buffers\r\n\t\t\tshaderTextureLOD: false // set to use shader texture LOD\r\n\t\t};\r\n\t\r\n\t\t// When rendered geometry doesn't include these attributes but the material does,\r\n\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\r\n\t\tthis.defaultAttributeValues = {\r\n\t\t\t'color': [ 1, 1, 1 ],\r\n\t\t\t'uv': [ 0, 0 ],\r\n\t\t\t'uv2': [ 0, 0 ]\r\n\t\t};\r\n\t\r\n\t\tthis.index0AttributeName = undefined;\r\n\t\r\n\t\tif ( parameters !== undefined ) {\r\n\t\r\n\t\t\tif ( parameters.attributes !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.setValues( parameters );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;\r\n\t\r\n\tTHREE.ShaderMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.fragmentShader = source.fragmentShader;\r\n\t\tthis.vertexShader = source.vertexShader;\r\n\t\r\n\t\tthis.uniforms = THREE.UniformsUtils.clone( source.uniforms );\r\n\t\r\n\t\tthis.defines = source.defines;\r\n\t\r\n\t\tthis.shading = source.shading;\r\n\t\r\n\t\tthis.wireframe = source.wireframe;\r\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\t\r\n\t\tthis.fog = source.fog;\r\n\t\r\n\t\tthis.lights = source.lights;\r\n\t\r\n\t\tthis.vertexColors = source.vertexColors;\r\n\t\r\n\t\tthis.skinning = source.skinning;\r\n\t\r\n\t\tthis.morphTargets = source.morphTargets;\r\n\t\tthis.morphNormals = source.morphNormals;\r\n\t\r\n\t\tthis.extensions = source.extensions;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ShaderMaterial.prototype.toJSON = function ( meta ) {\r\n\t\r\n\t\tvar data = THREE.Material.prototype.toJSON.call( this, meta );\r\n\t\r\n\t\tdata.uniforms = this.uniforms;\r\n\t\tdata.vertexShader = this.vertexShader;\r\n\t\tdata.fragmentShader = this.fragmentShader;\r\n\t\r\n\t\treturn data;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/RawShaderMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.RawShaderMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.ShaderMaterial.call( this, parameters );\r\n\t\r\n\t\tthis.type = 'RawShaderMaterial';\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\r\n\tTHREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;\r\n\t\r\n\t// File:src/materials/SpriteMaterial.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *\tuvOffset: new THREE.Vector2(),\r\n\t *\tuvScale: new THREE.Vector2(),\r\n\t *\r\n\t *  fog: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.SpriteMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'SpriteMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff );\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.rotation = 0;\r\n\t\r\n\t\tthis.fog = false;\r\n\t\r\n\t\t// set parameters\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;\r\n\t\r\n\tTHREE.SpriteMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.color.copy( source.color );\r\n\t\tthis.map = source.map;\r\n\t\r\n\t\tthis.rotation = source.rotation;\r\n\t\r\n\t\tthis.fog = source.fog;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/textures/Texture.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author szimek / https://github.com/szimek/\r\n\t */\r\n\t\r\n\tTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.sourceFile = '';\r\n\t\r\n\t\tthis.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;\r\n\t\tthis.mipmaps = [];\r\n\t\r\n\t\tthis.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;\r\n\t\r\n\t\tthis.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\r\n\t\tthis.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\r\n\t\r\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\r\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\r\n\t\r\n\t\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\r\n\t\r\n\t\tthis.format = format !== undefined ? format : THREE.RGBAFormat;\r\n\t\tthis.type = type !== undefined ? type : THREE.UnsignedByteType;\r\n\t\r\n\t\tthis.offset = new THREE.Vector2( 0, 0 );\r\n\t\tthis.repeat = new THREE.Vector2( 1, 1 );\r\n\t\r\n\t\tthis.generateMipmaps = true;\r\n\t\tthis.premultiplyAlpha = false;\r\n\t\tthis.flipY = true;\r\n\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\r\n\t\r\n\t\r\n\t\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\r\n\t\t//\r\n\t\t// Also changing the encoding after already used by a Material will not automatically make the Material\r\n\t\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\r\n\t\tthis.encoding = THREE.LinearEncoding;\r\n\t\r\n\t\tthis.version = 0;\r\n\t\tthis.onUpdate = null;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Texture.DEFAULT_IMAGE = undefined;\r\n\tTHREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;\r\n\t\r\n\tTHREE.Texture.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Texture,\r\n\t\r\n\t\tset needsUpdate ( value ) {\r\n\t\r\n\t\t\tif ( value === true ) this.version ++;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tthis.image = source.image;\r\n\t\t\tthis.mipmaps = source.mipmaps.slice( 0 );\r\n\t\r\n\t\t\tthis.mapping = source.mapping;\r\n\t\r\n\t\t\tthis.wrapS = source.wrapS;\r\n\t\t\tthis.wrapT = source.wrapT;\r\n\t\r\n\t\t\tthis.magFilter = source.magFilter;\r\n\t\t\tthis.minFilter = source.minFilter;\r\n\t\r\n\t\t\tthis.anisotropy = source.anisotropy;\r\n\t\r\n\t\t\tthis.format = source.format;\r\n\t\t\tthis.type = source.type;\r\n\t\r\n\t\t\tthis.offset.copy( source.offset );\r\n\t\t\tthis.repeat.copy( source.repeat );\r\n\t\r\n\t\t\tthis.generateMipmaps = source.generateMipmaps;\r\n\t\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\r\n\t\t\tthis.flipY = source.flipY;\r\n\t\t\tthis.unpackAlignment = source.unpackAlignment;\r\n\t\t\tthis.encoding = source.encoding;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function ( meta ) {\r\n\t\r\n\t\t\tif ( meta.textures[ this.uuid ] !== undefined ) {\r\n\t\r\n\t\t\t\treturn meta.textures[ this.uuid ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction getDataURL( image ) {\r\n\t\r\n\t\t\t\tvar canvas;\r\n\t\r\n\t\t\t\tif ( image.toDataURL !== undefined ) {\r\n\t\r\n\t\t\t\t\tcanvas = image;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tcanvas = document.createElement( 'canvas' );\r\n\t\t\t\t\tcanvas.width = image.width;\r\n\t\t\t\t\tcanvas.height = image.height;\r\n\t\r\n\t\t\t\t\tcanvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\r\n\t\r\n\t\t\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\treturn canvas.toDataURL( 'image/png' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar output = {\r\n\t\t\t\tmetadata: {\r\n\t\t\t\t\tversion: 4.4,\r\n\t\t\t\t\ttype: 'Texture',\r\n\t\t\t\t\tgenerator: 'Texture.toJSON'\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tuuid: this.uuid,\r\n\t\t\t\tname: this.name,\r\n\t\r\n\t\t\t\tmapping: this.mapping,\r\n\t\r\n\t\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\r\n\t\t\t\toffset: [ this.offset.x, this.offset.y ],\r\n\t\t\t\twrap: [ this.wrapS, this.wrapT ],\r\n\t\r\n\t\t\t\tminFilter: this.minFilter,\r\n\t\t\t\tmagFilter: this.magFilter,\r\n\t\t\t\tanisotropy: this.anisotropy\r\n\t\t\t};\r\n\t\r\n\t\t\tif ( this.image !== undefined ) {\r\n\t\r\n\t\t\t\t// TODO: Move to THREE.Image\r\n\t\r\n\t\t\t\tvar image = this.image;\r\n\t\r\n\t\t\t\tif ( image.uuid === undefined ) {\r\n\t\r\n\t\t\t\t\timage.uuid = THREE.Math.generateUUID(); // UGH\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( meta.images[ image.uuid ] === undefined ) {\r\n\t\r\n\t\t\t\t\tmeta.images[ image.uuid ] = {\r\n\t\t\t\t\t\tuuid: image.uuid,\r\n\t\t\t\t\t\turl: getDataURL( image )\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\toutput.image = image.uuid;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tmeta.textures[ this.uuid ] = output;\r\n\t\r\n\t\t\treturn output;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttransformUv: function ( uv ) {\r\n\t\r\n\t\t\tif ( this.mapping !== THREE.UVMapping )  return;\r\n\t\r\n\t\t\tuv.multiply( this.repeat );\r\n\t\t\tuv.add( this.offset );\r\n\t\r\n\t\t\tif ( uv.x < 0 || uv.x > 1 ) {\r\n\t\r\n\t\t\t\tswitch ( this.wrapS ) {\r\n\t\r\n\t\t\t\t\tcase THREE.RepeatWrapping:\r\n\t\r\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.ClampToEdgeWrapping:\r\n\t\r\n\t\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.MirroredRepeatWrapping:\r\n\t\r\n\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\r\n\t\r\n\t\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( uv.y < 0 || uv.y > 1 ) {\r\n\t\r\n\t\t\t\tswitch ( this.wrapT ) {\r\n\t\r\n\t\t\t\t\tcase THREE.RepeatWrapping:\r\n\t\r\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.ClampToEdgeWrapping:\r\n\t\r\n\t\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.MirroredRepeatWrapping:\r\n\t\r\n\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\r\n\t\r\n\t\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.flipY ) {\r\n\t\r\n\t\t\t\tuv.y = 1 - uv.y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );\r\n\t\r\n\tTHREE.TextureIdCount = 0;\r\n\t\r\n\t// File:src/textures/CanvasTexture.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\t\r\n\t\tTHREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\t\r\n\t\tthis.needsUpdate = true;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\tTHREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;\r\n\t\r\n\t// File:src/textures/CubeTexture.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\t\r\n\t\timages = images !== undefined ? images : [];\r\n\t\tmapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;\r\n\t\r\n\t\tTHREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\t\r\n\t\tthis.flipY = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\tTHREE.CubeTexture.prototype.constructor = THREE.CubeTexture;\r\n\t\r\n\tObject.defineProperty( THREE.CubeTexture.prototype, 'images', {\r\n\t\r\n\t\tget: function () {\r\n\t\r\n\t\t\treturn this.image;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset: function ( value ) {\r\n\t\r\n\t\t\tthis.image = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/textures/CompressedTexture.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\t\r\n\t\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\t\r\n\t\tthis.image = { width: width, height: height };\r\n\t\tthis.mipmaps = mipmaps;\r\n\t\r\n\t\t// no flipping for cube textures\r\n\t\t// (also flipping doesn't work for compressed textures )\r\n\t\r\n\t\tthis.flipY = false;\r\n\t\r\n\t\t// can't generate mipmaps for compressed textures\r\n\t\t// mips must be embedded in DDS files\r\n\t\r\n\t\tthis.generateMipmaps = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\tTHREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;\r\n\t\r\n\t// File:src/textures/DataTexture.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\t\r\n\t\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\t\r\n\t\tthis.image = { data: data, width: width, height: height };\r\n\t\r\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\r\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\r\n\t\r\n\t\tthis.flipY = false;\r\n\t\tthis.generateMipmaps  = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\tTHREE.DataTexture.prototype.constructor = THREE.DataTexture;\r\n\t\r\n\t// File:src/textures/VideoTexture.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\t\r\n\t\tTHREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\t\r\n\t\tthis.generateMipmaps = false;\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\tfunction update() {\r\n\t\r\n\t\t\trequestAnimationFrame( update );\r\n\t\r\n\t\t\tif ( video.readyState === video.HAVE_ENOUGH_DATA ) {\r\n\t\r\n\t\t\t\tscope.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tupdate();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\tTHREE.VideoTexture.prototype.constructor = THREE.VideoTexture;\r\n\t\r\n\t// File:src/objects/Group.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Group = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Group';\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Group.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Group.prototype.constructor = THREE.Group;\r\n\t\r\n\t// File:src/objects/Points.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Points = function ( geometry, material ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Points';\r\n\t\r\n\t\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n\t\tthis.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Points.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Points.prototype.constructor = THREE.Points;\r\n\t\r\n\tTHREE.Points.prototype.raycast = ( function () {\r\n\t\r\n\t\tvar inverseMatrix = new THREE.Matrix4();\r\n\t\tvar ray = new THREE.Ray();\r\n\t\tvar sphere = new THREE.Sphere();\r\n\t\r\n\t\treturn function raycast( raycaster, intersects ) {\r\n\t\r\n\t\t\tvar object = this;\r\n\t\t\tvar geometry = this.geometry;\r\n\t\t\tvar matrixWorld = this.matrixWorld;\r\n\t\t\tvar threshold = raycaster.params.Points.threshold;\r\n\t\r\n\t\t\t// Checking boundingSphere distance to ray\r\n\t\r\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\t\r\n\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\tsphere.applyMatrix4( matrixWorld );\r\n\t\r\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tinverseMatrix.getInverse( matrixWorld );\r\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\t\r\n\t\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\r\n\t\t\tvar localThresholdSq = localThreshold * localThreshold;\r\n\t\t\tvar position = new THREE.Vector3();\r\n\t\r\n\t\t\tfunction testPoint( point, index ) {\r\n\t\r\n\t\t\t\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\r\n\t\r\n\t\t\t\tif ( rayPointDistanceSq < localThresholdSq ) {\r\n\t\r\n\t\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\r\n\t\t\t\t\tintersectPoint.applyMatrix4( matrixWorld );\r\n\t\r\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\r\n\t\r\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\r\n\t\r\n\t\t\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\r\n\t\t\t\t\t\tpoint: intersectPoint.clone(),\r\n\t\t\t\t\t\tindex: index,\r\n\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\tobject: object\r\n\t\r\n\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\tvar index = geometry.index;\r\n\t\t\t\tvar attributes = geometry.attributes;\r\n\t\t\t\tvar positions = attributes.position.array;\r\n\t\r\n\t\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\t\tvar indices = index.array;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar a = indices[ i ];\r\n\t\r\n\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\r\n\t\r\n\t\t\t\t\t\ttestPoint( position, a );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tposition.fromArray( positions, i * 3 );\r\n\t\r\n\t\t\t\t\t\ttestPoint( position, i );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tvar vertices = geometry.vertices;\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\ttestPoint( vertices[ i ], i );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.Points.prototype.clone = function () {\r\n\t\r\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/objects/Line.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Line = function ( geometry, material, mode ) {\r\n\t\r\n\t\tif ( mode === 1 ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\r\n\t\t\treturn new THREE.LineSegments( geometry, material );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Line';\r\n\t\r\n\t\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n\t\tthis.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Line.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Line.prototype.constructor = THREE.Line;\r\n\t\r\n\tTHREE.Line.prototype.raycast = ( function () {\r\n\t\r\n\t\tvar inverseMatrix = new THREE.Matrix4();\r\n\t\tvar ray = new THREE.Ray();\r\n\t\tvar sphere = new THREE.Sphere();\r\n\t\r\n\t\treturn function raycast( raycaster, intersects ) {\r\n\t\r\n\t\t\tvar precision = raycaster.linePrecision;\r\n\t\t\tvar precisionSq = precision * precision;\r\n\t\r\n\t\t\tvar geometry = this.geometry;\r\n\t\t\tvar matrixWorld = this.matrixWorld;\r\n\t\r\n\t\t\t// Checking boundingSphere distance to ray\r\n\t\r\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\t\r\n\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\tsphere.applyMatrix4( matrixWorld );\r\n\t\r\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tinverseMatrix.getInverse( matrixWorld );\r\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\t\r\n\t\t\tvar vStart = new THREE.Vector3();\r\n\t\t\tvar vEnd = new THREE.Vector3();\r\n\t\t\tvar interSegment = new THREE.Vector3();\r\n\t\t\tvar interRay = new THREE.Vector3();\r\n\t\t\tvar step = this instanceof THREE.LineSegments ? 2 : 1;\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\tvar index = geometry.index;\r\n\t\t\t\tvar attributes = geometry.attributes;\r\n\t\t\t\tvar positions = attributes.position.array;\r\n\t\r\n\t\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\t\tvar indices = index.array;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\r\n\t\r\n\t\t\t\t\t\tvar a = indices[ i ];\r\n\t\t\t\t\t\tvar b = indices[ i + 1 ];\r\n\t\r\n\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\r\n\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\r\n\t\r\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\t\r\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\t\r\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\r\n\t\r\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\r\n\t\r\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\t\r\n\t\t\t\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\t\tobject: this\r\n\t\r\n\t\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\r\n\t\r\n\t\t\t\t\t\tvStart.fromArray( positions, 3 * i );\r\n\t\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\r\n\t\r\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\t\r\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\t\r\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\r\n\t\r\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\r\n\t\r\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\t\r\n\t\t\t\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\t\tobject: this\r\n\t\r\n\t\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\tvar vertices = geometry.vertices;\r\n\t\t\t\tvar nbVertices = vertices.length;\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\r\n\t\r\n\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\r\n\t\r\n\t\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\t\r\n\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\r\n\t\r\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\r\n\t\r\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\t\r\n\t\t\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\tobject: this\r\n\t\r\n\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.Line.prototype.clone = function () {\r\n\t\r\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\r\n\t\r\n\t};\r\n\t\r\n\t// DEPRECATED\r\n\t\r\n\tTHREE.LineStrip = 0;\r\n\tTHREE.LinePieces = 1;\r\n\t\r\n\t// File:src/objects/LineSegments.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.LineSegments = function ( geometry, material ) {\r\n\t\r\n\t\tTHREE.Line.call( this, geometry, material );\r\n\t\r\n\t\tthis.type = 'LineSegments';\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LineSegments.prototype = Object.create( THREE.Line.prototype );\r\n\tTHREE.LineSegments.prototype.constructor = THREE.LineSegments;\r\n\t\r\n\t// File:src/objects/Mesh.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author jonobr1 / http://jonobr1.com/\r\n\t */\r\n\t\r\n\tTHREE.Mesh = function ( geometry, material ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Mesh';\r\n\t\r\n\t\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n\t\tthis.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\t\r\n\t\tthis.drawMode = THREE.TrianglesDrawMode;\r\n\t\r\n\t\tthis.updateMorphTargets();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Mesh.prototype.constructor = THREE.Mesh;\r\n\t\r\n\tTHREE.Mesh.prototype.setDrawMode = function ( value ) {\r\n\t\r\n\t\tthis.drawMode = value;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Mesh.prototype.updateMorphTargets = function () {\r\n\t\r\n\t\tif ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {\r\n\t\r\n\t\t\tthis.morphTargetBase = - 1;\r\n\t\t\tthis.morphTargetInfluences = [];\r\n\t\t\tthis.morphTargetDictionary = {};\r\n\t\r\n\t\t\tfor ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\r\n\t\r\n\t\t\t\tthis.morphTargetInfluences.push( 0 );\r\n\t\t\t\tthis.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {\r\n\t\r\n\t\tif ( this.morphTargetDictionary[ name ] !== undefined ) {\r\n\t\r\n\t\t\treturn this.morphTargetDictionary[ name ];\r\n\t\r\n\t\t}\r\n\t\r\n\t\tconsole.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );\r\n\t\r\n\t\treturn 0;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.Mesh.prototype.raycast = ( function () {\r\n\t\r\n\t\tvar inverseMatrix = new THREE.Matrix4();\r\n\t\tvar ray = new THREE.Ray();\r\n\t\tvar sphere = new THREE.Sphere();\r\n\t\r\n\t\tvar vA = new THREE.Vector3();\r\n\t\tvar vB = new THREE.Vector3();\r\n\t\tvar vC = new THREE.Vector3();\r\n\t\r\n\t\tvar tempA = new THREE.Vector3();\r\n\t\tvar tempB = new THREE.Vector3();\r\n\t\tvar tempC = new THREE.Vector3();\r\n\t\r\n\t\tvar uvA = new THREE.Vector2();\r\n\t\tvar uvB = new THREE.Vector2();\r\n\t\tvar uvC = new THREE.Vector2();\r\n\t\r\n\t\tvar barycoord = new THREE.Vector3();\r\n\t\r\n\t\tvar intersectionPoint = new THREE.Vector3();\r\n\t\tvar intersectionPointWorld = new THREE.Vector3();\r\n\t\r\n\t\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\r\n\t\r\n\t\t\tTHREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\r\n\t\r\n\t\t\tuv1.multiplyScalar( barycoord.x );\r\n\t\t\tuv2.multiplyScalar( barycoord.y );\r\n\t\t\tuv3.multiplyScalar( barycoord.z );\r\n\t\r\n\t\t\tuv1.add( uv2 ).add( uv3 );\r\n\t\r\n\t\t\treturn uv1.clone();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {\r\n\t\r\n\t\t\tvar intersect;\r\n\t\t\tvar material = object.material;\r\n\t\r\n\t\t\tif ( material.side === THREE.BackSide ) {\r\n\t\r\n\t\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( intersect === null ) return null;\r\n\t\r\n\t\t\tintersectionPointWorld.copy( point );\r\n\t\t\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\r\n\t\r\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\r\n\t\r\n\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\r\n\t\r\n\t\t\treturn {\r\n\t\t\t\tdistance: distance,\r\n\t\t\t\tpoint: intersectionPointWorld.clone(),\r\n\t\t\t\tobject: object\r\n\t\t\t};\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {\r\n\t\r\n\t\t\tvA.fromArray( positions, a * 3 );\r\n\t\t\tvB.fromArray( positions, b * 3 );\r\n\t\t\tvC.fromArray( positions, c * 3 );\r\n\t\r\n\t\t\tvar intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );\r\n\t\r\n\t\t\tif ( intersection ) {\r\n\t\r\n\t\t\t\tif ( uvs ) {\r\n\t\r\n\t\t\t\t\tuvA.fromArray( uvs, a * 2 );\r\n\t\t\t\t\tuvB.fromArray( uvs, b * 2 );\r\n\t\t\t\t\tuvC.fromArray( uvs, c * 2 );\r\n\t\r\n\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tintersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );\r\n\t\t\t\tintersection.faceIndex = a;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn intersection;\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn function raycast( raycaster, intersects ) {\r\n\t\r\n\t\t\tvar geometry = this.geometry;\r\n\t\t\tvar material = this.material;\r\n\t\t\tvar matrixWorld = this.matrixWorld;\r\n\t\r\n\t\t\tif ( material === undefined ) return;\r\n\t\r\n\t\t\t// Checking boundingSphere distance to ray\r\n\t\r\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\t\r\n\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\tsphere.applyMatrix4( matrixWorld );\r\n\t\r\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tinverseMatrix.getInverse( matrixWorld );\r\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\t\r\n\t\t\t// Check boundingBox before continuing\r\n\t\r\n\t\t\tif ( geometry.boundingBox !== null ) {\r\n\t\r\n\t\t\t\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar uvs, intersection;\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\tvar a, b, c;\r\n\t\t\t\tvar index = geometry.index;\r\n\t\t\t\tvar attributes = geometry.attributes;\r\n\t\t\t\tvar positions = attributes.position.array;\r\n\t\r\n\t\t\t\tif ( attributes.uv !== undefined ) {\r\n\t\r\n\t\t\t\t\tuvs = attributes.uv.array;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\t\tvar indices = index.array;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\ta = indices[ i ];\r\n\t\t\t\t\t\tb = indices[ i + 1 ];\r\n\t\t\t\t\t\tc = indices[ i + 2 ];\r\n\t\r\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\r\n\t\r\n\t\t\t\t\t\tif ( intersection ) {\r\n\t\r\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\r\n\t\t\t\t\t\t\tintersects.push( intersection );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 9 ) {\r\n\t\r\n\t\t\t\t\t\ta = i / 3;\r\n\t\t\t\t\t\tb = a + 1;\r\n\t\t\t\t\t\tc = a + 2;\r\n\t\r\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\r\n\t\r\n\t\t\t\t\t\tif ( intersection ) {\r\n\t\r\n\t\t\t\t\t\t\tintersection.index = a; // triangle number in positions buffer semantics\r\n\t\t\t\t\t\t\tintersects.push( intersection );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\tvar fvA, fvB, fvC;\r\n\t\t\t\tvar isFaceMaterial = material instanceof THREE.MultiMaterial;\r\n\t\t\t\tvar materials = isFaceMaterial === true ? material.materials : null;\r\n\t\r\n\t\t\t\tvar vertices = geometry.vertices;\r\n\t\t\t\tvar faces = geometry.faces;\r\n\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\r\n\t\t\t\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\r\n\t\r\n\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tvar face = faces[ f ];\r\n\t\t\t\t\tvar faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;\r\n\t\r\n\t\t\t\t\tif ( faceMaterial === undefined ) continue;\r\n\t\r\n\t\t\t\t\tfvA = vertices[ face.a ];\r\n\t\t\t\t\tfvB = vertices[ face.b ];\r\n\t\t\t\t\tfvC = vertices[ face.c ];\r\n\t\r\n\t\t\t\t\tif ( faceMaterial.morphTargets === true ) {\r\n\t\r\n\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\r\n\t\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\r\n\t\r\n\t\t\t\t\t\tvA.set( 0, 0, 0 );\r\n\t\t\t\t\t\tvB.set( 0, 0, 0 );\r\n\t\t\t\t\t\tvC.set( 0, 0, 0 );\r\n\t\r\n\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\r\n\t\r\n\t\t\t\t\t\t\tif ( influence === 0 ) continue;\r\n\t\r\n\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\r\n\t\r\n\t\t\t\t\t\t\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\r\n\t\t\t\t\t\t\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\r\n\t\t\t\t\t\t\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tvA.add( fvA );\r\n\t\t\t\t\t\tvB.add( fvB );\r\n\t\t\t\t\t\tvC.add( fvC );\r\n\t\r\n\t\t\t\t\t\tfvA = vA;\r\n\t\t\t\t\t\tfvB = vB;\r\n\t\t\t\t\t\tfvC = vC;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tintersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\r\n\t\r\n\t\t\t\t\tif ( intersection ) {\r\n\t\r\n\t\t\t\t\t\tif ( uvs ) {\r\n\t\r\n\t\t\t\t\t\t\tvar uvs_f = uvs[ f ];\r\n\t\t\t\t\t\t\tuvA.copy( uvs_f[ 0 ] );\r\n\t\t\t\t\t\t\tuvB.copy( uvs_f[ 1 ] );\r\n\t\t\t\t\t\t\tuvC.copy( uvs_f[ 2 ] );\r\n\t\r\n\t\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tintersection.face = face;\r\n\t\t\t\t\t\tintersection.faceIndex = f;\r\n\t\t\t\t\t\tintersects.push( intersection );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.Mesh.prototype.clone = function () {\r\n\t\r\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/objects/Bone.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author ikerr / http://verold.com\r\n\t */\r\n\t\r\n\tTHREE.Bone = function ( skin ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Bone';\r\n\t\r\n\t\tthis.skin = skin;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Bone.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Bone.prototype.constructor = THREE.Bone;\r\n\t\r\n\tTHREE.Bone.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.skin = source.skin;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/objects/Skeleton.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author michael guerrero / http://realitymeltdown.com\r\n\t * @author ikerr / http://verold.com\r\n\t */\r\n\t\r\n\tTHREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {\r\n\t\r\n\t\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\r\n\t\r\n\t\tthis.identityMatrix = new THREE.Matrix4();\r\n\t\r\n\t\t// copy the bone array\r\n\t\r\n\t\tbones = bones || [];\r\n\t\r\n\t\tthis.bones = bones.slice( 0 );\r\n\t\r\n\t\t// create a bone texture or an array of floats\r\n\t\r\n\t\tif ( this.useVertexTexture ) {\r\n\t\r\n\t\t\t// layout (1 matrix = 4 pixels)\r\n\t\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\r\n\t\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\r\n\t\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\r\n\t\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\r\n\t\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\r\n\t\r\n\t\t\t\r\n\t\t\tvar size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\r\n\t\t\tsize = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );\r\n\t\t\tsize = Math.max( size, 4 );\r\n\t\r\n\t\t\tthis.boneTextureWidth = size;\r\n\t\t\tthis.boneTextureHeight = size;\r\n\t\r\n\t\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\r\n\t\t\tthis.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.boneMatrices = new Float32Array( 16 * this.bones.length );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// use the supplied bone inverses or calculate the inverses\r\n\t\r\n\t\tif ( boneInverses === undefined ) {\r\n\t\r\n\t\t\tthis.calculateInverses();\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tif ( this.bones.length === boneInverses.length ) {\r\n\t\r\n\t\t\t\tthis.boneInverses = boneInverses.slice( 0 );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\r\n\t\r\n\t\t\t\tthis.boneInverses = [];\r\n\t\r\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\t\r\n\t\t\t\t\tthis.boneInverses.push( new THREE.Matrix4() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Skeleton.prototype.calculateInverses = function () {\r\n\t\r\n\t\tthis.boneInverses = [];\r\n\t\r\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\t\r\n\t\t\tvar inverse = new THREE.Matrix4();\r\n\t\r\n\t\t\tif ( this.bones[ b ] ) {\r\n\t\r\n\t\t\t\tinverse.getInverse( this.bones[ b ].matrixWorld );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.boneInverses.push( inverse );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Skeleton.prototype.pose = function () {\r\n\t\r\n\t\tvar bone;\r\n\t\r\n\t\t// recover the bind-time world matrices\r\n\t\r\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\t\r\n\t\t\tbone = this.bones[ b ];\r\n\t\r\n\t\t\tif ( bone ) {\r\n\t\r\n\t\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ b ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// compute the local matrices, positions, rotations and scales\r\n\t\r\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\t\r\n\t\t\tbone = this.bones[ b ];\r\n\t\r\n\t\t\tif ( bone ) {\r\n\t\r\n\t\t\t\tif ( bone.parent ) {\r\n\t\r\n\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\r\n\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Skeleton.prototype.update = ( function () {\r\n\t\r\n\t\tvar offsetMatrix = new THREE.Matrix4();\r\n\t\r\n\t\treturn function update() {\r\n\t\r\n\t\t\t// flatten bone matrices to array\r\n\t\r\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\t\r\n\t\t\t\t// compute the offset between the current and the original transform\r\n\t\r\n\t\t\t\tvar matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\r\n\t\r\n\t\t\t\toffsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\r\n\t\t\t\toffsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.useVertexTexture ) {\r\n\t\r\n\t\t\t\tthis.boneTexture.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\tTHREE.Skeleton.prototype.clone = function () {\r\n\t\r\n\t\treturn new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/objects/SkinnedMesh.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author ikerr / http://verold.com\r\n\t */\r\n\t\r\n\tTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\r\n\t\r\n\t\tTHREE.Mesh.call( this, geometry, material );\r\n\t\r\n\t\tthis.type = 'SkinnedMesh';\r\n\t\r\n\t\tthis.bindMode = \"attached\";\r\n\t\tthis.bindMatrix = new THREE.Matrix4();\r\n\t\tthis.bindMatrixInverse = new THREE.Matrix4();\r\n\t\r\n\t\t// init bones\r\n\t\r\n\t\t// TODO: remove bone creation as there is no reason (other than\r\n\t\t// convenience) for THREE.SkinnedMesh to do this.\r\n\t\r\n\t\tvar bones = [];\r\n\t\r\n\t\tif ( this.geometry && this.geometry.bones !== undefined ) {\r\n\t\r\n\t\t\tvar bone, gbone;\r\n\t\r\n\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\r\n\t\r\n\t\t\t\tgbone = this.geometry.bones[ b ];\r\n\t\r\n\t\t\t\tbone = new THREE.Bone( this );\r\n\t\t\t\tbones.push( bone );\r\n\t\r\n\t\t\t\tbone.name = gbone.name;\r\n\t\t\t\tbone.position.fromArray( gbone.pos );\r\n\t\t\t\tbone.quaternion.fromArray( gbone.rotq );\r\n\t\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\r\n\t\r\n\t\t\t\tgbone = this.geometry.bones[ b ];\r\n\t\r\n\t\t\t\tif ( gbone.parent !== - 1 && gbone.parent !== null ) {\r\n\t\r\n\t\t\t\t\tbones[ gbone.parent ].add( bones[ b ] );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis.add( bones[ b ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.normalizeSkinWeights();\r\n\t\r\n\t\tthis.updateMatrixWorld( true );\r\n\t\tthis.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );\r\n\tTHREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;\r\n\t\r\n\tTHREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {\r\n\t\r\n\t\tthis.skeleton = skeleton;\r\n\t\r\n\t\tif ( bindMatrix === undefined ) {\r\n\t\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\t\r\n\t\t\tthis.skeleton.calculateInverses();\r\n\t\r\n\t\t\tbindMatrix = this.matrixWorld;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.bindMatrix.copy( bindMatrix );\r\n\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SkinnedMesh.prototype.pose = function () {\r\n\t\r\n\t\tthis.skeleton.pose();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {\r\n\t\r\n\t\tif ( this.geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {\r\n\t\r\n\t\t\t\tvar sw = this.geometry.skinWeights[ i ];\r\n\t\r\n\t\t\t\tvar scale = 1.0 / sw.lengthManhattan();\r\n\t\r\n\t\t\t\tif ( scale !== Infinity ) {\r\n\t\r\n\t\t\t\t\tsw.multiplyScalar( scale );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tsw.set( 1, 0, 0, 0 ); // do something reasonable\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t} else if ( this.geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\tvar vec = new THREE.Vector4();\r\n\t\r\n\t\t\tvar skinWeight = this.geometry.attributes.skinWeight;\r\n\t\r\n\t\t\tfor ( var i = 0; i < skinWeight.count; i ++ ) {\r\n\t\r\n\t\t\t\tvec.x = skinWeight.getX( i );\r\n\t\t\t\tvec.y = skinWeight.getY( i );\r\n\t\t\t\tvec.z = skinWeight.getZ( i );\r\n\t\t\t\tvec.w = skinWeight.getW( i );\r\n\t\r\n\t\t\t\tvar scale = 1.0 / vec.lengthManhattan();\r\n\t\r\n\t\t\t\tif ( scale !== Infinity ) {\r\n\t\r\n\t\t\t\t\tvec.multiplyScalar( scale );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvec.set( 1, 0, 0, 0 ); // do something reasonable\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {\r\n\t\r\n\t\tTHREE.Mesh.prototype.updateMatrixWorld.call( this, true );\r\n\t\r\n\t\tif ( this.bindMode === \"attached\" ) {\r\n\t\r\n\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\r\n\t\r\n\t\t} else if ( this.bindMode === \"detached\" ) {\r\n\t\r\n\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SkinnedMesh.prototype.clone = function() {\r\n\t\r\n\t\treturn new this.constructor( this.geometry, this.material, this.useVertexTexture ).copy( this );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/objects/LOD.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.LOD = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'LOD';\r\n\t\r\n\t\tObject.defineProperties( this, {\r\n\t\t\tlevels: {\r\n\t\t\t\tenumerable: true,\r\n\t\t\t\tvalue: []\r\n\t\t\t},\r\n\t\t\tobjects: {\r\n\t\t\t\tget: function () {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\r\n\t\t\t\t\treturn this.levels;\r\n\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} );\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.LOD.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.LOD.prototype.constructor = THREE.LOD;\r\n\t\r\n\tTHREE.LOD.prototype.addLevel = function ( object, distance ) {\r\n\t\r\n\t\tif ( distance === undefined ) distance = 0;\r\n\t\r\n\t\tdistance = Math.abs( distance );\r\n\t\r\n\t\tvar levels = this.levels;\r\n\t\r\n\t\tfor ( var l = 0; l < levels.length; l ++ ) {\r\n\t\r\n\t\t\tif ( distance < levels[ l ].distance ) {\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tlevels.splice( l, 0, { distance: distance, object: object } );\r\n\t\r\n\t\tthis.add( object );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LOD.prototype.getObjectForDistance = function ( distance ) {\r\n\t\r\n\t\tvar levels = this.levels;\r\n\t\r\n\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tif ( distance < levels[ i ].distance ) {\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn levels[ i - 1 ].object;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LOD.prototype.raycast = ( function () {\r\n\t\r\n\t\tvar matrixPosition = new THREE.Vector3();\r\n\t\r\n\t\treturn function raycast( raycaster, intersects ) {\r\n\t\r\n\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\r\n\t\r\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\r\n\t\r\n\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.LOD.prototype.update = function () {\r\n\t\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\t\r\n\t\treturn function update( camera ) {\r\n\t\r\n\t\t\tvar levels = this.levels;\r\n\t\r\n\t\t\tif ( levels.length > 1 ) {\r\n\t\r\n\t\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\r\n\t\r\n\t\t\t\tvar distance = v1.distanceTo( v2 );\r\n\t\r\n\t\t\t\tlevels[ 0 ].object.visible = true;\r\n\t\r\n\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tif ( distance >= levels[ i ].distance ) {\r\n\t\r\n\t\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\r\n\t\t\t\t\t\tlevels[ i ].object.visible = true;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( ; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tlevels[ i ].object.visible = false;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\tTHREE.LOD.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Object3D.prototype.copy.call( this, source, false );\r\n\t\r\n\t\tvar levels = source.levels;\r\n\t\r\n\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tvar level = levels[ i ];\r\n\t\r\n\t\t\tthis.addLevel( level.object.clone(), level.distance );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LOD.prototype.toJSON = function ( meta ) {\r\n\t\r\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\t\r\n\t\tdata.object.levels = [];\r\n\t\r\n\t\tvar levels = this.levels;\r\n\t\r\n\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tvar level = levels[ i ];\r\n\t\r\n\t\t\tdata.object.levels.push( {\r\n\t\t\t\tobject: level.object.uuid,\r\n\t\t\t\tdistance: level.distance\r\n\t\t\t} );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn data;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/objects/Sprite.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Sprite = ( function () {\r\n\t\r\n\t\tvar indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );\r\n\t\tvar vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );\r\n\t\tvar uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );\r\n\t\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\t\tgeometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\t\r\n\t\treturn function Sprite( material ) {\r\n\t\r\n\t\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\t\tthis.type = 'Sprite';\r\n\t\r\n\t\t\tthis.geometry = geometry;\r\n\t\t\tthis.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\r\n\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\tTHREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Sprite.prototype.constructor = THREE.Sprite;\r\n\t\r\n\tTHREE.Sprite.prototype.raycast = ( function () {\r\n\t\r\n\t\tvar matrixPosition = new THREE.Vector3();\r\n\t\r\n\t\treturn function raycast( raycaster, intersects ) {\r\n\t\r\n\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\r\n\t\r\n\t\t\tvar distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );\r\n\t\t\tvar guessSizeSq = this.scale.x * this.scale.y;\r\n\t\r\n\t\t\tif ( distanceSq > guessSizeSq ) {\r\n\t\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\tdistance: Math.sqrt( distanceSq ),\r\n\t\t\t\tpoint: this.position,\r\n\t\t\t\tface: null,\r\n\t\t\t\tobject: this\r\n\t\r\n\t\t\t} );\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.Sprite.prototype.clone = function () {\r\n\t\r\n\t\treturn new this.constructor( this.material ).copy( this );\r\n\t\r\n\t};\r\n\t\r\n\t// Backwards compatibility\r\n\t\r\n\tTHREE.Particle = THREE.Sprite;\r\n\t\r\n\t// File:src/objects/LensFlare.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.lensFlares = [];\r\n\t\r\n\t\tthis.positionScreen = new THREE.Vector3();\r\n\t\tthis.customUpdateCallback = undefined;\r\n\t\r\n\t\tif ( texture !== undefined ) {\r\n\t\r\n\t\t\tthis.add( texture, size, distance, blending, color );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.LensFlare.prototype.constructor = THREE.LensFlare;\r\n\t\r\n\t\r\n\t/*\r\n\t * Add: adds another flare\r\n\t */\r\n\t\r\n\tTHREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {\r\n\t\r\n\t\tif ( size === undefined ) size = - 1;\r\n\t\tif ( distance === undefined ) distance = 0;\r\n\t\tif ( opacity === undefined ) opacity = 1;\r\n\t\tif ( color === undefined ) color = new THREE.Color( 0xffffff );\r\n\t\tif ( blending === undefined ) blending = THREE.NormalBlending;\r\n\t\r\n\t\tdistance = Math.min( distance, Math.max( 0, distance ) );\r\n\t\r\n\t\tthis.lensFlares.push( {\r\n\t\t\ttexture: texture,\t// THREE.Texture\r\n\t\t\tsize: size, \t\t// size in pixels (-1 = use texture.width)\r\n\t\t\tdistance: distance, \t// distance (0-1) from light source (0=at light source)\r\n\t\t\tx: 0, y: 0, z: 0,\t// screen position (-1 => 1) z = 0 is in front z = 1 is back\r\n\t\t\tscale: 1, \t\t// scale\r\n\t\t\trotation: 0, \t\t// rotation\r\n\t\t\topacity: opacity,\t// opacity\r\n\t\t\tcolor: color,\t\t// color\r\n\t\t\tblending: blending\t// blending\r\n\t\t} );\r\n\t\r\n\t};\r\n\t\r\n\t/*\r\n\t * Update lens flares update positions on all flares based on the screen position\r\n\t * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\r\n\t */\r\n\t\r\n\tTHREE.LensFlare.prototype.updateLensFlares = function () {\r\n\t\r\n\t\tvar f, fl = this.lensFlares.length;\r\n\t\tvar flare;\r\n\t\tvar vecX = - this.positionScreen.x * 2;\r\n\t\tvar vecY = - this.positionScreen.y * 2;\r\n\t\r\n\t\tfor ( f = 0; f < fl; f ++ ) {\r\n\t\r\n\t\t\tflare = this.lensFlares[ f ];\r\n\t\r\n\t\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\r\n\t\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\r\n\t\r\n\t\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\r\n\t\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LensFlare.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.positionScreen.copy( source.positionScreen );\r\n\t\tthis.customUpdateCallback = source.customUpdateCallback;\r\n\t\r\n\t\tfor ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tthis.lensFlares.push( source.lensFlares[ i ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/scenes/Scene.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Scene = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Scene';\r\n\t\r\n\t\tthis.fog = null;\r\n\t\tthis.overrideMaterial = null;\r\n\t\r\n\t\tthis.autoUpdate = true; // checked by the renderer\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Scene.prototype.constructor = THREE.Scene;\r\n\t\r\n\tTHREE.Scene.prototype.copy = function ( source, recursive ) {\r\n\t\r\n\t\tTHREE.Object3D.prototype.copy.call( this, source, recursive );\r\n\t\r\n\t\tif ( source.fog !== null ) this.fog = source.fog.clone();\r\n\t\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\r\n\t\r\n\t\tthis.autoUpdate = source.autoUpdate;\r\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/scenes/Fog.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Fog = function ( color, near, far ) {\r\n\t\r\n\t\tthis.name = '';\r\n\t\r\n\t\tthis.color = new THREE.Color( color );\r\n\t\r\n\t\tthis.near = ( near !== undefined ) ? near : 1;\r\n\t\tthis.far = ( far !== undefined ) ? far : 1000;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Fog.prototype.clone = function () {\r\n\t\r\n\t\treturn new THREE.Fog( this.color.getHex(), this.near, this.far );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/scenes/FogExp2.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.FogExp2 = function ( color, density ) {\r\n\t\r\n\t\tthis.name = '';\r\n\t\r\n\t\tthis.color = new THREE.Color( color );\r\n\t\tthis.density = ( density !== undefined ) ? density : 0.00025;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.FogExp2.prototype.clone = function () {\r\n\t\r\n\t\treturn new THREE.FogExp2( this.color.getHex(), this.density );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk.js\r\n\t\r\n\tTHREE.ShaderChunk = {};\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'alphamap_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'alphamap_pars_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tuniform sampler2D alphaMap;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'alphatest_fragment' ] = \"#ifdef ALPHATEST\\n\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'aomap_fragment' ] = \"#ifdef USE_AOMAP\\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'aomap_pars_fragment' ] = \"#ifdef USE_AOMAP\\n\tuniform sampler2D aoMap;\\n\tuniform float aoMapIntensity;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'begin_vertex' ] = \"\\nvec3 transformed = vec3( position );\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'beginnormal_vertex' ] = \"\\nvec3 objectNormal = vec3( normal );\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/bsdfs.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'bsdfs' ] = \"bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\t\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\t\t}\\n\t\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\treturn 1.0 / ( gl * gv );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat alpha = pow2( roughness );\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_GGX_Smith( alpha, dotNL, dotNV );\\n\tfloat D = D_GGX( alpha, dotNH );\\n\treturn F * ( G * D );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\tvec4 r = roughness * c0 + c1;\\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_BlinnPhong_Implicit( );\\n\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'bumpmap_pars_fragment' ] = \"#ifdef USE_BUMPMAP\\n\tuniform sampler2D bumpMap;\\n\tuniform float bumpScale;\\n\tvec2 dHdxy_fwd() {\\n\t\tvec2 dSTdx = dFdx( vUv );\\n\t\tvec2 dSTdy = dFdy( vUv );\\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\t\treturn vec2( dBx, dBy );\\n\t}\\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\t\tvec3 vSigmaX = dFdx( surf_pos );\\n\t\tvec3 vSigmaY = dFdy( surf_pos );\\n\t\tvec3 vN = surf_norm;\\n\t\tvec3 R1 = cross( vSigmaY, vN );\\n\t\tvec3 R2 = cross( vN, vSigmaX );\\n\t\tfloat fDet = dot( vSigmaX, R1 );\\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\t}\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'color_fragment' ] = \"#ifdef USE_COLOR\\n\tdiffuseColor.rgb *= vColor;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'color_pars_fragment' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'color_pars_vertex' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'color_vertex' ] = \"#ifdef USE_COLOR\\n\tvColor.xyz = color.xyz;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/common.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'common' ] = \"#define PI 3.14159\\n#define PI2 6.28318\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nstruct IncidentLight {\\n\tvec3 color;\\n\tvec3 direction;\\n\tbool visible;\\n};\\nstruct ReflectedLight {\\n\tvec3 directDiffuse;\\n\tvec3 directSpecular;\\n\tvec3 indirectDiffuse;\\n\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\tvec3 position;\\n\tvec3 normal;\\n\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/cube_uv_reflection_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'cube_uv_reflection_fragment' ] = \"#ifdef ENVMAP_TYPE_CUBE_UV\\nconst float cubeUV_textureSize = 1024.0;\\nint getFaceFromDirection(vec3 direction) {\\n    vec3 absDirection = abs(direction);\\n    int face = -1;\\n    if( absDirection.x > absDirection.z ) {\\n        if(absDirection.x > absDirection.y )\\n            face = direction.x > 0.0 ? 0 : 3;\\n        else\\n            face = direction.y > 0.0 ? 1 : 4;\\n    }\\n    else {\\n        if(absDirection.z > absDirection.y )\\n            face = direction.z > 0.0 ? 2 : 5;\\n        else\\n            face = direction.y > 0.0 ? 1 : 4;\\n    }\\n    return face;\\n}\\nconst float cubeUV_maxLods1 = log2(cubeUV_textureSize*0.25) - 1.0;\\nconst float cubeUV_rangeClamp = exp2((6.0 - 1.0) * 2.0);\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n    float scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n    float dxRoughness = dFdx(roughness);\\n    float dyRoughness = dFdy(roughness);\\n    vec3 dx = dFdx( vec * scale * dxRoughness );\\n    vec3 dy = dFdy( vec * scale * dyRoughness );\\n    float d = max( dot( dx, dx ), dot( dy, dy ) );\\n    d = clamp(d, 1.0, cubeUV_rangeClamp);\\n    float mipLevel = 0.5 * log2(d);\\n    return vec2(floor(mipLevel), fract(mipLevel));\\n}\\nconst float cubeUV_maxLods2 = log2(cubeUV_textureSize*0.25) - 2.0;\\nconst float cubeUV_rcpTextureSize = 1.0 / cubeUV_textureSize;\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n    mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n    float a = 16.0 * cubeUV_rcpTextureSize;\\n    vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n    vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n    float powScale = exp2_packed.x * exp2_packed.y;\\n    float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n    float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n    bool bRes = mipLevel == 0.0;\\n    scale =  bRes && (scale < a) ? a : scale;\\n    vec3 r;\\n    vec2 offset;\\n    int face = getFaceFromDirection(direction);\\n    float rcpPowScale = 1.0 / powScale;\\n    if( face == 0) {\\n        r = vec3(direction.x, -direction.z, direction.y);\\n        offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n        offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n    }\\n    else if( face == 1) {\\n        r = vec3(direction.y, direction.x, direction.z);\\n        offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n        offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n    }\\n    else if( face == 2) {\\n        r = vec3(direction.z, direction.x, direction.y);\\n        offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n        offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n    }\\n    else if( face == 3) {\\n        r = vec3(direction.x, direction.z, direction.y);\\n        offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n        offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n    }\\n    else if( face == 4) {\\n        r = vec3(direction.y, direction.x, -direction.z);\\n        offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n        offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n    }\\n    else {\\n        r = vec3(direction.z, -direction.x, direction.y);\\n        offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n        offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n    }\\n    r = normalize(r);\\n    float texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n    vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n    vec2 base = offset + vec2( texelOffset );\\n    return base + s * ( scale - 2.0 * texelOffset );\\n}\\nconst float cubeUV_maxLods3 = log2(cubeUV_textureSize*0.25) - 3.0;\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\n    float roughnessVal = roughness* cubeUV_maxLods3;\\n    float r1 = floor(roughnessVal);\\n    float r2 = r1 + 1.0;\\n    float t = fract(roughnessVal);\\n    vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n    float s = mipInfo.y;\\n    float level0 = mipInfo.x;\\n    float level1 = level0 + 1.0;\\n    level1 = level1 > 5.0 ? 5.0 : level1;\\n    level0 += min( floor( s + 0.5 ), 5.0 );\\n    vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n    vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n    vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n    vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n    vec4 result = mix(color10, color20, t);\\n    return vec4(result.rgb, 1.0);\\n}\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'defaultnormal_vertex' ] = \"#ifdef FLIP_SIDED\\n\tobjectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'displacementmap_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'displacementmap_pars_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\tuniform sampler2D displacementMap;\\n\tuniform float displacementScale;\\n\tuniform float displacementBias;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'emissivemap_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'emissivemap_pars_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tuniform sampler2D emissiveMap;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/encodings_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'encodings_pars_fragment' ] = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n  return value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n  float maxComponent = max( max( value.r, value.g ), value.b );\\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n  float maxRGB = max( value.x, max( value.g, value.b ) );\\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n  M            = ceil( M * 255.0 ) / 255.0;\\n  return vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n    float maxRGB = max( value.x, max( value.g, value.b ) );\\n    float D      = max( maxRange / maxRGB, 1.0 );\\n    D            = min( floor( D ) / 255.0, 1.0 );\\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n  vec4 vResult;\\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n  vResult.w = fract(Le);\\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n  return vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n  float Le = value.z * 255.0 + value.w;\\n  vec3 Xp_Y_XYZp;\\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n  return vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/encodings_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'encodings_fragment' ] = \"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'envmap_fragment' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#else\\n\t\tvec3 reflectVec = vReflect;\\n\t#endif\\n\t#ifdef DOUBLE_SIDED\\n\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\t#else\\n\t\tfloat flipNormal = 1.0;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\tvec2 sampleUV;\\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\\n\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\t#endif\\n\tenvColor = envMapTexelToLinear( envColor );\\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_MIX )\\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_ADD )\\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'envmap_pars_fragment' ] = \"#if defined( USE_ENVMAP ) || defined( STANDARD )\\n\tuniform float reflectivity;\\n\tuniform float envMapIntenstiy;\\n#endif\\n#ifdef USE_ENVMAP\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tuniform samplerCube envMap;\\n\t#else\\n\t\tuniform sampler2D envMap;\\n\t#endif\\n\tuniform float flipEnvMap;\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( STANDARD )\\n\t\tuniform float refractionRatio;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'envmap_pars_vertex' ] = \"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG ) && ! defined( STANDARD )\\n\tvarying vec3 vReflect;\\n\tuniform float refractionRatio;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'envmap_vertex' ] = \"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG ) && ! defined( STANDARD )\\n\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\tvReflect = reflect( cameraToVertex, worldNormal );\\n\t#else\\n\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'fog_fragment' ] = \"#ifdef USE_FOG\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\t#else\\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\t#endif\\n\t#ifdef FOG_EXP2\\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\\n\t#else\\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\t#endif\\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'fog_pars_fragment' ] = \"#ifdef USE_FOG\\n\tuniform vec3 fogColor;\\n\t#ifdef FOG_EXP2\\n\t\tuniform float fogDensity;\\n\t#else\\n\t\tuniform float fogNear;\\n\t\tuniform float fogFar;\\n\t#endif\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lightmap_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lightmap_pars_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\tuniform sampler2D lightMap;\\n\tuniform float lightMapIntensity;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_lambert_vertex' ] = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tdirectLight = getPointDirectLightIrradiance( pointLights[ i ], geometry );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tdirectLight = getSpotDirectLightIrradiance( spotLights[ i ], geometry );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectLight = getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\t\t#endif\\n\t}\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_pars.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_pars' ] = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\tvec3 irradiance = ambientLightColor;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\tstruct DirectionalLight {\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\tIncidentLight getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry ) {\\n\t\tIncidentLight directLight;\\n\t\tdirectLight.color = directionalLight.color;\\n\t\tdirectLight.direction = directionalLight.direction;\\n\t\tdirectLight.visible = true;\\n\t\treturn directLight;\\n\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\tstruct PointLight {\\n\t\tvec3 position;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\tIncidentLight getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry ) {\\n\t\tIncidentLight directLight;\\n\t\tvec3 lVector = pointLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\\n\t\t\tdirectLight.color = pointLight.color;\\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t\treturn directLight;\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tstruct SpotLight {\\n\t\tvec3 position;\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tfloat coneCos;\\n\t\tfloat penumbraCos;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\tIncidentLight getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry ) {\\n\t\tIncidentLight directLight;\\n\t\tvec3 lVector = spotLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\t\t\tdirectLight.color = spotLight.color;\\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t\treturn directLight;\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tstruct HemisphereLight {\\n\t\tvec3 direction;\\n\t\tvec3 skyColor;\\n\t\tvec3 groundColor;\\n\t};\\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tirradiance *= PI;\\n\t\t#endif\\n\t\treturn irradiance;\\n\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( STANDARD )\\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\t\t#else\\n\t\t\tfloat flipNormal = 1.0;\\n\t\t#endif\\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#endif\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\n\t\t#else\\n\t\t\tvec4 envMapColor = vec4( 0.0 );\\n\t\t#endif\\n\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\\n\t}\\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\t}\\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\t\t#endif\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\t\t#else\\n\t\t\tfloat flipNormal = 1.0;\\n\t\t#endif\\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#endif\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\t\tvec2 sampleUV;\\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#endif\\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#endif\\n\t\t#endif\\n\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\treturn envMapColor.rgb * envMapIntensity;\\n\t}\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_phong_fragment' ] = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_phong_pars_fragment' ] = \"#ifdef USE_ENVMAP\\n\tvarying vec3 vWorldPosition;\\n#endif\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\tvec3\tdiffuseColor;\\n\tvec3\tspecularColor;\\n\tfloat\tspecularShininess;\\n\tfloat\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\t(0)\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_phong_pars_vertex' ] = \"#ifdef USE_ENVMAP\\n\tvarying vec3 vWorldPosition;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_phong_vertex' ] = \"#ifdef USE_ENVMAP\\n\tvWorldPosition = worldPosition.xyz;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_standard_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_standard_fragment' ] = \"StandardMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\nmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_standard_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_standard_pars_fragment' ] = \"struct StandardMaterial {\\n\tvec3\tdiffuseColor;\\n\tfloat\tspecularRoughness;\\n\tvec3\tspecularColor;\\n};\\nvoid RE_Direct_Standard( const in IncidentLight directLight, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n}\\nvoid RE_IndirectDiffuse_Standard( const in vec3 irradiance, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Standard( const in vec3 radiance, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_Standard\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Standard\\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Standard\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_template.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_template' ] = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tdirectLight = getPointDirectLightIrradiance( pointLight, geometry );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tdirectLight = getSpotDirectLightIrradiance( spotLight, geometry );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tdirectLight = getDirectionalDirectLightIrradiance( directionalLight, geometry );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\t#ifdef USE_LIGHTMAP\\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tlightMapIrradiance *= PI;\\n\t\t#endif\\n\t\tirradiance += lightMapIrradiance;\\n\t#endif\\n\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t}\\n\t#endif\\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\n\t#endif\\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n\tRE_IndirectSpecular( radiance, geometry, material, reflectedLight );\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'logdepthbuf_fragment' ] = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'logdepthbuf_pars_fragment' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tuniform float logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'logdepthbuf_pars_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n\tuniform float logDepthBufFC;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'logdepthbuf_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvFragDepth = 1.0 + gl_Position.w;\\n\t#else\\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'map_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 texelColor = texture2D( map, vUv );\\n\ttexelColor = mapTexelToLinear( texelColor );\\n\tdiffuseColor *= texelColor;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'map_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform sampler2D map;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'map_particle_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'map_particle_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform vec4 offsetRepeat;\\n\tuniform sampler2D map;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'metalnessmap_fragment' ] = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\tmetalnessFactor *= texelMetalness.r;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'metalnessmap_pars_fragment' ] = \"#ifdef USE_METALNESSMAP\\n\tuniform sampler2D metalnessMap;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'morphnormal_vertex' ] = \"#ifdef USE_MORPHNORMALS\\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'morphtarget_pars_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\t#ifndef USE_MORPHNORMALS\\n\tuniform float morphTargetInfluences[ 8 ];\\n\t#else\\n\tuniform float morphTargetInfluences[ 4 ];\\n\t#endif\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'morphtarget_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\t#ifndef USE_MORPHNORMALS\\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/normal_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'normal_fragment' ] = \"#ifdef FLAT_SHADED\\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\tvec3 normal = normalize( vNormal );\\n\t#ifdef DOUBLE_SIDED\\n\t\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\n\t#endif\\n#endif\\n#ifdef USE_NORMALMAP\\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'normalmap_pars_fragment' ] = \"#ifdef USE_NORMALMAP\\n\tuniform sampler2D normalMap;\\n\tuniform vec2 normalScale;\\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\\n\t\tvec2 st0 = dFdx( vUv.st );\\n\t\tvec2 st1 = dFdy( vUv.st );\\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\t\tvec3 N = normalize( surf_norm );\\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\t\tmapN.xy = normalScale * mapN.xy;\\n\t\tmat3 tsn = mat3( S, T, N );\\n\t\treturn normalize( tsn * mapN );\\n\t}\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/premultiplied_alpha_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'premultiplied_alpha_fragment' ] = \"#ifdef PREMULTIPLIED_ALPHA\\n\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'project_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 mvPosition = modelViewMatrix * skinned;\\n#else\\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'roughnessmap_fragment' ] = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\troughnessFactor *= texelRoughness.r;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'roughnessmap_pars_fragment' ] = \"#ifdef USE_ROUGHNESSMAP\\n\tuniform sampler2D roughnessMap;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'shadowmap_pars_fragment' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n\tfloat unpackDepth( const in vec4 rgba_depth ) {\\n\t\tconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\\n\t\treturn dot( rgba_depth, bit_shift );\\n\t}\\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\t\treturn step( compare, unpackDepth( texture2D( depths, uv ) ) );\\n\t}\\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\t\tvec2 f = fract( uv * size + 0.5 );\\n\t\tfloat a = mix( lb, lt, f.y );\\n\t\tfloat b = mix( rb, rt, f.y );\\n\t\tfloat c = mix( a, b, f.x );\\n\t\treturn c;\\n\t}\\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tshadowCoord.xyz /= shadowCoord.w;\\n\t\tshadowCoord.z += shadowBias;\\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\t\tbool inFrustum = all( inFrustumVec );\\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\t\tbool frustumTest = all( frustumTestVec );\\n\t\tif ( frustumTest ) {\\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\t\t#endif\\n\t\t}\\n\t\treturn 1.0;\\n\t}\\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\t\tvec3 absV = abs( v );\\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\t\tabsV *= scaleToCube;\\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\t\tvec2 planar = v.xy;\\n\t\tfloat almostATexel = 1.5 * texelSizeY;\\n\t\tfloat almostOne = 1.0 - almostATexel;\\n\t\tif ( absV.z >= almostOne ) {\\n\t\t\tif ( v.z > 0.0 )\\n\t\t\t\tplanar.x = 4.0 - v.x;\\n\t\t} else if ( absV.x >= almostOne ) {\\n\t\t\tfloat signX = sign( v.x );\\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\\n\t\t} else if ( absV.y >= almostOne ) {\\n\t\t\tfloat signY = sign( v.y );\\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\t\t\tplanar.y = v.z * signY - 2.0;\\n\t\t}\\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\t}\\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\t\tvec3 lightToPosition = shadowCoord.xyz;\\n\t\tvec3 bd3D = normalize( lightToPosition );\\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\t\t#endif\\n\t}\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'shadowmap_pars_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'shadowmap_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'shadowmask_pars_fragment' ] = \"float getShadowMask() {\\n\tfloat shadow = 1.0;\\n\t#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#endif\\n\treturn shadow;\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'skinbase_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'skinning_pars_vertex' ] = \"#ifdef USE_SKINNING\\n\tuniform mat4 bindMatrix;\\n\tuniform mat4 bindMatrixInverse;\\n\t#ifdef BONE_TEXTURE\\n\t\tuniform sampler2D boneTexture;\\n\t\tuniform int boneTextureWidth;\\n\t\tuniform int boneTextureHeight;\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tfloat j = i * 4.0;\\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\\n\t\t\ty = dy * ( y + 0.5 );\\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\t\t\treturn bone;\\n\t\t}\\n\t#else\\n\t\tuniform mat4 boneGlobalMatrices[ MAX_BONES ];\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tmat4 bone = boneGlobalMatrices[ int(i) ];\\n\t\t\treturn bone;\\n\t\t}\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'skinning_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\tvec4 skinned = vec4( 0.0 );\\n\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\tskinned  = bindMatrixInverse * skinned;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'skinnormal_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 skinMatrix = mat4( 0.0 );\\n\tskinMatrix += skinWeight.x * boneMatX;\\n\tskinMatrix += skinWeight.y * boneMatY;\\n\tskinMatrix += skinWeight.z * boneMatZ;\\n\tskinMatrix += skinWeight.w * boneMatW;\\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'specularmap_fragment' ] = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\tspecularStrength = texelSpecular.r;\\n#else\\n\tspecularStrength = 1.0;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'specularmap_pars_fragment' ] = \"#ifdef USE_SPECULARMAP\\n\tuniform sampler2D specularMap;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/tonemapping_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'tonemapping_fragment' ] = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/tonemapping_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'tonemapping_pars_fragment' ] = \"#define saturate(a) clamp( a, 0.0, 1.0 )\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n  return toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  color = max( vec3( 0.0 ), color - 0.004 );\\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'uv2_pars_fragment' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvarying vec2 vUv2;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'uv2_pars_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tattribute vec2 uv2;\\n\tvarying vec2 vUv2;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'uv2_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvUv2 = uv2;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'uv_pars_fragment' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'uv_pars_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n\tuniform vec4 offsetRepeat;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'uv_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'worldpos_vertex' ] = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( STANDARD ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\t#ifdef USE_SKINNING\\n\t\tvec4 worldPosition = modelMatrix * skinned;\\n\t#else\\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/UniformsUtils.js\r\n\t\r\n\t/**\r\n\t * Uniform Utilities\r\n\t */\r\n\t\r\n\tTHREE.UniformsUtils = {\r\n\t\r\n\t\tmerge: function ( uniforms ) {\r\n\t\r\n\t\t\tvar merged = {};\r\n\t\r\n\t\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\r\n\t\r\n\t\t\t\tvar tmp = this.clone( uniforms[ u ] );\r\n\t\r\n\t\t\t\tfor ( var p in tmp ) {\r\n\t\r\n\t\t\t\t\tmerged[ p ] = tmp[ p ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn merged;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function ( uniforms_src ) {\r\n\t\r\n\t\t\tvar uniforms_dst = {};\r\n\t\r\n\t\t\tfor ( var u in uniforms_src ) {\r\n\t\r\n\t\t\t\tuniforms_dst[ u ] = {};\r\n\t\r\n\t\t\t\tfor ( var p in uniforms_src[ u ] ) {\r\n\t\r\n\t\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\r\n\t\r\n\t\t\t\t\tif ( parameter_src instanceof THREE.Color ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Vector2 ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Vector3 ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Vector4 ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Matrix3 ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Matrix4 ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Texture ) {\r\n\t\r\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\r\n\t\r\n\t\t\t\t\t} else if ( Array.isArray( parameter_src ) ) {\r\n\t\r\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn uniforms_dst;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/shaders/UniformsLib.js\r\n\t\r\n\t/**\r\n\t * Uniforms library for shared webgl shaders\r\n\t */\r\n\t\r\n\tTHREE.UniformsLib = {\r\n\t\r\n\t\tcommon: {\r\n\t\r\n\t\t\t\"diffuse\": { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n\t\t\t\"opacity\": { type: \"f\", value: 1.0 },\r\n\t\r\n\t\t\t\"map\": { type: \"t\", value: null },\r\n\t\t\t\"offsetRepeat\": { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\r\n\t\r\n\t\t\t\"specularMap\": { type: \"t\", value: null },\r\n\t\t\t\"alphaMap\": { type: \"t\", value: null },\r\n\t\r\n\t\t\t\"envMap\": { type: \"t\", value: null },\r\n\t\t\t\"flipEnvMap\": { type: \"f\", value: - 1 },\r\n\t\t\t\"reflectivity\": { type: \"f\", value: 1.0 },\r\n\t\t\t\"refractionRatio\": { type: \"f\", value: 0.98 }\r\n\t\r\n\t\t},\r\n\t\r\n\t\taomap: {\r\n\t\r\n\t\t\t\"aoMap\": { type: \"t\", value: null },\r\n\t\t\t\"aoMapIntensity\": { type: \"f\", value: 1 }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlightmap: {\r\n\t\r\n\t\t\t\"lightMap\": { type: \"t\", value: null },\r\n\t\t\t\"lightMapIntensity\": { type: \"f\", value: 1 }\r\n\t\r\n\t\t},\r\n\t\r\n\t\temissivemap: {\r\n\t\r\n\t\t\t\"emissiveMap\": { type: \"t\", value: null }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tbumpmap: {\r\n\t\r\n\t\t\t\"bumpMap\": { type: \"t\", value: null },\r\n\t\t\t\"bumpScale\": { type: \"f\", value: 1 }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalmap: {\r\n\t\r\n\t\t\t\"normalMap\": { type: \"t\", value: null },\r\n\t\t\t\"normalScale\": { type: \"v2\", value: new THREE.Vector2( 1, 1 ) }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdisplacementmap: {\r\n\t\r\n\t\t\t\"displacementMap\": { type: \"t\", value: null },\r\n\t\t\t\"displacementScale\": { type: \"f\", value: 1 },\r\n\t\t\t\"displacementBias\": { type: \"f\", value: 0 }\r\n\t\r\n\t\t},\r\n\t\r\n\t\troughnessmap: {\r\n\t\r\n\t\t\t\"roughnessMap\": { type: \"t\", value: null }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmetalnessmap: {\r\n\t\r\n\t\t\t\"metalnessMap\": { type: \"t\", value: null }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfog: {\r\n\t\r\n\t\t\t\"fogDensity\": { type: \"f\", value: 0.00025 },\r\n\t\t\t\"fogNear\": { type: \"f\", value: 1 },\r\n\t\t\t\"fogFar\": { type: \"f\", value: 2000 },\r\n\t\t\t\"fogColor\": { type: \"c\", value: new THREE.Color( 0xffffff ) }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlights: {\r\n\t\r\n\t\t\t\"ambientLightColor\": { type: \"fv\", value: [] },\r\n\t\r\n\t\t\t\"directionalLights\": { type: \"sa\", value: [], properties: {\r\n\t\t\t\t\"direction\": { type: \"v3\" },\r\n\t\t\t\t\"color\": { type: \"c\" },\r\n\t\r\n\t\t\t\t\"shadow\": { type: \"i\" },\r\n\t\t\t\t\"shadowBias\": { type: \"f\" },\r\n\t\t\t\t\"shadowRadius\": { type: \"f\" },\r\n\t\t\t\t\"shadowMapSize\": { type: \"v2\" }\r\n\t\t\t} },\r\n\t\r\n\t\t\t\"directionalShadowMap\": { type: \"tv\", value: [] },\r\n\t\t\t\"directionalShadowMatrix\": { type: \"m4v\", value: [] },\r\n\t\r\n\t\t\t\"spotLights\": { type: \"sa\", value: [], properties: {\r\n\t\t\t\t\"color\": { type: \"c\" },\r\n\t\t\t\t\"position\": { type: \"v3\" },\r\n\t\t\t\t\"direction\": { type: \"v3\" },\r\n\t\t\t\t\"distance\": { type: \"f\" },\r\n\t\t\t\t\"coneCos\": { type: \"f\" },\r\n\t\t\t\t\"penumbraCos\": { type: \"f\" },\r\n\t\t\t\t\"decay\": { type: \"f\" },\r\n\t\r\n\t\t\t\t\"shadow\": { type: \"i\" },\r\n\t\t\t\t\"shadowBias\": { type: \"f\" },\r\n\t\t\t\t\"shadowRadius\": { type: \"f\" },\r\n\t\t\t\t\"shadowMapSize\": { type: \"v2\" }\r\n\t\t\t} },\r\n\t\r\n\t\t\t\"spotShadowMap\": { type: \"tv\", value: [] },\r\n\t\t\t\"spotShadowMatrix\": { type: \"m4v\", value: [] },\r\n\t\r\n\t\t\t\"pointLights\": { type: \"sa\", value: [], properties: {\r\n\t\t\t\t\"color\": { type: \"c\" },\r\n\t\t\t\t\"position\": { type: \"v3\" },\r\n\t\t\t\t\"decay\": { type: \"f\" },\r\n\t\t\t\t\"distance\": { type: \"f\" },\r\n\t\r\n\t\t\t\t\"shadow\": { type: \"i\" },\r\n\t\t\t\t\"shadowBias\": { type: \"f\" },\r\n\t\t\t\t\"shadowRadius\": { type: \"f\" },\r\n\t\t\t\t\"shadowMapSize\": { type: \"v2\" }\r\n\t\t\t} },\r\n\t\r\n\t\t\t\"pointShadowMap\": { type: \"tv\", value: [] },\r\n\t\t\t\"pointShadowMatrix\": { type: \"m4v\", value: [] },\r\n\t\r\n\t\t\t\"hemisphereLights\": { type: \"sa\", value: [], properties: {\r\n\t\t\t\t\"direction\": { type: \"v3\" },\r\n\t\t\t\t\"skyColor\": { type: \"c\" },\r\n\t\t\t\t\"groundColor\": { type: \"c\" }\r\n\t\t\t} }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tpoints: {\r\n\t\r\n\t\t\t\"diffuse\": { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n\t\t\t\"opacity\": { type: \"f\", value: 1.0 },\r\n\t\t\t\"size\": { type: \"f\", value: 1.0 },\r\n\t\t\t\"scale\": { type: \"f\", value: 1.0 },\r\n\t\t\t\"map\": { type: \"t\", value: null },\r\n\t\t\t\"offsetRepeat\": { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) }\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/cube_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'cube_frag' ] = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/cube_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'cube_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\t#include <logdepthbuf_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/depth_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'depth_frag' ] = \"uniform float mNear;\\nuniform float mFar;\\nuniform float opacity;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\t#include <logdepthbuf_fragment>\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\t#else\\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\t#endif\\n\tfloat color = 1.0 - smoothstep( mNear, mFar, depth );\\n\tgl_FragColor = vec4( vec3( color ), opacity );\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/depth_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'depth_vert' ] = \"#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/depthRGBA_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'depthRGBA_frag' ] = \"#include <common>\\n#include <logdepthbuf_pars_fragment>\\nvec4 pack_depth( const in float depth ) {\\n\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\\n\tconst vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\\n\tvec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\\n\tres -= res.xxyz * bit_mask;\\n\treturn res;\\n}\\nvoid main() {\\n\t#include <logdepthbuf_fragment>\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tgl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\\n\t#else\\n\t\tgl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\\n\t#endif\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/depthRGBA_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'depthRGBA_vert' ] = \"#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/distanceRGBA_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'distanceRGBA_frag' ] = \"uniform vec3 lightPos;\\nvarying vec4 vWorldPosition;\\n#include <common>\\nvec4 pack1K ( float depth ) {\\n\tdepth /= 1000.0;\\n\tconst vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\\n\tconst vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\\n\tvec4 res = mod( depth * bitSh * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\\n\tres -= res.xxyz * bitMsk;\\n\treturn res;\\n}\\nfloat unpack1K ( vec4 color ) {\\n\tconst vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\\n\treturn dot( color, bitSh ) * 1000.0;\\n}\\nvoid main () {\\n\tgl_FragColor = pack1K( length( vWorldPosition.xyz - lightPos.xyz ) );\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/distanceRGBA_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'distanceRGBA_vert' ] = \"varying vec4 vWorldPosition;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\nvoid main() {\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <worldpos_vertex>\\n\tvWorldPosition = worldPosition;\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/equirect_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'equirect_frag' ] = \"uniform sampler2D tEquirect;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\tvec3 direction = normalize( vWorldPosition );\\n\tvec2 sampleUV;\\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/equirect_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'equirect_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\t#include <logdepthbuf_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/linedashed_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'linedashed_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\t\tdiscard;\\n\t}\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <color_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/linedashed_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'linedashed_vert' ] = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\tvLineDistance = scale * lineDistance;\\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\tgl_Position = projectionMatrix * mvPosition;\\n\t#include <logdepthbuf_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/meshbasic_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'meshbasic_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\tReflectedLight reflectedLight;\\n\treflectedLight.directDiffuse = vec3( 0.0 );\\n\treflectedLight.directSpecular = vec3( 0.0 );\\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\\n\treflectedLight.indirectSpecular = vec3( 0.0 );\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/meshbasic_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'meshbasic_vert' ] = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <skinbase_vertex>\\n\t#ifdef USE_ENVMAP\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#endif\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/meshlambert_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'meshlambert_frag' ] = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <emissivemap_fragment>\\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\t#include <lightmap_fragment>\\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\t#ifdef DOUBLE_SIDED\\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\t#else\\n\t\treflectedLight.directDiffuse = vLightFront;\\n\t#endif\\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/meshlambert_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'meshlambert_vert' ] = \"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <lights_lambert_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/meshphong_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'meshphong_frag' ] = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_phong_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/meshphong_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'meshphong_vert' ] = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <lights_phong_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <lights_phong_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/meshstandard_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'meshstandard_frag' ] = \"#define STANDARD\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\nuniform float envMapIntensity;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_standard_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <roughnessmap_fragment>\\n\t#include <metalnessmap_fragment>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_standard_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/meshstandard_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'meshstandard_vert' ] = \"#define STANDARD\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/normal_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'normal_frag' ] = \"uniform float opacity;\\nvarying vec3 vNormal;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\tgl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/normal_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'normal_vert' ] = \"varying vec3 vNormal;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\tvNormal = normalize( normalMatrix * normal );\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/points_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'points_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_particle_fragment>\\n\t#include <color_fragment>\\n\t#include <alphatest_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/points_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'points_vert' ] = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#ifdef USE_SIZEATTENUATION\\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\t#else\\n\t\tgl_PointSize = size;\\n\t#endif\\n\t#include <logdepthbuf_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib.js\r\n\t\r\n\t/**\r\n\t * Webgl Shader Library for three.js\r\n\t *\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t */\r\n\t\r\n\t\r\n\tTHREE.ShaderLib = {\r\n\t\r\n\t\t'basic': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"aomap\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"fog\" ]\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk['meshbasic_vert'],\r\n\t\t\tfragmentShader: THREE.ShaderChunk['meshbasic_frag']\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'lambert': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"aomap\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"lightmap\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"emissivemap\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"lights\" ],\r\n\t\r\n\t\t\t\t{\r\n\t\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) }\r\n\t\t\t\t}\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk['meshlambert_vert'],\r\n\t\t\tfragmentShader: THREE.ShaderChunk['meshlambert_frag']\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'phong': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"aomap\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"lightmap\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"emissivemap\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"bumpmap\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"normalmap\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"displacementmap\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"lights\" ],\r\n\t\r\n\t\t\t\t{\r\n\t\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\t\"specular\" : { type: \"c\", value: new THREE.Color( 0x111111 ) },\r\n\t\t\t\t\t\"shininess\": { type: \"f\", value: 30 }\r\n\t\t\t\t}\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk['meshphong_vert'],\r\n\t\t\tfragmentShader: THREE.ShaderChunk['meshphong_frag']\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'standard': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"aomap\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"lightmap\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"emissivemap\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"bumpmap\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"normalmap\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"displacementmap\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"roughnessmap\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"metalnessmap\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"lights\" ],\r\n\t\r\n\t\t\t\t{\r\n\t\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\t\"roughness\": { type: \"f\", value: 0.5 },\r\n\t\t\t\t\t\"metalness\": { type: \"f\", value: 0 },\r\n\t\t\t\t\t\"envMapIntensity\" : { type: \"f\", value: 1 } // temporary\r\n\t\t\t\t}\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk['meshstandard_vert'],\r\n\t\t\tfragmentShader: THREE.ShaderChunk['meshstandard_frag']\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'points': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ \"points\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"fog\" ]\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk['points_vert'],\r\n\t\t\tfragmentShader: THREE.ShaderChunk['points_frag']\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'dashed': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\r\n\t\t\t\t{\r\n\t\t\t\t\t\"scale\"    : { type: \"f\", value: 1 },\r\n\t\t\t\t\t\"dashSize\" : { type: \"f\", value: 1 },\r\n\t\t\t\t\t\"totalSize\": { type: \"f\", value: 2 }\r\n\t\t\t\t}\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk['linedashed_vert'],\r\n\t\t\tfragmentShader: THREE.ShaderChunk['linedashed_frag']\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'depth': {\r\n\t\r\n\t\t\tuniforms: {\r\n\t\r\n\t\t\t\t\"mNear\": { type: \"f\", value: 1.0 },\r\n\t\t\t\t\"mFar\" : { type: \"f\", value: 2000.0 },\r\n\t\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk['depth_vert'],\r\n\t\t\tfragmentShader: THREE.ShaderChunk['depth_frag']\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'normal': {\r\n\t\r\n\t\t\tuniforms: {\r\n\t\r\n\t\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk['normal_vert'],\r\n\t\t\tfragmentShader: THREE.ShaderChunk['normal_frag']\r\n\t\r\n\t\t},\r\n\t\r\n\t\t/* -------------------------------------------------------------------------\r\n\t\t//\tCube map shader\r\n\t\t ------------------------------------------------------------------------- */\r\n\t\r\n\t\t'cube': {\r\n\t\r\n\t\t\tuniforms: {\r\n\t\t\t\t\"tCube\": { type: \"t\", value: null },\r\n\t\t\t\t\"tFlip\": { type: \"f\", value: - 1 }\r\n\t\t\t},\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk['cube_vert'],\r\n\t\t\tfragmentShader: THREE.ShaderChunk['cube_frag']\r\n\t\r\n\t\t},\r\n\t\r\n\t\t/* -------------------------------------------------------------------------\r\n\t\t//\tCube map shader\r\n\t\t ------------------------------------------------------------------------- */\r\n\t\r\n\t\t'equirect': {\r\n\t\r\n\t\t\tuniforms: {\r\n\t\t\t\t\"tEquirect\": { type: \"t\", value: null },\r\n\t\t\t\t\"tFlip\": { type: \"f\", value: - 1 }\r\n\t\t\t},\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk['equirect_vert'],\r\n\t\t\tfragmentShader: THREE.ShaderChunk['equirect_frag']\r\n\t\r\n\t\t},\r\n\t\r\n\t\t/* Depth encoding into RGBA texture\r\n\t\t *\r\n\t\t * based on SpiderGL shadow map example\r\n\t\t * http://spidergl.org/example.php?id=6\r\n\t\t *\r\n\t\t * originally from\r\n\t\t * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD\r\n\t\t *\r\n\t\t * see also\r\n\t\t * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\r\n\t\t */\r\n\t\r\n\t\t'depthRGBA': {\r\n\t\r\n\t\t\tuniforms: {},\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk['depthRGBA_vert'],\r\n\t\t\tfragmentShader: THREE.ShaderChunk['depthRGBA_frag']\r\n\t\r\n\t\t},\r\n\t\r\n\t\r\n\t\t'distanceRGBA': {\r\n\t\r\n\t\t\tuniforms: {\r\n\t\r\n\t\t\t\t\"lightPos\": { type: \"v3\", value: new THREE.Vector3( 0, 0, 0 ) }\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk['distanceRGBA_vert'],\r\n\t\t\tfragmentShader: THREE.ShaderChunk['distanceRGBA_frag']\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/WebGLRenderer.js\r\n\t\r\n\t/**\r\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author szimek / https://github.com/szimek/\r\n\t */\r\n\t\r\n\tTHREE.WebGLRenderer = function ( parameters ) {\r\n\t\r\n\t\tconsole.log( 'THREE.WebGLRenderer', THREE.REVISION );\r\n\t\r\n\t\tparameters = parameters || {};\r\n\t\r\n\t\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),\r\n\t\t_context = parameters.context !== undefined ? parameters.context : null,\r\n\t\r\n\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\r\n\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\r\n\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\r\n\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\r\n\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\r\n\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;\r\n\t\r\n\t\tvar lights = [];\r\n\t\r\n\t\tvar opaqueObjects = [];\r\n\t\tvar opaqueObjectsLastIndex = - 1;\r\n\t\tvar transparentObjects = [];\r\n\t\tvar transparentObjectsLastIndex = - 1;\r\n\t\r\n\t\tvar morphInfluences = new Float32Array( 8 );\r\n\t\r\n\t\tvar sprites = [];\r\n\t\tvar lensFlares = [];\r\n\t\r\n\t\t// public properties\r\n\t\r\n\t\tthis.domElement = _canvas;\r\n\t\tthis.context = null;\r\n\t\r\n\t\t// clearing\r\n\t\r\n\t\tthis.autoClear = true;\r\n\t\tthis.autoClearColor = true;\r\n\t\tthis.autoClearDepth = true;\r\n\t\tthis.autoClearStencil = true;\r\n\t\r\n\t\t// scene graph\r\n\t\r\n\t\tthis.sortObjects = true;\r\n\t\r\n\t\t// physically based shading\r\n\t\r\n\t\tthis.gammaFactor = 2.0;\t// for backwards compatibility\r\n\t\tthis.gammaInput = false;\r\n\t\tthis.gammaOutput = false;\r\n\t\r\n\t\t// physical lights\r\n\t\r\n\t\tthis.physicallyCorrectLights = false;\r\n\t\r\n\t\t// tone mapping\r\n\t\r\n\t\tthis.toneMapping = THREE.LinearToneMapping;\r\n\t\tthis.toneMappingExposure = 1.0;\r\n\t\tthis.toneMappingWhitePoint = 1.0;\r\n\t\r\n\t\t// morphs\r\n\t\r\n\t\tthis.maxMorphTargets = 8;\r\n\t\tthis.maxMorphNormals = 4;\r\n\t\r\n\t\t// flags\r\n\t\r\n\t\tthis.autoScaleCubemaps = true;\r\n\t\r\n\t\t// internal properties\r\n\t\r\n\t\tvar _this = this,\r\n\t\r\n\t\t// internal state cache\r\n\t\r\n\t\t_currentProgram = null,\r\n\t\t_currentRenderTarget = null,\r\n\t\t_currentFramebuffer = null,\r\n\t\t_currentMaterialId = - 1,\r\n\t\t_currentGeometryProgram = '',\r\n\t\t_currentCamera = null,\r\n\t\r\n\t\t_currentScissor = new THREE.Vector4(),\r\n\t\t_currentScissorTest = null,\r\n\t\r\n\t\t_currentViewport = new THREE.Vector4(),\r\n\t\r\n\t\t//\r\n\t\r\n\t\t_usedTextureUnits = 0,\r\n\t\r\n\t\t//\r\n\t\r\n\t\t_clearColor = new THREE.Color( 0x000000 ),\r\n\t\t_clearAlpha = 0,\r\n\t\r\n\t\t_width = _canvas.width,\r\n\t\t_height = _canvas.height,\r\n\t\r\n\t\t_pixelRatio = 1,\r\n\t\r\n\t\t_scissor = new THREE.Vector4( 0, 0, _width, _height ),\r\n\t\t_scissorTest = false,\r\n\t\r\n\t\t_viewport = new THREE.Vector4( 0, 0, _width, _height ),\r\n\t\r\n\t\t// frustum\r\n\t\r\n\t\t_frustum = new THREE.Frustum(),\r\n\t\r\n\t\t// camera matrices cache\r\n\t\r\n\t\t_projScreenMatrix = new THREE.Matrix4(),\r\n\t\r\n\t\t_vector3 = new THREE.Vector3(),\r\n\t\r\n\t\t// light arrays cache\r\n\t\r\n\t\t_lights = {\r\n\t\r\n\t\t\thash: '',\r\n\t\r\n\t\t\tambient: [ 0, 0, 0 ],\r\n\t\t\tdirectional: [],\r\n\t\t\tdirectionalShadowMap: [],\r\n\t\t\tdirectionalShadowMatrix: [],\r\n\t\t\tspot: [],\r\n\t\t\tspotShadowMap: [],\r\n\t\t\tspotShadowMatrix: [],\r\n\t\t\tpoint: [],\r\n\t\t\tpointShadowMap: [],\r\n\t\t\tpointShadowMatrix: [],\r\n\t\t\themi: [],\r\n\t\r\n\t\t\tshadows: [],\r\n\t\t\tshadowsPointLight: 0\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// info\r\n\t\r\n\t\t_infoMemory = {\r\n\t\r\n\t\t\tgeometries: 0,\r\n\t\t\ttextures: 0\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_infoRender = {\r\n\t\r\n\t\t\tcalls: 0,\r\n\t\t\tvertices: 0,\r\n\t\t\tfaces: 0,\r\n\t\t\tpoints: 0\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.info = {\r\n\t\r\n\t\t\trender: _infoRender,\r\n\t\t\tmemory: _infoMemory,\r\n\t\t\tprograms: null\r\n\t\r\n\t\t};\r\n\t\r\n\t\r\n\t\t// initialize\r\n\t\r\n\t\tvar _gl;\r\n\t\r\n\t\ttry {\r\n\t\r\n\t\t\tvar attributes = {\r\n\t\t\t\talpha: _alpha,\r\n\t\t\t\tdepth: _depth,\r\n\t\t\t\tstencil: _stencil,\r\n\t\t\t\tantialias: _antialias,\r\n\t\t\t\tpremultipliedAlpha: _premultipliedAlpha,\r\n\t\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\r\n\t\t\t};\r\n\t\r\n\t\t\t_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\r\n\t\r\n\t\t\tif ( _gl === null ) {\r\n\t\r\n\t\t\t\tif ( _canvas.getContext( 'webgl' ) !== null ) {\r\n\t\r\n\t\t\t\t\tthrow 'Error creating WebGL context with your selected attributes.';\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthrow 'Error creating WebGL context.';\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\r\n\t\r\n\t\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\r\n\t\r\n\t\t\t\t_gl.getShaderPrecisionFormat = function () {\r\n\t\r\n\t\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\r\n\t\r\n\t\t} catch ( error ) {\r\n\t\r\n\t\t\tconsole.error( 'THREE.WebGLRenderer: ' + error );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar extensions = new THREE.WebGLExtensions( _gl );\r\n\t\r\n\t\textensions.get( 'OES_texture_float' );\r\n\t\textensions.get( 'OES_texture_float_linear' );\r\n\t\textensions.get( 'OES_texture_half_float' );\r\n\t\textensions.get( 'OES_texture_half_float_linear' );\r\n\t\textensions.get( 'OES_standard_derivatives' );\r\n\t\textensions.get( 'ANGLE_instanced_arrays' );\r\n\t\r\n\t\tif ( extensions.get( 'OES_element_index_uint' ) ) {\r\n\t\r\n\t\t\tTHREE.BufferGeometry.MaxIndex = 4294967296;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );\r\n\t\r\n\t\tvar state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );\r\n\t\tvar properties = new THREE.WebGLProperties();\r\n\t\tvar objects = new THREE.WebGLObjects( _gl, properties, this.info );\r\n\t\tvar programCache = new THREE.WebGLPrograms( this, capabilities );\r\n\t\tvar lightCache = new THREE.WebGLLights();\r\n\t\r\n\t\tthis.info.programs = programCache.programs;\r\n\t\r\n\t\tvar bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );\r\n\t\tvar indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\r\n\t\r\n\t\t//\r\n\t\r\n\t\tfunction getTargetPixelRatio() {\r\n\t\r\n\t\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction glClearColor( r, g, b, a ) {\r\n\t\r\n\t\t\tif ( _premultipliedAlpha === true ) {\r\n\t\r\n\t\t\t\tr *= a; g *= a; b *= a;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.clearColor( r, g, b, a );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setDefaultGLState() {\r\n\t\r\n\t\t\tstate.init();\r\n\t\r\n\t\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\r\n\t\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\r\n\t\r\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction resetGLState() {\r\n\t\r\n\t\t\t_currentProgram = null;\r\n\t\t\t_currentCamera = null;\r\n\t\r\n\t\t\t_currentGeometryProgram = '';\r\n\t\t\t_currentMaterialId = - 1;\r\n\t\r\n\t\t\tstate.reset();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tsetDefaultGLState();\r\n\t\r\n\t\tthis.context = _gl;\r\n\t\tthis.capabilities = capabilities;\r\n\t\tthis.extensions = extensions;\r\n\t\tthis.properties = properties;\r\n\t\tthis.state = state;\r\n\t\r\n\t\t// shadow map\r\n\t\r\n\t\tvar shadowMap = new THREE.WebGLShadowMap( this, _lights, objects );\r\n\t\r\n\t\tthis.shadowMap = shadowMap;\r\n\t\r\n\t\r\n\t\t// Plugins\r\n\t\r\n\t\tvar spritePlugin = new THREE.SpritePlugin( this, sprites );\r\n\t\tvar lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );\r\n\t\r\n\t\t// API\r\n\t\r\n\t\tthis.getContext = function () {\r\n\t\r\n\t\t\treturn _gl;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getContextAttributes = function () {\r\n\t\r\n\t\t\treturn _gl.getContextAttributes();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.forceContextLoss = function () {\r\n\t\r\n\t\t\textensions.get( 'WEBGL_lose_context' ).loseContext();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getMaxAnisotropy = ( function () {\r\n\t\r\n\t\t\tvar value;\r\n\t\r\n\t\t\treturn function getMaxAnisotropy() {\r\n\t\r\n\t\t\t\tif ( value !== undefined ) return value;\r\n\t\r\n\t\t\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\t\r\n\t\t\t\tif ( extension !== null ) {\r\n\t\r\n\t\t\t\t\tvalue = _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvalue = 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn value;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )();\r\n\t\r\n\t\tthis.getPrecision = function () {\r\n\t\r\n\t\t\treturn capabilities.precision;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getPixelRatio = function () {\r\n\t\r\n\t\t\treturn _pixelRatio;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setPixelRatio = function ( value ) {\r\n\t\r\n\t\t\tif ( value === undefined ) return;\r\n\t\r\n\t\t\t_pixelRatio = value;\r\n\t\r\n\t\t\tthis.setSize( _viewport.z, _viewport.w, false );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getSize = function () {\r\n\t\r\n\t\t\treturn {\r\n\t\t\t\twidth: _width,\r\n\t\t\t\theight: _height\r\n\t\t\t};\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setSize = function ( width, height, updateStyle ) {\r\n\t\r\n\t\t\t_width = width;\r\n\t\t\t_height = height;\r\n\t\r\n\t\t\t_canvas.width = width * _pixelRatio;\r\n\t\t\t_canvas.height = height * _pixelRatio;\r\n\t\r\n\t\t\tif ( updateStyle !== false ) {\r\n\t\r\n\t\t\t\t_canvas.style.width = width + 'px';\r\n\t\t\t\t_canvas.style.height = height + 'px';\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.setViewport( 0, 0, width, height );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setViewport = function ( x, y, width, height ) {\r\n\t\r\n\t\t\tstate.viewport( _viewport.set( x, y, width, height ) );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setScissor = function ( x, y, width, height ) {\r\n\t\r\n\t\t\tstate.scissor( _scissor.set( x, y, width, height ) );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setScissorTest = function ( boolean ) {\r\n\t\r\n\t\t\tstate.setScissorTest( _scissorTest = boolean );\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Clearing\r\n\t\r\n\t\tthis.getClearColor = function () {\r\n\t\r\n\t\t\treturn _clearColor;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setClearColor = function ( color, alpha ) {\r\n\t\r\n\t\t\t_clearColor.set( color );\r\n\t\r\n\t\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\r\n\t\r\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getClearAlpha = function () {\r\n\t\r\n\t\t\treturn _clearAlpha;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setClearAlpha = function ( alpha ) {\r\n\t\r\n\t\t\t_clearAlpha = alpha;\r\n\t\r\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clear = function ( color, depth, stencil ) {\r\n\t\r\n\t\t\tvar bits = 0;\r\n\t\r\n\t\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\r\n\t\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\r\n\t\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\r\n\t\r\n\t\t\t_gl.clear( bits );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clearColor = function () {\r\n\t\r\n\t\t\tthis.clear( true, false, false );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clearDepth = function () {\r\n\t\r\n\t\t\tthis.clear( false, true, false );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clearStencil = function () {\r\n\t\r\n\t\t\tthis.clear( false, false, true );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\r\n\t\r\n\t\t\tthis.setRenderTarget( renderTarget );\r\n\t\t\tthis.clear( color, depth, stencil );\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Reset\r\n\t\r\n\t\tthis.resetGLState = resetGLState;\r\n\t\r\n\t\tthis.dispose = function() {\r\n\t\r\n\t\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Events\r\n\t\r\n\t\tfunction onContextLost( event ) {\r\n\t\r\n\t\t\tevent.preventDefault();\r\n\t\r\n\t\t\tresetGLState();\r\n\t\t\tsetDefaultGLState();\r\n\t\r\n\t\t\tproperties.clear();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction onTextureDispose( event ) {\r\n\t\r\n\t\t\tvar texture = event.target;\r\n\t\r\n\t\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\r\n\t\r\n\t\t\tdeallocateTexture( texture );\r\n\t\r\n\t\t\t_infoMemory.textures --;\r\n\t\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction onRenderTargetDispose( event ) {\r\n\t\r\n\t\t\tvar renderTarget = event.target;\r\n\t\r\n\t\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\r\n\t\r\n\t\t\tdeallocateRenderTarget( renderTarget );\r\n\t\r\n\t\t\t_infoMemory.textures --;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction onMaterialDispose( event ) {\r\n\t\r\n\t\t\tvar material = event.target;\r\n\t\r\n\t\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\r\n\t\r\n\t\t\tdeallocateMaterial( material );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Buffer deallocation\r\n\t\r\n\t\tfunction deallocateTexture( texture ) {\r\n\t\r\n\t\t\tvar textureProperties = properties.get( texture );\r\n\t\r\n\t\t\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\r\n\t\r\n\t\t\t\t// cube texture\r\n\t\r\n\t\t\t\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// 2D texture\r\n\t\r\n\t\t\t\tif ( textureProperties.__webglInit === undefined ) return;\r\n\t\r\n\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// remove all webgl properties\r\n\t\t\tproperties.delete( texture );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction deallocateRenderTarget( renderTarget ) {\r\n\t\r\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\r\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\r\n\t\r\n\t\t\tif ( ! renderTarget || textureProperties.__webglTexture === undefined ) return;\r\n\t\r\n\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\r\n\t\r\n\t\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\r\n\t\t\t\t\t_gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\r\n\t\t\t\t_gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tproperties.delete( renderTarget.texture );\r\n\t\t\tproperties.delete( renderTarget );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction deallocateMaterial( material ) {\r\n\t\r\n\t\t\treleaseMaterialProgramReference( material );\r\n\t\r\n\t\t\tproperties.delete( material );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\tfunction releaseMaterialProgramReference( material ) {\r\n\t\r\n\t\t\tvar programInfo = properties.get( material ).program;\r\n\t\r\n\t\t\tmaterial.program = undefined;\r\n\t\r\n\t\t\tif ( programInfo !== undefined ) {\r\n\t\r\n\t\t\t\tprogramCache.releaseProgram( programInfo );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Buffer rendering\r\n\t\r\n\t\tthis.renderBufferImmediate = function ( object, program, material ) {\r\n\t\r\n\t\t\tstate.initAttributes();\r\n\t\r\n\t\t\tvar buffers = properties.get( object );\r\n\t\r\n\t\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\r\n\t\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\r\n\t\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\r\n\t\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\r\n\t\r\n\t\t\tvar attributes = program.getAttributes();\r\n\t\r\n\t\t\tif ( object.hasPositions ) {\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\r\n\t\r\n\t\t\t\tstate.enableAttribute( attributes.position );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object.hasNormals ) {\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\r\n\t\r\n\t\t\t\tif ( material.type !== 'MeshPhongMaterial' && material.type !== 'MeshStandardMaterial' && material.shading === THREE.FlatShading ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\r\n\t\r\n\t\t\t\t\t\tvar array = object.normalArray;\r\n\t\r\n\t\t\t\t\t\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\r\n\t\t\t\t\t\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\r\n\t\t\t\t\t\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\r\n\t\r\n\t\t\t\t\t\tarray[ i + 0 ] = nx;\r\n\t\t\t\t\t\tarray[ i + 1 ] = ny;\r\n\t\t\t\t\t\tarray[ i + 2 ] = nz;\r\n\t\r\n\t\t\t\t\t\tarray[ i + 3 ] = nx;\r\n\t\t\t\t\t\tarray[ i + 4 ] = ny;\r\n\t\t\t\t\t\tarray[ i + 5 ] = nz;\r\n\t\r\n\t\t\t\t\t\tarray[ i + 6 ] = nx;\r\n\t\t\t\t\t\tarray[ i + 7 ] = ny;\r\n\t\t\t\t\t\tarray[ i + 8 ] = nz;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\r\n\t\r\n\t\t\t\tstate.enableAttribute( attributes.normal );\r\n\t\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object.hasUvs && material.map ) {\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\r\n\t\r\n\t\t\t\tstate.enableAttribute( attributes.uv );\r\n\t\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\r\n\t\r\n\t\t\t\tstate.enableAttribute( attributes.color );\r\n\t\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.disableUnusedAttributes();\r\n\t\r\n\t\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\r\n\t\r\n\t\t\tobject.count = 0;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\r\n\t\r\n\t\t\tsetMaterial( material );\r\n\t\r\n\t\t\tvar program = setProgram( camera, fog, material, object );\r\n\t\r\n\t\t\tvar updateBuffers = false;\r\n\t\t\tvar geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;\r\n\t\r\n\t\t\tif ( geometryProgram !== _currentGeometryProgram ) {\r\n\t\r\n\t\t\t\t_currentGeometryProgram = geometryProgram;\r\n\t\t\t\tupdateBuffers = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// morph targets\r\n\t\r\n\t\t\tvar morphTargetInfluences = object.morphTargetInfluences;\r\n\t\r\n\t\t\tif ( morphTargetInfluences !== undefined ) {\r\n\t\r\n\t\t\t\tvar activeInfluences = [];\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar influence = morphTargetInfluences[ i ];\r\n\t\t\t\t\tactiveInfluences.push( [ influence, i ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tactiveInfluences.sort( absNumericalSort );\r\n\t\r\n\t\t\t\tif ( activeInfluences.length > 8 ) {\r\n\t\r\n\t\t\t\t\tactiveInfluences.length = 8;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar morphAttributes = geometry.morphAttributes;\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar influence = activeInfluences[ i ];\r\n\t\t\t\t\tmorphInfluences[ i ] = influence[ 0 ];\r\n\t\r\n\t\t\t\t\tif ( influence[ 0 ] !== 0 ) {\r\n\t\r\n\t\t\t\t\t\tvar index = influence[ 1 ];\r\n\t\r\n\t\t\t\t\t\tif ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );\r\n\t\t\t\t\t\tif ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tif ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );\r\n\t\t\t\t\t\tif ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar uniforms = program.getUniforms();\r\n\t\r\n\t\t\t\tif ( uniforms.morphTargetInfluences !== null ) {\r\n\t\r\n\t\t\t\t\t_gl.uniform1fv( uniforms.morphTargetInfluences, morphInfluences );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tupdateBuffers = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar index = geometry.index;\r\n\t\t\tvar position = geometry.attributes.position;\r\n\t\r\n\t\t\tif ( material.wireframe === true ) {\r\n\t\r\n\t\t\t\tindex = objects.getWireframeAttribute( geometry );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar renderer;\r\n\t\r\n\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\trenderer = indexedBufferRenderer;\r\n\t\t\t\trenderer.setIndex( index );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\trenderer = bufferRenderer;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\tsetupVertexAttributes( material, program, geometry );\r\n\t\r\n\t\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar dataStart = 0;\r\n\t\t\tvar dataCount = Infinity;\r\n\t\r\n\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\tdataCount = index.count;\r\n\t\r\n\t\t\t} else if ( position !== undefined ) {\r\n\t\r\n\t\t\t\tdataCount = position.count;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar rangeStart = geometry.drawRange.start;\r\n\t\t\tvar rangeCount = geometry.drawRange.count;\r\n\t\r\n\t\t\tvar groupStart = group !== null ? group.start : 0;\r\n\t\t\tvar groupCount = group !== null ? group.count : Infinity;\r\n\t\r\n\t\t\tvar drawStart = Math.max( dataStart, rangeStart, groupStart );\r\n\t\t\tvar drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\r\n\t\r\n\t\t\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tif ( object instanceof THREE.Mesh ) {\r\n\t\r\n\t\t\t\tif ( material.wireframe === true ) {\r\n\t\r\n\t\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\r\n\t\t\t\t\trenderer.setMode( _gl.LINES );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tswitch ( object.drawMode ) {\r\n\t\r\n\t\t\t\t\t\tcase THREE.TrianglesDrawMode:\r\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase THREE.TriangleStripDrawMode:\r\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_STRIP );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase THREE.TriangleFanDrawMode:\r\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_FAN );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t} else if ( object instanceof THREE.Line ) {\r\n\t\r\n\t\t\t\tvar lineWidth = material.linewidth;\r\n\t\r\n\t\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\r\n\t\r\n\t\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\r\n\t\r\n\t\t\t\tif ( object instanceof THREE.LineSegments ) {\r\n\t\r\n\t\t\t\t\trenderer.setMode( _gl.LINES );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( object instanceof THREE.Points ) {\r\n\t\r\n\t\t\t\trenderer.setMode( _gl.POINTS );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\r\n\t\r\n\t\t\t\tif ( geometry.maxInstancedCount > 0 ) {\r\n\t\r\n\t\t\t\t\trenderer.renderInstances( geometry, drawStart, drawCount );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\trenderer.render( drawStart, drawCount );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\r\n\t\r\n\t\t\tvar extension;\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\r\n\t\r\n\t\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\t\r\n\t\t\t\tif ( extension === null ) {\r\n\t\r\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\r\n\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( startIndex === undefined ) startIndex = 0;\r\n\t\r\n\t\t\tstate.initAttributes();\r\n\t\r\n\t\t\tvar geometryAttributes = geometry.attributes;\r\n\t\r\n\t\t\tvar programAttributes = program.getAttributes();\r\n\t\r\n\t\t\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\r\n\t\r\n\t\t\tfor ( var name in programAttributes ) {\r\n\t\r\n\t\t\t\tvar programAttribute = programAttributes[ name ];\r\n\t\r\n\t\t\t\tif ( programAttribute >= 0 ) {\r\n\t\r\n\t\t\t\t\tvar geometryAttribute = geometryAttributes[ name ];\r\n\t\r\n\t\t\t\t\tif ( geometryAttribute !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tvar size = geometryAttribute.itemSize;\r\n\t\t\t\t\t\tvar buffer = objects.getAttributeBuffer( geometryAttribute );\r\n\t\r\n\t\t\t\t\t\tif ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\t\r\n\t\t\t\t\t\t\tvar data = geometryAttribute.data;\r\n\t\t\t\t\t\t\tvar stride = data.stride;\r\n\t\t\t\t\t\t\tvar offset = geometryAttribute.offset;\r\n\t\r\n\t\t\t\t\t\t\tif ( data instanceof THREE.InstancedInterleavedBuffer ) {\r\n\t\r\n\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );\r\n\t\r\n\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\r\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tif ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {\r\n\t\r\n\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );\r\n\t\r\n\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\r\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tvar value = materialDefaultAttributeValues[ name ];\r\n\t\r\n\t\t\t\t\t\tif ( value !== undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tswitch ( value.length ) {\r\n\t\r\n\t\t\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, value );\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, value );\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib4fv( programAttribute, value );\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib1fv( programAttribute, value );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.disableUnusedAttributes();\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Sorting\r\n\t\r\n\t\tfunction absNumericalSort( a, b ) {\r\n\t\r\n\t\t\treturn Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction painterSortStable ( a, b ) {\r\n\t\r\n\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\r\n\t\r\n\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\r\n\t\r\n\t\t\t} else if ( a.material.id !== b.material.id ) {\r\n\t\r\n\t\t\t\treturn a.material.id - b.material.id;\r\n\t\r\n\t\t\t} else if ( a.z !== b.z ) {\r\n\t\r\n\t\t\t\treturn a.z - b.z;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\treturn a.id - b.id;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction reversePainterSortStable ( a, b ) {\r\n\t\r\n\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\r\n\t\r\n\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\r\n\t\r\n\t\t\t} if ( a.z !== b.z ) {\r\n\t\r\n\t\t\t\treturn b.z - a.z;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\treturn a.id - b.id;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Rendering\r\n\t\r\n\t\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\r\n\t\r\n\t\t\tif ( camera instanceof THREE.Camera === false ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar fog = scene.fog;\r\n\t\r\n\t\t\t// reset caching for this frame\r\n\t\r\n\t\t\t_currentGeometryProgram = '';\r\n\t\t\t_currentMaterialId = - 1;\r\n\t\t\t_currentCamera = null;\r\n\t\r\n\t\t\t// update scene graph\r\n\t\r\n\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\r\n\t\r\n\t\t\t// update camera matrices and frustum\r\n\t\r\n\t\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\r\n\t\r\n\t\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\r\n\t\r\n\t\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\r\n\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\t\r\n\t\t\tlights.length = 0;\r\n\t\r\n\t\t\topaqueObjectsLastIndex = - 1;\r\n\t\t\ttransparentObjectsLastIndex = - 1;\r\n\t\r\n\t\t\tsprites.length = 0;\r\n\t\t\tlensFlares.length = 0;\r\n\t\r\n\t\t\tprojectObject( scene, camera );\r\n\t\r\n\t\t\topaqueObjects.length = opaqueObjectsLastIndex + 1;\r\n\t\t\ttransparentObjects.length = transparentObjectsLastIndex + 1;\r\n\t\r\n\t\t\tif ( _this.sortObjects === true ) {\r\n\t\r\n\t\t\t\topaqueObjects.sort( painterSortStable );\r\n\t\t\t\ttransparentObjects.sort( reversePainterSortStable );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tsetupLights( lights, camera );\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tshadowMap.render( scene, camera );\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\t_infoRender.calls = 0;\r\n\t\t\t_infoRender.vertices = 0;\r\n\t\t\t_infoRender.faces = 0;\r\n\t\t\t_infoRender.points = 0;\r\n\t\r\n\t\t\tif ( renderTarget === undefined ) {\r\n\t\r\n\t\t\t\trenderTarget = null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.setRenderTarget( renderTarget );\r\n\t\r\n\t\t\tif ( this.autoClear || forceClear ) {\r\n\t\r\n\t\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tif ( scene.overrideMaterial ) {\r\n\t\r\n\t\t\t\tvar overrideMaterial = scene.overrideMaterial;\r\n\t\r\n\t\t\t\trenderObjects( opaqueObjects, camera, fog, overrideMaterial );\r\n\t\t\t\trenderObjects( transparentObjects, camera, fog, overrideMaterial );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// opaque pass (front-to-back order)\r\n\t\r\n\t\t\t\tstate.setBlending( THREE.NoBlending );\r\n\t\t\t\trenderObjects( opaqueObjects, camera, fog );\r\n\t\r\n\t\t\t\t// transparent pass (back-to-front order)\r\n\t\r\n\t\t\t\trenderObjects( transparentObjects, camera, fog );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// custom render plugins (post pass)\r\n\t\r\n\t\t\tspritePlugin.render( scene, camera );\r\n\t\t\tlensFlarePlugin.render( scene, camera, _currentViewport );\r\n\t\r\n\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\r\n\t\r\n\t\t\tif ( renderTarget ) {\r\n\t\r\n\t\t\t\tvar texture = renderTarget.texture;\r\n\t\r\n\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&\r\n\t\t\t\t\t\ttexture.minFilter !== THREE.NearestFilter &&\r\n\t\t\t\t\t\ttexture.minFilter !== THREE.LinearFilter ) {\r\n\t\r\n\t\t\t\t\tupdateRenderTargetMipmap( renderTarget );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\r\n\t\r\n\t\t\tstate.setDepthTest( true );\r\n\t\t\tstate.setDepthWrite( true );\r\n\t\t\tstate.setColorWrite( true );\r\n\t\r\n\t\t\t// _gl.finish();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction pushRenderItem( object, geometry, material, z, group ) {\r\n\t\r\n\t\t\tvar array, index;\r\n\t\r\n\t\t\t// allocate the next position in the appropriate array\r\n\t\r\n\t\t\tif ( material.transparent ) {\r\n\t\r\n\t\t\t\tarray = transparentObjects;\r\n\t\t\t\tindex = ++ transparentObjectsLastIndex;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tarray = opaqueObjects;\r\n\t\t\t\tindex = ++ opaqueObjectsLastIndex;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// recycle existing render item or grow the array\r\n\t\r\n\t\t\tvar renderItem = array[ index ];\r\n\t\r\n\t\t\tif ( renderItem !== undefined ) {\r\n\t\r\n\t\t\t\trenderItem.id = object.id;\r\n\t\t\t\trenderItem.object = object;\r\n\t\t\t\trenderItem.geometry = geometry;\r\n\t\t\t\trenderItem.material = material;\r\n\t\t\t\trenderItem.z = _vector3.z;\r\n\t\t\t\trenderItem.group = group;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\trenderItem = {\r\n\t\t\t\t\tid: object.id,\r\n\t\t\t\t\tobject: object,\r\n\t\t\t\t\tgeometry: geometry,\r\n\t\t\t\t\tmaterial: material,\r\n\t\t\t\t\tz: _vector3.z,\r\n\t\t\t\t\tgroup: group\r\n\t\t\t\t};\r\n\t\r\n\t\t\t\t// assert( index === array.length );\r\n\t\t\t\tarray.push( renderItem );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction projectObject( object, camera ) {\r\n\t\r\n\t\t\tif ( object.visible === false ) return;\r\n\t\r\n\t\t\tif ( object.layers.test( camera.layers ) ) {\r\n\t\r\n\t\t\t\tif ( object instanceof THREE.Light ) {\r\n\t\r\n\t\t\t\t\tlights.push( object );\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.Sprite ) {\r\n\t\r\n\t\t\t\t\tif ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {\r\n\t\r\n\t\t\t\t\t\tsprites.push( object );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.LensFlare ) {\r\n\t\r\n\t\t\t\t\tlensFlares.push( object );\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject ) {\r\n\t\r\n\t\t\t\t\tif ( _this.sortObjects === true ) {\r\n\t\r\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\r\n\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tpushRenderItem( object, null, object.material, _vector3.z, null );\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {\r\n\t\r\n\t\t\t\t\tif ( object instanceof THREE.SkinnedMesh ) {\r\n\t\r\n\t\t\t\t\t\tobject.skeleton.update();\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {\r\n\t\r\n\t\t\t\t\t\tvar material = object.material;\r\n\t\r\n\t\t\t\t\t\tif ( material.visible === true ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( _this.sortObjects === true ) {\r\n\t\r\n\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\r\n\t\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\tvar geometry = objects.update( object );\r\n\t\r\n\t\t\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvar groups = geometry.groups;\r\n\t\t\t\t\t\t\t\tvar materials = material.materials;\r\n\t\r\n\t\t\t\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tvar group = groups[ i ];\r\n\t\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\r\n\t\r\n\t\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, groupMaterial, _vector3.z, group );\r\n\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, material, _vector3.z, null );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar children = object.children;\r\n\t\r\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tprojectObject( children[ i ], camera );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction renderObjects( renderList, camera, fog, overrideMaterial ) {\r\n\t\r\n\t\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar renderItem = renderList[ i ];\r\n\t\r\n\t\t\t\tvar object = renderItem.object;\r\n\t\t\t\tvar geometry = renderItem.geometry;\r\n\t\t\t\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\r\n\t\t\t\tvar group = renderItem.group;\r\n\t\r\n\t\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\r\n\t\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\r\n\t\r\n\t\t\t\tif ( object instanceof THREE.ImmediateRenderObject ) {\r\n\t\r\n\t\t\t\t\tsetMaterial( material );\r\n\t\r\n\t\t\t\t\tvar program = setProgram( camera, fog, material, object );\r\n\t\r\n\t\t\t\t\t_currentGeometryProgram = '';\r\n\t\r\n\t\t\t\t\tobject.render( function ( object ) {\r\n\t\r\n\t\t\t\t\t\t_this.renderBufferImmediate( object, program, material );\r\n\t\r\n\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t_this.renderBufferDirect( camera, fog, geometry, material, object, group );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction initMaterial( material, fog, object ) {\r\n\t\r\n\t\t\tvar materialProperties = properties.get( material );\r\n\t\r\n\t\t\tvar parameters = programCache.getParameters( material, _lights, fog, object );\r\n\t\t\tvar code = programCache.getProgramCode( material, parameters );\r\n\t\r\n\t\t\tvar program = materialProperties.program;\r\n\t\t\tvar programChange = true;\r\n\t\r\n\t\t\tif ( program === undefined ) {\r\n\t\r\n\t\t\t\t// new material\r\n\t\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\r\n\t\r\n\t\t\t} else if ( program.code !== code ) {\r\n\t\r\n\t\t\t\t// changed glsl or parameters\r\n\t\t\t\treleaseMaterialProgramReference( material );\r\n\t\r\n\t\t\t} else if ( parameters.shaderID !== undefined ) {\r\n\t\r\n\t\t\t\t// same glsl and uniform list\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// only rebuild uniform list\r\n\t\t\t\tprogramChange = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( programChange ) {\r\n\t\r\n\t\t\t\tif ( parameters.shaderID ) {\r\n\t\r\n\t\t\t\t\tvar shader = THREE.ShaderLib[ parameters.shaderID ];\r\n\t\r\n\t\t\t\t\tmaterialProperties.__webglShader = {\r\n\t\t\t\t\t\tname: material.type,\r\n\t\t\t\t\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\r\n\t\t\t\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\t\t\t\tfragmentShader: shader.fragmentShader\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tmaterialProperties.__webglShader = {\r\n\t\t\t\t\t\tname: material.type,\r\n\t\t\t\t\t\tuniforms: material.uniforms,\r\n\t\t\t\t\t\tvertexShader: material.vertexShader,\r\n\t\t\t\t\t\tfragmentShader: material.fragmentShader\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tmaterial.__webglShader = materialProperties.__webglShader;\r\n\t\r\n\t\t\t\tprogram = programCache.acquireProgram( material, parameters, code );\r\n\t\r\n\t\t\t\tmaterialProperties.program = program;\r\n\t\t\t\tmaterial.program = program;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar attributes = program.getAttributes();\r\n\t\r\n\t\t\tif ( material.morphTargets ) {\r\n\t\r\n\t\t\t\tmaterial.numSupportedMorphTargets = 0;\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\r\n\t\r\n\t\t\t\t\tif ( attributes[ 'morphTarget' + i ] >= 0 ) {\r\n\t\r\n\t\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.morphNormals ) {\r\n\t\r\n\t\t\t\tmaterial.numSupportedMorphNormals = 0;\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\r\n\t\r\n\t\t\t\t\tif ( attributes[ 'morphNormal' + i ] >= 0 ) {\r\n\t\r\n\t\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tmaterialProperties.uniformsList = [];\r\n\t\r\n\t\t\tvar uniforms = materialProperties.__webglShader.uniforms,\r\n\t\t\t\tuniformLocations = materialProperties.program.getUniforms();\r\n\t\r\n\t\t\tfor ( var u in uniforms ) {\r\n\t\r\n\t\t\t\tvar location = uniformLocations[ u ];\r\n\t\r\n\t\t\t\tif ( location ) {\r\n\t\r\n\t\t\t\t\tmaterialProperties.uniformsList.push( [ materialProperties.__webglShader.uniforms[ u ], location ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t\tmaterial instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t\tmaterial instanceof THREE.MeshStandardMaterial ||\r\n\t\t\t\t\tmaterial.lights ) {\r\n\t\r\n\t\t\t\t// store the light setup it was created for\r\n\t\r\n\t\t\t\tmaterialProperties.lightsHash = _lights.hash;\r\n\t\r\n\t\t\t\t// wire up the material to this renderer's lighting state\r\n\t\r\n\t\t\t\tuniforms.ambientLightColor.value = _lights.ambient;\r\n\t\t\t\tuniforms.directionalLights.value = _lights.directional;\r\n\t\t\t\tuniforms.spotLights.value = _lights.spot;\r\n\t\t\t\tuniforms.pointLights.value = _lights.point;\r\n\t\t\t\tuniforms.hemisphereLights.value = _lights.hemi;\r\n\t\r\n\t\t\t\tuniforms.directionalShadowMap.value = _lights.directionalShadowMap;\r\n\t\t\t\tuniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;\r\n\t\t\t\tuniforms.spotShadowMap.value = _lights.spotShadowMap;\r\n\t\t\t\tuniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;\r\n\t\t\t\tuniforms.pointShadowMap.value = _lights.pointShadowMap;\r\n\t\t\t\tuniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// detect dynamic uniforms\r\n\t\r\n\t\t\tmaterialProperties.hasDynamicUniforms = false;\r\n\t\r\n\t\t\tfor ( var j = 0, jl = materialProperties.uniformsList.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\tvar uniform = materialProperties.uniformsList[ j ][ 0 ];\r\n\t\r\n\t\t\t\tif ( uniform.dynamic === true ) {\r\n\t\r\n\t\t\t\t\tmaterialProperties.hasDynamicUniforms = true;\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setMaterial( material ) {\r\n\t\r\n\t\t\tsetMaterialFaces( material );\r\n\t\r\n\t\t\tif ( material.transparent === true ) {\r\n\t\r\n\t\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tstate.setBlending( THREE.NoBlending );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.setDepthFunc( material.depthFunc );\r\n\t\t\tstate.setDepthTest( material.depthTest );\r\n\t\t\tstate.setDepthWrite( material.depthWrite );\r\n\t\t\tstate.setColorWrite( material.colorWrite );\r\n\t\t\tstate.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setMaterialFaces( material ) {\r\n\t\r\n\t\t\tmaterial.side !== THREE.DoubleSide ? state.enable( _gl.CULL_FACE ) : state.disable( _gl.CULL_FACE );\r\n\t\t\tstate.setFlipSided( material.side === THREE.BackSide );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setProgram( camera, fog, material, object ) {\r\n\t\r\n\t\t\t_usedTextureUnits = 0;\r\n\t\r\n\t\t\tvar materialProperties = properties.get( material );\r\n\t\r\n\t\t\tif ( materialProperties.program === undefined ) {\r\n\t\r\n\t\t\t\tmaterial.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( materialProperties.lightsHash !== undefined &&\r\n\t\t\t\tmaterialProperties.lightsHash !== _lights.hash ) {\r\n\t\r\n\t\t\t\tmaterial.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.needsUpdate ) {\r\n\t\r\n\t\t\t\tinitMaterial( material, fog, object );\r\n\t\t\t\tmaterial.needsUpdate = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar refreshProgram = false;\r\n\t\t\tvar refreshMaterial = false;\r\n\t\t\tvar refreshLights = false;\r\n\t\r\n\t\t\tvar program = materialProperties.program,\r\n\t\t\t\tp_uniforms = program.getUniforms(),\r\n\t\t\t\tm_uniforms = materialProperties.__webglShader.uniforms;\r\n\t\r\n\t\t\tif ( program.id !== _currentProgram ) {\r\n\t\r\n\t\t\t\t_gl.useProgram( program.program );\r\n\t\t\t\t_currentProgram = program.id;\r\n\t\r\n\t\t\t\trefreshProgram = true;\r\n\t\t\t\trefreshMaterial = true;\r\n\t\t\t\trefreshLights = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.id !== _currentMaterialId ) {\r\n\t\r\n\t\t\t\t_currentMaterialId = material.id;\r\n\t\r\n\t\t\t\trefreshMaterial = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( refreshProgram || camera !== _currentCamera ) {\r\n\t\r\n\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\t\r\n\t\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\r\n\t\r\n\t\t\t\t\t_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\tif ( camera !== _currentCamera ) {\r\n\t\r\n\t\t\t\t\t_currentCamera = camera;\r\n\t\r\n\t\t\t\t\t// lighting uniforms depend on the camera so enforce an update\r\n\t\t\t\t\t// now, in case this material supports lights - or later, when\r\n\t\t\t\t\t// the next material that does gets activated:\r\n\t\r\n\t\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\r\n\t\t\t\t\trefreshLights = true;\t\t// remains set until update done\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// load material specific uniforms\r\n\t\t\t\t// (shader material also gets them for the sake of genericity)\r\n\t\r\n\t\t\t\tif ( material instanceof THREE.ShaderMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\r\n\t\t\t\t\t material.envMap ) {\r\n\t\r\n\t\t\t\t\tif ( p_uniforms.cameraPosition !== undefined ) {\r\n\t\r\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\t\t\t\t_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshBasicMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\r\n\t\t\t\t\t material instanceof THREE.ShaderMaterial ||\r\n\t\t\t\t\t material.skinning ) {\r\n\t\r\n\t\t\t\t\tif ( p_uniforms.viewMatrix !== undefined ) {\r\n\t\r\n\t\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\tif ( p_uniforms.toneMappingExposure !== undefined ) {\r\n\t\r\n\t\t\t\t\t_gl.uniform1f( p_uniforms.toneMappingExposure, _this.toneMappingExposure );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( p_uniforms.toneMappingWhitePoint !== undefined ) {\r\n\t\r\n\t\t\t\t\t_gl.uniform1f( p_uniforms.toneMappingWhitePoint, _this.toneMappingWhitePoint );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// skinning uniforms must be set even if material didn't change\r\n\t\t\t// auto-setting of texture unit for bone texture must go before other textures\r\n\t\t\t// not sure why, but otherwise weird things happen\r\n\t\r\n\t\t\tif ( material.skinning ) {\r\n\t\r\n\t\t\t\tif ( object.bindMatrix && p_uniforms.bindMatrix !== undefined ) {\r\n\t\r\n\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== undefined ) {\r\n\t\r\n\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( capabilities.floatVertexTextures && object.skeleton && object.skeleton.useVertexTexture ) {\r\n\t\r\n\t\t\t\t\tif ( p_uniforms.boneTexture !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tvar textureUnit = getTextureUnit();\r\n\t\r\n\t\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTexture, textureUnit );\r\n\t\t\t\t\t\t_this.setTexture( object.skeleton.boneTexture, textureUnit );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( p_uniforms.boneTextureWidth !== undefined ) {\r\n\t\r\n\t\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( p_uniforms.boneTextureHeight !== undefined ) {\r\n\t\r\n\t\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( object.skeleton && object.skeleton.boneMatrices ) {\r\n\t\r\n\t\t\t\t\tif ( p_uniforms.boneGlobalMatrices !== undefined ) {\r\n\t\r\n\t\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( refreshMaterial ) {\r\n\t\r\n\t\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\r\n\t\t\t\t\t material.lights ) {\r\n\t\r\n\t\t\t\t\t// the current material requires lighting info\r\n\t\r\n\t\t\t\t\t// note: all lighting uniforms are always set correctly\r\n\t\t\t\t\t// they simply reference the renderer's state for their\r\n\t\t\t\t\t// values\r\n\t\t\t\t\t//\r\n\t\t\t\t\t// use the current material's .needsUpdate flags to set\r\n\t\t\t\t\t// the GL state when required\r\n\t\r\n\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// refresh uniforms common to several materials\r\n\t\r\n\t\t\t\tif ( fog && material.fog ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsFog( m_uniforms, fog );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( material instanceof THREE.MeshBasicMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshStandardMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// refresh single material specific uniforms\r\n\t\r\n\t\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\r\n\t\t\t\t\trefreshUniformsDash( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.PointsMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsPoints( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsLambert( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsPhong( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.MeshStandardMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsStandard( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\r\n\t\r\n\t\t\t\t\tm_uniforms.mNear.value = camera.near;\r\n\t\t\t\t\tm_uniforms.mFar.value = camera.far;\r\n\t\t\t\t\tm_uniforms.opacity.value = material.opacity;\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\r\n\t\r\n\t\t\t\t\tm_uniforms.opacity.value = material.opacity;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// load common uniforms\r\n\t\r\n\t\t\t\tloadUniformsGeneric( materialProperties.uniformsList );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tloadUniformsMatrices( p_uniforms, object );\r\n\t\r\n\t\t\tif ( p_uniforms.modelMatrix !== undefined ) {\r\n\t\r\n\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( materialProperties.hasDynamicUniforms === true ) {\r\n\t\r\n\t\t\t\tupdateDynamicUniforms( materialProperties.uniformsList, object, camera );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn program;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction updateDynamicUniforms ( uniforms, object, camera ) {\r\n\t\r\n\t\t\tvar dynamicUniforms = [];\r\n\t\r\n\t\t\tfor ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\tvar uniform = uniforms[ j ][ 0 ];\r\n\t\t\t\tvar onUpdateCallback = uniform.onUpdateCallback;\r\n\t\r\n\t\t\t\tif ( onUpdateCallback !== undefined ) {\r\n\t\r\n\t\t\t\t\tonUpdateCallback.bind( uniform )( object, camera );\r\n\t\t\t\t\tdynamicUniforms.push( uniforms[ j ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tloadUniformsGeneric( dynamicUniforms );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Uniforms (refresh uniforms objects)\r\n\t\r\n\t\tfunction refreshUniformsCommon ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.opacity.value = material.opacity;\r\n\t\r\n\t\t\tuniforms.diffuse.value = material.color;\r\n\t\r\n\t\t\tif ( material.emissive ) {\r\n\t\r\n\t\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tuniforms.map.value = material.map;\r\n\t\t\tuniforms.specularMap.value = material.specularMap;\r\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\r\n\t\r\n\t\t\tif ( material.aoMap ) {\r\n\t\r\n\t\t\t\tuniforms.aoMap.value = material.aoMap;\r\n\t\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// uv repeat and offset setting priorities\r\n\t\t\t// 1. color map\r\n\t\t\t// 2. specular map\r\n\t\t\t// 3. normal map\r\n\t\t\t// 4. bump map\r\n\t\t\t// 5. alpha map\r\n\t\t\t// 6. emissive map\r\n\t\r\n\t\t\tvar uvScaleMap;\r\n\t\r\n\t\t\tif ( material.map ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.map;\r\n\t\r\n\t\t\t} else if ( material.specularMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.specularMap;\r\n\t\r\n\t\t\t} else if ( material.displacementMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.displacementMap;\r\n\t\r\n\t\t\t} else if ( material.normalMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.normalMap;\r\n\t\r\n\t\t\t} else if ( material.bumpMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.bumpMap;\r\n\t\r\n\t\t\t} else if ( material.roughnessMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.roughnessMap;\r\n\t\r\n\t\t\t} else if ( material.metalnessMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.metalnessMap;\r\n\t\r\n\t\t\t} else if ( material.alphaMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.alphaMap;\r\n\t\r\n\t\t\t} else if ( material.emissiveMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.emissiveMap;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( uvScaleMap !== undefined ) {\r\n\t\r\n\t\t\t\tif ( uvScaleMap instanceof THREE.WebGLRenderTarget ) {\r\n\t\r\n\t\t\t\t\tuvScaleMap = uvScaleMap.texture;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar offset = uvScaleMap.offset;\r\n\t\t\t\tvar repeat = uvScaleMap.repeat;\r\n\t\r\n\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tuniforms.envMap.value = material.envMap;\r\n\t\t\tuniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;\r\n\t\r\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\r\n\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsLine ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.diffuse.value = material.color;\r\n\t\t\tuniforms.opacity.value = material.opacity;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsDash ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.dashSize.value = material.dashSize;\r\n\t\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\r\n\t\t\tuniforms.scale.value = material.scale;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsPoints ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.diffuse.value = material.color;\r\n\t\t\tuniforms.opacity.value = material.opacity;\r\n\t\t\tuniforms.size.value = material.size * _pixelRatio;\r\n\t\t\tuniforms.scale.value = _canvas.clientHeight / 2.0; // TODO: Cache this.\r\n\t\r\n\t\t\tuniforms.map.value = material.map;\r\n\t\r\n\t\t\tif ( material.map !== null ) {\r\n\t\r\n\t\t\t\tvar offset = material.map.offset;\r\n\t\t\t\tvar repeat = material.map.repeat;\r\n\t\r\n\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsFog ( uniforms, fog ) {\r\n\t\r\n\t\t\tuniforms.fogColor.value = fog.color;\r\n\t\r\n\t\t\tif ( fog instanceof THREE.Fog ) {\r\n\t\r\n\t\t\t\tuniforms.fogNear.value = fog.near;\r\n\t\t\t\tuniforms.fogFar.value = fog.far;\r\n\t\r\n\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\r\n\t\r\n\t\t\t\tuniforms.fogDensity.value = fog.density;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsLambert ( uniforms, material ) {\r\n\t\r\n\t\t\tif ( material.lightMap ) {\r\n\t\r\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\r\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.emissiveMap ) {\r\n\t\r\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsPhong ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.specular.value = material.specular;\r\n\t\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\r\n\t\r\n\t\t\tif ( material.lightMap ) {\r\n\t\r\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\r\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.emissiveMap ) {\r\n\t\r\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.bumpMap ) {\r\n\t\r\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\r\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.normalMap ) {\r\n\t\r\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\r\n\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.displacementMap ) {\r\n\t\r\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\r\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\r\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsStandard ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.roughness.value = material.roughness;\r\n\t\t\tuniforms.metalness.value = material.metalness;\r\n\t\r\n\t\t\tif ( material.roughnessMap ) {\r\n\t\r\n\t\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.metalnessMap ) {\r\n\t\r\n\t\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.lightMap ) {\r\n\t\r\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\r\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.emissiveMap ) {\r\n\t\r\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.bumpMap ) {\r\n\t\r\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\r\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.normalMap ) {\r\n\t\r\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\r\n\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.displacementMap ) {\r\n\t\r\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\r\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\r\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.envMap ) {\r\n\t\r\n\t\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\r\n\t\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\r\n\t\r\n\t\tfunction markUniformsLightsNeedsUpdate ( uniforms, value ) {\r\n\t\r\n\t\t\tuniforms.ambientLightColor.needsUpdate = value;\r\n\t\r\n\t\t\tuniforms.directionalLights.needsUpdate = value;\r\n\t\t\tuniforms.pointLights.needsUpdate = value;\r\n\t\t\tuniforms.spotLights.needsUpdate = value;\r\n\t\t\tuniforms.hemisphereLights.needsUpdate = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Uniforms (load to GPU)\r\n\t\r\n\t\tfunction loadUniformsMatrices ( uniforms, object ) {\r\n\t\r\n\t\t\t_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object.modelViewMatrix.elements );\r\n\t\r\n\t\t\tif ( uniforms.normalMatrix ) {\r\n\t\r\n\t\t\t\t_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object.normalMatrix.elements );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction getTextureUnit() {\r\n\t\r\n\t\t\tvar textureUnit = _usedTextureUnits;\r\n\t\r\n\t\t\tif ( textureUnit >= capabilities.maxTextures ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_usedTextureUnits += 1;\r\n\t\r\n\t\t\treturn textureUnit;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction loadUniform( uniform, type, location, value ) {\r\n\t\r\n\t\t\tvar texture, textureUnit;\r\n\t\r\n\t\t\tif ( type === '1i' ) {\r\n\t\r\n\t\t\t\t_gl.uniform1i( location, value );\r\n\t\r\n\t\t\t} else if ( type === '1f' ) {\r\n\t\r\n\t\t\t\t_gl.uniform1f( location, value );\r\n\t\r\n\t\t\t} else if ( type === '2f' ) {\r\n\t\r\n\t\t\t\t_gl.uniform2f( location, value[ 0 ], value[ 1 ] );\r\n\t\r\n\t\t\t} else if ( type === '3f' ) {\r\n\t\r\n\t\t\t\t_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );\r\n\t\r\n\t\t\t} else if ( type === '4f' ) {\r\n\t\r\n\t\t\t\t_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );\r\n\t\r\n\t\t\t} else if ( type === '1iv' ) {\r\n\t\r\n\t\t\t\t_gl.uniform1iv( location, value );\r\n\t\r\n\t\t\t} else if ( type === '3iv' ) {\r\n\t\r\n\t\t\t\t_gl.uniform3iv( location, value );\r\n\t\r\n\t\t\t} else if ( type === '1fv' ) {\r\n\t\r\n\t\t\t\t_gl.uniform1fv( location, value );\r\n\t\r\n\t\t\t} else if ( type === '2fv' ) {\r\n\t\r\n\t\t\t\t_gl.uniform2fv( location, value );\r\n\t\r\n\t\t\t} else if ( type === '3fv' ) {\r\n\t\r\n\t\t\t\t_gl.uniform3fv( location, value );\r\n\t\r\n\t\t\t} else if ( type === '4fv' ) {\r\n\t\r\n\t\t\t\t_gl.uniform4fv( location, value );\r\n\t\r\n\t\t\t} else if ( type === 'Matrix2fv' ) {\r\n\t\r\n\t\t\t\t_gl.uniformMatrix2fv( location, false, value );\r\n\t\r\n\t\t\t} else if ( type === 'Matrix3fv' ) {\r\n\t\r\n\t\t\t\t_gl.uniformMatrix3fv( location, false, value );\r\n\t\r\n\t\t\t} else if ( type === 'Matrix4fv' ) {\r\n\t\r\n\t\t\t\t_gl.uniformMatrix4fv( location, false, value );\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\t} else if ( type === 'i' ) {\r\n\t\r\n\t\t\t\t// single integer\r\n\t\t\t\t_gl.uniform1i( location, value );\r\n\t\r\n\t\t\t} else if ( type === 'f' ) {\r\n\t\r\n\t\t\t\t// single float\r\n\t\t\t\t_gl.uniform1f( location, value );\r\n\t\r\n\t\t\t} else if ( type === 'v2' ) {\r\n\t\r\n\t\t\t\t// single THREE.Vector2\r\n\t\t\t\t_gl.uniform2f( location, value.x, value.y );\r\n\t\r\n\t\t\t} else if ( type === 'v3' ) {\r\n\t\r\n\t\t\t\t// single THREE.Vector3\r\n\t\t\t\t_gl.uniform3f( location, value.x, value.y, value.z );\r\n\t\r\n\t\t\t} else if ( type === 'v4' ) {\r\n\t\r\n\t\t\t\t// single THREE.Vector4\r\n\t\t\t\t_gl.uniform4f( location, value.x, value.y, value.z, value.w );\r\n\t\r\n\t\t\t} else if ( type === 'c' ) {\r\n\t\r\n\t\t\t\t// single THREE.Color\r\n\t\t\t\t_gl.uniform3f( location, value.r, value.g, value.b );\r\n\t\r\n\t\t\t} else if ( type === 's' ) {\r\n\t\r\n\t\t\t\t// TODO: Optimize this\r\n\t\r\n\t\t\t\tvar properties = uniform.properties;\r\n\t\r\n\t\t\t\tfor ( var name in properties ) {\r\n\t\r\n\t\t\t\t\tvar property = properties[ name ];\r\n\t\t\t\t\tvar locationProperty = location[ name ];\r\n\t\t\t\t\tvar valueProperty = value[ name ];\r\n\t\r\n\t\t\t\t\tloadUniform( property, property.type, locationProperty, valueProperty );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( type === 'sa' ) {\r\n\t\r\n\t\t\t\t// TODO: Optimize this\r\n\t\r\n\t\t\t\tvar properties = uniform.properties;\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = value.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tfor ( var name in properties ) {\r\n\t\r\n\t\t\t\t\t\tvar property = properties[ name ];\r\n\t\t\t\t\t\tvar locationProperty =  location[ i ][ name ];\r\n\t\t\t\t\t\tvar valueProperty = value[ i ][ name ];\r\n\t\r\n\t\t\t\t\t\tloadUniform( property, property.type, locationProperty, valueProperty );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( type === 'iv1' ) {\r\n\t\r\n\t\t\t\t// flat array of integers (JS or typed array)\r\n\t\t\t\t_gl.uniform1iv( location, value );\r\n\t\r\n\t\t\t} else if ( type === 'iv' ) {\r\n\t\r\n\t\t\t\t// flat array of integers with 3 x N size (JS or typed array)\r\n\t\t\t\t_gl.uniform3iv( location, value );\r\n\t\r\n\t\t\t} else if ( type === 'fv1' ) {\r\n\t\r\n\t\t\t\t// flat array of floats (JS or typed array)\r\n\t\t\t\t_gl.uniform1fv( location, value );\r\n\t\r\n\t\t\t} else if ( type === 'fv' ) {\r\n\t\r\n\t\t\t\t// flat array of floats with 3 x N size (JS or typed array)\r\n\t\t\t\t_gl.uniform3fv( location, value );\r\n\t\r\n\t\t\t} else if ( type === 'v2v' ) {\r\n\t\r\n\t\t\t\t// array of THREE.Vector2\r\n\t\r\n\t\t\t\tif ( uniform._array === undefined ) {\r\n\t\r\n\t\t\t\t\tuniform._array = new Float32Array( 2 * value.length );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var i = 0, i2 = 0, il = value.length; i < il; i ++, i2 += 2 ) {\r\n\t\r\n\t\t\t\t\tuniform._array[ i2 + 0 ] = value[ i ].x;\r\n\t\t\t\t\tuniform._array[ i2 + 1 ] = value[ i ].y;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.uniform2fv( location, uniform._array );\r\n\t\r\n\t\t\t} else if ( type === 'v3v' ) {\r\n\t\r\n\t\t\t\t// array of THREE.Vector3\r\n\t\r\n\t\t\t\tif ( uniform._array === undefined ) {\r\n\t\r\n\t\t\t\t\tuniform._array = new Float32Array( 3 * value.length );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var i = 0, i3 = 0, il = value.length; i < il; i ++, i3 += 3 ) {\r\n\t\r\n\t\t\t\t\tuniform._array[ i3 + 0 ] = value[ i ].x;\r\n\t\t\t\t\tuniform._array[ i3 + 1 ] = value[ i ].y;\r\n\t\t\t\t\tuniform._array[ i3 + 2 ] = value[ i ].z;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.uniform3fv( location, uniform._array );\r\n\t\r\n\t\t\t} else if ( type === 'v4v' ) {\r\n\t\r\n\t\t\t\t// array of THREE.Vector4\r\n\t\r\n\t\t\t\tif ( uniform._array === undefined ) {\r\n\t\r\n\t\t\t\t\tuniform._array = new Float32Array( 4 * value.length );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var i = 0, i4 = 0, il = value.length; i < il; i ++, i4 += 4 ) {\r\n\t\r\n\t\t\t\t\tuniform._array[ i4 + 0 ] = value[ i ].x;\r\n\t\t\t\t\tuniform._array[ i4 + 1 ] = value[ i ].y;\r\n\t\t\t\t\tuniform._array[ i4 + 2 ] = value[ i ].z;\r\n\t\t\t\t\tuniform._array[ i4 + 3 ] = value[ i ].w;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.uniform4fv( location, uniform._array );\r\n\t\r\n\t\t\t} else if ( type === 'm2' ) {\r\n\t\r\n\t\t\t\t// single THREE.Matrix2\r\n\t\t\t\t_gl.uniformMatrix2fv( location, false, value.elements );\r\n\t\r\n\t\t\t} else if ( type === 'm3' ) {\r\n\t\r\n\t\t\t\t// single THREE.Matrix3\r\n\t\t\t\t_gl.uniformMatrix3fv( location, false, value.elements );\r\n\t\r\n\t\t\t} else if ( type === 'm3v' ) {\r\n\t\r\n\t\t\t\t// array of THREE.Matrix3\r\n\t\r\n\t\t\t\tif ( uniform._array === undefined ) {\r\n\t\r\n\t\t\t\t\tuniform._array = new Float32Array( 9 * value.length );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tvalue[ i ].flattenToArrayOffset( uniform._array, i * 9 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.uniformMatrix3fv( location, false, uniform._array );\r\n\t\r\n\t\t\t} else if ( type === 'm4' ) {\r\n\t\r\n\t\t\t\t// single THREE.Matrix4\r\n\t\t\t\t_gl.uniformMatrix4fv( location, false, value.elements );\r\n\t\r\n\t\t\t} else if ( type === 'm4v' ) {\r\n\t\r\n\t\t\t\t// array of THREE.Matrix4\r\n\t\r\n\t\t\t\tif ( uniform._array === undefined ) {\r\n\t\r\n\t\t\t\t\tuniform._array = new Float32Array( 16 * value.length );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tvalue[ i ].flattenToArrayOffset( uniform._array, i * 16 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.uniformMatrix4fv( location, false, uniform._array );\r\n\t\r\n\t\t\t} else if ( type === 't' ) {\r\n\t\r\n\t\t\t\t// single THREE.Texture (2d or cube)\r\n\t\r\n\t\t\t\ttexture = value;\r\n\t\t\t\ttextureUnit = getTextureUnit();\r\n\t\r\n\t\t\t\t_gl.uniform1i( location, textureUnit );\r\n\t\r\n\t\t\t\tif ( ! texture ) return;\r\n\t\r\n\t\t\t\tif ( texture instanceof THREE.CubeTexture ||\r\n\t\t\t\t\t ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\r\n\t\r\n\t\t\t\t\t// CompressedTexture can have Array in image :/\r\n\t\r\n\t\t\t\t\tsetCubeTexture( texture, textureUnit );\r\n\t\r\n\t\t\t\t} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {\r\n\t\r\n\t\t\t\t\tsetCubeTextureDynamic( texture.texture, textureUnit );\r\n\t\r\n\t\t\t\t} else if ( texture instanceof THREE.WebGLRenderTarget ) {\r\n\t\r\n\t\t\t\t\t_this.setTexture( texture.texture, textureUnit );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t_this.setTexture( texture, textureUnit );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( type === 'tv' ) {\r\n\t\r\n\t\t\t\t// array of THREE.Texture (2d or cube)\r\n\t\r\n\t\t\t\tif ( uniform._array === undefined ) {\r\n\t\r\n\t\t\t\t\tuniform._array = [];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = uniform.value.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tuniform._array[ i ] = getTextureUnit();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.uniform1iv( location, uniform._array );\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = uniform.value.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\ttexture = uniform.value[ i ];\r\n\t\t\t\t\ttextureUnit = uniform._array[ i ];\r\n\t\r\n\t\t\t\t\tif ( ! texture ) continue;\r\n\t\r\n\t\t\t\t\tif ( texture instanceof THREE.CubeTexture ||\r\n\t\t\t\t\t\t ( texture.image instanceof Array && texture.image.length === 6 ) ) {\r\n\t\r\n\t\t\t\t\t\t// CompressedTexture can have Array in image :/\r\n\t\r\n\t\t\t\t\t\tsetCubeTexture( texture, textureUnit );\r\n\t\r\n\t\t\t\t\t} else if ( texture instanceof THREE.WebGLRenderTarget ) {\r\n\t\r\n\t\t\t\t\t\t_this.setTexture( texture.texture, textureUnit );\r\n\t\r\n\t\t\t\t\t} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {\r\n\t\r\n\t\t\t\t\t\tsetCubeTextureDynamic( texture.texture, textureUnit );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t_this.setTexture( texture, textureUnit );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction loadUniformsGeneric( uniforms ) {\r\n\t\r\n\t\t\tfor ( var i = 0, l = uniforms.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar uniform = uniforms[ i ][ 0 ];\r\n\t\r\n\t\t\t\t// needsUpdate property is not added to all uniforms.\r\n\t\t\t\tif ( uniform.needsUpdate === false ) continue;\r\n\t\r\n\t\t\t\tvar type = uniform.type;\r\n\t\t\t\tvar location = uniforms[ i ][ 1 ];\r\n\t\t\t\tvar value = uniform.value;\r\n\t\r\n\t\t\t\tloadUniform( uniform, type, location, value );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setupLights ( lights, camera ) {\r\n\t\r\n\t\t\tvar l, ll, light,\r\n\t\t\tr = 0, g = 0, b = 0,\r\n\t\t\tcolor,\r\n\t\t\tintensity,\r\n\t\t\tdistance,\r\n\t\r\n\t\t\tviewMatrix = camera.matrixWorldInverse,\r\n\t\r\n\t\t\tdirectionalLength = 0,\r\n\t\t\tpointLength = 0,\r\n\t\t\tspotLength = 0,\r\n\t\t\themiLength = 0,\r\n\t\r\n\t\t\tshadowsLength = 0;\r\n\t\r\n\t\t\t_lights.shadowsPointLight = 0;\r\n\t\r\n\t\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\t\r\n\t\t\t\tlight = lights[ l ];\r\n\t\r\n\t\t\t\tcolor = light.color;\r\n\t\t\t\tintensity = light.intensity;\r\n\t\t\t\tdistance = light.distance;\r\n\t\r\n\t\t\t\tif ( light instanceof THREE.AmbientLight ) {\r\n\t\r\n\t\t\t\t\tr += color.r * intensity;\r\n\t\t\t\t\tg += color.g * intensity;\r\n\t\t\t\t\tb += color.b * intensity;\r\n\t\r\n\t\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\r\n\t\r\n\t\t\t\t\tvar uniforms = lightCache.get( light );\r\n\t\r\n\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\r\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\t\tuniforms.direction.sub( _vector3 );\r\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\r\n\t\r\n\t\t\t\t\tuniforms.shadow = light.castShadow;\r\n\t\r\n\t\t\t\t\tif ( light.castShadow ) {\r\n\t\r\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\r\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\r\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\r\n\t\r\n\t\t\t\t\t\t_lights.shadows[ shadowsLength ++ ] = light;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t_lights.directionalShadowMap[ directionalLength ] = light.shadow.map;\r\n\t\t\t\t\t_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\r\n\t\t\t\t\t_lights.directional[ directionalLength ++ ] = uniforms;\r\n\t\r\n\t\t\t\t} else if ( light instanceof THREE.SpotLight ) {\r\n\t\r\n\t\t\t\t\tvar uniforms = lightCache.get( light );\r\n\t\r\n\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\r\n\t\r\n\t\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\r\n\t\t\t\t\tuniforms.distance = distance;\r\n\t\r\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\t\tuniforms.direction.sub( _vector3 );\r\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\r\n\t\r\n\t\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\r\n\t\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\r\n\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\r\n\t\r\n\t\t\t\t\tuniforms.shadow = light.castShadow;\r\n\t\r\n\t\t\t\t\tif ( light.castShadow ) {\r\n\t\r\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\r\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\r\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\r\n\t\r\n\t\t\t\t\t\t_lights.shadows[ shadowsLength ++ ] = light;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t_lights.spotShadowMap[ spotLength ] = light.shadow.map;\r\n\t\t\t\t\t_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\r\n\t\t\t\t\t_lights.spot[ spotLength ++ ] = uniforms;\r\n\t\r\n\t\t\t\t} else if ( light instanceof THREE.PointLight ) {\r\n\t\r\n\t\t\t\t\tvar uniforms = lightCache.get( light );\r\n\t\r\n\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\r\n\t\r\n\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\r\n\t\t\t\t\tuniforms.distance = light.distance;\r\n\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\r\n\t\r\n\t\t\t\t\tuniforms.shadow = light.castShadow;\r\n\t\r\n\t\t\t\t\tif ( light.castShadow ) {\r\n\t\r\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\r\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\r\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\r\n\t\r\n\t\t\t\t\t\t_lights.shadows[ shadowsLength ++ ] = light;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t_lights.pointShadowMap[ pointLength ] = light.shadow.map;\r\n\t\r\n\t\t\t\t\tif ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ] = new THREE.Matrix4();\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// for point lights we set the shadow matrix to be a translation-only matrix\r\n\t\t\t\t\t// equal to inverse of the light's position\r\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld ).negate();\r\n\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );\r\n\t\r\n\t\t\t\t\t_lights.point[ pointLength ++ ] = uniforms;\r\n\t\r\n\t\t\t\t} else if ( light instanceof THREE.HemisphereLight ) {\r\n\t\r\n\t\t\t\t\tvar uniforms = lightCache.get( light );\r\n\t\r\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\r\n\t\t\t\t\tuniforms.direction.normalize();\r\n\t\r\n\t\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\r\n\t\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\r\n\t\r\n\t\t\t\t\t_lights.hemi[ hemiLength ++ ] = uniforms;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_lights.ambient[ 0 ] = r;\r\n\t\t\t_lights.ambient[ 1 ] = g;\r\n\t\t\t_lights.ambient[ 2 ] = b;\r\n\t\r\n\t\t\t_lights.directional.length = directionalLength;\r\n\t\t\t_lights.spot.length = spotLength;\r\n\t\t\t_lights.point.length = pointLength;\r\n\t\t\t_lights.hemi.length = hemiLength;\r\n\t\r\n\t\t\t_lights.shadows.length = shadowsLength;\r\n\t\r\n\t\t\t_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + shadowsLength;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// GL state setting\r\n\t\r\n\t\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\r\n\t\r\n\t\t\tif ( cullFace === THREE.CullFaceNone ) {\r\n\t\r\n\t\t\t\tstate.disable( _gl.CULL_FACE );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tif ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {\r\n\t\r\n\t\t\t\t\t_gl.frontFace( _gl.CW );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t_gl.frontFace( _gl.CCW );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( cullFace === THREE.CullFaceBack ) {\r\n\t\r\n\t\t\t\t\t_gl.cullFace( _gl.BACK );\r\n\t\r\n\t\t\t\t} else if ( cullFace === THREE.CullFaceFront ) {\r\n\t\r\n\t\t\t\t\t_gl.cullFace( _gl.FRONT );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t_gl.cullFace( _gl.FRONT_AND_BACK );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tstate.enable( _gl.CULL_FACE );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Textures\r\n\t\r\n\t\tfunction setTextureParameters ( textureType, texture, isPowerOfTwoImage ) {\r\n\t\r\n\t\t\tvar extension;\r\n\t\r\n\t\t\tif ( isPowerOfTwoImage ) {\r\n\t\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\r\n\t\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\r\n\t\r\n\t\t\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\r\n\t\r\n\t\t\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\t\r\n\t\t\tif ( extension ) {\r\n\t\r\n\t\t\t\tif ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\r\n\t\t\t\tif ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\r\n\t\r\n\t\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\r\n\t\r\n\t\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );\r\n\t\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction uploadTexture( textureProperties, texture, slot ) {\r\n\t\r\n\t\t\tif ( textureProperties.__webglInit === undefined ) {\r\n\t\r\n\t\t\t\ttextureProperties.__webglInit = true;\r\n\t\r\n\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\t\r\n\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\r\n\t\r\n\t\t\t\t_infoMemory.textures ++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\r\n\t\r\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\r\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\r\n\t\r\n\t\t\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\r\n\t\r\n\t\t\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\r\n\t\r\n\t\t\t\timage = makePowerOfTwo( image );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\r\n\t\t\tglFormat = paramThreeToGL( texture.format ),\r\n\t\t\tglType = paramThreeToGL( texture.type );\r\n\t\r\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\r\n\t\r\n\t\t\tvar mipmap, mipmaps = texture.mipmaps;\r\n\t\r\n\t\t\tif ( texture instanceof THREE.DataTexture ) {\r\n\t\r\n\t\t\t\t// use manually created mipmaps if available\r\n\t\t\t\t// if there are no manual mipmaps\r\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\t\r\n\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttexture.generateMipmaps = false;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( texture instanceof THREE.CompressedTexture ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\r\n\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\r\n\t\r\n\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\r\n\t\r\n\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// regular Texture (image, video, canvas)\r\n\t\r\n\t\t\t\t// use manually created mipmaps if available\r\n\t\t\t\t// if there are no manual mipmaps\r\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\t\r\n\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttexture.generateMipmaps = false;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\t\r\n\t\t\ttextureProperties.__version = texture.version;\r\n\t\r\n\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.setTexture = function ( texture, slot ) {\r\n\t\r\n\t\t\tvar textureProperties = properties.get( texture );\r\n\t\r\n\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\r\n\t\r\n\t\t\t\tvar image = texture.image;\r\n\t\r\n\t\t\t\tif ( image === undefined ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\r\n\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( image.complete === false ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\r\n\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tuploadTexture( textureProperties, texture, slot );\r\n\t\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction clampToMaxSize ( image, maxSize ) {\r\n\t\r\n\t\t\tif ( image.width > maxSize || image.height > maxSize ) {\r\n\t\r\n\t\t\t\t// Warning: Scaling through the canvas will only work with images that use\r\n\t\t\t\t// premultiplied alpha.\r\n\t\r\n\t\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\r\n\t\r\n\t\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\t\tcanvas.width = Math.floor( image.width * scale );\r\n\t\t\t\tcanvas.height = Math.floor( image.height * scale );\r\n\t\r\n\t\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\r\n\t\r\n\t\t\t\treturn canvas;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn image;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction isPowerOfTwo( image ) {\r\n\t\r\n\t\t\treturn THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction textureNeedsPowerOfTwo( texture ) {\r\n\t\r\n\t\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) return true;\r\n\t\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) return true;\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction makePowerOfTwo( image ) {\r\n\t\r\n\t\t\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {\r\n\t\r\n\t\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\t\tcanvas.width = THREE.Math.nearestPowerOfTwo( image.width );\r\n\t\t\t\tcanvas.height = THREE.Math.nearestPowerOfTwo( image.height );\r\n\t\r\n\t\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\t\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\r\n\t\r\n\t\t\t\treturn canvas;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn image;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setCubeTexture ( texture, slot ) {\r\n\t\r\n\t\t\tvar textureProperties = properties.get( texture );\r\n\t\r\n\t\t\tif ( texture.image.length === 6 ) {\r\n\t\r\n\t\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\r\n\t\r\n\t\t\t\t\tif ( ! textureProperties.__image__webglTextureCube ) {\r\n\t\r\n\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\t\r\n\t\t\t\t\t\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\r\n\t\r\n\t\t\t\t\t\t_infoMemory.textures ++;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\r\n\t\r\n\t\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\t\r\n\t\t\t\t\tvar isCompressed = texture instanceof THREE.CompressedTexture;\r\n\t\t\t\t\tvar isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;\r\n\t\r\n\t\t\t\t\tvar cubeImage = [];\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tif ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {\r\n\t\r\n\t\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar image = cubeImage[ 0 ],\r\n\t\t\t\t\tisPowerOfTwoImage = isPowerOfTwo( image ),\r\n\t\t\t\t\tglFormat = paramThreeToGL( texture.format ),\r\n\t\t\t\t\tglType = paramThreeToGL( texture.type );\r\n\t\r\n\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tif ( ! isCompressed ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( isDataTexture ) {\r\n\t\r\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\r\n\t\r\n\t\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\r\n\t\r\n\t\t\t\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\t\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()\" );\r\n\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) {\r\n\t\r\n\t\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttextureProperties.__version = texture.version;\r\n\t\r\n\t\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setCubeTextureDynamic ( texture, slot ) {\r\n\t\r\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Render targets\r\n\t\r\n\t\t// Setup storage for target texture and bind it to correct framebuffer\r\n\t\tfunction setupFrameBufferTexture ( framebuffer, renderTarget, attachment, textureTarget ) {\r\n\t\r\n\t\t\tvar glFormat = paramThreeToGL( renderTarget.texture.format );\r\n\t\t\tvar glType = paramThreeToGL( renderTarget.texture.type );\r\n\t\t\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\r\n\t\tfunction setupRenderBufferStorage ( renderbuffer, renderTarget ) {\r\n\t\r\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\r\n\t\r\n\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\r\n\t\r\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\r\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\t\r\n\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\t\r\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\r\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// FIXME: We don't support !depth !stencil\r\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Setup GL resources for a non-texture depth buffer\r\n\t\tfunction setupDepthRenderbuffer( renderTarget ) {\r\n\t\r\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\r\n\t\r\n\t\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\t\r\n\t\t\tif ( isCube ) {\r\n\t\r\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\r\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\r\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\r\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\r\n\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Set up GL resources for the render target\r\n\t\tfunction setupRenderTarget( renderTarget ) {\r\n\t\r\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\r\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\r\n\t\r\n\t\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\r\n\t\r\n\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\r\n\t\r\n\t\t\t_infoMemory.textures ++;\r\n\t\r\n\t\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\t\t\tvar isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height );\r\n\t\r\n\t\t\t// Setup framebuffer\r\n\t\r\n\t\t\tif ( isCube ) {\r\n\t\r\n\t\t\t\trenderTargetProperties.__webglFramebuffer = [];\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Setup color buffer\r\n\t\r\n\t\t\tif ( isCube ) {\r\n\t\r\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\r\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\r\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\r\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\r\n\t\r\n\t\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, null );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Setup depth and stencil buffers\r\n\t\r\n\t\t\tif ( renderTarget.depthBuffer ) {\r\n\t\r\n\t\t\t\tsetupDepthRenderbuffer( renderTarget );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.getCurrentRenderTarget = function() {\r\n\t\r\n\t\t\treturn _currentRenderTarget;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.setRenderTarget = function ( renderTarget ) {\r\n\t\r\n\t\t\t_currentRenderTarget = renderTarget;\r\n\t\r\n\t\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\r\n\t\r\n\t\t\t\tsetupRenderTarget( renderTarget );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\t\t\tvar framebuffer;\r\n\t\r\n\t\t\tif ( renderTarget ) {\r\n\t\r\n\t\t\t\tvar renderTargetProperties = properties.get( renderTarget );\r\n\t\r\n\t\t\t\tif ( isCube ) {\r\n\t\r\n\t\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_currentScissor.copy( renderTarget.scissor );\r\n\t\t\t\t_currentScissorTest = renderTarget.scissorTest;\r\n\t\r\n\t\t\t\t_currentViewport.copy( renderTarget.viewport );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tframebuffer = null;\r\n\t\r\n\t\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\r\n\t\t\t\t_currentScissorTest = _scissorTest;\r\n\t\r\n\t\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( _currentFramebuffer !== framebuffer ) {\r\n\t\r\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t\t\t_currentFramebuffer = framebuffer;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.scissor( _currentScissor );\r\n\t\t\tstate.setScissorTest( _currentScissorTest );\r\n\t\r\n\t\t\tstate.viewport( _currentViewport );\r\n\t\r\n\t\t\tif ( isCube ) {\r\n\t\r\n\t\t\t\tvar textureProperties = properties.get( renderTarget.texture );\r\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\r\n\t\r\n\t\t\tif ( renderTarget instanceof THREE.WebGLRenderTarget === false ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\r\n\t\r\n\t\t\tif ( framebuffer ) {\r\n\t\r\n\t\t\t\tvar restore = false;\r\n\t\r\n\t\t\t\tif ( framebuffer !== _currentFramebuffer ) {\r\n\t\r\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\r\n\t\t\t\t\trestore = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\ttry {\r\n\t\r\n\t\t\t\t\tvar texture = renderTarget.texture;\r\n\t\r\n\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat\r\n\t\t\t\t\t\t&& paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\r\n\t\r\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\r\n\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( texture.type !== THREE.UnsignedByteType\r\n\t\t\t\t\t\t&& paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE )\r\n\t\t\t\t\t\t&& ! ( texture.type === THREE.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) )\r\n\t\t\t\t\t\t&& ! ( texture.type === THREE.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\r\n\t\r\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\r\n\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\r\n\t\r\n\t\t\t\t\t\t_gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} finally {\r\n\t\r\n\t\t\t\t\tif ( restore ) {\r\n\t\r\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction updateRenderTargetMipmap( renderTarget ) {\r\n\t\r\n\t\t\tvar target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\r\n\t\t\tvar texture = properties.get( renderTarget.texture ).__webglTexture;\r\n\t\r\n\t\t\tstate.bindTexture( target, texture );\r\n\t\t\t_gl.generateMipmap( target );\r\n\t\t\tstate.bindTexture( target, null );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Fallback filters for non-power-of-2 textures\r\n\t\r\n\t\tfunction filterFallback ( f ) {\r\n\t\r\n\t\t\tif ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\r\n\t\r\n\t\t\t\treturn _gl.NEAREST;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn _gl.LINEAR;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Map three.js constants to WebGL constants\r\n\t\r\n\t\tfunction paramThreeToGL ( p ) {\r\n\t\r\n\t\t\tvar extension;\r\n\t\r\n\t\t\tif ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\r\n\t\t\tif ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\r\n\t\t\tif ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\r\n\t\r\n\t\t\tif ( p === THREE.NearestFilter ) return _gl.NEAREST;\r\n\t\t\tif ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\r\n\t\t\tif ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\r\n\t\r\n\t\t\tif ( p === THREE.LinearFilter ) return _gl.LINEAR;\r\n\t\t\tif ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\r\n\t\t\tif ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\r\n\t\r\n\t\t\tif ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\r\n\t\t\tif ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\r\n\t\t\tif ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\r\n\t\t\tif ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\r\n\t\r\n\t\t\tif ( p === THREE.ByteType ) return _gl.BYTE;\r\n\t\t\tif ( p === THREE.ShortType ) return _gl.SHORT;\r\n\t\t\tif ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\r\n\t\t\tif ( p === THREE.IntType ) return _gl.INT;\r\n\t\t\tif ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\r\n\t\t\tif ( p === THREE.FloatType ) return _gl.FLOAT;\r\n\t\r\n\t\t\textension = extensions.get( 'OES_texture_half_float' );\r\n\t\r\n\t\t\tif ( extension !== null ) {\r\n\t\r\n\t\t\t\tif ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( p === THREE.AlphaFormat ) return _gl.ALPHA;\r\n\t\t\tif ( p === THREE.RGBFormat ) return _gl.RGB;\r\n\t\t\tif ( p === THREE.RGBAFormat ) return _gl.RGBA;\r\n\t\t\tif ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\r\n\t\t\tif ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\r\n\t\r\n\t\t\tif ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\r\n\t\t\tif ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\r\n\t\t\tif ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\r\n\t\r\n\t\t\tif ( p === THREE.ZeroFactor ) return _gl.ZERO;\r\n\t\t\tif ( p === THREE.OneFactor ) return _gl.ONE;\r\n\t\t\tif ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\r\n\t\t\tif ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\r\n\t\t\tif ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\r\n\t\t\tif ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\r\n\t\t\tif ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\r\n\t\t\tif ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\r\n\t\r\n\t\t\tif ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\r\n\t\t\tif ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\r\n\t\t\tif ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\r\n\t\r\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\r\n\t\r\n\t\t\tif ( extension !== null ) {\r\n\t\r\n\t\t\t\tif ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\r\n\t\t\t\tif ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\r\n\t\t\t\tif ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\r\n\t\t\t\tif ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\r\n\t\r\n\t\t\tif ( extension !== null ) {\r\n\t\r\n\t\t\t\tif ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\r\n\t\t\t\tif ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\r\n\t\t\t\tif ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\r\n\t\t\t\tif ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\r\n\t\r\n\t\t\tif ( extension !== null ) {\r\n\t\r\n\t\t\t\tif ( p === THREE.RGB_ETC1_Format ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\textension = extensions.get( 'EXT_blend_minmax' );\r\n\t\r\n\t\t\tif ( extension !== null ) {\r\n\t\r\n\t\t\t\tif ( p === THREE.MinEquation ) return extension.MIN_EXT;\r\n\t\t\t\tif ( p === THREE.MaxEquation ) return extension.MAX_EXT;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn 0;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/WebGLRenderTarget.js\r\n\t\r\n\t/**\r\n\t * @author szimek / https://github.com/szimek/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author Marius Kintel / https://github.com/kintel\r\n\t */\r\n\t\r\n\t/*\r\n\t In options, we can specify:\r\n\t * Texture parameters for an auto-generated target texture\r\n\t * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\r\n\t*/\r\n\tTHREE.WebGLRenderTarget = function ( width, height, options ) {\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.width = width;\r\n\t\tthis.height = height;\r\n\t\r\n\t\tthis.scissor = new THREE.Vector4( 0, 0, width, height );\r\n\t\tthis.scissorTest = false;\r\n\t\r\n\t\tthis.viewport = new THREE.Vector4( 0, 0, width, height );\r\n\t\r\n\t\toptions = options || {};\r\n\t\r\n\t\tif ( options.minFilter === undefined ) options.minFilter = THREE.LinearFilter;\r\n\t\r\n\t\tthis.texture = new THREE.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy );\r\n\t\r\n\t\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\r\n\t\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.WebGLRenderTarget.prototype = {\r\n\t\r\n\t\tconstructor: THREE.WebGLRenderTarget,\r\n\t\r\n\t\tsetSize: function ( width, height ) {\r\n\t\r\n\t\t\tif ( this.width !== width || this.height !== height ) {\r\n\t\r\n\t\t\t\tthis.width = width;\r\n\t\t\t\tthis.height = height;\r\n\t\r\n\t\t\t\tthis.dispose();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.viewport.set( 0, 0, width, height );\r\n\t\t\tthis.scissor.set( 0, 0, width, height );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tthis.width = source.width;\r\n\t\t\tthis.height = source.height;\r\n\t\r\n\t\t\tthis.viewport.copy( source.viewport );\r\n\t\r\n\t\t\tthis.texture = source.texture.clone();\r\n\t\r\n\t\t\tthis.depthBuffer = source.depthBuffer;\r\n\t\t\tthis.stencilBuffer = source.stencilBuffer;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );\r\n\t\r\n\t// File:src/renderers/WebGLRenderTargetCube.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com\r\n\t */\r\n\t\r\n\tTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\r\n\t\r\n\t\tTHREE.WebGLRenderTarget.call( this, width, height, options );\r\n\t\r\n\t\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\r\n\t\tthis.activeMipMapLevel = 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\r\n\tTHREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;\r\n\t\r\n\t// File:src/renderers/webgl/WebGLBufferRenderer.js\r\n\t\r\n\t/**\r\n\t* @author mrdoob / http://mrdoob.com/\r\n\t*/\r\n\t\r\n\tTHREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {\r\n\t\r\n\t\tvar mode;\r\n\t\r\n\t\tfunction setMode( value ) {\r\n\t\r\n\t\t\tmode = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction render( start, count ) {\r\n\t\r\n\t\t\t_gl.drawArrays( mode, start, count );\r\n\t\r\n\t\t\t_infoRender.calls ++;\r\n\t\t\t_infoRender.vertices += count;\r\n\t\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction renderInstances( geometry ) {\r\n\t\r\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\t\r\n\t\t\tif ( extension === null ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar position = geometry.attributes.position;\r\n\t\r\n\t\t\tvar count = 0;\r\n\t\r\n\t\t\tif ( position instanceof THREE.InterleavedBufferAttribute ) {\r\n\t\r\n\t\t\t\tcount = position.data.count;\r\n\t\r\n\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tcount = position.count;\r\n\t\r\n\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_infoRender.calls ++;\r\n\t\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\r\n\t\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.setMode = setMode;\r\n\t\tthis.render = render;\r\n\t\tthis.renderInstances = renderInstances;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js\r\n\t\r\n\t/**\r\n\t* @author mrdoob / http://mrdoob.com/\r\n\t*/\r\n\t\r\n\tTHREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {\r\n\t\r\n\t\tvar mode;\r\n\t\r\n\t\tfunction setMode( value ) {\r\n\t\r\n\t\t\tmode = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar type, size;\r\n\t\r\n\t\tfunction setIndex( index ) {\r\n\t\r\n\t\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\r\n\t\r\n\t\t\t\ttype = _gl.UNSIGNED_INT;\r\n\t\t\t\tsize = 4;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\ttype = _gl.UNSIGNED_SHORT;\r\n\t\t\t\tsize = 2;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction render( start, count ) {\r\n\t\r\n\t\t\t_gl.drawElements( mode, count, type, start * size );\r\n\t\r\n\t\t\t_infoRender.calls ++;\r\n\t\t\t_infoRender.vertices += count;\r\n\t\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction renderInstances( geometry, start, count ) {\r\n\t\r\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\t\r\n\t\t\tif ( extension === null ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\textension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );\r\n\t\r\n\t\t\t_infoRender.calls ++;\r\n\t\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\r\n\t\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\r\n\t\t}\r\n\t\r\n\t\tthis.setMode = setMode;\r\n\t\tthis.setIndex = setIndex;\r\n\t\tthis.render = render;\r\n\t\tthis.renderInstances = renderInstances;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLExtensions.js\r\n\t\r\n\t/**\r\n\t* @author mrdoob / http://mrdoob.com/\r\n\t*/\r\n\t\r\n\tTHREE.WebGLExtensions = function ( gl ) {\r\n\t\r\n\t\tvar extensions = {};\r\n\t\r\n\t\tthis.get = function ( name ) {\r\n\t\r\n\t\t\tif ( extensions[ name ] !== undefined ) {\r\n\t\r\n\t\t\t\treturn extensions[ name ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar extension;\r\n\t\r\n\t\t\tswitch ( name ) {\r\n\t\r\n\t\t\t\tcase 'EXT_texture_filter_anisotropic':\r\n\t\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'WEBGL_compressed_texture_s3tc':\r\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\r\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'WEBGL_compressed_texture_etc1':\r\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tdefault:\r\n\t\t\t\t\textension = gl.getExtension( name );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( extension === null ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\textensions[ name ] = extension;\r\n\t\r\n\t\t\treturn extension;\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLCapabilities.js\r\n\t\r\n\tTHREE.WebGLCapabilities = function ( gl, extensions, parameters ) {\r\n\t\r\n\t\tfunction getMaxPrecision( precision ) {\r\n\t\r\n\t\t\tif ( precision === 'highp' ) {\r\n\t\r\n\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\r\n\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\r\n\t\r\n\t\t\t\t\treturn 'highp';\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tprecision = 'mediump';\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( precision === 'mediump' ) {\r\n\t\r\n\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\r\n\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\r\n\t\r\n\t\t\t\t\treturn 'mediump';\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn 'lowp';\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.getMaxPrecision = getMaxPrecision;\r\n\t\r\n\t\tthis.precision = parameters.precision !== undefined ? parameters.precision : 'highp',\r\n\t\tthis.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;\r\n\t\r\n\t\tthis.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\r\n\t\tthis.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\r\n\t\tthis.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\r\n\t\tthis.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\r\n\t\r\n\t\tthis.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\r\n\t\tthis.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\r\n\t\tthis.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\r\n\t\tthis.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\r\n\t\r\n\t\tthis.vertexTextures = this.maxVertexTextures > 0;\r\n\t\tthis.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\r\n\t\tthis.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;\r\n\t\r\n\t\tvar _maxPrecision = getMaxPrecision( this.precision );\r\n\t\r\n\t\tif ( _maxPrecision !== this.precision ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );\r\n\t\t\tthis.precision = _maxPrecision;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tif ( this.logarithmicDepthBuffer ) {\r\n\t\r\n\t\t\tthis.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLGeometries.js\r\n\t\r\n\t/**\r\n\t* @author mrdoob / http://mrdoob.com/\r\n\t*/\r\n\t\r\n\tTHREE.WebGLGeometries = function ( gl, properties, info ) {\r\n\t\r\n\t\tvar geometries = {};\r\n\t\r\n\t\tfunction get( object ) {\r\n\t\r\n\t\t\tvar geometry = object.geometry;\r\n\t\r\n\t\t\tif ( geometries[ geometry.id ] !== undefined ) {\r\n\t\r\n\t\t\t\treturn geometries[ geometry.id ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\r\n\t\r\n\t\t\tvar buffergeometry;\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\tbuffergeometry = geometry;\r\n\t\r\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\tif ( geometry._bufferGeometry === undefined ) {\r\n\t\r\n\t\t\t\t\tgeometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tbuffergeometry = geometry._bufferGeometry;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgeometries[ geometry.id ] = buffergeometry;\r\n\t\r\n\t\t\tinfo.memory.geometries ++;\r\n\t\r\n\t\t\treturn buffergeometry;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction onGeometryDispose( event ) {\r\n\t\r\n\t\t\tvar geometry = event.target;\r\n\t\t\tvar buffergeometry = geometries[ geometry.id ];\r\n\t\r\n\t\t\tif ( buffergeometry.index !== null ) {\r\n\t\r\n\t\t\t\tdeleteAttribute( buffergeometry.index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tdeleteAttributes( buffergeometry.attributes );\r\n\t\r\n\t\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\r\n\t\r\n\t\t\tdelete geometries[ geometry.id ];\r\n\t\r\n\t\t\t// TODO\r\n\t\r\n\t\t\tvar property = properties.get( geometry );\r\n\t\r\n\t\t\tif ( property.wireframe ) {\r\n\t\r\n\t\t\t\tdeleteAttribute( property.wireframe );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tproperties.delete( geometry );\r\n\t\r\n\t\t\tvar bufferproperty = properties.get( buffergeometry );\r\n\t\r\n\t\t\tif ( bufferproperty.wireframe ) {\r\n\t\r\n\t\t\t\tdeleteAttribute( bufferproperty.wireframe );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tproperties.delete( buffergeometry );\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tinfo.memory.geometries --;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction getAttributeBuffer( attribute ) {\r\n\t\r\n\t\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\t\r\n\t\t\t\treturn properties.get( attribute.data ).__webglBuffer;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn properties.get( attribute ).__webglBuffer;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction deleteAttribute( attribute ) {\r\n\t\r\n\t\t\tvar buffer = getAttributeBuffer( attribute );\r\n\t\r\n\t\t\tif ( buffer !== undefined ) {\r\n\t\r\n\t\t\t\tgl.deleteBuffer( buffer );\r\n\t\t\t\tremoveAttributeBuffer( attribute );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction deleteAttributes( attributes ) {\r\n\t\r\n\t\t\tfor ( var name in attributes ) {\r\n\t\r\n\t\t\t\tdeleteAttribute( attributes[ name ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction removeAttributeBuffer( attribute ) {\r\n\t\r\n\t\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\t\r\n\t\t\t\tproperties.delete( attribute.data );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tproperties.delete( attribute );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.get = get;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLLights.js\r\n\t\r\n\t/**\r\n\t* @author mrdoob / http://mrdoob.com/\r\n\t*/\r\n\t\r\n\tTHREE.WebGLLights = function () {\r\n\t\r\n\t\tvar lights = {};\r\n\t\r\n\t\tthis.get = function ( light ) {\r\n\t\r\n\t\t\tif ( lights[ light.id ] !== undefined ) {\r\n\t\r\n\t\t\t\treturn lights[ light.id ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar uniforms;\r\n\t\r\n\t\t\tswitch ( light.type ) {\r\n\t\r\n\t\t\t\tcase 'DirectionalLight':\r\n\t\t\t\t\tuniforms = {\r\n\t\t\t\t\t\tdirection: new THREE.Vector3(),\r\n\t\t\t\t\t\tcolor: new THREE.Color(),\r\n\t\r\n\t\t\t\t\t\tshadow: false,\r\n\t\t\t\t\t\tshadowBias: 0,\r\n\t\t\t\t\t\tshadowRadius: 1,\r\n\t\t\t\t\t\tshadowMapSize: new THREE.Vector2()\r\n\t\t\t\t\t};\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'SpotLight':\r\n\t\t\t\t\tuniforms = {\r\n\t\t\t\t\t\tposition: new THREE.Vector3(),\r\n\t\t\t\t\t\tdirection: new THREE.Vector3(),\r\n\t\t\t\t\t\tcolor: new THREE.Color(),\r\n\t\t\t\t\t\tdistance: 0,\r\n\t\t\t\t\t\tconeCos: 0,\r\n\t\t\t\t\t\tpenumbraCos: 0,\r\n\t\t\t\t\t\tdecay: 0,\r\n\t\r\n\t\t\t\t\t\tshadow: false,\r\n\t\t\t\t\t\tshadowBias: 0,\r\n\t\t\t\t\t\tshadowRadius: 1,\r\n\t\t\t\t\t\tshadowMapSize: new THREE.Vector2()\r\n\t\t\t\t\t};\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'PointLight':\r\n\t\t\t\t\tuniforms = {\r\n\t\t\t\t\t\tposition: new THREE.Vector3(),\r\n\t\t\t\t\t\tcolor: new THREE.Color(),\r\n\t\t\t\t\t\tdistance: 0,\r\n\t\t\t\t\t\tdecay: 0,\r\n\t\r\n\t\t\t\t\t\tshadow: false,\r\n\t\t\t\t\t\tshadowBias: 0,\r\n\t\t\t\t\t\tshadowRadius: 1,\r\n\t\t\t\t\t\tshadowMapSize: new THREE.Vector2()\r\n\t\t\t\t\t};\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'HemisphereLight':\r\n\t\t\t\t\tuniforms = {\r\n\t\t\t\t\t\tdirection: new THREE.Vector3(),\r\n\t\t\t\t\t\tskyColor: new THREE.Color(),\r\n\t\t\t\t\t\tgroundColor: new THREE.Color()\r\n\t\t\t\t\t};\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tlights[ light.id ] = uniforms;\r\n\t\r\n\t\t\treturn uniforms;\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLObjects.js\r\n\t\r\n\t/**\r\n\t* @author mrdoob / http://mrdoob.com/\r\n\t*/\r\n\t\r\n\tTHREE.WebGLObjects = function ( gl, properties, info ) {\r\n\t\r\n\t\tvar geometries = new THREE.WebGLGeometries( gl, properties, info );\r\n\t\r\n\t\t//\r\n\t\r\n\t\tfunction update( object ) {\r\n\t\r\n\t\t\t// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.\r\n\t\r\n\t\t\tvar geometry = geometries.get( object );\r\n\t\r\n\t\t\tif ( object.geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\tgeometry.updateFromObject( object );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar index = geometry.index;\r\n\t\t\tvar attributes = geometry.attributes;\r\n\t\r\n\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\tupdateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var name in attributes ) {\r\n\t\r\n\t\t\t\tupdateAttribute( attributes[ name ], gl.ARRAY_BUFFER );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// morph targets\r\n\t\r\n\t\t\tvar morphAttributes = geometry.morphAttributes;\r\n\t\r\n\t\t\tfor ( var name in morphAttributes ) {\r\n\t\r\n\t\t\t\tvar array = morphAttributes[ name ];\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tupdateAttribute( array[ i ], gl.ARRAY_BUFFER );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn geometry;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction updateAttribute( attribute, bufferType ) {\r\n\t\r\n\t\t\tvar data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;\r\n\t\r\n\t\t\tvar attributeProperties = properties.get( data );\r\n\t\r\n\t\t\tif ( attributeProperties.__webglBuffer === undefined ) {\r\n\t\r\n\t\t\t\tcreateBuffer( attributeProperties, data, bufferType );\r\n\t\r\n\t\t\t} else if ( attributeProperties.version !== data.version ) {\r\n\t\r\n\t\t\t\tupdateBuffer( attributeProperties, data, bufferType );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction createBuffer( attributeProperties, data, bufferType ) {\r\n\t\r\n\t\t\tattributeProperties.__webglBuffer = gl.createBuffer();\r\n\t\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\r\n\t\r\n\t\t\tvar usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\r\n\t\r\n\t\t\tgl.bufferData( bufferType, data.array, usage );\r\n\t\r\n\t\t\tattributeProperties.version = data.version;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction updateBuffer( attributeProperties, data, bufferType ) {\r\n\t\r\n\t\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\r\n\t\r\n\t\t\tif ( data.dynamic === false || data.updateRange.count === - 1 ) {\r\n\t\r\n\t\t\t\t// Not using update ranges\r\n\t\r\n\t\t\t\tgl.bufferSubData( bufferType, 0, data.array );\r\n\t\r\n\t\t\t} else if ( data.updateRange.count === 0 ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tgl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,\r\n\t\t\t\t\t\t\t\t  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );\r\n\t\r\n\t\t\t\tdata.updateRange.count = 0; // reset range\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tattributeProperties.version = data.version;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction getAttributeBuffer( attribute ) {\r\n\t\r\n\t\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\t\r\n\t\t\t\treturn properties.get( attribute.data ).__webglBuffer;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn properties.get( attribute ).__webglBuffer;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction getWireframeAttribute( geometry ) {\r\n\t\r\n\t\t\tvar property = properties.get( geometry );\r\n\t\r\n\t\t\tif ( property.wireframe !== undefined ) {\r\n\t\r\n\t\t\t\treturn property.wireframe;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar indices = [];\r\n\t\r\n\t\t\tvar index = geometry.index;\r\n\t\t\tvar attributes = geometry.attributes;\r\n\t\t\tvar position = attributes.position;\r\n\t\r\n\t\t\t// console.time( 'wireframe' );\r\n\t\r\n\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\tvar edges = {};\r\n\t\t\t\tvar array = index.array;\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\r\n\t\r\n\t\t\t\t\tvar a = array[ i + 0 ];\r\n\t\t\t\t\tvar b = array[ i + 1 ];\r\n\t\t\t\t\tvar c = array[ i + 2 ];\r\n\t\r\n\t\t\t\t\tif ( checkEdge( edges, a, b ) ) indices.push( a, b );\r\n\t\t\t\t\tif ( checkEdge( edges, b, c ) ) indices.push( b, c );\r\n\t\t\t\t\tif ( checkEdge( edges, c, a ) ) indices.push( c, a );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tvar array = attributes.position.array;\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\r\n\t\r\n\t\t\t\t\tvar a = i + 0;\r\n\t\t\t\t\tvar b = i + 1;\r\n\t\t\t\t\tvar c = i + 2;\r\n\t\r\n\t\t\t\t\tindices.push( a, b, b, c, c, a );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// console.timeEnd( 'wireframe' );\r\n\t\r\n\t\t\tvar TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;\r\n\t\t\tvar attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );\r\n\t\r\n\t\t\tupdateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\r\n\t\r\n\t\t\tproperty.wireframe = attribute;\r\n\t\r\n\t\t\treturn attribute;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction checkEdge( edges, a, b ) {\r\n\t\r\n\t\t\tif ( a > b ) {\r\n\t\r\n\t\t\t\tvar tmp = a;\r\n\t\t\t\ta = b;\r\n\t\t\t\tb = tmp;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar list = edges[ a ];\r\n\t\r\n\t\t\tif ( list === undefined ) {\r\n\t\r\n\t\t\t\tedges[ a ] = [ b ];\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t} else if ( list.indexOf( b ) === -1 ) {\r\n\t\r\n\t\t\t\tlist.push( b );\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.getAttributeBuffer = getAttributeBuffer;\r\n\t\tthis.getWireframeAttribute = getWireframeAttribute;\r\n\t\r\n\t\tthis.update = update;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLProgram.js\r\n\t\r\n\tTHREE.WebGLProgram = ( function () {\r\n\t\r\n\t\tvar programIdCount = 0;\r\n\t\r\n\t\t// TODO: Combine the regex\r\n\t\tvar structRe = /^([\\w\\d_]+)\\.([\\w\\d_]+)$/;\r\n\t\tvar arrayStructRe = /^([\\w\\d_]+)\\[(\\d+)\\]\\.([\\w\\d_]+)$/;\r\n\t\tvar arrayRe = /^([\\w\\d_]+)\\[0\\]$/;\r\n\t\r\n\t\tfunction getEncodingComponents( encoding ) {\r\n\t\r\n\t\t\tswitch ( encoding ) {\r\n\t\r\n\t\t\t\tcase THREE.LinearEncoding:\r\n\t\t\t\t\treturn [ 'Linear','( value )' ];\r\n\t\t\t\tcase THREE.sRGBEncoding:\r\n\t\t\t\t\treturn [ 'sRGB','( value )' ];\r\n\t\t\t\tcase THREE.RGBEEncoding:\r\n\t\t\t\t\treturn [ 'RGBE','( value )' ];\r\n\t\t\t\tcase THREE.RGBM7Encoding:\r\n\t\t\t\t\treturn [ 'RGBM','( value, 7.0 )' ];\r\n\t\t\t\tcase THREE.RGBM16Encoding:\r\n\t\t\t\t\treturn [ 'RGBM','( value, 16.0 )' ];\r\n\t\t\t\tcase THREE.RGBDEncoding:\r\n\t\t\t\t\treturn [ 'RGBD','( value, 256.0 )' ];\r\n\t\t\t\tcase THREE.GammaEncoding:\r\n\t\t\t\t\treturn [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error( 'unsupported encoding: ' + encoding );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction getTexelDecodingFunction( functionName, encoding ) {\r\n\t\r\n\t\t\tvar components = getEncodingComponents( encoding );\r\n\t\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return \" + components[ 0 ] + \"ToLinear\" + components[ 1 ] + \"; }\";\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction getTexelEncodingFunction( functionName, encoding ) {\r\n\t\r\n\t\t\tvar components = getEncodingComponents( encoding );\r\n\t\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return LinearTo\" + components[ 0 ] + components[ 1 ] + \"; }\";\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction getToneMappingFunction( functionName, toneMapping ) {\r\n\t\r\n\t\t\tvar toneMappingName;\r\n\t\r\n\t\t\tswitch ( toneMapping ) {\r\n\t\r\n\t\t\t\tcase THREE.LinearToneMapping:\r\n\t\t\t\t\ttoneMappingName = \"Linear\";\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase THREE.ReinhardToneMapping:\r\n\t\t\t\t\ttoneMappingName = \"Reinhard\";\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase THREE.Uncharted2ToneMapping:\r\n\t\t\t\t\ttoneMappingName = \"Uncharted2\";\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase THREE.CineonToneMapping:\r\n\t\t\t\t\ttoneMappingName = \"OptimizedCineon\";\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn \"vec3 \" + functionName + \"( vec3 color ) { return \" + toneMappingName + \"ToneMapping( color ); }\";\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\r\n\t\r\n\t\t\textensions = extensions || {};\r\n\t\r\n\t\t\tvar chunks = [\r\n\t\t\t\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\r\n\t\t\t\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\r\n\t\t\t\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\r\n\t\t\t\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',\r\n\t\t\t];\r\n\t\r\n\t\t\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction generateDefines( defines ) {\r\n\t\r\n\t\t\tvar chunks = [];\r\n\t\r\n\t\t\tfor ( var name in defines ) {\r\n\t\r\n\t\t\t\tvar value = defines[ name ];\r\n\t\r\n\t\t\t\tif ( value === false ) continue;\r\n\t\r\n\t\t\t\tchunks.push( '#define ' + name + ' ' + value );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn chunks.join( '\\n' );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction fetchUniformLocations( gl, program, identifiers ) {\r\n\t\r\n\t\t\tvar uniforms = {};\r\n\t\r\n\t\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\r\n\t\r\n\t\t\tfor ( var i = 0; i < n; i ++ ) {\r\n\t\r\n\t\t\t\tvar info = gl.getActiveUniform( program, i );\r\n\t\t\t\tvar name = info.name;\r\n\t\t\t\tvar location = gl.getUniformLocation( program, name );\r\n\t\r\n\t\t\t\t//console.log(\"THREE.WebGLProgram: ACTIVE UNIFORM:\", name);\r\n\t\r\n\t\t\t\tvar matches = structRe.exec( name );\r\n\t\t\t\tif ( matches ) {\r\n\t\r\n\t\t\t\t\tvar structName = matches[ 1 ];\r\n\t\t\t\t\tvar structProperty = matches[ 2 ];\r\n\t\r\n\t\t\t\t\tvar uniformsStruct = uniforms[ structName ];\r\n\t\r\n\t\t\t\t\tif ( ! uniformsStruct ) {\r\n\t\r\n\t\t\t\t\t\tuniformsStruct = uniforms[ structName ] = {};\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tuniformsStruct[ structProperty ] = location;\r\n\t\r\n\t\t\t\t\tcontinue;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tmatches = arrayStructRe.exec( name );\r\n\t\r\n\t\t\t\tif ( matches ) {\r\n\t\r\n\t\t\t\t\tvar arrayName = matches[ 1 ];\r\n\t\t\t\t\tvar arrayIndex = matches[ 2 ];\r\n\t\t\t\t\tvar arrayProperty = matches[ 3 ];\r\n\t\r\n\t\t\t\t\tvar uniformsArray = uniforms[ arrayName ];\r\n\t\r\n\t\t\t\t\tif ( ! uniformsArray ) {\r\n\t\r\n\t\t\t\t\t\tuniformsArray = uniforms[ arrayName ] = [];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar uniformsArrayIndex = uniformsArray[ arrayIndex ];\r\n\t\r\n\t\t\t\t\tif ( ! uniformsArrayIndex ) {\r\n\t\r\n\t\t\t\t\t\tuniformsArrayIndex = uniformsArray[ arrayIndex ] = {};\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tuniformsArrayIndex[ arrayProperty ] = location;\r\n\t\r\n\t\t\t\t\tcontinue;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tmatches = arrayRe.exec( name );\r\n\t\r\n\t\t\t\tif ( matches ) {\r\n\t\r\n\t\t\t\t\tvar arrayName = matches[ 1 ];\r\n\t\r\n\t\t\t\t\tuniforms[ arrayName ] = location;\r\n\t\r\n\t\t\t\t\tcontinue;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tuniforms[ name ] = location;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn uniforms;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction fetchAttributeLocations( gl, program, identifiers ) {\r\n\t\r\n\t\t\tvar attributes = {};\r\n\t\r\n\t\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\r\n\t\r\n\t\t\tfor ( var i = 0; i < n; i ++ ) {\r\n\t\r\n\t\t\t\tvar info = gl.getActiveAttrib( program, i );\r\n\t\t\t\tvar name = info.name;\r\n\t\r\n\t\t\t\t// console.log(\"THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\", name, i );\r\n\t\r\n\t\t\t\tattributes[ name ] = gl.getAttribLocation( program, name );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn attributes;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction filterEmptyLine( string ) {\r\n\t\r\n\t\t\treturn string !== '';\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction replaceLightNums( string, parameters ) {\r\n\t\r\n\t\t\treturn string\r\n\t\t\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\r\n\t\t\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\r\n\t\t\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\r\n\t\t\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction parseIncludes( string ) {\r\n\t\r\n\t\t\tvar pattern = /#include +<([\\w\\d.]+)>/g;\r\n\t\r\n\t\t\tfunction replace( match, include ) {\r\n\t\r\n\t\t\t\tvar replace = THREE.ShaderChunk[ include ];\r\n\t\r\n\t\t\t\tif ( replace === undefined ) {\r\n\t\r\n\t\t\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn parseIncludes( replace );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn string.replace( pattern, replace );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction unrollLoops( string ) {\r\n\t\r\n\t\t\tvar pattern = /for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\r\n\t\r\n\t\t\tfunction replace( match, start, end, snippet ) {\r\n\t\r\n\t\t\t\tvar unroll = '';\r\n\t\r\n\t\t\t\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\r\n\t\r\n\t\t\t\t\tunroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn unroll;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn string.replace( pattern, replace );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn function WebGLProgram( renderer, code, material, parameters ) {\r\n\t\r\n\t\t\tvar gl = renderer.context;\r\n\t\r\n\t\t\tvar extensions = material.extensions;\r\n\t\t\tvar defines = material.defines;\r\n\t\r\n\t\t\tvar vertexShader = material.__webglShader.vertexShader;\r\n\t\t\tvar fragmentShader = material.__webglShader.fragmentShader;\r\n\t\r\n\t\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\r\n\t\r\n\t\t\tif ( parameters.shadowMapType === THREE.PCFShadowMap ) {\r\n\t\r\n\t\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\r\n\t\r\n\t\t\t} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\r\n\t\r\n\t\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n\t\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\r\n\t\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n\t\r\n\t\t\tif ( parameters.envMap ) {\r\n\t\r\n\t\t\t\tswitch ( material.envMap.mapping ) {\r\n\t\r\n\t\t\t\t\tcase THREE.CubeReflectionMapping:\r\n\t\t\t\t\tcase THREE.CubeRefractionMapping:\r\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.CubeUVReflectionMapping:\r\n\t\t\t\t\tcase THREE.CubeUVRefractionMapping:\r\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.EquirectangularReflectionMapping:\r\n\t\t\t\t\tcase THREE.EquirectangularRefractionMapping:\r\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.SphericalReflectionMapping:\r\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tswitch ( material.envMap.mapping ) {\r\n\t\r\n\t\t\t\t\tcase THREE.CubeRefractionMapping:\r\n\t\t\t\t\tcase THREE.EquirectangularRefractionMapping:\r\n\t\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tswitch ( material.combine ) {\r\n\t\r\n\t\t\t\t\tcase THREE.MultiplyOperation:\r\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.MixOperation:\r\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.AddOperation:\r\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\r\n\t\r\n\t\t\t// console.log( 'building new program ' );\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar customExtensions = generateExtensions( extensions, parameters, renderer.extensions );\r\n\t\r\n\t\t\tvar customDefines = generateDefines( defines );\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar program = gl.createProgram();\r\n\t\r\n\t\t\tvar prefixVertex, prefixFragment;\r\n\t\r\n\t\t\tif ( material instanceof THREE.RawShaderMaterial ) {\r\n\t\r\n\t\t\t\tprefixVertex = '';\r\n\t\t\t\tprefixFragment = '';\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tprefixVertex = [\r\n\t\r\n\t\t\t\t\t'precision ' + parameters.precision + ' float;',\r\n\t\t\t\t\t'precision ' + parameters.precision + ' int;',\r\n\t\r\n\t\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\r\n\t\r\n\t\t\t\t\tcustomDefines,\r\n\t\r\n\t\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\r\n\t\r\n\t\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n\t\r\n\t\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\r\n\t\r\n\t\t\t\t\tparameters.map ? '#define USE_MAP' : '',\r\n\t\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\r\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\r\n\t\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n\t\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\r\n\t\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\r\n\t\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n\t\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n\t\t\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\r\n\t\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n\t\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\r\n\t\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\r\n\t\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n\t\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\r\n\t\r\n\t\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\r\n\t\r\n\t\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\r\n\t\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\r\n\t\r\n\t\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\r\n\t\t\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\r\n\t\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n\t\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\t\r\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n\t\t\t\t\tparameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',\r\n\t\r\n\t\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\r\n\t\r\n\t\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n\t\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\t\r\n\t\r\n\t\t\t\t\t'uniform mat4 modelMatrix;',\r\n\t\t\t\t\t'uniform mat4 modelViewMatrix;',\r\n\t\t\t\t\t'uniform mat4 projectionMatrix;',\r\n\t\t\t\t\t'uniform mat4 viewMatrix;',\r\n\t\t\t\t\t'uniform mat3 normalMatrix;',\r\n\t\t\t\t\t'uniform vec3 cameraPosition;',\r\n\t\r\n\t\t\t\t\t'attribute vec3 position;',\r\n\t\t\t\t\t'attribute vec3 normal;',\r\n\t\t\t\t\t'attribute vec2 uv;',\r\n\t\r\n\t\t\t\t\t'#ifdef USE_COLOR',\r\n\t\r\n\t\t\t\t\t'\tattribute vec3 color;',\r\n\t\r\n\t\t\t\t\t'#endif',\r\n\t\r\n\t\t\t\t\t'#ifdef USE_MORPHTARGETS',\r\n\t\r\n\t\t\t\t\t'\tattribute vec3 morphTarget0;',\r\n\t\t\t\t\t'\tattribute vec3 morphTarget1;',\r\n\t\t\t\t\t'\tattribute vec3 morphTarget2;',\r\n\t\t\t\t\t'\tattribute vec3 morphTarget3;',\r\n\t\r\n\t\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\r\n\t\r\n\t\t\t\t\t'\t\tattribute vec3 morphNormal0;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphNormal1;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphNormal2;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphNormal3;',\r\n\t\r\n\t\t\t\t\t'\t#else',\r\n\t\r\n\t\t\t\t\t'\t\tattribute vec3 morphTarget4;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphTarget5;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphTarget6;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphTarget7;',\r\n\t\r\n\t\t\t\t\t'\t#endif',\r\n\t\r\n\t\t\t\t\t'#endif',\r\n\t\r\n\t\t\t\t\t'#ifdef USE_SKINNING',\r\n\t\r\n\t\t\t\t\t'\tattribute vec4 skinIndex;',\r\n\t\t\t\t\t'\tattribute vec4 skinWeight;',\r\n\t\r\n\t\t\t\t\t'#endif',\r\n\t\r\n\t\t\t\t\t'\\n'\r\n\t\r\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\r\n\t\r\n\t\t\t\tprefixFragment = [\r\n\t\r\n\t\t\t\t\tcustomExtensions,\r\n\t\r\n\t\t\t\t\t'precision ' + parameters.precision + ' float;',\r\n\t\t\t\t\t'precision ' + parameters.precision + ' int;',\r\n\t\r\n\t\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\r\n\t\r\n\t\t\t\t\tcustomDefines,\r\n\t\r\n\t\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\r\n\t\r\n\t\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n\t\r\n\t\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\r\n\t\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\r\n\t\r\n\t\t\t\t\tparameters.map ? '#define USE_MAP' : '',\r\n\t\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\r\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\r\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\r\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\r\n\t\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n\t\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\r\n\t\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\r\n\t\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n\t\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n\t\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n\t\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\r\n\t\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\r\n\t\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n\t\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\r\n\t\r\n\t\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\r\n\t\r\n\t\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n\t\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\t\r\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n\t\t\t\t\tparameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',\r\n\t\r\n\t\t\t\t\tparameters.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : '',\r\n\t\r\n\t\t\t\t\tparameters.physicallyCorrectLights ? \"#define PHYSICALLY_CORRECT_LIGHTS\" : '',\r\n\t\r\n\t\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n\t\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\t\r\n\t\t\t\t\tparameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\r\n\t\r\n\t\t\t\t\t'uniform mat4 viewMatrix;',\r\n\t\t\t\t\t'uniform vec3 cameraPosition;',\r\n\t\r\n\t\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? \"#define TONE_MAPPING\" : '',\r\n\t\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? THREE.ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below\r\n\t\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? getToneMappingFunction( \"toneMapping\", parameters.toneMapping ) : '',\r\n\t\r\n\t\t\t\t\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? THREE.ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\r\n\t\t\t\t\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\r\n\t\t\t\t\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\r\n\t\t\t\t\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\r\n\t\t\t\t\tparameters.outputEncoding ? getTexelEncodingFunction( \"linearToOutputTexel\", parameters.outputEncoding ) : '',\r\n\t\r\n\t\t\t\t\t'\\n'\r\n\t\r\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvertexShader = parseIncludes( vertexShader, parameters );\r\n\t\t\tvertexShader = replaceLightNums( vertexShader, parameters );\r\n\t\r\n\t\t\tfragmentShader = parseIncludes( fragmentShader, parameters );\r\n\t\t\tfragmentShader = replaceLightNums( fragmentShader, parameters );\r\n\t\r\n\t\t\tif ( material instanceof THREE.ShaderMaterial === false ) {\r\n\t\r\n\t\t\t\tvertexShader = unrollLoops( vertexShader );\r\n\t\t\t\tfragmentShader = unrollLoops( fragmentShader );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar vertexGlsl = prefixVertex + vertexShader;\r\n\t\t\tvar fragmentGlsl = prefixFragment + fragmentShader;\r\n\t\r\n\t\t\t// console.log( '*VERTEX*', vertexGlsl );\r\n\t\t\t// console.log( '*FRAGMENT*', fragmentGlsl );\r\n\t\r\n\t\t\tvar glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\r\n\t\t\tvar glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\r\n\t\r\n\t\t\tgl.attachShader( program, glVertexShader );\r\n\t\t\tgl.attachShader( program, glFragmentShader );\r\n\t\r\n\t\t\t// Force a particular attribute to index 0.\r\n\t\r\n\t\t\tif ( material.index0AttributeName !== undefined ) {\r\n\t\r\n\t\t\t\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\r\n\t\r\n\t\t\t} else if ( parameters.morphTargets === true ) {\r\n\t\r\n\t\t\t\t// programs with morphTargets displace position out of attribute 0\r\n\t\t\t\tgl.bindAttribLocation( program, 0, 'position' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgl.linkProgram( program );\r\n\t\r\n\t\t\tvar programLog = gl.getProgramInfoLog( program );\r\n\t\t\tvar vertexLog = gl.getShaderInfoLog( glVertexShader );\r\n\t\t\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader );\r\n\t\r\n\t\t\tvar runnable = true;\r\n\t\t\tvar haveDiagnostics = true;\r\n\t\r\n\t\t\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\r\n\t\t\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\r\n\t\r\n\t\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\r\n\t\r\n\t\t\t\trunnable = false;\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\r\n\t\r\n\t\t\t} else if ( programLog !== '' ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\r\n\t\r\n\t\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\r\n\t\r\n\t\t\t\thaveDiagnostics = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( haveDiagnostics ) {\r\n\t\r\n\t\t\t\tthis.diagnostics = {\r\n\t\r\n\t\t\t\t\trunnable: runnable,\r\n\t\t\t\t\tmaterial: material,\r\n\t\r\n\t\t\t\t\tprogramLog: programLog,\r\n\t\r\n\t\t\t\t\tvertexShader: {\r\n\t\r\n\t\t\t\t\t\tlog: vertexLog,\r\n\t\t\t\t\t\tprefix: prefixVertex\r\n\t\r\n\t\t\t\t\t},\r\n\t\r\n\t\t\t\t\tfragmentShader: {\r\n\t\r\n\t\t\t\t\t\tlog: fragmentLog,\r\n\t\t\t\t\t\tprefix: prefixFragment\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// clean up\r\n\t\r\n\t\t\tgl.deleteShader( glVertexShader );\r\n\t\t\tgl.deleteShader( glFragmentShader );\r\n\t\r\n\t\t\t// set up caching for uniform locations\r\n\t\r\n\t\t\tvar cachedUniforms;\r\n\t\r\n\t\t\tthis.getUniforms = function() {\r\n\t\r\n\t\t\t\tif ( cachedUniforms === undefined ) {\r\n\t\r\n\t\t\t\t\tcachedUniforms = fetchUniformLocations( gl, program );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn cachedUniforms;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\t// set up caching for attribute locations\r\n\t\r\n\t\t\tvar cachedAttributes;\r\n\t\r\n\t\t\tthis.getAttributes = function() {\r\n\t\r\n\t\t\t\tif ( cachedAttributes === undefined ) {\r\n\t\r\n\t\t\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn cachedAttributes;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\t// free resource\r\n\t\r\n\t\t\tthis.destroy = function() {\r\n\t\r\n\t\t\t\tgl.deleteProgram( program );\r\n\t\t\t\tthis.program = undefined;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\t// DEPRECATED\r\n\t\r\n\t\t\tObject.defineProperties( this, {\r\n\t\r\n\t\t\t\tuniforms: {\r\n\t\t\t\t\tget: function() {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\r\n\t\t\t\t\t\treturn this.getUniforms();\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tattributes: {\r\n\t\t\t\t\tget: function() {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\r\n\t\t\t\t\t\treturn this.getAttributes();\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} );\r\n\t\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tthis.id = programIdCount ++;\r\n\t\t\tthis.code = code;\r\n\t\t\tthis.usedTimes = 1;\r\n\t\t\tthis.program = program;\r\n\t\t\tthis.vertexShader = glVertexShader;\r\n\t\t\tthis.fragmentShader = glFragmentShader;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\t// File:src/renderers/webgl/WebGLPrograms.js\r\n\t\r\n\tTHREE.WebGLPrograms = function ( renderer, capabilities ) {\r\n\t\r\n\t\tvar programs = [];\r\n\t\r\n\t\tvar shaderIDs = {\r\n\t\t\tMeshDepthMaterial: 'depth',\r\n\t\t\tMeshNormalMaterial: 'normal',\r\n\t\t\tMeshBasicMaterial: 'basic',\r\n\t\t\tMeshLambertMaterial: 'lambert',\r\n\t\t\tMeshPhongMaterial: 'phong',\r\n\t\t\tMeshStandardMaterial: 'standard',\r\n\t\t\tLineBasicMaterial: 'basic',\r\n\t\t\tLineDashedMaterial: 'dashed',\r\n\t\t\tPointsMaterial: 'points'\r\n\t\t};\r\n\t\r\n\t\tvar parameterNames = [\r\n\t\t\t\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\r\n\t\t\t\"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"displacementMap\", \"specularMap\",\r\n\t\t\t\"roughnessMap\", \"metalnessMap\",\r\n\t\t\t\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\r\n\t\t\t\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\r\n\t\t\t\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\r\n\t\t\t\"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\r\n\t\t\t\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\",\r\n\t\t\t\"shadowMapEnabled\", \"pointLightShadows\", \"toneMapping\", 'physicallyCorrectLights',\r\n\t\t\t\"shadowMapType\",\r\n\t\t\t\"alphaTest\", \"doubleSided\", \"flipSided\"\r\n\t\t];\r\n\t\r\n\t\r\n\t\tfunction allocateBones ( object ) {\r\n\t\r\n\t\t\tif ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\r\n\t\r\n\t\t\t\treturn 1024;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// default for when object is not specified\r\n\t\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\r\n\t\t\t\t//\r\n\t\t\t\t//  - leave some extra space for other uniforms\r\n\t\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\r\n\t\t\t\t//    (up to 54 should be safe)\r\n\t\r\n\t\t\t\tvar nVertexUniforms = capabilities.maxVertexUniforms;\r\n\t\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\r\n\t\r\n\t\t\t\tvar maxBones = nVertexMatrices;\r\n\t\r\n\t\t\t\tif ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\r\n\t\r\n\t\t\t\t\tmaxBones = Math.min( object.skeleton.bones.length, maxBones );\r\n\t\r\n\t\t\t\t\tif ( maxBones < object.skeleton.bones.length ) {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn maxBones;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\r\n\t\r\n\t\t\tvar encoding;\r\n\t\r\n\t\t\tif ( ! map ) {\r\n\t\r\n\t\t\t\tencoding = THREE.LinearEncoding;\r\n\t\r\n\t\t\t} else if ( map instanceof THREE.Texture ) {\r\n\t\r\n\t\t\t\tencoding = map.encoding;\r\n\t\r\n\t\t\t} else if ( map instanceof THREE.WebGLRenderTarget ) {\r\n\t\r\n\t\t\t\tencoding = map.texture.encoding;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\r\n\t\t\tif ( encoding === THREE.LinearEncoding && gammaOverrideLinear ) {\r\n\t\r\n\t\t\t\tencoding = THREE.GammaEncoding;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn encoding;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.getParameters = function ( material, lights, fog, object ) {\r\n\t\r\n\t\t\tvar shaderID = shaderIDs[ material.type ];\r\n\t\r\n\t\t\t// heuristics to create shader parameters according to lights in the scene\r\n\t\t\t// (not to blow over maxLights budget)\r\n\t\r\n\t\t\tvar maxBones = allocateBones( object );\r\n\t\t\tvar precision = renderer.getPrecision();\r\n\t\r\n\t\t\tif ( material.precision !== null ) {\r\n\t\r\n\t\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\r\n\t\r\n\t\t\t\tif ( precision !== material.precision ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar parameters = {\r\n\t\r\n\t\t\t\tshaderID: shaderID,\r\n\t\r\n\t\t\t\tprecision: precision,\r\n\t\t\t\tsupportsVertexTextures: capabilities.vertexTextures,\r\n\t\t\t\toutputEncoding: getTextureEncodingFromMap( renderer.getCurrentRenderTarget(), renderer.gammaOutput ),\r\n\t\t\t\tmap: !! material.map,\r\n\t\t\t\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\r\n\t\t\t\tenvMap: !! material.envMap,\r\n\t\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\r\n\t\t\t\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\r\n\t\t\t\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === THREE.CubeUVReflectionMapping ) || ( material.envMap.mapping === THREE.CubeUVRefractionMapping ) ),\r\n\t\t\t\tlightMap: !! material.lightMap,\r\n\t\t\t\taoMap: !! material.aoMap,\r\n\t\t\t\temissiveMap: !! material.emissiveMap,\r\n\t\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\r\n\t\t\t\tbumpMap: !! material.bumpMap,\r\n\t\t\t\tnormalMap: !! material.normalMap,\r\n\t\t\t\tdisplacementMap: !! material.displacementMap,\r\n\t\t\t\troughnessMap: !! material.roughnessMap,\r\n\t\t\t\tmetalnessMap: !! material.metalnessMap,\r\n\t\t\t\tspecularMap: !! material.specularMap,\r\n\t\t\t\talphaMap: !! material.alphaMap,\r\n\t\r\n\t\t\t\tcombine: material.combine,\r\n\t\r\n\t\t\t\tvertexColors: material.vertexColors,\r\n\t\r\n\t\t\t\tfog: fog,\r\n\t\t\t\tuseFog: material.fog,\r\n\t\t\t\tfogExp: fog instanceof THREE.FogExp2,\r\n\t\r\n\t\t\t\tflatShading: material.shading === THREE.FlatShading,\r\n\t\r\n\t\t\t\tsizeAttenuation: material.sizeAttenuation,\r\n\t\t\t\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\r\n\t\r\n\t\t\t\tskinning: material.skinning,\r\n\t\t\t\tmaxBones: maxBones,\r\n\t\t\t\tuseVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,\r\n\t\r\n\t\t\t\tmorphTargets: material.morphTargets,\r\n\t\t\t\tmorphNormals: material.morphNormals,\r\n\t\t\t\tmaxMorphTargets: renderer.maxMorphTargets,\r\n\t\t\t\tmaxMorphNormals: renderer.maxMorphNormals,\r\n\t\r\n\t\t\t\tnumDirLights: lights.directional.length,\r\n\t\t\t\tnumPointLights: lights.point.length,\r\n\t\t\t\tnumSpotLights: lights.spot.length,\r\n\t\t\t\tnumHemiLights: lights.hemi.length,\r\n\t\r\n\t\t\t\tpointLightShadows: lights.shadowsPointLight,\r\n\t\r\n\t\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,\r\n\t\t\t\tshadowMapType: renderer.shadowMap.type,\r\n\t\r\n\t\t\t\ttoneMapping: renderer.toneMapping,\r\n\t\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\r\n\t\r\n\t\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\r\n\t\r\n\t\t\t\talphaTest: material.alphaTest,\r\n\t\t\t\tdoubleSided: material.side === THREE.DoubleSide,\r\n\t\t\t\tflipSided: material.side === THREE.BackSide\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\treturn parameters;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getProgramCode = function ( material, parameters ) {\r\n\t\r\n\t\t\tvar chunks = [];\r\n\t\r\n\t\t\tif ( parameters.shaderID ) {\r\n\t\r\n\t\t\t\tchunks.push( parameters.shaderID );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tchunks.push( material.fragmentShader );\r\n\t\t\t\tchunks.push( material.vertexShader );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.defines !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var name in material.defines ) {\r\n\t\r\n\t\t\t\t\tchunks.push( name );\r\n\t\t\t\t\tchunks.push( material.defines[ name ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\r\n\t\r\n\t\t\t\tvar parameterName = parameterNames[ i ];\r\n\t\t\t\tchunks.push( parameterName );\r\n\t\t\t\tchunks.push( parameters[ parameterName ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn chunks.join();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.acquireProgram = function ( material, parameters, code ) {\r\n\t\r\n\t\t\tvar program;\r\n\t\r\n\t\t\t// Check if code has been already compiled\r\n\t\t\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\r\n\t\r\n\t\t\t\tvar programInfo = programs[ p ];\r\n\t\r\n\t\t\t\tif ( programInfo.code === code ) {\r\n\t\r\n\t\t\t\t\tprogram = programInfo;\r\n\t\t\t\t\t++ program.usedTimes;\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( program === undefined ) {\r\n\t\r\n\t\t\t\tprogram = new THREE.WebGLProgram( renderer, code, material, parameters );\r\n\t\t\t\tprograms.push( program );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn program;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.releaseProgram = function( program ) {\r\n\t\r\n\t\t\tif ( -- program.usedTimes === 0 ) {\r\n\t\r\n\t\t\t\t// Remove from unordered set\r\n\t\t\t\tvar i = programs.indexOf( program );\r\n\t\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\r\n\t\t\t\tprograms.pop();\r\n\t\r\n\t\t\t\t// Free WebGL resources\r\n\t\t\t\tprogram.destroy();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Exposed for resource monitoring & error feedback via renderer.info:\r\n\t\tthis.programs = programs;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLProperties.js\r\n\t\r\n\t/**\r\n\t* @author fordacious / fordacious.github.io\r\n\t*/\r\n\t\r\n\tTHREE.WebGLProperties = function () {\r\n\t\r\n\t\tvar properties = {};\r\n\t\r\n\t\tthis.get = function ( object ) {\r\n\t\r\n\t\t\tvar uuid = object.uuid;\r\n\t\t\tvar map = properties[ uuid ];\r\n\t\r\n\t\t\tif ( map === undefined ) {\r\n\t\r\n\t\t\t\tmap = {};\r\n\t\t\t\tproperties[ uuid ] = map;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn map;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.delete = function ( object ) {\r\n\t\r\n\t\t\tdelete properties[ object.uuid ];\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clear = function () {\r\n\t\r\n\t\t\tproperties = {};\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLShader.js\r\n\t\r\n\tTHREE.WebGLShader = ( function () {\r\n\t\r\n\t\tfunction addLineNumbers( string ) {\r\n\t\r\n\t\t\tvar lines = string.split( '\\n' );\r\n\t\r\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\r\n\t\r\n\t\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn lines.join( '\\n' );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn function WebGLShader( gl, type, string ) {\r\n\t\r\n\t\t\tvar shader = gl.createShader( type );\r\n\t\r\n\t\t\tgl.shaderSource( shader, string );\r\n\t\t\tgl.compileShader( shader );\r\n\t\r\n\t\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// --enable-privileged-webgl-extension\r\n\t\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\r\n\t\r\n\t\t\treturn shader;\r\n\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\t// File:src/renderers/webgl/WebGLShadowMap.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {\r\n\t\r\n\t\tvar _gl = _renderer.context,\r\n\t\t_state = _renderer.state,\r\n\t\t_frustum = new THREE.Frustum(),\r\n\t\t_projScreenMatrix = new THREE.Matrix4(),\r\n\t\r\n\t\t_shadowMapSize = new THREE.Vector2(),\r\n\t\r\n\t\t_lookTarget = new THREE.Vector3(),\r\n\t\t_lightPositionWorld = new THREE.Vector3(),\r\n\t\r\n\t\t_renderList = [],\r\n\t\r\n\t\t_MorphingFlag = 1,\r\n\t\t_SkinningFlag = 2,\r\n\t\r\n\t\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\r\n\t\r\n\t\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\r\n\t\t_distanceMaterials = new Array( _NumberOfMaterialVariants );\r\n\t\r\n\t\tvar cubeDirections = [\r\n\t\t\tnew THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( - 1, 0, 0 ), new THREE.Vector3( 0, 0, 1 ),\r\n\t\t\tnew THREE.Vector3( 0, 0, - 1 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, - 1, 0 )\r\n\t\t];\r\n\t\r\n\t\tvar cubeUps = [\r\n\t\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ),\r\n\t\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ),\tnew THREE.Vector3( 0, 0, - 1 )\r\n\t\t];\r\n\t\r\n\t\tvar cube2DViewPorts = [\r\n\t\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),\r\n\t\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()\r\n\t\t];\r\n\t\r\n\t\t// init\r\n\t\r\n\t\tvar depthShader = THREE.ShaderLib[ \"depthRGBA\" ];\r\n\t\tvar depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );\r\n\t\r\n\t\tvar distanceShader = THREE.ShaderLib[ \"distanceRGBA\" ];\r\n\t\tvar distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms );\r\n\t\r\n\t\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\r\n\t\r\n\t\t\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\r\n\t\t\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\r\n\t\r\n\t\t\tvar depthMaterial = new THREE.ShaderMaterial( {\r\n\t\t\t\tuniforms: depthUniforms,\r\n\t\t\t\tvertexShader: depthShader.vertexShader,\r\n\t\t\t\tfragmentShader: depthShader.fragmentShader,\r\n\t\t\t\tmorphTargets: useMorphing,\r\n\t\t\t\tskinning: useSkinning\r\n\t\t\t} );\r\n\t\r\n\t\t\t_depthMaterials[ i ] = depthMaterial;\r\n\t\r\n\t\t\tvar distanceMaterial = new THREE.ShaderMaterial( {\r\n\t\t\t\tdefines: {\r\n\t\t\t\t\t'USE_SHADOWMAP': ''\r\n\t\t\t\t},\r\n\t\t\t\tuniforms: distanceUniforms,\r\n\t\t\t\tvertexShader: distanceShader.vertexShader,\r\n\t\t\t\tfragmentShader: distanceShader.fragmentShader,\r\n\t\t\t\tmorphTargets: useMorphing,\r\n\t\t\t\tskinning: useSkinning\r\n\t\t\t} );\r\n\t\r\n\t\t\t_distanceMaterials[ i ] = distanceMaterial;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\tthis.enabled = false;\r\n\t\r\n\t\tthis.autoUpdate = true;\r\n\t\tthis.needsUpdate = false;\r\n\t\r\n\t\tthis.type = THREE.PCFShadowMap;\r\n\t\tthis.cullFace = THREE.CullFaceFront;\r\n\t\r\n\t\tthis.render = function ( scene, camera ) {\r\n\t\r\n\t\t\tvar faceCount, isPointLight;\r\n\t\t\tvar shadows = _lights.shadows;\r\n\t\r\n\t\t\tif ( shadows.length === 0 ) return;\r\n\t\r\n\t\t\tif ( scope.enabled === false ) return;\r\n\t\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\r\n\t\r\n\t\t\t// Set GL state for depth map.\r\n\t\t\t_state.clearColor( 1, 1, 1, 1 );\r\n\t\t\t_state.disable( _gl.BLEND );\r\n\t\t\t_state.enable( _gl.CULL_FACE );\r\n\t\t\t_gl.frontFace( _gl.CCW );\r\n\t\t\t_gl.cullFace( scope.cullFace === THREE.CullFaceFront ? _gl.FRONT : _gl.BACK );\r\n\t\t\t_state.setDepthTest( true );\r\n\t\t\t_state.setScissorTest( false );\r\n\t\r\n\t\t\t// render depth map\r\n\t\r\n\t\t\tfor ( var i = 0, il = shadows.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar light = shadows[ i ];\r\n\t\r\n\t\t\t\tvar shadow = light.shadow;\r\n\t\t\t\tvar shadowCamera = shadow.camera;\r\n\t\r\n\t\t\t\t_shadowMapSize.copy( shadow.mapSize );\r\n\t\r\n\t\t\t\tif ( light instanceof THREE.PointLight ) {\r\n\t\r\n\t\t\t\t\tfaceCount = 6;\r\n\t\t\t\t\tisPointLight = true;\r\n\t\r\n\t\t\t\t\tvar vpWidth = _shadowMapSize.x;\r\n\t\t\t\t\tvar vpHeight = _shadowMapSize.y;\r\n\t\r\n\t\t\t\t\t// These viewports map a cube-map onto a 2D texture with the\r\n\t\t\t\t\t// following orientation:\r\n\t\t\t\t\t//\r\n\t\t\t\t\t//  xzXZ\r\n\t\t\t\t\t//   y Y\r\n\t\t\t\t\t//\r\n\t\t\t\t\t// X - Positive x direction\r\n\t\t\t\t\t// x - Negative x direction\r\n\t\t\t\t\t// Y - Positive y direction\r\n\t\t\t\t\t// y - Negative y direction\r\n\t\t\t\t\t// Z - Positive z direction\r\n\t\t\t\t\t// z - Negative z direction\r\n\t\r\n\t\t\t\t\t// positive X\r\n\t\t\t\t\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t\t// negative X\r\n\t\t\t\t\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t\t// positive Z\r\n\t\t\t\t\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t\t// negative Z\r\n\t\t\t\t\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t\t// positive Y\r\n\t\t\t\t\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\r\n\t\t\t\t\t// negative Y\r\n\t\t\t\t\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\r\n\t\r\n\t\t\t\t\t_shadowMapSize.x *= 4.0;\r\n\t\t\t\t\t_shadowMapSize.y *= 2.0;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tfaceCount = 1;\r\n\t\t\t\t\tisPointLight = false;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( shadow.map === null ) {\r\n\t\r\n\t\t\t\t\tvar pars = { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\r\n\t\r\n\t\t\t\t\tshadow.map = new THREE.WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\r\n\t\r\n\t\t\t\t\t//\r\n\t\r\n\t\t\t\t\tif ( light instanceof THREE.SpotLight ) {\r\n\t\r\n\t\t\t\t\t\tshadowCamera.aspect = _shadowMapSize.x / _shadowMapSize.y;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tshadowCamera.updateProjectionMatrix();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar shadowMap = shadow.map;\r\n\t\t\t\tvar shadowMatrix = shadow.matrix;\r\n\t\r\n\t\t\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\tshadowCamera.position.copy( _lightPositionWorld );\r\n\t\r\n\t\t\t\t_renderer.setRenderTarget( shadowMap );\r\n\t\t\t\t_renderer.clear();\r\n\t\r\n\t\t\t\t// render shadow map for each cube face (if omni-directional) or\r\n\t\t\t\t// run a single pass if not\r\n\t\r\n\t\t\t\tfor ( var face = 0; face < faceCount; face ++ ) {\r\n\t\r\n\t\t\t\t\tif ( isPointLight ) {\r\n\t\r\n\t\t\t\t\t\t_lookTarget.copy( shadowCamera.position );\r\n\t\t\t\t\t\t_lookTarget.add( cubeDirections[ face ] );\r\n\t\t\t\t\t\tshadowCamera.up.copy( cubeUps[ face ] );\r\n\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\r\n\t\r\n\t\t\t\t\t\tvar vpDimensions = cube2DViewPorts[ face ];\r\n\t\t\t\t\t\t_state.viewport( vpDimensions );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tshadowCamera.updateMatrixWorld();\r\n\t\t\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\r\n\t\r\n\t\t\t\t\t// compute shadow matrix\r\n\t\r\n\t\t\t\t\tshadowMatrix.set(\r\n\t\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\r\n\t\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\r\n\t\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\r\n\t\t\t\t\t\t0.0, 0.0, 0.0, 1.0\r\n\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\r\n\t\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\r\n\t\r\n\t\t\t\t\t// update camera matrices and frustum\r\n\t\r\n\t\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\r\n\t\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\t\r\n\t\t\t\t\t// set object matrices & frustum culling\r\n\t\r\n\t\t\t\t\t_renderList.length = 0;\r\n\t\r\n\t\t\t\t\tprojectObject( scene, camera, shadowCamera );\r\n\t\r\n\t\t\t\t\t// render shadow map\r\n\t\t\t\t\t// render regular objects\r\n\t\r\n\t\t\t\t\tfor ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar object = _renderList[ j ];\r\n\t\t\t\t\t\tvar geometry = _objects.update( object );\r\n\t\t\t\t\t\tvar material = object.material;\r\n\t\r\n\t\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\r\n\t\r\n\t\t\t\t\t\t\tvar groups = geometry.groups;\r\n\t\t\t\t\t\t\tvar materials = material.materials;\r\n\t\r\n\t\t\t\t\t\t\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvar group = groups[ k ];\r\n\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\r\n\t\r\n\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );\r\n\t\t\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );\r\n\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Restore GL state.\r\n\t\t\tvar clearColor = _renderer.getClearColor(),\r\n\t\t\tclearAlpha = _renderer.getClearAlpha();\r\n\t\t\t_renderer.setClearColor( clearColor, clearAlpha );\r\n\t\r\n\t\t\t_state.enable( _gl.BLEND );\r\n\t\r\n\t\t\tif ( scope.cullFace === THREE.CullFaceFront ) {\r\n\t\r\n\t\t\t\t_gl.cullFace( _gl.BACK );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tscope.needsUpdate = false;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {\r\n\t\r\n\t\t\tvar geometry = object.geometry;\r\n\t\r\n\t\t\tvar newMaterial = null;\r\n\t\r\n\t\t\tvar materialVariants = _depthMaterials;\r\n\t\t\tvar customMaterial = object.customDepthMaterial;\r\n\t\r\n\t\t\tif ( isPointLight ) {\r\n\t\r\n\t\t\t\tmaterialVariants = _distanceMaterials;\r\n\t\t\t\tcustomMaterial = object.customDistanceMaterial;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( ! customMaterial ) {\r\n\t\r\n\t\t\t\tvar useMorphing = geometry.morphTargets !== undefined &&\r\n\t\t\t\t\t\tgeometry.morphTargets.length > 0 && material.morphTargets;\r\n\t\r\n\t\t\t\tvar useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;\r\n\t\r\n\t\t\t\tvar variantIndex = 0;\r\n\t\r\n\t\t\t\tif ( useMorphing ) variantIndex |= _MorphingFlag;\r\n\t\t\t\tif ( useSkinning ) variantIndex |= _SkinningFlag;\r\n\t\r\n\t\t\t\tnewMaterial = materialVariants[ variantIndex ];\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tnewMaterial = customMaterial;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tnewMaterial.visible = material.visible;\r\n\t\t\tnewMaterial.wireframe = material.wireframe;\r\n\t\t\tnewMaterial.wireframeLinewidth = material.wireframeLinewidth;\r\n\t\r\n\t\t\tif ( isPointLight && newMaterial.uniforms.lightPos !== undefined ) {\r\n\t\r\n\t\t\t\tnewMaterial.uniforms.lightPos.value.copy( lightPositionWorld );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn newMaterial;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction projectObject( object, camera, shadowCamera ) {\r\n\t\r\n\t\t\tif ( object.visible === false ) return;\r\n\t\r\n\t\t\tif ( object.layers.test( camera.layers ) && ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) ) {\r\n\t\r\n\t\t\t\tif ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\r\n\t\r\n\t\t\t\t\tvar material = object.material;\r\n\t\r\n\t\t\t\t\tif ( material.visible === true ) {\r\n\t\r\n\t\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\r\n\t\t\t\t\t\t_renderList.push( object );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar children = object.children;\r\n\t\r\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tprojectObject( children[ i ], camera, shadowCamera );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLState.js\r\n\t\r\n\t/**\r\n\t* @author mrdoob / http://mrdoob.com/\r\n\t*/\r\n\t\r\n\tTHREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {\r\n\t\r\n\t\tvar _this = this;\r\n\t\r\n\t\tvar color = new THREE.Vector4();\r\n\t\r\n\t\tvar newAttributes = new Uint8Array( 16 );\r\n\t\tvar enabledAttributes = new Uint8Array( 16 );\r\n\t\tvar attributeDivisors = new Uint8Array( 16 );\r\n\t\r\n\t\tvar capabilities = {};\r\n\t\r\n\t\tvar compressedTextureFormats = null;\r\n\t\r\n\t\tvar currentBlending = null;\r\n\t\tvar currentBlendEquation = null;\r\n\t\tvar currentBlendSrc = null;\r\n\t\tvar currentBlendDst = null;\r\n\t\tvar currentBlendEquationAlpha = null;\r\n\t\tvar currentBlendSrcAlpha = null;\r\n\t\tvar currentBlendDstAlpha = null;\r\n\t\tvar currentPremultipledAlpha = false;\r\n\t\r\n\t\tvar currentDepthFunc = null;\r\n\t\tvar currentDepthWrite = null;\r\n\t\r\n\t\tvar currentColorWrite = null;\r\n\t\r\n\t\tvar currentStencilWrite = null;\r\n\t\tvar currentStencilFunc = null;\r\n\t\tvar currentStencilRef = null;\r\n\t\tvar currentStencilMask = null;\r\n\t\tvar currentStencilFail  = null;\r\n\t\tvar currentStencilZFail = null;\r\n\t\tvar currentStencilZPass = null;\r\n\t\r\n\t\tvar currentFlipSided = null;\r\n\t\r\n\t\tvar currentLineWidth = null;\r\n\t\r\n\t\tvar currentPolygonOffsetFactor = null;\r\n\t\tvar currentPolygonOffsetUnits = null;\r\n\t\r\n\t\tvar currentScissorTest = null;\r\n\t\r\n\t\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\r\n\t\r\n\t\tvar currentTextureSlot = undefined;\r\n\t\tvar currentBoundTextures = {};\r\n\t\r\n\t\tvar currentClearColor = new THREE.Vector4();\r\n\t\tvar currentClearDepth = null;\r\n\t\tvar currentClearStencil = null;\r\n\t\r\n\t\tvar currentScissor = new THREE.Vector4();\r\n\t\tvar currentViewport = new THREE.Vector4();\r\n\t\r\n\t\tvar emptyTexture = gl.createTexture();\r\n\t\tgl.bindTexture( gl.TEXTURE_2D, emptyTexture );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR );\r\n\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 1, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, new Uint8Array( 3 ) );\r\n\t\r\n\t\tthis.init = function () {\r\n\t\r\n\t\t\tthis.clearColor( 0, 0, 0, 1 );\r\n\t\t\tthis.clearDepth( 1 );\r\n\t\t\tthis.clearStencil( 0 );\r\n\t\r\n\t\t\tthis.enable( gl.DEPTH_TEST );\r\n\t\t\tgl.depthFunc( gl.LEQUAL );\r\n\t\r\n\t\t\tgl.frontFace( gl.CCW );\r\n\t\t\tgl.cullFace( gl.BACK );\r\n\t\t\tthis.enable( gl.CULL_FACE );\r\n\t\r\n\t\t\tthis.enable( gl.BLEND );\r\n\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.initAttributes = function () {\r\n\t\r\n\t\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tnewAttributes[ i ] = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.enableAttribute = function ( attribute ) {\r\n\t\r\n\t\t\tnewAttributes[ attribute ] = 1;\r\n\t\r\n\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\r\n\t\r\n\t\t\t\tgl.enableVertexAttribArray( attribute );\r\n\t\t\t\tenabledAttributes[ attribute ] = 1;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( attributeDivisors[ attribute ] !== 0 ) {\r\n\t\r\n\t\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\t\r\n\t\t\t\textension.vertexAttribDivisorANGLE( attribute, 0 );\r\n\t\t\t\tattributeDivisors[ attribute ] = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {\r\n\t\r\n\t\t\tnewAttributes[ attribute ] = 1;\r\n\t\r\n\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\r\n\t\r\n\t\t\t\tgl.enableVertexAttribArray( attribute );\r\n\t\t\t\tenabledAttributes[ attribute ] = 1;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\r\n\t\r\n\t\t\t\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\r\n\t\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.disableUnusedAttributes = function () {\r\n\t\r\n\t\t\tfor ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\r\n\t\r\n\t\t\t\t\tgl.disableVertexAttribArray( i );\r\n\t\t\t\t\tenabledAttributes[ i ] = 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.enable = function ( id ) {\r\n\t\r\n\t\t\tif ( capabilities[ id ] !== true ) {\r\n\t\r\n\t\t\t\tgl.enable( id );\r\n\t\t\t\tcapabilities[ id ] = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.disable = function ( id ) {\r\n\t\r\n\t\t\tif ( capabilities[ id ] !== false ) {\r\n\t\r\n\t\t\t\tgl.disable( id );\r\n\t\t\t\tcapabilities[ id ] = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getCompressedTextureFormats = function () {\r\n\t\r\n\t\t\tif ( compressedTextureFormats === null ) {\r\n\t\r\n\t\t\t\tcompressedTextureFormats = [];\r\n\t\r\n\t\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\r\n\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\r\n\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {\r\n\t\r\n\t\t\t\t\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tcompressedTextureFormats.push( formats[ i ] );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn compressedTextureFormats;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\r\n\t\r\n\t\t\tif ( blending === THREE.NoBlending ) {\r\n\t\r\n\t\t\t\tthis.disable( gl.BLEND );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.enable( gl.BLEND );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\r\n\t\r\n\t\t\t\tif ( blending === THREE.AdditiveBlending ) {\r\n\t\r\n\t\t\t\t\tif ( premultipliedAlpha ) {\r\n\t\r\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( blending === THREE.SubtractiveBlending ) {\r\n\t\r\n\t\t\t\t\tif ( premultipliedAlpha ) {\r\n\t\r\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( blending === THREE.MultiplyBlending ) {\r\n\t\r\n\t\t\t\t\tif ( premultipliedAlpha ) {\r\n\t\r\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.SRC_COLOR, gl.SRC_ALPHA );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tif ( premultipliedAlpha ) {\r\n\t\r\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcurrentBlending = blending;\r\n\t\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( blending === THREE.CustomBlending ) {\r\n\t\r\n\t\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\r\n\t\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\r\n\t\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\r\n\t\r\n\t\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\r\n\t\r\n\t\t\t\t\tgl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\r\n\t\r\n\t\t\t\t\tcurrentBlendEquation = blendEquation;\r\n\t\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\r\n\t\r\n\t\t\t\t\tgl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\r\n\t\r\n\t\t\t\t\tcurrentBlendSrc = blendSrc;\r\n\t\t\t\t\tcurrentBlendDst = blendDst;\r\n\t\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\r\n\t\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tcurrentBlendEquation = null;\r\n\t\t\t\tcurrentBlendSrc = null;\r\n\t\t\t\tcurrentBlendDst = null;\r\n\t\t\t\tcurrentBlendEquationAlpha = null;\r\n\t\t\t\tcurrentBlendSrcAlpha = null;\r\n\t\t\t\tcurrentBlendDstAlpha = null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setDepthFunc = function ( depthFunc ) {\r\n\t\r\n\t\t\tif ( currentDepthFunc !== depthFunc ) {\r\n\t\r\n\t\t\t\tif ( depthFunc ) {\r\n\t\r\n\t\t\t\t\tswitch ( depthFunc ) {\r\n\t\r\n\t\t\t\t\t\tcase THREE.NeverDepth:\r\n\t\r\n\t\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase THREE.AlwaysDepth:\r\n\t\r\n\t\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase THREE.LessDepth:\r\n\t\r\n\t\t\t\t\t\t\tgl.depthFunc( gl.LESS );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase THREE.LessEqualDepth:\r\n\t\r\n\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase THREE.EqualDepth:\r\n\t\r\n\t\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase THREE.GreaterEqualDepth:\r\n\t\r\n\t\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase THREE.GreaterDepth:\r\n\t\r\n\t\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase THREE.NotEqualDepth:\r\n\t\r\n\t\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tdefault:\r\n\t\r\n\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcurrentDepthFunc = depthFunc;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setDepthTest = function ( depthTest ) {\r\n\t\r\n\t\t\tif ( depthTest ) {\r\n\t\r\n\t\t\t\tthis.enable( gl.DEPTH_TEST );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.disable( gl.DEPTH_TEST );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setDepthWrite = function ( depthWrite ) {\r\n\t\r\n\t\t\t// TODO: Rename to setDepthMask\r\n\t\r\n\t\t\tif ( currentDepthWrite !== depthWrite ) {\r\n\t\r\n\t\t\t\tgl.depthMask( depthWrite );\r\n\t\t\t\tcurrentDepthWrite = depthWrite;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setColorWrite = function ( colorWrite ) {\r\n\t\r\n\t\t\t// TODO: Rename to setColorMask\r\n\t\r\n\t\t\tif ( currentColorWrite !== colorWrite ) {\r\n\t\r\n\t\t\t\tgl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );\r\n\t\t\t\tcurrentColorWrite = colorWrite;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setStencilFunc = function ( stencilFunc, stencilRef, stencilMask ) {\r\n\t\r\n\t\t\tif ( currentStencilFunc !== stencilFunc ||\r\n\t\t\t\t\t currentStencilRef \t!== stencilRef \t||\r\n\t\t\t\t\t currentStencilMask !== stencilMask ) {\r\n\t\r\n\t\t\t\tgl.stencilFunc( stencilFunc,  stencilRef, stencilMask );\r\n\t\r\n\t\t\t\tcurrentStencilFunc = stencilFunc;\r\n\t\t\t\tcurrentStencilRef  = stencilRef;\r\n\t\t\t\tcurrentStencilMask = stencilMask;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setStencilOp = function ( stencilFail, stencilZFail, stencilZPass ) {\r\n\t\r\n\t\t\tif ( currentStencilFail\t !== stencilFail \t||\r\n\t\t\t\t\t currentStencilZFail !== stencilZFail ||\r\n\t\t\t\t\t currentStencilZPass !== stencilZPass ) {\r\n\t\r\n\t\t\t\tgl.stencilOp( stencilFail,  stencilZFail, stencilZPass );\r\n\t\r\n\t\t\t\tcurrentStencilFail  = stencilFail;\r\n\t\t\t\tcurrentStencilZFail = stencilZFail;\r\n\t\t\t\tcurrentStencilZPass = stencilZPass;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setStencilTest = function ( stencilTest ) {\r\n\t\r\n\t\t\tif ( stencilTest ) {\r\n\t\r\n\t\t\t\tthis.enable( gl.STENCIL_TEST );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.disable( gl.STENCIL_TEST );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setStencilWrite = function ( stencilWrite ) {\r\n\t\r\n\t\t\t// TODO: Rename to setStencilMask\r\n\t\r\n\t\t\tif ( currentStencilWrite !== stencilWrite ) {\r\n\t\r\n\t\t\t\tgl.stencilMask( stencilWrite );\r\n\t\t\t\tcurrentStencilWrite = stencilWrite;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setFlipSided = function ( flipSided ) {\r\n\t\r\n\t\t\tif ( currentFlipSided !== flipSided ) {\r\n\t\r\n\t\t\t\tif ( flipSided ) {\r\n\t\r\n\t\t\t\t\tgl.frontFace( gl.CW );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tgl.frontFace( gl.CCW );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcurrentFlipSided = flipSided;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setLineWidth = function ( width ) {\r\n\t\r\n\t\t\tif ( width !== currentLineWidth ) {\r\n\t\r\n\t\t\t\tgl.lineWidth( width );\r\n\t\r\n\t\t\t\tcurrentLineWidth = width;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setPolygonOffset = function ( polygonOffset, factor, units ) {\r\n\t\r\n\t\t\tif ( polygonOffset ) {\r\n\t\r\n\t\t\t\tthis.enable( gl.POLYGON_OFFSET_FILL );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.disable( gl.POLYGON_OFFSET_FILL );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( polygonOffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {\r\n\t\r\n\t\t\t\tgl.polygonOffset( factor, units );\r\n\t\r\n\t\t\t\tcurrentPolygonOffsetFactor = factor;\r\n\t\t\t\tcurrentPolygonOffsetUnits = units;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getScissorTest = function () {\r\n\t\r\n\t\t\treturn currentScissorTest;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setScissorTest = function ( scissorTest ) {\r\n\t\r\n\t\t\tcurrentScissorTest = scissorTest;\r\n\t\r\n\t\t\tif ( scissorTest ) {\r\n\t\r\n\t\t\t\tthis.enable( gl.SCISSOR_TEST );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.disable( gl.SCISSOR_TEST );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// texture\r\n\t\r\n\t\tthis.activeTexture = function ( webglSlot ) {\r\n\t\r\n\t\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\r\n\t\r\n\t\t\tif ( currentTextureSlot !== webglSlot ) {\r\n\t\r\n\t\t\t\tgl.activeTexture( webglSlot );\r\n\t\t\t\tcurrentTextureSlot = webglSlot;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.bindTexture = function ( webglType, webglTexture ) {\r\n\t\r\n\t\t\tif ( currentTextureSlot === undefined ) {\r\n\t\r\n\t\t\t\t_this.activeTexture();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\r\n\t\r\n\t\t\tif ( boundTexture === undefined ) {\r\n\t\r\n\t\t\t\tboundTexture = { type: undefined, texture: undefined };\r\n\t\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\r\n\t\r\n\t\t\t\tgl.bindTexture( webglType, webglTexture || emptyTexture );\r\n\t\r\n\t\t\t\tboundTexture.type = webglType;\r\n\t\t\t\tboundTexture.texture = webglTexture;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.compressedTexImage2D = function () {\r\n\t\r\n\t\t\ttry {\r\n\t\r\n\t\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\r\n\t\r\n\t\t\t} catch ( error ) {\r\n\t\r\n\t\t\t\tconsole.error( error );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.texImage2D = function () {\r\n\t\r\n\t\t\ttry {\r\n\t\r\n\t\t\t\tgl.texImage2D.apply( gl, arguments );\r\n\t\r\n\t\t\t} catch ( error ) {\r\n\t\r\n\t\t\t\tconsole.error( error );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// clear values\r\n\t\r\n\t\tthis.clearColor = function ( r, g, b, a ) {\r\n\t\r\n\t\t\tcolor.set( r, g, b, a );\r\n\t\r\n\t\t\tif ( currentClearColor.equals( color ) === false ) {\r\n\t\r\n\t\t\t\tgl.clearColor( r, g, b, a );\r\n\t\t\t\tcurrentClearColor.copy( color );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clearDepth = function ( depth ) {\r\n\t\r\n\t\t\tif ( currentClearDepth !== depth ) {\r\n\t\r\n\t\t\t\tgl.clearDepth( depth );\r\n\t\t\t\tcurrentClearDepth = depth;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clearStencil = function ( stencil ) {\r\n\t\r\n\t\t\tif ( currentClearStencil !== stencil ) {\r\n\t\r\n\t\t\t\tgl.clearStencil( stencil );\r\n\t\t\t\tcurrentClearStencil = stencil;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t//\r\n\t\r\n\t\tthis.scissor = function ( scissor ) {\r\n\t\r\n\t\t\tif ( currentScissor.equals( scissor ) === false ) {\r\n\t\r\n\t\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\r\n\t\t\t\tcurrentScissor.copy( scissor );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.viewport = function ( viewport ) {\r\n\t\r\n\t\t\tif ( currentViewport.equals( viewport ) === false ) {\r\n\t\r\n\t\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\r\n\t\t\t\tcurrentViewport.copy( viewport );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t//\r\n\t\r\n\t\tthis.reset = function () {\r\n\t\r\n\t\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\r\n\t\r\n\t\t\t\tif ( enabledAttributes[ i ] === 1 ) {\r\n\t\r\n\t\t\t\t\tgl.disableVertexAttribArray( i );\r\n\t\t\t\t\tenabledAttributes[ i ] = 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tcapabilities = {};\r\n\t\r\n\t\t\tcompressedTextureFormats = null;\r\n\t\r\n\t\t\tcurrentTextureSlot = undefined;\r\n\t\t\tcurrentBoundTextures = {};\r\n\t\r\n\t\t\tcurrentBlending = null;\r\n\t\r\n\t\t\tcurrentColorWrite = null;\r\n\t\t\tcurrentDepthWrite = null;\r\n\t\t\tcurrentStencilWrite = null;\r\n\t\r\n\t\t\tcurrentFlipSided = null;\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/plugins/LensFlarePlugin.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.LensFlarePlugin = function ( renderer, flares ) {\r\n\t\r\n\t\tvar gl = renderer.context;\r\n\t\tvar state = renderer.state;\r\n\t\r\n\t\tvar vertexBuffer, elementBuffer;\r\n\t\tvar program, attributes, uniforms;\r\n\t\tvar hasVertexTexture;\r\n\t\r\n\t\tvar tempTexture, occlusionTexture;\r\n\t\r\n\t\tfunction init() {\r\n\t\r\n\t\t\tvar vertices = new Float32Array( [\r\n\t\t\t\t- 1, - 1,  0, 0,\r\n\t\t\t\t 1, - 1,  1, 0,\r\n\t\t\t\t 1,  1,  1, 1,\r\n\t\t\t\t- 1,  1,  0, 1\r\n\t\t\t] );\r\n\t\r\n\t\t\tvar faces = new Uint16Array( [\r\n\t\t\t\t0, 1, 2,\r\n\t\t\t\t0, 2, 3\r\n\t\t\t] );\r\n\t\r\n\t\t\t// buffers\r\n\t\r\n\t\t\tvertexBuffer     = gl.createBuffer();\r\n\t\t\telementBuffer    = gl.createBuffer();\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\r\n\t\r\n\t\t\t// textures\r\n\t\r\n\t\t\ttempTexture      = gl.createTexture();\r\n\t\t\tocclusionTexture = gl.createTexture();\r\n\t\r\n\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\t\r\n\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\r\n\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\t\r\n\t\t\thasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;\r\n\t\r\n\t\t\tvar shader;\r\n\t\r\n\t\t\tif ( hasVertexTexture ) {\r\n\t\r\n\t\t\t\tshader = {\r\n\t\r\n\t\t\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\t\r\n\t\t\t\t\t\t\"uniform vec3 screenPosition;\",\r\n\t\t\t\t\t\t\"uniform vec2 scale;\",\r\n\t\t\t\t\t\t\"uniform float rotation;\",\r\n\t\r\n\t\t\t\t\t\t\"uniform sampler2D occlusionMap;\",\r\n\t\r\n\t\t\t\t\t\t\"attribute vec2 position;\",\r\n\t\t\t\t\t\t\"attribute vec2 uv;\",\r\n\t\r\n\t\t\t\t\t\t\"varying vec2 vUV;\",\r\n\t\t\t\t\t\t\"varying float vVisibility;\",\r\n\t\r\n\t\t\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\t\t\t\"vUV = uv;\",\r\n\t\r\n\t\t\t\t\t\t\t\"vec2 pos = position;\",\r\n\t\r\n\t\t\t\t\t\t\t\"if ( renderType == 2 ) {\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\r\n\t\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\r\n\t\t\t\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\r\n\t\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n\t\t\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\t\r\n\t\t\t\t\t\t\t\"}\",\r\n\t\r\n\t\t\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\t\r\n\t\t\t\t\t\t\"}\"\r\n\t\r\n\t\t\t\t\t].join( \"\\n\" ),\r\n\t\r\n\t\t\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\t\r\n\t\t\t\t\t\t\"uniform sampler2D map;\",\r\n\t\t\t\t\t\t\"uniform float opacity;\",\r\n\t\t\t\t\t\t\"uniform vec3 color;\",\r\n\t\r\n\t\t\t\t\t\t\"varying vec2 vUV;\",\r\n\t\t\t\t\t\t\"varying float vVisibility;\",\r\n\t\r\n\t\t\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\t\t\t// pink square\r\n\t\r\n\t\t\t\t\t\t\t\"if ( renderType == 0 ) {\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\r\n\t\r\n\t\t\t\t\t\t\t// restore\r\n\t\r\n\t\t\t\t\t\t\t\"} else if ( renderType == 1 ) {\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\r\n\t\r\n\t\t\t\t\t\t\t// flare\r\n\t\r\n\t\t\t\t\t\t\t\"} else {\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\r\n\t\t\t\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\r\n\t\t\t\t\t\t\t\t\"gl_FragColor = texture;\",\r\n\t\t\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\r\n\t\r\n\t\t\t\t\t\t\t\"}\",\r\n\t\r\n\t\t\t\t\t\t\"}\"\r\n\t\r\n\t\t\t\t\t].join( \"\\n\" )\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tshader = {\r\n\t\r\n\t\t\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\t\r\n\t\t\t\t\t\t\"uniform vec3 screenPosition;\",\r\n\t\t\t\t\t\t\"uniform vec2 scale;\",\r\n\t\t\t\t\t\t\"uniform float rotation;\",\r\n\t\r\n\t\t\t\t\t\t\"attribute vec2 position;\",\r\n\t\t\t\t\t\t\"attribute vec2 uv;\",\r\n\t\r\n\t\t\t\t\t\t\"varying vec2 vUV;\",\r\n\t\r\n\t\t\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\t\t\t\"vUV = uv;\",\r\n\t\r\n\t\t\t\t\t\t\t\"vec2 pos = position;\",\r\n\t\r\n\t\t\t\t\t\t\t\"if ( renderType == 2 ) {\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n\t\t\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\t\r\n\t\t\t\t\t\t\t\"}\",\r\n\t\r\n\t\t\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\t\r\n\t\t\t\t\t\t\"}\"\r\n\t\r\n\t\t\t\t\t].join( \"\\n\" ),\r\n\t\r\n\t\t\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\t\t\t\"precision mediump float;\",\r\n\t\r\n\t\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\t\r\n\t\t\t\t\t\t\"uniform sampler2D map;\",\r\n\t\t\t\t\t\t\"uniform sampler2D occlusionMap;\",\r\n\t\t\t\t\t\t\"uniform float opacity;\",\r\n\t\t\t\t\t\t\"uniform vec3 color;\",\r\n\t\r\n\t\t\t\t\t\t\"varying vec2 vUV;\",\r\n\t\r\n\t\t\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\t\t\t// pink square\r\n\t\r\n\t\t\t\t\t\t\t\"if ( renderType == 0 ) {\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\",\r\n\t\r\n\t\t\t\t\t\t\t// restore\r\n\t\r\n\t\t\t\t\t\t\t\"} else if ( renderType == 1 ) {\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\r\n\t\r\n\t\t\t\t\t\t\t// flare\r\n\t\r\n\t\t\t\t\t\t\t\"} else {\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\",\r\n\t\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\",\r\n\t\t\t\t\t\t\t\t\"visibility = ( 1.0 - visibility / 4.0 );\",\r\n\t\r\n\t\t\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\r\n\t\t\t\t\t\t\t\t\"texture.a *= opacity * visibility;\",\r\n\t\t\t\t\t\t\t\t\"gl_FragColor = texture;\",\r\n\t\t\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\r\n\t\r\n\t\t\t\t\t\t\t\"}\",\r\n\t\r\n\t\t\t\t\t\t\"}\"\r\n\t\r\n\t\t\t\t\t].join( \"\\n\" )\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tprogram = createProgram( shader );\r\n\t\r\n\t\t\tattributes = {\r\n\t\t\t\tvertex: gl.getAttribLocation ( program, \"position\" ),\r\n\t\t\t\tuv:     gl.getAttribLocation ( program, \"uv\" )\r\n\t\t\t};\r\n\t\r\n\t\t\tuniforms = {\r\n\t\t\t\trenderType:     gl.getUniformLocation( program, \"renderType\" ),\r\n\t\t\t\tmap:            gl.getUniformLocation( program, \"map\" ),\r\n\t\t\t\tocclusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\r\n\t\t\t\topacity:        gl.getUniformLocation( program, \"opacity\" ),\r\n\t\t\t\tcolor:          gl.getUniformLocation( program, \"color\" ),\r\n\t\t\t\tscale:          gl.getUniformLocation( program, \"scale\" ),\r\n\t\t\t\trotation:       gl.getUniformLocation( program, \"rotation\" ),\r\n\t\t\t\tscreenPosition: gl.getUniformLocation( program, \"screenPosition\" )\r\n\t\t\t};\r\n\t\r\n\t\t}\r\n\t\r\n\t\t/*\r\n\t\t * Render lens flares\r\n\t\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\r\n\t\t *         reads these back and calculates occlusion.\r\n\t\t */\r\n\t\r\n\t\tthis.render = function ( scene, camera, viewport ) {\r\n\t\r\n\t\t\tif ( flares.length === 0 ) return;\r\n\t\r\n\t\t\tvar tempPosition = new THREE.Vector3();\r\n\t\r\n\t\t\tvar invAspect = viewport.w / viewport.z,\r\n\t\t\t\thalfViewportWidth = viewport.z * 0.5,\r\n\t\t\t\thalfViewportHeight = viewport.w * 0.5;\r\n\t\r\n\t\t\tvar size = 16 / viewport.w,\r\n\t\t\t\tscale = new THREE.Vector2( size * invAspect, size );\r\n\t\r\n\t\t\tvar screenPosition = new THREE.Vector3( 1, 1, 0 ),\r\n\t\t\t\tscreenPositionPixels = new THREE.Vector2( 1, 1 );\r\n\t\r\n\t\t\tif ( program === undefined ) {\r\n\t\r\n\t\t\t\tinit();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgl.useProgram( program );\r\n\t\r\n\t\t\tstate.initAttributes();\r\n\t\t\tstate.enableAttribute( attributes.vertex );\r\n\t\t\tstate.enableAttribute( attributes.uv );\r\n\t\t\tstate.disableUnusedAttributes();\r\n\t\r\n\t\t\t// loop through all lens flares to update their occlusion and positions\r\n\t\t\t// setup gl and common used attribs/uniforms\r\n\t\r\n\t\t\tgl.uniform1i( uniforms.occlusionMap, 0 );\r\n\t\t\tgl.uniform1i( uniforms.map, 1 );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\t\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\r\n\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\r\n\t\t\tstate.disable( gl.CULL_FACE );\r\n\t\t\tstate.setDepthWrite( false );\r\n\t\r\n\t\t\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tsize = 16 / viewport.w;\r\n\t\t\t\tscale.set( size * invAspect, size );\r\n\t\r\n\t\t\t\t// calc object screen position\r\n\t\r\n\t\t\t\tvar flare = flares[ i ];\r\n\t\r\n\t\t\t\ttempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\r\n\t\r\n\t\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\r\n\t\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\r\n\t\r\n\t\t\t\t// setup arrays for gl programs\r\n\t\r\n\t\t\t\tscreenPosition.copy( tempPosition );\r\n\t\r\n\t\t\t\tscreenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;\r\n\t\t\t\tscreenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;\r\n\t\r\n\t\t\t\t// screen cull\r\n\t\r\n\t\t\t\tif ( hasVertexTexture || (\r\n\t\t\t\t\tscreenPositionPixels.x > 0 &&\r\n\t\t\t\t\tscreenPositionPixels.x < viewport.z &&\r\n\t\t\t\t\tscreenPositionPixels.y > 0 &&\r\n\t\t\t\t\tscreenPositionPixels.y < viewport.w ) ) {\r\n\t\r\n\t\t\t\t\t// save current RGB to temp texture\r\n\t\r\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\r\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, null );\r\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\r\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, viewport.x + screenPositionPixels.x - 8, viewport.y + screenPositionPixels.y - 8, 16, 16, 0 );\r\n\t\r\n\t\r\n\t\t\t\t\t// render pink quad\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 0 );\r\n\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\t\r\n\t\t\t\t\tstate.disable( gl.BLEND );\r\n\t\t\t\t\tstate.enable( gl.DEPTH_TEST );\r\n\t\r\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\t\r\n\t\r\n\t\t\t\t\t// copy result to occlusionMap\r\n\t\r\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\r\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\r\n\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, viewport.x + screenPositionPixels.x - 8, viewport.y + screenPositionPixels.y - 8, 16, 16, 0 );\r\n\t\r\n\t\r\n\t\t\t\t\t// restore graphics\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 1 );\r\n\t\t\t\t\tstate.disable( gl.DEPTH_TEST );\r\n\t\r\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\r\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\t\r\n\t\r\n\t\t\t\t\t// update object positions\r\n\t\r\n\t\t\t\t\tflare.positionScreen.copy( screenPosition );\r\n\t\r\n\t\t\t\t\tif ( flare.customUpdateCallback ) {\r\n\t\r\n\t\t\t\t\t\tflare.customUpdateCallback( flare );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tflare.updateLensFlares();\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// render flares\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 2 );\r\n\t\t\t\t\tstate.enable( gl.BLEND );\r\n\t\r\n\t\t\t\t\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar sprite = flare.lensFlares[ j ];\r\n\t\r\n\t\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\r\n\t\r\n\t\t\t\t\t\t\tscreenPosition.x = sprite.x;\r\n\t\t\t\t\t\t\tscreenPosition.y = sprite.y;\r\n\t\t\t\t\t\t\tscreenPosition.z = sprite.z;\r\n\t\r\n\t\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewport.w;\r\n\t\r\n\t\t\t\t\t\t\tscale.x = size * invAspect;\r\n\t\t\t\t\t\t\tscale.y = size;\r\n\t\r\n\t\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\t\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n\t\t\t\t\t\t\tgl.uniform1f( uniforms.rotation, sprite.rotation );\r\n\t\r\n\t\t\t\t\t\t\tgl.uniform1f( uniforms.opacity, sprite.opacity );\r\n\t\t\t\t\t\t\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\r\n\t\r\n\t\t\t\t\t\t\tstate.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\r\n\t\t\t\t\t\t\trenderer.setTexture( sprite.texture, 1 );\r\n\t\r\n\t\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// restore gl\r\n\t\r\n\t\t\tstate.enable( gl.CULL_FACE );\r\n\t\t\tstate.enable( gl.DEPTH_TEST );\r\n\t\t\tstate.setDepthWrite( true );\r\n\t\r\n\t\t\trenderer.resetGLState();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction createProgram ( shader ) {\r\n\t\r\n\t\t\tvar program = gl.createProgram();\r\n\t\r\n\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\r\n\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\r\n\t\r\n\t\t\tvar prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\r\n\t\r\n\t\t\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\r\n\t\t\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\r\n\t\r\n\t\t\tgl.compileShader( fragmentShader );\r\n\t\t\tgl.compileShader( vertexShader );\r\n\t\r\n\t\t\tgl.attachShader( program, fragmentShader );\r\n\t\t\tgl.attachShader( program, vertexShader );\r\n\t\r\n\t\t\tgl.linkProgram( program );\r\n\t\r\n\t\t\treturn program;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/plugins/SpritePlugin.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.SpritePlugin = function ( renderer, sprites ) {\r\n\t\r\n\t\tvar gl = renderer.context;\r\n\t\tvar state = renderer.state;\r\n\t\r\n\t\tvar vertexBuffer, elementBuffer;\r\n\t\tvar program, attributes, uniforms;\r\n\t\r\n\t\tvar texture;\r\n\t\r\n\t\t// decompose matrixWorld\r\n\t\r\n\t\tvar spritePosition = new THREE.Vector3();\r\n\t\tvar spriteRotation = new THREE.Quaternion();\r\n\t\tvar spriteScale = new THREE.Vector3();\r\n\t\r\n\t\tfunction init() {\r\n\t\r\n\t\t\tvar vertices = new Float32Array( [\r\n\t\t\t\t- 0.5, - 0.5,  0, 0,\r\n\t\t\t\t  0.5, - 0.5,  1, 0,\r\n\t\t\t\t  0.5,   0.5,  1, 1,\r\n\t\t\t\t- 0.5,   0.5,  0, 1\r\n\t\t\t] );\r\n\t\r\n\t\t\tvar faces = new Uint16Array( [\r\n\t\t\t\t0, 1, 2,\r\n\t\t\t\t0, 2, 3\r\n\t\t\t] );\r\n\t\r\n\t\t\tvertexBuffer  = gl.createBuffer();\r\n\t\t\telementBuffer = gl.createBuffer();\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\r\n\t\r\n\t\t\tprogram = createProgram();\r\n\t\r\n\t\t\tattributes = {\r\n\t\t\t\tposition:\t\t\tgl.getAttribLocation ( program, 'position' ),\r\n\t\t\t\tuv:\t\t\t\t\tgl.getAttribLocation ( program, 'uv' )\r\n\t\t\t};\r\n\t\r\n\t\t\tuniforms = {\r\n\t\t\t\tuvOffset:\t\t\tgl.getUniformLocation( program, 'uvOffset' ),\r\n\t\t\t\tuvScale:\t\t\tgl.getUniformLocation( program, 'uvScale' ),\r\n\t\r\n\t\t\t\trotation:\t\t\tgl.getUniformLocation( program, 'rotation' ),\r\n\t\t\t\tscale:\t\t\t\tgl.getUniformLocation( program, 'scale' ),\r\n\t\r\n\t\t\t\tcolor:\t\t\t\tgl.getUniformLocation( program, 'color' ),\r\n\t\t\t\tmap:\t\t\t\tgl.getUniformLocation( program, 'map' ),\r\n\t\t\t\topacity:\t\t\tgl.getUniformLocation( program, 'opacity' ),\r\n\t\r\n\t\t\t\tmodelViewMatrix: \tgl.getUniformLocation( program, 'modelViewMatrix' ),\r\n\t\t\t\tprojectionMatrix:\tgl.getUniformLocation( program, 'projectionMatrix' ),\r\n\t\r\n\t\t\t\tfogType:\t\t\tgl.getUniformLocation( program, 'fogType' ),\r\n\t\t\t\tfogDensity:\t\t\tgl.getUniformLocation( program, 'fogDensity' ),\r\n\t\t\t\tfogNear:\t\t\tgl.getUniformLocation( program, 'fogNear' ),\r\n\t\t\t\tfogFar:\t\t\t\tgl.getUniformLocation( program, 'fogFar' ),\r\n\t\t\t\tfogColor:\t\t\tgl.getUniformLocation( program, 'fogColor' ),\r\n\t\r\n\t\t\t\talphaTest:\t\t\tgl.getUniformLocation( program, 'alphaTest' )\r\n\t\t\t};\r\n\t\r\n\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\tcanvas.width = 8;\r\n\t\t\tcanvas.height = 8;\r\n\t\r\n\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\tcontext.fillStyle = 'white';\r\n\t\t\tcontext.fillRect( 0, 0, 8, 8 );\r\n\t\r\n\t\t\ttexture = new THREE.Texture( canvas );\r\n\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.render = function ( scene, camera ) {\r\n\t\r\n\t\t\tif ( sprites.length === 0 ) return;\r\n\t\r\n\t\t\t// setup gl\r\n\t\r\n\t\t\tif ( program === undefined ) {\r\n\t\r\n\t\t\t\tinit();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgl.useProgram( program );\r\n\t\r\n\t\t\tstate.initAttributes();\r\n\t\t\tstate.enableAttribute( attributes.position );\r\n\t\t\tstate.enableAttribute( attributes.uv );\r\n\t\t\tstate.disableUnusedAttributes();\r\n\t\r\n\t\t\tstate.disable( gl.CULL_FACE );\r\n\t\t\tstate.enable( gl.BLEND );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\r\n\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\r\n\t\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\t\r\n\t\t\tstate.activeTexture( gl.TEXTURE0 );\r\n\t\t\tgl.uniform1i( uniforms.map, 0 );\r\n\t\r\n\t\t\tvar oldFogType = 0;\r\n\t\t\tvar sceneFogType = 0;\r\n\t\t\tvar fog = scene.fog;\r\n\t\r\n\t\t\tif ( fog ) {\r\n\t\r\n\t\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\r\n\t\r\n\t\t\t\tif ( fog instanceof THREE.Fog ) {\r\n\t\r\n\t\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\r\n\t\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\r\n\t\t\t\t\toldFogType = 1;\r\n\t\t\t\t\tsceneFogType = 1;\r\n\t\r\n\t\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\r\n\t\r\n\t\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\r\n\t\t\t\t\toldFogType = 2;\r\n\t\t\t\t\tsceneFogType = 2;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tgl.uniform1i( uniforms.fogType, 0 );\r\n\t\t\t\toldFogType = 0;\r\n\t\t\t\tsceneFogType = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\t// update positions and sort\r\n\t\r\n\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar sprite = sprites[ i ];\r\n\t\r\n\t\t\t\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\r\n\t\t\t\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tsprites.sort( painterSortStable );\r\n\t\r\n\t\t\t// render all sprites\r\n\t\r\n\t\t\tvar scale = [];\r\n\t\r\n\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar sprite = sprites[ i ];\r\n\t\t\t\tvar material = sprite.material;\r\n\t\r\n\t\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\r\n\t\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\r\n\t\r\n\t\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\r\n\t\r\n\t\t\t\tscale[ 0 ] = spriteScale.x;\r\n\t\t\t\tscale[ 1 ] = spriteScale.y;\r\n\t\r\n\t\t\t\tvar fogType = 0;\r\n\t\r\n\t\t\t\tif ( scene.fog && material.fog ) {\r\n\t\r\n\t\t\t\t\tfogType = sceneFogType;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( oldFogType !== fogType ) {\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\r\n\t\t\t\t\toldFogType = fogType;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( material.map !== null ) {\r\n\t\r\n\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\r\n\t\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\r\n\t\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\r\n\t\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\r\n\t\r\n\t\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\r\n\t\t\t\tgl.uniform2fv( uniforms.scale, scale );\r\n\t\r\n\t\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n\t\t\t\tstate.setDepthTest( material.depthTest );\r\n\t\t\t\tstate.setDepthWrite( material.depthWrite );\r\n\t\r\n\t\t\t\tif ( material.map && material.map.image && material.map.image.width ) {\r\n\t\r\n\t\t\t\t\trenderer.setTexture( material.map, 0 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\trenderer.setTexture( texture, 0 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// restore gl\r\n\t\r\n\t\t\tstate.enable( gl.CULL_FACE );\r\n\t\r\n\t\t\trenderer.resetGLState();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction createProgram () {\r\n\t\r\n\t\t\tvar program = gl.createProgram();\r\n\t\r\n\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\r\n\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\r\n\t\r\n\t\t\tgl.shaderSource( vertexShader, [\r\n\t\r\n\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\r\n\t\r\n\t\t\t\t'uniform mat4 modelViewMatrix;',\r\n\t\t\t\t'uniform mat4 projectionMatrix;',\r\n\t\t\t\t'uniform float rotation;',\r\n\t\t\t\t'uniform vec2 scale;',\r\n\t\t\t\t'uniform vec2 uvOffset;',\r\n\t\t\t\t'uniform vec2 uvScale;',\r\n\t\r\n\t\t\t\t'attribute vec2 position;',\r\n\t\t\t\t'attribute vec2 uv;',\r\n\t\r\n\t\t\t\t'varying vec2 vUV;',\r\n\t\r\n\t\t\t\t'void main() {',\r\n\t\r\n\t\t\t\t\t'vUV = uvOffset + uv * uvScale;',\r\n\t\r\n\t\t\t\t\t'vec2 alignedPosition = position * scale;',\r\n\t\r\n\t\t\t\t\t'vec2 rotatedPosition;',\r\n\t\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\r\n\t\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\r\n\t\r\n\t\t\t\t\t'vec4 finalPosition;',\r\n\t\r\n\t\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\r\n\t\t\t\t\t'finalPosition.xy += rotatedPosition;',\r\n\t\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\r\n\t\r\n\t\t\t\t\t'gl_Position = finalPosition;',\r\n\t\r\n\t\t\t\t'}'\r\n\t\r\n\t\t\t].join( '\\n' ) );\r\n\t\r\n\t\t\tgl.shaderSource( fragmentShader, [\r\n\t\r\n\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\r\n\t\r\n\t\t\t\t'uniform vec3 color;',\r\n\t\t\t\t'uniform sampler2D map;',\r\n\t\t\t\t'uniform float opacity;',\r\n\t\r\n\t\t\t\t'uniform int fogType;',\r\n\t\t\t\t'uniform vec3 fogColor;',\r\n\t\t\t\t'uniform float fogDensity;',\r\n\t\t\t\t'uniform float fogNear;',\r\n\t\t\t\t'uniform float fogFar;',\r\n\t\t\t\t'uniform float alphaTest;',\r\n\t\r\n\t\t\t\t'varying vec2 vUV;',\r\n\t\r\n\t\t\t\t'void main() {',\r\n\t\r\n\t\t\t\t\t'vec4 texture = texture2D( map, vUV );',\r\n\t\r\n\t\t\t\t\t'if ( texture.a < alphaTest ) discard;',\r\n\t\r\n\t\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\r\n\t\r\n\t\t\t\t\t'if ( fogType > 0 ) {',\r\n\t\r\n\t\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\r\n\t\t\t\t\t\t'float fogFactor = 0.0;',\r\n\t\r\n\t\t\t\t\t\t'if ( fogType == 1 ) {',\r\n\t\r\n\t\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\r\n\t\r\n\t\t\t\t\t\t'} else {',\r\n\t\r\n\t\t\t\t\t\t\t'const float LOG2 = 1.442695;',\r\n\t\t\t\t\t\t\t'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\r\n\t\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\r\n\t\r\n\t\t\t\t\t\t'}',\r\n\t\r\n\t\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\r\n\t\r\n\t\t\t\t\t'}',\r\n\t\r\n\t\t\t\t'}'\r\n\t\r\n\t\t\t].join( '\\n' ) );\r\n\t\r\n\t\t\tgl.compileShader( vertexShader );\r\n\t\t\tgl.compileShader( fragmentShader );\r\n\t\r\n\t\t\tgl.attachShader( program, vertexShader );\r\n\t\t\tgl.attachShader( program, fragmentShader );\r\n\t\r\n\t\t\tgl.linkProgram( program );\r\n\t\r\n\t\t\treturn program;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction painterSortStable ( a, b ) {\r\n\t\t\t\r\n\t\t\tif ( a.renderOrder !== b.renderOrder ) {\r\n\t\r\n\t\t\t\treturn a.renderOrder - b.renderOrder;\r\n\t\r\n\t\t\t} else if ( a.z !== b.z ) {\r\n\t\r\n\t\t\t\treturn b.z - a.z;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\treturn b.id - a.id;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/Three.Legacy.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tObject.defineProperties( THREE.Box2.prototype, {\r\n\t\tempty: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\r\n\t\t\t\treturn this.isEmpty();\r\n\t\t\t}\r\n\t\t},\r\n\t\tisIntersectionBox: {\r\n\t\t\tvalue: function ( box ) {\r\n\t\t\t\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\r\n\t\t\t\treturn this.intersectsBox( box );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE.Box3.prototype, {\r\n\t\tempty: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\r\n\t\t\t\treturn this.isEmpty();\r\n\t\t\t}\r\n\t\t},\r\n\t\tisIntersectionBox: {\r\n\t\t\tvalue: function ( box ) {\r\n\t\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\r\n\t\t\t\treturn this.intersectsBox( box );\r\n\t\t\t}\r\n\t\t},\r\n\t\tisIntersectionSphere: {\r\n\t\t\tvalue: function ( sphere ) {\r\n\t\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\r\n\t\t\t\treturn this.intersectsSphere( sphere );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE.Matrix3.prototype, {\r\n\t\tmultiplyVector3: {\r\n\t\t\tvalue: function ( vector ) {\r\n\t\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\r\n\t\t\t\treturn vector.applyMatrix3( this );\r\n\t\t\t}\r\n\t\t},\r\n\t\tmultiplyVector3Array: {\r\n\t\t\tvalue: function ( a ) {\r\n\t\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\r\n\t\t\t\treturn this.applyToVector3Array( a );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE.Matrix4.prototype, {\r\n\t\textractPosition: {\r\n\t\t\tvalue: function ( m ) {\r\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\r\n\t\t\t\treturn this.copyPosition( m );\r\n\t\t\t}\r\n\t\t},\r\n\t\tsetRotationFromQuaternion: {\r\n\t\t\tvalue: function ( q ) {\r\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\r\n\t\t\t\treturn this.makeRotationFromQuaternion( q );\r\n\t\t\t}\r\n\t\t},\r\n\t\tmultiplyVector3: {\r\n\t\t\tvalue: function ( vector ) {\r\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\r\n\t\t\t\treturn vector.applyProjection( this );\r\n\t\t\t}\r\n\t\t},\r\n\t\tmultiplyVector4: {\r\n\t\t\tvalue: function ( vector ) {\r\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n\t\t\t\treturn vector.applyMatrix4( this );\r\n\t\t\t}\r\n\t\t},\r\n\t\tmultiplyVector3Array: {\r\n\t\t\tvalue: function ( a ) {\r\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\r\n\t\t\t\treturn this.applyToVector3Array( a );\r\n\t\t\t}\r\n\t\t},\r\n\t\trotateAxis: {\r\n\t\t\tvalue: function ( v ) {\r\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\r\n\t\t\t\tv.transformDirection( this );\r\n\t\t\t}\r\n\t\t},\r\n\t\tcrossVector: {\r\n\t\t\tvalue: function ( vector ) {\r\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n\t\t\t\treturn vector.applyMatrix4( this );\r\n\t\t\t}\r\n\t\t},\r\n\t\ttranslate: {\r\n\t\t\tvalue: function ( v ) {\r\n\t\t\t\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\trotateX: {\r\n\t\t\tvalue: function ( angle ) {\r\n\t\t\t\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\trotateY: {\r\n\t\t\tvalue: function ( angle ) {\r\n\t\t\t\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\trotateZ: {\r\n\t\t\tvalue: function ( angle ) {\r\n\t\t\t\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\trotateByAxis: {\r\n\t\t\tvalue: function ( axis, angle ) {\r\n\t\t\t\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE.Plane.prototype, {\r\n\t\tisIntersectionLine: {\r\n\t\t\tvalue: function ( line ) {\r\n\t\t\t\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\r\n\t\t\t\treturn this.intersectsLine( line );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE.Quaternion.prototype, {\r\n\t\tmultiplyVector3: {\r\n\t\t\tvalue: function ( vector ) {\r\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\r\n\t\t\t\treturn vector.applyQuaternion( this );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE.Ray.prototype, {\r\n\t\tisIntersectionBox: {\r\n\t\t\tvalue: function ( box ) {\r\n\t\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\r\n\t\t\t\treturn this.intersectsBox( box );\r\n\t\t\t}\r\n\t\t},\r\n\t\tisIntersectionPlane: {\r\n\t\t\tvalue: function ( plane ) {\r\n\t\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\r\n\t\t\t\treturn this.intersectsPlane( plane );\r\n\t\t\t}\r\n\t\t},\r\n\t\tisIntersectionSphere: {\r\n\t\t\tvalue: function ( sphere ) {\r\n\t\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\r\n\t\t\t\treturn this.intersectsSphere( sphere );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE.Vector3.prototype, {\r\n\t\tsetEulerFromRotationMatrix: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tsetEulerFromQuaternion: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tgetPositionFromMatrix: {\r\n\t\t\tvalue: function ( m ) {\r\n\t\t\t\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\r\n\t\t\t\treturn this.setFromMatrixPosition( m );\r\n\t\t\t}\r\n\t\t},\r\n\t\tgetScaleFromMatrix: {\r\n\t\t\tvalue: function ( m ) {\r\n\t\t\t\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\r\n\t\t\t\treturn this.setFromMatrixScale( m );\r\n\t\t\t}\r\n\t\t},\r\n\t\tgetColumnFromMatrix: {\r\n\t\t\tvalue: function ( index, matrix ) {\r\n\t\t\t\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\r\n\t\t\t\treturn this.setFromMatrixColumn( index, matrix );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\t//\r\n\t\r\n\tTHREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {\r\n\t\r\n\t\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\r\n\t\treturn new THREE.Face3( a, b, c, normal, color, materialIndex );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Vertex = function ( x, y, z ) {\r\n\t\r\n\t\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\r\n\t\treturn new THREE.Vector3( x, y, z );\r\n\t\r\n\t};\r\n\t\r\n\t//\r\n\t\r\n\tObject.defineProperties( THREE.Object3D.prototype, {\r\n\t\teulerOrder: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\r\n\t\t\t\treturn this.rotation.order;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\r\n\t\t\t\tthis.rotation.order = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tgetChildByName: {\r\n\t\t\tvalue: function ( name ) {\r\n\t\t\t\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\r\n\t\t\t\treturn this.getObjectByName( name );\r\n\t\t\t}\r\n\t\t},\r\n\t\trenderDepth: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\ttranslate: {\r\n\t\t\tvalue: function ( distance, axis ) {\r\n\t\t\t\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\r\n\t\t\t\treturn this.translateOnAxis( axis, distance );\r\n\t\t\t}\r\n\t\t},\r\n\t\tuseQuaternion: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\t//\r\n\t\r\n\tObject.defineProperties( THREE, {\r\n\t\tPointCloud: {\r\n\t\t\tvalue: function ( geometry, material ) {\r\n\t\t\t\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\r\n\t\t\t\treturn new THREE.Points( geometry, material );\r\n\t\t\t}\r\n\t\t},\r\n\t\tParticleSystem: {\r\n\t\t\tvalue: function ( geometry, material ) {\r\n\t\t\t\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\r\n\t\t\t\treturn new THREE.Points( geometry, material );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\t//\r\n\t\r\n\tObject.defineProperties( THREE.Light.prototype, {\r\n\t\tonlyShadow: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowCameraFov: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\r\n\t\t\t\tthis.shadow.camera.fov = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowCameraLeft: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\r\n\t\t\t\tthis.shadow.camera.left = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowCameraRight: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\r\n\t\t\t\tthis.shadow.camera.right = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowCameraTop: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\r\n\t\t\t\tthis.shadow.camera.top = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowCameraBottom: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\r\n\t\t\t\tthis.shadow.camera.bottom = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowCameraNear: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\r\n\t\t\t\tthis.shadow.camera.near = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowCameraFar: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\r\n\t\t\t\tthis.shadow.camera.far = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowCameraVisible: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowBias: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\r\n\t\t\t\tthis.shadow.bias = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowDarkness: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowMapWidth: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\r\n\t\t\t\tthis.shadow.mapSize.width = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowMapHeight: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\r\n\t\t\t\tthis.shadow.mapSize.height = value;\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\t//\r\n\t\r\n\tObject.defineProperties( THREE.BufferAttribute.prototype, {\r\n\t\tlength: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\r\n\t\t\t\treturn this.array.length;\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE.BufferGeometry.prototype, {\r\n\t\tdrawcalls: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\r\n\t\t\t\treturn this.groups;\r\n\t\t\t}\r\n\t\t},\r\n\t\toffsets: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\r\n\t\t\t\treturn this.groups;\r\n\t\t\t}\r\n\t\t},\r\n\t\taddIndex: {\r\n\t\t\tvalue: function ( index ) {\r\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\r\n\t\t\t\tthis.setIndex( index );\r\n\t\t\t}\r\n\t\t},\r\n\t\taddDrawCall: {\r\n\t\t\tvalue: function ( start, count, indexOffset ) {\r\n\t\t\t\tif ( indexOffset !== undefined ) {\r\n\t\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\r\n\t\t\t\t}\r\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\r\n\t\t\t\tthis.addGroup( start, count );\r\n\t\t\t}\r\n\t\t},\r\n\t\tclearDrawCalls: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\r\n\t\t\t\tthis.clearGroups();\r\n\t\t\t}\r\n\t\t},\r\n\t\tcomputeTangents: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tcomputeOffsets: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\t//\r\n\t\r\n\tObject.defineProperties( THREE.Material.prototype, {\r\n\t\twrapAround: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\twrapRGB: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );\r\n\t\t\t\treturn new THREE.Color();\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE, {\r\n\t\tPointCloudMaterial: {\r\n\t\t\tvalue: function ( parameters ) {\r\n\t\t\t\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\r\n\t\t\t\treturn new THREE.PointsMaterial( parameters );\r\n\t\t\t}\r\n\t\t},\r\n\t\tParticleBasicMaterial: {\r\n\t\t\tvalue: function ( parameters ) {\r\n\t\t\t\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\r\n\t\t\t\treturn new THREE.PointsMaterial( parameters );\r\n\t\t\t}\r\n\t\t},\r\n\t\tParticleSystemMaterial:{\r\n\t\t\tvalue: function ( parameters ) {\r\n\t\t\t\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\r\n\t\t\t\treturn new THREE.PointsMaterial( parameters );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE.MeshPhongMaterial.prototype, {\r\n\t\tmetal: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\r\n\t\t\t\treturn false;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE.ShaderMaterial.prototype, {\r\n\t\tderivatives: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\r\n\t\t\t\treturn this.extensions.derivatives;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\r\n\t\t\t\tthis.extensions.derivatives = value;\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\t//\r\n\t\r\n\tObject.defineProperties( THREE.WebGLRenderer.prototype, {\r\n\t\tsupportsFloatTextures: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\r\n\t\t\t\treturn this.extensions.get( 'OES_texture_float' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tsupportsHalfFloatTextures: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\r\n\t\t\t\treturn this.extensions.get( 'OES_texture_half_float' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tsupportsStandardDerivatives: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\r\n\t\t\t\treturn this.extensions.get( 'OES_standard_derivatives' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tsupportsCompressedTextureS3TC: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\r\n\t\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tsupportsCompressedTexturePVRTC: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\r\n\t\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tsupportsBlendMinMax: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\r\n\t\t\t\treturn this.extensions.get( 'EXT_blend_minmax' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tsupportsVertexTextures: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\treturn this.capabilities.vertexTextures;\r\n\t\t\t}\r\n\t\t},\r\n\t\tsupportsInstancedArrays: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\r\n\t\t\t\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tenableScissorTest: {\r\n\t\t\tvalue: function ( boolean ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\r\n\t\t\t\tthis.setScissorTest( boolean );\r\n\t\t\t}\r\n\t\t},\r\n\t\tinitMaterial: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\taddPrePlugin: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\taddPostPlugin: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tupdateShadowMap: {\r\n\t\t\tvalue: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowMapEnabled: {\r\n\t\t\tget: function () {\r\n\t\t\t\treturn this.shadowMap.enabled;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\r\n\t\t\t\tthis.shadowMap.enabled = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowMapType: {\r\n\t\t\tget: function () {\r\n\t\t\t\treturn this.shadowMap.type;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\r\n\t\t\t\tthis.shadowMap.type = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowMapCullFace: {\r\n\t\t\tget: function () {\r\n\t\t\t\treturn this.shadowMap.cullFace;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\r\n\t\t\t\tthis.shadowMap.cullFace = value;\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\t//\r\n\t\r\n\tObject.defineProperties( THREE.WebGLRenderTarget.prototype, {\r\n\t\twrapS: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\r\n\t\t\t\treturn this.texture.wrapS;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\r\n\t\t\t\tthis.texture.wrapS = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\twrapT: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\r\n\t\t\t\treturn this.texture.wrapT;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\r\n\t\t\t\tthis.texture.wrapT = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tmagFilter: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\r\n\t\t\t\treturn this.texture.magFilter;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\r\n\t\t\t\tthis.texture.magFilter = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tminFilter: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\r\n\t\t\t\treturn this.texture.minFilter;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\r\n\t\t\t\tthis.texture.minFilter = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tanisotropy: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\r\n\t\t\t\treturn this.texture.anisotropy;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\r\n\t\t\t\tthis.texture.anisotropy = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\toffset: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\r\n\t\t\t\treturn this.texture.offset;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\r\n\t\t\t\tthis.texture.offset = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\trepeat: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\r\n\t\t\t\treturn this.texture.repeat;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\r\n\t\t\t\tthis.texture.repeat = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tformat: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\r\n\t\t\t\treturn this.texture.format;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\r\n\t\t\t\tthis.texture.format = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\ttype: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\r\n\t\t\t\treturn this.texture.type;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\r\n\t\t\t\tthis.texture.type = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tgenerateMipmaps: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\r\n\t\t\t\treturn this.texture.generateMipmaps;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\r\n\t\t\t\tthis.texture.generateMipmaps = value;\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\t//\r\n\t\r\n\tTHREE.GeometryUtils = {\r\n\t\r\n\t\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\r\n\t\r\n\t\t\tvar matrix;\r\n\t\r\n\t\t\tif ( geometry2 instanceof THREE.Mesh ) {\r\n\t\r\n\t\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\r\n\t\r\n\t\t\t\tmatrix = geometry2.matrix;\r\n\t\t\t\tgeometry2 = geometry2.geometry;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcenter: function ( geometry ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\r\n\t\t\treturn geometry.center();\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ImageUtils = {\r\n\t\r\n\t\tcrossOrigin: undefined,\r\n\t\r\n\t\tloadTexture: function ( url, mapping, onLoad, onError ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\r\n\t\r\n\t\t\tvar loader = new THREE.TextureLoader();\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\r\n\t\t\tvar texture = loader.load( url, onLoad, undefined, onError );\r\n\t\r\n\t\t\tif ( mapping ) texture.mapping = mapping;\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\r\n\t\r\n\t\t\tvar loader = new THREE.CubeTextureLoader();\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\r\n\t\t\tvar texture = loader.load( urls, onLoad, undefined, onError );\r\n\t\r\n\t\t\tif ( mapping ) texture.mapping = mapping;\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tloadCompressedTexture: function () {\r\n\t\r\n\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tloadCompressedTextureCube: function () {\r\n\t\r\n\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t//\r\n\t\r\n\tTHREE.Projector = function () {\r\n\t\r\n\t\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\r\n\t\r\n\t\tthis.projectVector = function ( vector, camera ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\r\n\t\t\tvector.project( camera );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.unprojectVector = function ( vector, camera ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\r\n\t\t\tvector.unproject( camera );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.pickingRay = function ( vector, camera ) {\r\n\t\r\n\t\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t//\r\n\t\r\n\tTHREE.CanvasRenderer = function () {\r\n\t\r\n\t\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\r\n\t\r\n\t\tthis.domElement = document.createElement( 'canvas' );\r\n\t\tthis.clear = function () {};\r\n\t\tthis.render = function () {};\r\n\t\tthis.setClearColor = function () {};\r\n\t\tthis.setSize = function () {};\r\n\t\r\n\t};\r\n\t\r\n\t//\r\n\t\r\n\tTHREE.MeshFaceMaterial = THREE.MultiMaterial;\r\n\t\r\n\t// File:src/extras/CurveUtils.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t */\r\n\t\r\n\tTHREE.CurveUtils = {\r\n\t\r\n\t\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\r\n\t\r\n\t\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Puay Bing, thanks for helping with this derivative!\r\n\t\r\n\t\ttangentCubicBezier: function ( t, p0, p1, p2, p3 ) {\r\n\t\r\n\t\t\treturn - 3 * p0 * ( 1 - t ) * ( 1 - t )  +\r\n\t\t\t\t3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +\r\n\t\t\t\t6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +\r\n\t\t\t\t3 * t * t * p3;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\r\n\t\r\n\t\t\t// To check if my formulas are correct\r\n\t\r\n\t\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3  3t^2 + 1\r\n\t\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t\r\n\t\t\tvar h01 = - 6 * t * t + 6 * t; \t//  2t3 + 3t2\r\n\t\t\tvar h11 = 3 * t * t - 2 * t;\t// t3  t2\r\n\t\r\n\t\t\treturn h00 + h10 + h01 + h11;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Catmull-Rom\r\n\t\r\n\t\tinterpolate: function( p0, p1, p2, p3, t ) {\r\n\t\r\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5;\r\n\t\t\tvar v1 = ( p3 - p1 ) * 0.5;\r\n\t\t\tvar t2 = t * t;\r\n\t\t\tvar t3 = t * t2;\r\n\t\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/SceneUtils.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.SceneUtils = {\r\n\t\r\n\t\tcreateMultiMaterialObject: function ( geometry, materials ) {\r\n\t\r\n\t\t\tvar group = new THREE.Group();\r\n\t\r\n\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tgroup.add( new THREE.Mesh( geometry, materials[ i ] ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn group;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdetach: function ( child, parent, scene ) {\r\n\t\r\n\t\t\tchild.applyMatrix( parent.matrixWorld );\r\n\t\t\tparent.remove( child );\r\n\t\t\tscene.add( child );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tattach: function ( child, scene, parent ) {\r\n\t\r\n\t\t\tvar matrixWorldInverse = new THREE.Matrix4();\r\n\t\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\r\n\t\t\tchild.applyMatrix( matrixWorldInverse );\r\n\t\r\n\t\t\tscene.remove( child );\r\n\t\t\tparent.add( child );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/ShapeUtils.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t */\r\n\t\r\n\tTHREE.ShapeUtils = {\r\n\t\r\n\t\t// calculate area of the contour polygon\r\n\t\r\n\t\tarea: function ( contour ) {\r\n\t\r\n\t\t\tvar n = contour.length;\r\n\t\t\tvar a = 0.0;\r\n\t\r\n\t\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\r\n\t\r\n\t\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn a * 0.5;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttriangulate: ( function () {\r\n\t\r\n\t\t\t/**\r\n\t\t\t * This code is a quick port of code written in C++ which was submitted to\r\n\t\t\t * flipcode.com by John W. Ratcliff  // July 22, 2000\r\n\t\t\t * See original code and more information here:\r\n\t\t\t * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\r\n\t\t\t *\r\n\t\t\t * ported to actionscript by Zevan Rosser\r\n\t\t\t * www.actionsnippet.com\r\n\t\t\t *\r\n\t\t\t * ported to javascript by Joshua Koo\r\n\t\t\t * http://www.lab4games.net/zz85/blog\r\n\t\t\t *\r\n\t\t\t */\r\n\t\r\n\t\t\tfunction snip( contour, u, v, w, n, verts ) {\r\n\t\r\n\t\t\t\tvar p;\r\n\t\t\t\tvar ax, ay, bx, by;\r\n\t\t\t\tvar cx, cy, px, py;\r\n\t\r\n\t\t\t\tax = contour[ verts[ u ] ].x;\r\n\t\t\t\tay = contour[ verts[ u ] ].y;\r\n\t\r\n\t\t\t\tbx = contour[ verts[ v ] ].x;\r\n\t\t\t\tby = contour[ verts[ v ] ].y;\r\n\t\r\n\t\t\t\tcx = contour[ verts[ w ] ].x;\r\n\t\t\t\tcy = contour[ verts[ w ] ].y;\r\n\t\r\n\t\t\t\tif ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;\r\n\t\r\n\t\t\t\tvar aX, aY, bX, bY, cX, cY;\r\n\t\t\t\tvar apx, apy, bpx, bpy, cpx, cpy;\r\n\t\t\t\tvar cCROSSap, bCROSScp, aCROSSbp;\r\n\t\r\n\t\t\t\taX = cx - bx;  aY = cy - by;\r\n\t\t\t\tbX = ax - cx;  bY = ay - cy;\r\n\t\t\t\tcX = bx - ax;  cY = by - ay;\r\n\t\r\n\t\t\t\tfor ( p = 0; p < n; p ++ ) {\r\n\t\r\n\t\t\t\t\tpx = contour[ verts[ p ] ].x;\r\n\t\t\t\t\tpy = contour[ verts[ p ] ].y;\r\n\t\r\n\t\t\t\t\tif ( ( ( px === ax ) && ( py === ay ) ) ||\r\n\t\t\t\t\t\t ( ( px === bx ) && ( py === by ) ) ||\r\n\t\t\t\t\t\t ( ( px === cx ) && ( py === cy ) ) )\tcontinue;\r\n\t\r\n\t\t\t\t\tapx = px - ax;  apy = py - ay;\r\n\t\t\t\t\tbpx = px - bx;  bpy = py - by;\r\n\t\t\t\t\tcpx = px - cx;  cpy = py - cy;\r\n\t\r\n\t\t\t\t\t// see if p is inside triangle abc\r\n\t\r\n\t\t\t\t\taCROSSbp = aX * bpy - aY * bpx;\r\n\t\t\t\t\tcCROSSap = cX * apy - cY * apx;\r\n\t\t\t\t\tbCROSScp = bX * cpy - bY * cpx;\r\n\t\r\n\t\t\t\t\tif ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// takes in an contour array and returns\r\n\t\r\n\t\t\treturn function ( contour, indices ) {\r\n\t\r\n\t\t\t\tvar n = contour.length;\r\n\t\r\n\t\t\t\tif ( n < 3 ) return null;\r\n\t\r\n\t\t\t\tvar result = [],\r\n\t\t\t\t\tverts = [],\r\n\t\t\t\t\tvertIndices = [];\r\n\t\r\n\t\t\t\t/* we want a counter-clockwise polygon in verts */\r\n\t\r\n\t\t\t\tvar u, v, w;\r\n\t\r\n\t\t\t\tif ( THREE.ShapeUtils.area( contour ) > 0.0 ) {\r\n\t\r\n\t\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = v;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar nv = n;\r\n\t\r\n\t\t\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\r\n\t\r\n\t\t\t\tvar count = 2 * nv;   /* error detection */\r\n\t\r\n\t\t\t\tfor ( v = nv - 1; nv > 2; ) {\r\n\t\r\n\t\t\t\t\t/* if we loop, it is probably a non-simple polygon */\r\n\t\r\n\t\t\t\t\tif ( ( count -- ) <= 0 ) {\r\n\t\r\n\t\t\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\r\n\t\r\n\t\t\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\r\n\t\t\t\t\t\t//return null;\r\n\t\t\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\r\n\t\t\t\t\t\tconsole.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );\r\n\t\r\n\t\t\t\t\t\tif ( indices ) return vertIndices;\r\n\t\t\t\t\t\treturn result;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\r\n\t\r\n\t\t\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\r\n\t\t\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\r\n\t\t\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\r\n\t\r\n\t\t\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\r\n\t\r\n\t\t\t\t\t\tvar a, b, c, s, t;\r\n\t\r\n\t\t\t\t\t\t/* true names of the vertices */\r\n\t\r\n\t\t\t\t\t\ta = verts[ u ];\r\n\t\t\t\t\t\tb = verts[ v ];\r\n\t\t\t\t\t\tc = verts[ w ];\r\n\t\r\n\t\t\t\t\t\t/* output Triangle */\r\n\t\r\n\t\t\t\t\t\tresult.push( [ contour[ a ],\r\n\t\t\t\t\t\t\tcontour[ b ],\r\n\t\t\t\t\t\t\tcontour[ c ] ] );\r\n\t\r\n\t\r\n\t\t\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\r\n\t\r\n\t\t\t\t\t\t/* remove v from the remaining polygon */\r\n\t\r\n\t\t\t\t\t\tfor ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tverts[ s ] = verts[ t ];\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tnv --;\r\n\t\r\n\t\t\t\t\t\t/* reset error detection counter */\r\n\t\r\n\t\t\t\t\t\tcount = 2 * nv;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( indices ) return vertIndices;\r\n\t\t\t\treturn result;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t} )(),\r\n\t\r\n\t\ttriangulateShape: function ( contour, holes ) {\r\n\t\r\n\t\t\tfunction point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\r\n\t\r\n\t\t\t\t// inOtherPt needs to be collinear to the inSegment\r\n\t\t\t\tif ( inSegPt1.x !== inSegPt2.x ) {\r\n\t\r\n\t\t\t\t\tif ( inSegPt1.x < inSegPt2.x ) {\r\n\t\r\n\t\t\t\t\t\treturn\t( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\treturn\t( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tif ( inSegPt1.y < inSegPt2.y ) {\r\n\t\r\n\t\t\t\t\t\treturn\t( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\treturn\t( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\r\n\t\r\n\t\t\t\tvar seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\r\n\t\t\t\tvar seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\r\n\t\r\n\t\t\t\tvar seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\r\n\t\t\t\tvar seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\r\n\t\r\n\t\t\t\tvar limit\t\t= seg1dy * seg2dx - seg1dx * seg2dy;\r\n\t\t\t\tvar perpSeg1\t= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\r\n\t\r\n\t\t\t\tif ( Math.abs( limit ) > Number.EPSILON ) {\r\n\t\r\n\t\t\t\t\t// not parallel\r\n\t\r\n\t\t\t\t\tvar perpSeg2;\r\n\t\t\t\t\tif ( limit > 0 ) {\r\n\t\r\n\t\t\t\t\t\tif ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) \t\treturn [];\r\n\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n\t\t\t\t\t\tif ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) \t\treturn [];\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tif ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) \t\treturn [];\r\n\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n\t\t\t\t\t\tif ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) \t\treturn [];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// i.e. to reduce rounding errors\r\n\t\t\t\t\t// intersection at endpoint of segment#1?\r\n\t\t\t\t\tif ( perpSeg2 === 0 ) {\r\n\t\r\n\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\r\n\t\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\r\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( perpSeg2 === limit ) {\r\n\t\r\n\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\r\n\t\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\r\n\t\t\t\t\t\treturn [ inSeg1Pt2 ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// intersection at endpoint of segment#2?\r\n\t\t\t\t\tif ( perpSeg1 === 0 )\t\treturn [ inSeg2Pt1 ];\r\n\t\t\t\t\tif ( perpSeg1 === limit )\treturn [ inSeg2Pt2 ];\r\n\t\r\n\t\t\t\t\t// return real intersection point\r\n\t\t\t\t\tvar factorSeg1 = perpSeg2 / limit;\r\n\t\t\t\t\treturn\t[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\r\n\t\t\t\t\t\t\t\ty: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// parallel or collinear\r\n\t\t\t\t\tif ( ( perpSeg1 !== 0 ) ||\r\n\t\t\t\t\t\t ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) \t\t\treturn [];\r\n\t\r\n\t\t\t\t\t// they are collinear or degenerate\r\n\t\t\t\t\tvar seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );\t// segment1 is just a point?\r\n\t\t\t\t\tvar seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );\t// segment2 is just a point?\r\n\t\t\t\t\t// both segments are points\r\n\t\t\t\t\tif ( seg1Pt && seg2Pt ) {\r\n\t\r\n\t\t\t\t\t\tif ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||\r\n\t\t\t\t\t\t\t ( inSeg1Pt1.y !== inSeg2Pt1.y ) )\t\treturn [];\t// they are distinct  points\r\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];                 \t\t\t\t\t\t// they are the same point\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// segment#1  is a single point\r\n\t\t\t\t\tif ( seg1Pt ) {\r\n\t\r\n\t\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )\t\treturn [];\t\t// but not in segment#2\r\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// segment#2  is a single point\r\n\t\t\t\t\tif ( seg2Pt ) {\r\n\t\r\n\t\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )\t\treturn [];\t\t// but not in segment#1\r\n\t\t\t\t\t\treturn [ inSeg2Pt1 ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// they are collinear segments, which might overlap\r\n\t\t\t\t\tvar seg1min, seg1max, seg1minVal, seg1maxVal;\r\n\t\t\t\t\tvar seg2min, seg2max, seg2minVal, seg2maxVal;\r\n\t\t\t\t\tif ( seg1dx !== 0 ) {\r\n\t\r\n\t\t\t\t\t\t// the segments are NOT on a vertical line\r\n\t\t\t\t\t\tif ( inSeg1Pt1.x < inSeg1Pt2.x ) {\r\n\t\r\n\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\r\n\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\r\n\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( inSeg2Pt1.x < inSeg2Pt2.x ) {\r\n\t\r\n\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\r\n\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\r\n\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t// the segments are on a vertical line\r\n\t\t\t\t\t\tif ( inSeg1Pt1.y < inSeg1Pt2.y ) {\r\n\t\r\n\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\r\n\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\r\n\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( inSeg2Pt1.y < inSeg2Pt2.y ) {\r\n\t\r\n\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\r\n\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\r\n\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( seg1minVal <= seg2minVal ) {\r\n\t\r\n\t\t\t\t\t\tif ( seg1maxVal <  seg2minVal )\treturn [];\r\n\t\t\t\t\t\tif ( seg1maxVal === seg2minVal )\t{\r\n\t\r\n\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\r\n\t\t\t\t\t\t\treturn [ seg2min ];\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg2min, seg1max ];\r\n\t\t\t\t\t\treturn\t[ seg2min, seg2max ];\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tif ( seg1minVal >  seg2maxVal )\treturn [];\r\n\t\t\t\t\t\tif ( seg1minVal === seg2maxVal )\t{\r\n\t\r\n\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\r\n\t\t\t\t\t\t\treturn [ seg1min ];\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg1min, seg1max ];\r\n\t\t\t\t\t\treturn\t[ seg1min, seg2max ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\r\n\t\r\n\t\t\t\t// The order of legs is important\r\n\t\r\n\t\t\t\t// translation of all points, so that Vertex is at (0,0)\r\n\t\t\t\tvar legFromPtX\t= inLegFromPt.x - inVertex.x,  legFromPtY\t= inLegFromPt.y - inVertex.y;\r\n\t\t\t\tvar legToPtX\t= inLegToPt.x\t- inVertex.x,  legToPtY\t\t= inLegToPt.y\t- inVertex.y;\r\n\t\t\t\tvar otherPtX\t= inOtherPt.x\t- inVertex.x,  otherPtY\t\t= inOtherPt.y\t- inVertex.y;\r\n\t\r\n\t\t\t\t// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\r\n\t\t\t\tvar from2toAngle\t= legFromPtX * legToPtY - legFromPtY * legToPtX;\r\n\t\t\t\tvar from2otherAngle\t= legFromPtX * otherPtY - legFromPtY * otherPtX;\r\n\t\r\n\t\t\t\tif ( Math.abs( from2toAngle ) > Number.EPSILON ) {\r\n\t\r\n\t\t\t\t\t// angle != 180 deg.\r\n\t\r\n\t\t\t\t\tvar other2toAngle\t\t= otherPtX * legToPtY - otherPtY * legToPtX;\r\n\t\t\t\t\t// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\r\n\t\r\n\t\t\t\t\tif ( from2toAngle > 0 ) {\r\n\t\r\n\t\t\t\t\t\t// main angle < 180 deg.\r\n\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t// main angle > 180 deg.\r\n\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// angle == 180 deg.\r\n\t\t\t\t\t// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\r\n\t\t\t\t\treturn\t( from2otherAngle > 0 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\tfunction removeHoles( contour, holes ) {\r\n\t\r\n\t\t\t\tvar shape = contour.concat(); // work on this shape\r\n\t\t\t\tvar hole;\r\n\t\r\n\t\t\t\tfunction isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\r\n\t\r\n\t\t\t\t\t// Check if hole point lies within angle around shape point\r\n\t\t\t\t\tvar lastShapeIdx = shape.length - 1;\r\n\t\r\n\t\t\t\t\tvar prevShapeIdx = inShapeIdx - 1;\r\n\t\t\t\t\tif ( prevShapeIdx < 0 )\t\t\tprevShapeIdx = lastShapeIdx;\r\n\t\r\n\t\t\t\t\tvar nextShapeIdx = inShapeIdx + 1;\r\n\t\t\t\t\tif ( nextShapeIdx > lastShapeIdx )\tnextShapeIdx = 0;\r\n\t\r\n\t\t\t\t\tvar insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );\r\n\t\t\t\t\tif ( ! insideAngle ) {\r\n\t\r\n\t\t\t\t\t\t// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\r\n\t\t\t\t\t\treturn\tfalse;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// Check if shape point lies within angle around hole point\r\n\t\t\t\t\tvar lastHoleIdx = hole.length - 1;\r\n\t\r\n\t\t\t\t\tvar prevHoleIdx = inHoleIdx - 1;\r\n\t\t\t\t\tif ( prevHoleIdx < 0 )\t\t\tprevHoleIdx = lastHoleIdx;\r\n\t\r\n\t\t\t\t\tvar nextHoleIdx = inHoleIdx + 1;\r\n\t\t\t\t\tif ( nextHoleIdx > lastHoleIdx )\tnextHoleIdx = 0;\r\n\t\r\n\t\t\t\t\tinsideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );\r\n\t\t\t\t\tif ( ! insideAngle ) {\r\n\t\r\n\t\t\t\t\t\t// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\r\n\t\t\t\t\t\treturn\tfalse;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\treturn\ttrue;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfunction intersectsShapeEdge( inShapePt, inHolePt ) {\r\n\t\r\n\t\t\t\t\t// checks for intersections with shape edges\r\n\t\t\t\t\tvar sIdx, nextIdx, intersection;\r\n\t\t\t\t\tfor ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\r\n\t\r\n\t\t\t\t\t\tnextIdx = sIdx + 1; nextIdx %= shape.length;\r\n\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );\r\n\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\treturn\tfalse;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar indepHoles = [];\r\n\t\r\n\t\t\t\tfunction intersectsHoleEdge( inShapePt, inHolePt ) {\r\n\t\r\n\t\t\t\t\t// checks for intersections with hole edges\r\n\t\t\t\t\tvar ihIdx, chkHole,\r\n\t\t\t\t\t\thIdx, nextIdx, intersection;\r\n\t\t\t\t\tfor ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\r\n\t\r\n\t\t\t\t\t\tchkHole = holes[ indepHoles[ ihIdx ]];\r\n\t\t\t\t\t\tfor ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tnextIdx = hIdx + 1; nextIdx %= chkHole.length;\r\n\t\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );\r\n\t\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn\tfalse;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar holeIndex, shapeIndex,\r\n\t\t\t\t\tshapePt, holePt,\r\n\t\t\t\t\tholeIdx, cutKey, failedCuts = [],\r\n\t\t\t\t\ttmpShape1, tmpShape2,\r\n\t\t\t\t\ttmpHole1, tmpHole2;\r\n\t\r\n\t\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\t\tindepHoles.push( h );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar minShapeIndex = 0;\r\n\t\t\t\tvar counter = indepHoles.length * 2;\r\n\t\t\t\twhile ( indepHoles.length > 0 ) {\r\n\t\r\n\t\t\t\t\tcounter --;\r\n\t\t\t\t\tif ( counter < 0 ) {\r\n\t\r\n\t\t\t\t\t\tconsole.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// search for shape-vertex and hole-vertex,\r\n\t\t\t\t\t// which can be connected without intersections\r\n\t\t\t\t\tfor ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\r\n\t\r\n\t\t\t\t\t\tshapePt = shape[ shapeIndex ];\r\n\t\t\t\t\t\tholeIndex\t= - 1;\r\n\t\r\n\t\t\t\t\t\t// search for hole which can be reached without intersections\r\n\t\t\t\t\t\tfor ( var h = 0; h < indepHoles.length; h ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tholeIdx = indepHoles[ h ];\r\n\t\r\n\t\t\t\t\t\t\t// prevent multiple checks\r\n\t\t\t\t\t\t\tcutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\r\n\t\t\t\t\t\t\tif ( failedCuts[ cutKey ] !== undefined )\t\t\tcontinue;\r\n\t\r\n\t\t\t\t\t\t\thole = holes[ holeIdx ];\r\n\t\t\t\t\t\t\tfor ( var h2 = 0; h2 < hole.length; h2 ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tholePt = hole[ h2 ];\r\n\t\t\t\t\t\t\t\tif ( ! isCutLineInsideAngles( shapeIndex, h2 ) )\t\tcontinue;\r\n\t\t\t\t\t\t\t\tif ( intersectsShapeEdge( shapePt, holePt ) )\t\tcontinue;\r\n\t\t\t\t\t\t\t\tif ( intersectsHoleEdge( shapePt, holePt ) )\t\tcontinue;\r\n\t\r\n\t\t\t\t\t\t\t\tholeIndex = h2;\r\n\t\t\t\t\t\t\t\tindepHoles.splice( h, 1 );\r\n\t\r\n\t\t\t\t\t\t\t\ttmpShape1 = shape.slice( 0, shapeIndex + 1 );\r\n\t\t\t\t\t\t\t\ttmpShape2 = shape.slice( shapeIndex );\r\n\t\t\t\t\t\t\t\ttmpHole1 = hole.slice( holeIndex );\r\n\t\t\t\t\t\t\t\ttmpHole2 = hole.slice( 0, holeIndex + 1 );\r\n\t\r\n\t\t\t\t\t\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\r\n\t\r\n\t\t\t\t\t\t\t\tminShapeIndex = shapeIndex;\r\n\t\r\n\t\t\t\t\t\t\t\t// Debug only, to show the selected cuts\r\n\t\t\t\t\t\t\t\t// glob_CutLines.push( [ shapePt, holePt ] );\r\n\t\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\r\n\t\r\n\t\t\t\t\t\t\tfailedCuts[ cutKey ] = true;\t\t\t// remember failure\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn shape; \t\t\t/* shape with no holes */\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\tvar i, il, f, face,\r\n\t\t\t\tkey, index,\r\n\t\t\t\tallPointsMap = {};\r\n\t\r\n\t\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\r\n\t\r\n\t\t\tvar allpoints = contour.concat();\r\n\t\r\n\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tArray.prototype.push.apply( allpoints, holes[ h ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\r\n\t\r\n\t\t\t// prepare all points map\r\n\t\r\n\t\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\r\n\t\r\n\t\t\t\tif ( allPointsMap[ key ] !== undefined ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( \"THREE.Shape: Duplicate point\", key );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tallPointsMap[ key ] = i;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// remove holes by cutting paths to holes and adding them to the shape\r\n\t\t\tvar shapeWithoutHoles = removeHoles( contour, holes );\r\n\t\r\n\t\t\tvar triangles = THREE.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\r\n\t\t\t//console.log( \"triangles\",triangles, triangles.length );\r\n\t\r\n\t\t\t// check all face vertices against all points map\r\n\t\r\n\t\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tface = triangles[ i ];\r\n\t\r\n\t\t\t\tfor ( f = 0; f < 3; f ++ ) {\r\n\t\r\n\t\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\r\n\t\r\n\t\t\t\t\tindex = allPointsMap[ key ];\r\n\t\r\n\t\t\t\t\tif ( index !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tface[ f ] = index;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn triangles.concat();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tisClockWise: function ( pts ) {\r\n\t\r\n\t\t\treturn THREE.ShapeUtils.area( pts ) < 0;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Bezier Curves formulas obtained from\r\n\t\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\r\n\t\r\n\t\t// Quad Bezier Functions\r\n\t\r\n\t\tb2: ( function () {\r\n\t\r\n\t\t\tfunction b2p0( t, p ) {\r\n\t\r\n\t\t\t\tvar k = 1 - t;\r\n\t\t\t\treturn k * k * p;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction b2p1( t, p ) {\r\n\t\r\n\t\t\t\treturn 2 * ( 1 - t ) * t * p;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction b2p2( t, p ) {\r\n\t\r\n\t\t\t\treturn t * t * p;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn function ( t, p0, p1, p2 ) {\r\n\t\r\n\t\t\t\treturn b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )(),\r\n\t\r\n\t\t// Cubic Bezier Functions\r\n\t\r\n\t\tb3: ( function () {\r\n\t\r\n\t\t\tfunction b3p0( t, p ) {\r\n\t\r\n\t\t\t\tvar k = 1 - t;\r\n\t\t\t\treturn k * k * k * p;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction b3p1( t, p ) {\r\n\t\r\n\t\t\t\tvar k = 1 - t;\r\n\t\t\t\treturn 3 * k * k * t * p;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction b3p2( t, p ) {\r\n\t\r\n\t\t\t\tvar k = 1 - t;\r\n\t\t\t\treturn 3 * k * t * t * p;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction b3p3( t, p ) {\r\n\t\r\n\t\t\t\treturn t * t * t * p;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn function ( t, p0, p1, p2, p3 ) {\r\n\t\r\n\t\t\t\treturn b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )()\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/core/Curve.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * Extensible curve object\r\n\t *\r\n\t * Some common of Curve methods\r\n\t * .getPoint(t), getTangent(t)\r\n\t * .getPointAt(u), getTagentAt(u)\r\n\t * .getPoints(), .getSpacedPoints()\r\n\t * .getLength()\r\n\t * .updateArcLengths()\r\n\t *\r\n\t * This following classes subclasses THREE.Curve:\r\n\t *\r\n\t * -- 2d classes --\r\n\t * THREE.LineCurve\r\n\t * THREE.QuadraticBezierCurve\r\n\t * THREE.CubicBezierCurve\r\n\t * THREE.SplineCurve\r\n\t * THREE.ArcCurve\r\n\t * THREE.EllipseCurve\r\n\t *\r\n\t * -- 3d classes --\r\n\t * THREE.LineCurve3\r\n\t * THREE.QuadraticBezierCurve3\r\n\t * THREE.CubicBezierCurve3\r\n\t * THREE.SplineCurve3\r\n\t * THREE.ClosedSplineCurve3\r\n\t *\r\n\t * A series of curves can be represented as a THREE.CurvePath\r\n\t *\r\n\t **/\r\n\t\r\n\t/**************************************************************\r\n\t *\tAbstract Curve base class\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.Curve = function () {\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Curve.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Curve,\r\n\t\r\n\t\t// Virtual base class method to overwrite and implement in subclasses\r\n\t\t//\t- t [0 .. 1]\r\n\t\r\n\t\tgetPoint: function ( t ) {\r\n\t\r\n\t\t\tconsole.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\r\n\t\t\treturn null;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Get point at relative position in curve according to arc length\r\n\t\t// - u [0 .. 1]\r\n\t\r\n\t\tgetPointAt: function ( u ) {\r\n\t\r\n\t\t\tvar t = this.getUtoTmapping( u );\r\n\t\t\treturn this.getPoint( t );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Get sequence of points using getPoint( t )\r\n\t\r\n\t\tgetPoints: function ( divisions ) {\r\n\t\r\n\t\t\tif ( ! divisions ) divisions = 5;\r\n\t\r\n\t\t\tvar d, pts = [];\r\n\t\r\n\t\t\tfor ( d = 0; d <= divisions; d ++ ) {\r\n\t\r\n\t\t\t\tpts.push( this.getPoint( d / divisions ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn pts;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Get sequence of points using getPointAt( u )\r\n\t\r\n\t\tgetSpacedPoints: function ( divisions ) {\r\n\t\r\n\t\t\tif ( ! divisions ) divisions = 5;\r\n\t\r\n\t\t\tvar d, pts = [];\r\n\t\r\n\t\t\tfor ( d = 0; d <= divisions; d ++ ) {\r\n\t\r\n\t\t\t\tpts.push( this.getPointAt( d / divisions ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn pts;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Get total curve arc length\r\n\t\r\n\t\tgetLength: function () {\r\n\t\r\n\t\t\tvar lengths = this.getLengths();\r\n\t\t\treturn lengths[ lengths.length - 1 ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Get list of cumulative segment lengths\r\n\t\r\n\t\tgetLengths: function ( divisions ) {\r\n\t\r\n\t\t\tif ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;\r\n\t\r\n\t\t\tif ( this.cacheArcLengths\r\n\t\t\t\t&& ( this.cacheArcLengths.length === divisions + 1 )\r\n\t\t\t\t&& ! this.needsUpdate ) {\r\n\t\r\n\t\t\t\t//console.log( \"cached\", this.cacheArcLengths );\r\n\t\t\t\treturn this.cacheArcLengths;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.needsUpdate = false;\r\n\t\r\n\t\t\tvar cache = [];\r\n\t\t\tvar current, last = this.getPoint( 0 );\r\n\t\t\tvar p, sum = 0;\r\n\t\r\n\t\t\tcache.push( 0 );\r\n\t\r\n\t\t\tfor ( p = 1; p <= divisions; p ++ ) {\r\n\t\r\n\t\t\t\tcurrent = this.getPoint ( p / divisions );\r\n\t\t\t\tsum += current.distanceTo( last );\r\n\t\t\t\tcache.push( sum );\r\n\t\t\t\tlast = current;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.cacheArcLengths = cache;\r\n\t\r\n\t\t\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdateArcLengths: function() {\r\n\t\r\n\t\t\tthis.needsUpdate = true;\r\n\t\t\tthis.getLengths();\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\r\n\t\r\n\t\tgetUtoTmapping: function ( u, distance ) {\r\n\t\r\n\t\t\tvar arcLengths = this.getLengths();\r\n\t\r\n\t\t\tvar i = 0, il = arcLengths.length;\r\n\t\r\n\t\t\tvar targetArcLength; // The targeted u distance value to get\r\n\t\r\n\t\t\tif ( distance ) {\r\n\t\r\n\t\t\t\ttargetArcLength = distance;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//var time = Date.now();\r\n\t\r\n\t\t\t// binary search for the index with largest value smaller than target u distance\r\n\t\r\n\t\t\tvar low = 0, high = il - 1, comparison;\r\n\t\r\n\t\t\twhile ( low <= high ) {\r\n\t\r\n\t\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\r\n\t\r\n\t\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\r\n\t\r\n\t\t\t\tif ( comparison < 0 ) {\r\n\t\r\n\t\t\t\t\tlow = i + 1;\r\n\t\r\n\t\t\t\t} else if ( comparison > 0 ) {\r\n\t\r\n\t\t\t\t\thigh = i - 1;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\thigh = i;\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t// DONE\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\ti = high;\r\n\t\r\n\t\t\t//console.log('b' , i, low, high, Date.now()- time);\r\n\t\r\n\t\t\tif ( arcLengths[ i ] === targetArcLength ) {\r\n\t\r\n\t\t\t\tvar t = i / ( il - 1 );\r\n\t\t\t\treturn t;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// we could get finer grain at lengths, or use simple interpolation between two points\r\n\t\r\n\t\t\tvar lengthBefore = arcLengths[ i ];\r\n\t\t\tvar lengthAfter = arcLengths[ i + 1 ];\r\n\t\r\n\t\t\tvar segmentLength = lengthAfter - lengthBefore;\r\n\t\r\n\t\t\t// determine where we are between the 'before' and 'after' points\r\n\t\r\n\t\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\r\n\t\r\n\t\t\t// add that fractional amount to t\r\n\t\r\n\t\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\r\n\t\r\n\t\t\treturn t;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Returns a unit vector tangent at t\r\n\t\t// In case any sub curve does not implement its tangent derivation,\r\n\t\t// 2 points a small delta apart will be used to find its gradient\r\n\t\t// which seems to give a reasonable approximation\r\n\t\r\n\t\tgetTangent: function( t ) {\r\n\t\r\n\t\t\tvar delta = 0.0001;\r\n\t\t\tvar t1 = t - delta;\r\n\t\t\tvar t2 = t + delta;\r\n\t\r\n\t\t\t// Capping in case of danger\r\n\t\r\n\t\t\tif ( t1 < 0 ) t1 = 0;\r\n\t\t\tif ( t2 > 1 ) t2 = 1;\r\n\t\r\n\t\t\tvar pt1 = this.getPoint( t1 );\r\n\t\t\tvar pt2 = this.getPoint( t2 );\r\n\t\r\n\t\t\tvar vec = pt2.clone().sub( pt1 );\r\n\t\t\treturn vec.normalize();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetTangentAt: function ( u ) {\r\n\t\r\n\t\t\tvar t = this.getUtoTmapping( u );\r\n\t\t\treturn this.getTangent( t );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// TODO: Transformation for Curves?\r\n\t\r\n\t/**************************************************************\r\n\t *\t3D Curves\r\n\t **************************************************************/\r\n\t\r\n\t// A Factory method for creating new curve subclasses\r\n\t\r\n\tTHREE.Curve.create = function ( constructor, getPointFunc ) {\r\n\t\r\n\t\tconstructor.prototype = Object.create( THREE.Curve.prototype );\r\n\t\tconstructor.prototype.constructor = constructor;\r\n\t\tconstructor.prototype.getPoint = getPointFunc;\r\n\t\r\n\t\treturn constructor;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/core/CurvePath.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t *\r\n\t **/\r\n\t\r\n\t/**************************************************************\r\n\t *\tCurved Path - a curve path is simply a array of connected\r\n\t *  curves, but retains the api of a curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.CurvePath = function () {\r\n\t\r\n\t\tthis.curves = [];\r\n\t\r\n\t\tthis.autoClose = false; // Automatically closes the path\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.CurvePath.prototype.constructor = THREE.CurvePath;\r\n\t\r\n\tTHREE.CurvePath.prototype.add = function ( curve ) {\r\n\t\r\n\t\tthis.curves.push( curve );\r\n\t\r\n\t};\r\n\t\r\n\t/*\r\n\tTHREE.CurvePath.prototype.checkConnection = function() {\r\n\t\t// TODO\r\n\t\t// If the ending of curve is not connected to the starting\r\n\t\t// or the next curve, then, this is not a real path\r\n\t};\r\n\t*/\r\n\t\r\n\tTHREE.CurvePath.prototype.closePath = function() {\r\n\t\r\n\t\t// TODO Test\r\n\t\t// and verify for vector3 (needs to implement equals)\r\n\t\t// Add a line curve if start and end of lines are not connected\r\n\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\r\n\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\r\n\t\r\n\t\tif ( ! startPoint.equals( endPoint ) ) {\r\n\t\r\n\t\t\tthis.curves.push( new THREE.LineCurve( endPoint, startPoint ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// To get accurate point with reference to\r\n\t// entire path distance at time t,\r\n\t// following has to be done:\r\n\t\r\n\t// 1. Length of each sub path have to be known\r\n\t// 2. Locate and identify type of curve\r\n\t// 3. Get t for the curve\r\n\t// 4. Return curve.getPointAt(t')\r\n\t\r\n\tTHREE.CurvePath.prototype.getPoint = function( t ) {\r\n\t\r\n\t\tvar d = t * this.getLength();\r\n\t\tvar curveLengths = this.getCurveLengths();\r\n\t\tvar i = 0;\r\n\t\r\n\t\t// To think about boundaries points.\r\n\t\r\n\t\twhile ( i < curveLengths.length ) {\r\n\t\r\n\t\t\tif ( curveLengths[ i ] >= d ) {\r\n\t\r\n\t\t\t\tvar diff = curveLengths[ i ] - d;\r\n\t\t\t\tvar curve = this.curves[ i ];\r\n\t\r\n\t\t\t\tvar u = 1 - diff / curve.getLength();\r\n\t\r\n\t\t\t\treturn curve.getPointAt( u );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\ti ++;\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn null;\r\n\t\r\n\t\t// loop where sum != 0, sum > d , sum+1 <d\r\n\t\r\n\t};\r\n\t\r\n\t/*\r\n\tTHREE.CurvePath.prototype.getTangent = function( t ) {\r\n\t};\r\n\t*/\r\n\t\r\n\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\r\n\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\r\n\t// getPoint() depends on getLength\r\n\t\r\n\tTHREE.CurvePath.prototype.getLength = function() {\r\n\t\r\n\t\tvar lens = this.getCurveLengths();\r\n\t\treturn lens[ lens.length - 1 ];\r\n\t\r\n\t};\r\n\t\r\n\t// Compute lengths and cache them\r\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\r\n\t\r\n\tTHREE.CurvePath.prototype.getCurveLengths = function() {\r\n\t\r\n\t\t// We use cache values if curves and cache array are same length\r\n\t\r\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\r\n\t\r\n\t\t\treturn this.cacheLengths;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Get length of sub-curve\r\n\t\t// Push sums into cached array\r\n\t\r\n\t\tvar lengths = [], sums = 0;\r\n\t\r\n\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tsums += this.curves[ i ].getLength();\r\n\t\t\tlengths.push( sums );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.cacheLengths = lengths;\r\n\t\r\n\t\treturn lengths;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t\r\n\t/**************************************************************\r\n\t *\tCreate Geometries Helpers\r\n\t **************************************************************/\r\n\t\r\n\t/// Generate geometry from path points (for Line or Points objects)\r\n\t\r\n\tTHREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {\r\n\t\r\n\t\tvar pts = this.getPoints( divisions );\r\n\t\treturn this.createGeometry( pts );\r\n\t\r\n\t};\r\n\t\r\n\t// Generate geometry from equidistant sampling along the path\r\n\t\r\n\tTHREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {\r\n\t\r\n\t\tvar pts = this.getSpacedPoints( divisions );\r\n\t\treturn this.createGeometry( pts );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CurvePath.prototype.createGeometry = function( points ) {\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\r\n\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tvar point = points[ i ];\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3( point.x, point.y, point.z || 0 ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn geometry;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/core/Font.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Font = function ( data ) {\r\n\t\r\n\t\tthis.data = data;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Font.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Font,\r\n\t\r\n\t\tgenerateShapes: function ( text, size, divisions ) {\r\n\t\r\n\t\t\tfunction createPaths( text ) {\r\n\t\r\n\t\t\t\tvar chars = String( text ).split( '' );\r\n\t\t\t\tvar scale = size / data.resolution;\r\n\t\t\t\tvar offset = 0;\r\n\t\r\n\t\t\t\tvar paths = [];\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < chars.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar ret = createPath( chars[ i ], scale, offset );\r\n\t\t\t\t\toffset += ret.offset;\r\n\t\r\n\t\t\t\t\tpaths.push( ret.path );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn paths;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction createPath( c, scale, offset ) {\r\n\t\r\n\t\t\t\tvar glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\r\n\t\r\n\t\t\t\tif ( ! glyph ) return;\r\n\t\r\n\t\t\t\tvar path = new THREE.Path();\r\n\t\r\n\t\t\t\tvar pts = [], b2 = THREE.ShapeUtils.b2, b3 = THREE.ShapeUtils.b3;\r\n\t\t\t\tvar x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\r\n\t\r\n\t\t\t\tif ( glyph.o ) {\r\n\t\r\n\t\t\t\t\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = outline.length; i < l; ) {\r\n\t\r\n\t\t\t\t\t\tvar action = outline[ i ++ ];\r\n\t\r\n\t\t\t\t\t\tswitch ( action ) {\r\n\t\r\n\t\t\t\t\t\t\tcase 'm': // moveTo\r\n\t\r\n\t\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\r\n\t\r\n\t\t\t\t\t\t\t\tpath.moveTo( x, y );\r\n\t\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t\tcase 'l': // lineTo\r\n\t\r\n\t\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\r\n\t\r\n\t\t\t\t\t\t\t\tpath.lineTo( x, y );\r\n\t\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t\tcase 'q': // quadraticCurveTo\r\n\t\r\n\t\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\r\n\t\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\r\n\t\r\n\t\t\t\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\r\n\t\r\n\t\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\r\n\t\r\n\t\t\t\t\t\t\t\tif ( laste ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\t\t\t\tcpy0 = laste.y;\r\n\t\r\n\t\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\r\n\t\t\t\t\t\t\t\t\t\tb2( t, cpx0, cpx1, cpx );\r\n\t\t\t\t\t\t\t\t\t\tb2( t, cpy0, cpy1, cpy );\r\n\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t\tcase 'b': // bezierCurveTo\r\n\t\r\n\t\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\r\n\t\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\r\n\t\t\t\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\t\tcpy2 = outline[ i ++ ] * scale;\r\n\t\r\n\t\t\t\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\r\n\t\r\n\t\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\r\n\t\r\n\t\t\t\t\t\t\t\tif ( laste ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\t\t\t\tcpy0 = laste.y;\r\n\t\r\n\t\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\r\n\t\t\t\t\t\t\t\t\t\tb3( t, cpx0, cpx1, cpx2, cpx );\r\n\t\t\t\t\t\t\t\t\t\tb3( t, cpy0, cpy1, cpy2, cpy );\r\n\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn { offset: glyph.ha * scale, path: path };\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tif ( size === undefined ) size = 100;\r\n\t\t\tif ( divisions === undefined ) divisions = 4;\r\n\t\r\n\t\t\tvar data = this.data;\r\n\t\r\n\t\t\tvar paths = createPaths( text );\r\n\t\t\tvar shapes = [];\r\n\t\r\n\t\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\r\n\t\r\n\t\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn shapes;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/core/Path.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * Creates free form 2d path using series of points, lines or curves.\r\n\t *\r\n\t **/\r\n\t\r\n\tTHREE.Path = function ( points ) {\r\n\t\r\n\t\tTHREE.CurvePath.call( this );\r\n\t\r\n\t\tthis.actions = [];\r\n\t\r\n\t\tif ( points ) {\r\n\t\r\n\t\t\tthis.fromPoints( points );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Path.prototype = Object.create( THREE.CurvePath.prototype );\r\n\tTHREE.Path.prototype.constructor = THREE.Path;\r\n\t\r\n\t// TODO Clean up PATH API\r\n\t\r\n\t// Create path using straight lines to connect all points\r\n\t// - vectors: array of Vector2\r\n\t\r\n\tTHREE.Path.prototype.fromPoints = function ( vectors ) {\r\n\t\r\n\t\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\r\n\t\r\n\t\tfor ( var i = 1, l = vectors.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tthis.lineTo( vectors[ i ].x, vectors[ i ].y );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// startPath() endPath()?\r\n\t\r\n\tTHREE.Path.prototype.moveTo = function ( x, y ) {\r\n\t\r\n\t\tthis.actions.push( { action: 'moveTo', args: [ x, y ] } );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Path.prototype.lineTo = function ( x, y ) {\r\n\t\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\tvar curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );\r\n\t\tthis.curves.push( curve );\r\n\t\r\n\t\tthis.actions.push( { action: 'lineTo', args: [ x, y ] } );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {\r\n\t\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\tvar curve = new THREE.QuadraticBezierCurve(\r\n\t\t\tnew THREE.Vector2( x0, y0 ),\r\n\t\t\tnew THREE.Vector2( aCPx, aCPy ),\r\n\t\t\tnew THREE.Vector2( aX, aY )\r\n\t\t);\r\n\t\r\n\t\tthis.curves.push( curve );\r\n\t\r\n\t\tthis.actions.push( { action: 'quadraticCurveTo', args: [ aCPx, aCPy, aX, aY ] } );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\r\n\t\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\tvar curve = new THREE.CubicBezierCurve(\r\n\t\t\tnew THREE.Vector2( x0, y0 ),\r\n\t\t\tnew THREE.Vector2( aCP1x, aCP1y ),\r\n\t\t\tnew THREE.Vector2( aCP2x, aCP2y ),\r\n\t\t\tnew THREE.Vector2( aX, aY )\r\n\t\t);\r\n\t\r\n\t\tthis.curves.push( curve );\r\n\t\r\n\t\tthis.actions.push( { action: 'bezierCurveTo', args: [ aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ] } );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {\r\n\t\r\n\t\tvar args = Array.prototype.slice.call( arguments );\r\n\t\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\tvar npts = [ new THREE.Vector2( x0, y0 ) ];\r\n\t\tArray.prototype.push.apply( npts, pts );\r\n\t\r\n\t\tvar curve = new THREE.SplineCurve( npts );\r\n\t\tthis.curves.push( curve );\r\n\t\r\n\t\tthis.actions.push( { action: 'splineThru', args: args } );\r\n\t\r\n\t};\r\n\t\r\n\t// FUTURE: Change the API or follow canvas API?\r\n\t\r\n\tTHREE.Path.prototype.arc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\t\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\tthis.absarc( aX + x0, aY + y0, aRadius,\r\n\t\t\taStartAngle, aEndAngle, aClockwise );\r\n\t\r\n\t };\r\n\t\r\n\t THREE.Path.prototype.absarc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\t\r\n\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n\t\r\n\t };\r\n\t\r\n\tTHREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\t\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\r\n\t\r\n\t };\r\n\t\r\n\t\r\n\tTHREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\t\r\n\t\tvar args = [\r\n\t\t\taX, aY,\r\n\t\t\txRadius, yRadius,\r\n\t\t\taStartAngle, aEndAngle,\r\n\t\t\taClockwise,\r\n\t\t\taRotation || 0 // aRotation is optional.\r\n\t\t];\r\n\t\r\n\t\tvar curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\r\n\t\tthis.curves.push( curve );\r\n\t\r\n\t\tvar lastPoint = curve.getPoint( 1 );\r\n\t\targs.push( lastPoint.x );\r\n\t\targs.push( lastPoint.y );\r\n\t\r\n\t\tthis.actions.push( { action: 'ellipse', args: args } );\r\n\t\r\n\t };\r\n\t\r\n\tTHREE.Path.prototype.getSpacedPoints = function ( divisions ) {\r\n\t\r\n\t\tif ( ! divisions ) divisions = 40;\r\n\t\r\n\t\tvar points = [];\r\n\t\r\n\t\tfor ( var i = 0; i < divisions; i ++ ) {\r\n\t\r\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\r\n\t\r\n\t\t\t//if ( !this.getPoint( i / divisions ) ) throw \"DIE\";\r\n\t\r\n\t\t}\r\n\t\r\n\t\tif ( this.autoClose ) {\r\n\t\r\n\t\t\tpoints.push( points[ 0 ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn points;\r\n\t\r\n\t};\r\n\t\r\n\t/* Return an array of vectors based on contour of the path */\r\n\t\r\n\tTHREE.Path.prototype.getPoints = function( divisions ) {\r\n\t\r\n\t\tdivisions = divisions || 12;\r\n\t\r\n\t\tvar b2 = THREE.ShapeUtils.b2;\r\n\t\tvar b3 = THREE.ShapeUtils.b3;\r\n\t\r\n\t\tvar points = [];\r\n\t\r\n\t\tvar cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,\r\n\t\t\tlaste, tx, ty;\r\n\t\r\n\t\tfor ( var i = 0, l = this.actions.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tvar item = this.actions[ i ];\r\n\t\r\n\t\t\tvar action = item.action;\r\n\t\t\tvar args = item.args;\r\n\t\r\n\t\t\tswitch ( action ) {\r\n\t\r\n\t\t\tcase 'moveTo':\r\n\t\r\n\t\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\tcase 'lineTo':\r\n\t\r\n\t\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\tcase 'quadraticCurveTo':\r\n\t\r\n\t\t\t\tcpx  = args[ 2 ];\r\n\t\t\t\tcpy  = args[ 3 ];\r\n\t\r\n\t\t\t\tcpx1 = args[ 0 ];\r\n\t\t\t\tcpy1 = args[ 1 ];\r\n\t\r\n\t\t\t\tif ( points.length > 0 ) {\r\n\t\r\n\t\t\t\t\tlaste = points[ points.length - 1 ];\r\n\t\r\n\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\tcpy0 = laste.y;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\t\r\n\t\t\t\t\tcpx0 = laste[ laste.length - 2 ];\r\n\t\t\t\t\tcpy0 = laste[ laste.length - 1 ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var j = 1; j <= divisions; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar t = j / divisions;\r\n\t\r\n\t\t\t\t\ttx = b2( t, cpx0, cpx1, cpx );\r\n\t\t\t\t\tty = b2( t, cpy0, cpy1, cpy );\r\n\t\r\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\tcase 'bezierCurveTo':\r\n\t\r\n\t\t\t\tcpx  = args[ 4 ];\r\n\t\t\t\tcpy  = args[ 5 ];\r\n\t\r\n\t\t\t\tcpx1 = args[ 0 ];\r\n\t\t\t\tcpy1 = args[ 1 ];\r\n\t\r\n\t\t\t\tcpx2 = args[ 2 ];\r\n\t\t\t\tcpy2 = args[ 3 ];\r\n\t\r\n\t\t\t\tif ( points.length > 0 ) {\r\n\t\r\n\t\t\t\t\tlaste = points[ points.length - 1 ];\r\n\t\r\n\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\tcpy0 = laste.y;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\t\r\n\t\t\t\t\tcpx0 = laste[ laste.length - 2 ];\r\n\t\t\t\t\tcpy0 = laste[ laste.length - 1 ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\tfor ( var j = 1; j <= divisions; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar t = j / divisions;\r\n\t\r\n\t\t\t\t\ttx = b3( t, cpx0, cpx1, cpx2, cpx );\r\n\t\t\t\t\tty = b3( t, cpy0, cpy1, cpy2, cpy );\r\n\t\r\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\tcase 'splineThru':\r\n\t\r\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\t\r\n\t\t\t\tvar last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );\r\n\t\t\t\tvar spts = [ last ];\r\n\t\r\n\t\t\t\tvar n = divisions * args[ 0 ].length;\r\n\t\r\n\t\t\t\tspts = spts.concat( args[ 0 ] );\r\n\t\r\n\t\t\t\tvar spline = new THREE.SplineCurve( spts );\r\n\t\r\n\t\t\t\tfor ( var j = 1; j <= n; j ++ ) {\r\n\t\r\n\t\t\t\t\tpoints.push( spline.getPointAt( j / n ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\tcase 'arc':\r\n\t\r\n\t\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\r\n\t\t\t\t\taRadius = args[ 2 ],\r\n\t\t\t\t\taStartAngle = args[ 3 ], aEndAngle = args[ 4 ],\r\n\t\t\t\t\taClockwise = !! args[ 5 ];\r\n\t\r\n\t\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\r\n\t\t\t\tvar angle;\r\n\t\t\t\tvar tdivisions = divisions * 2;\r\n\t\r\n\t\t\t\tfor ( var j = 1; j <= tdivisions; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar t = j / tdivisions;\r\n\t\r\n\t\t\t\t\tif ( ! aClockwise ) {\r\n\t\r\n\t\t\t\t\t\tt = 1 - t;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tangle = aStartAngle + t * deltaAngle;\r\n\t\r\n\t\t\t\t\ttx = aX + aRadius * Math.cos( angle );\r\n\t\t\t\t\tty = aY + aRadius * Math.sin( angle );\r\n\t\r\n\t\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\t\r\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t//console.log(points);\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\tcase 'ellipse':\r\n\t\r\n\t\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\r\n\t\t\t\t\txRadius = args[ 2 ],\r\n\t\t\t\t\tyRadius = args[ 3 ],\r\n\t\t\t\t\taStartAngle = args[ 4 ], aEndAngle = args[ 5 ],\r\n\t\t\t\t\taClockwise = !! args[ 6 ],\r\n\t\t\t\t\taRotation = args[ 7 ];\r\n\t\r\n\t\r\n\t\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\r\n\t\t\t\tvar angle;\r\n\t\t\t\tvar tdivisions = divisions * 2;\r\n\t\r\n\t\t\t\tvar cos, sin;\r\n\t\t\t\tif ( aRotation !== 0 ) {\r\n\t\r\n\t\t\t\t\tcos = Math.cos( aRotation );\r\n\t\t\t\t\tsin = Math.sin( aRotation );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var j = 1; j <= tdivisions; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar t = j / tdivisions;\r\n\t\r\n\t\t\t\t\tif ( ! aClockwise ) {\r\n\t\r\n\t\t\t\t\t\tt = 1 - t;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tangle = aStartAngle + t * deltaAngle;\r\n\t\r\n\t\t\t\t\ttx = aX + xRadius * Math.cos( angle );\r\n\t\t\t\t\tty = aY + yRadius * Math.sin( angle );\r\n\t\r\n\t\t\t\t\tif ( aRotation !== 0 ) {\r\n\t\r\n\t\t\t\t\t\tvar x = tx, y = ty;\r\n\t\r\n\t\t\t\t\t\t// Rotate the point about the center of the ellipse.\r\n\t\t\t\t\t\ttx = ( x - aX ) * cos - ( y - aY ) * sin + aX;\r\n\t\t\t\t\t\tty = ( x - aX ) * sin + ( y - aY ) * cos + aY;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\t\r\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t//console.log(points);\r\n\t\r\n\t\t\t\tbreak;\r\n\t\r\n\t\t\t} // end switch\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\r\n\t\t// Normalize to remove the closing point by default.\r\n\t\tvar lastPoint = points[ points.length - 1 ];\r\n\t\tif ( Math.abs( lastPoint.x - points[ 0 ].x ) < Number.EPSILON &&\r\n\t\t\t\t Math.abs( lastPoint.y - points[ 0 ].y ) < Number.EPSILON )\r\n\t\t\tpoints.splice( points.length - 1, 1 );\r\n\t\r\n\t\tif ( this.autoClose ) {\r\n\t\r\n\t\t\tpoints.push( points[ 0 ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn points;\r\n\t\r\n\t};\r\n\t\r\n\t//\r\n\t// Breaks path into shapes\r\n\t//\r\n\t//\tAssumptions (if parameter isCCW==true the opposite holds):\r\n\t//\t- solid shapes are defined clockwise (CW)\r\n\t//\t- holes are defined counterclockwise (CCW)\r\n\t//\r\n\t//\tIf parameter noHoles==true:\r\n\t//  - all subPaths are regarded as solid shapes\r\n\t//  - definition order CW/CCW has no relevance\r\n\t//\r\n\t\r\n\tTHREE.Path.prototype.toShapes = function( isCCW, noHoles ) {\r\n\t\r\n\t\tfunction extractSubpaths( inActions ) {\r\n\t\r\n\t\t\tvar subPaths = [], lastPath = new THREE.Path();\r\n\t\r\n\t\t\tfor ( var i = 0, l = inActions.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar item = inActions[ i ];\r\n\t\r\n\t\t\t\tvar args = item.args;\r\n\t\t\t\tvar action = item.action;\r\n\t\r\n\t\t\t\tif ( action === 'moveTo' ) {\r\n\t\r\n\t\t\t\t\tif ( lastPath.actions.length !== 0 ) {\r\n\t\r\n\t\t\t\t\t\tsubPaths.push( lastPath );\r\n\t\t\t\t\t\tlastPath = new THREE.Path();\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tlastPath[ action ].apply( lastPath, args );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( lastPath.actions.length !== 0 ) {\r\n\t\r\n\t\t\t\tsubPaths.push( lastPath );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// console.log(subPaths);\r\n\t\r\n\t\t\treturn\tsubPaths;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction toShapesNoHoles( inSubpaths ) {\r\n\t\r\n\t\t\tvar shapes = [];\r\n\t\r\n\t\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar tmpPath = inSubpaths[ i ];\r\n\t\r\n\t\t\t\tvar tmpShape = new THREE.Shape();\r\n\t\t\t\ttmpShape.actions = tmpPath.actions;\r\n\t\t\t\ttmpShape.curves = tmpPath.curves;\r\n\t\r\n\t\t\t\tshapes.push( tmpShape );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//console.log(\"shape\", shapes);\r\n\t\r\n\t\t\treturn shapes;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\r\n\t\r\n\t\t\tvar polyLen = inPolygon.length;\r\n\t\r\n\t\t\t// inPt on polygon contour => immediate success    or\r\n\t\t\t// toggling of inside/outside at every single! intersection point of an edge\r\n\t\t\t//  with the horizontal line through inPt, left of inPt\r\n\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\r\n\t\t\tvar inside = false;\r\n\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\r\n\t\r\n\t\t\t\tvar edgeLowPt  = inPolygon[ p ];\r\n\t\t\t\tvar edgeHighPt = inPolygon[ q ];\r\n\t\r\n\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\r\n\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\r\n\t\r\n\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\r\n\t\r\n\t\t\t\t\t// not parallel\r\n\t\t\t\t\tif ( edgeDy < 0 ) {\r\n\t\r\n\t\t\t\t\t\tedgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\r\n\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\r\n\t\r\n\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\r\n\t\r\n\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\r\n\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\r\n\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\r\n\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\r\n\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// parallel or collinear\r\n\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\r\n\t\t\t\t\t// edge lies on the same horizontal line as inPt\r\n\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\r\n\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\r\n\t\t\t\t\t// continue;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn\tinside;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar isClockWise = THREE.ShapeUtils.isClockWise;\r\n\t\r\n\t\tvar subPaths = extractSubpaths( this.actions );\r\n\t\tif ( subPaths.length === 0 ) return [];\r\n\t\r\n\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\r\n\t\r\n\t\r\n\t\tvar solid, tmpPath, tmpShape, shapes = [];\r\n\t\r\n\t\tif ( subPaths.length === 1 ) {\r\n\t\r\n\t\t\ttmpPath = subPaths[ 0 ];\r\n\t\t\ttmpShape = new THREE.Shape();\r\n\t\t\ttmpShape.actions = tmpPath.actions;\r\n\t\t\ttmpShape.curves = tmpPath.curves;\r\n\t\t\tshapes.push( tmpShape );\r\n\t\t\treturn shapes;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\r\n\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\r\n\t\r\n\t\t// console.log(\"Holes first\", holesFirst);\r\n\t\r\n\t\tvar betterShapeHoles = [];\r\n\t\tvar newShapes = [];\r\n\t\tvar newShapeHoles = [];\r\n\t\tvar mainIdx = 0;\r\n\t\tvar tmpPoints;\r\n\t\r\n\t\tnewShapes[ mainIdx ] = undefined;\r\n\t\tnewShapeHoles[ mainIdx ] = [];\r\n\t\r\n\t\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\r\n\t\r\n\t\t\ttmpPath = subPaths[ i ];\r\n\t\t\ttmpPoints = tmpPath.getPoints();\r\n\t\t\tsolid = isClockWise( tmpPoints );\r\n\t\t\tsolid = isCCW ? ! solid : solid;\r\n\t\r\n\t\t\tif ( solid ) {\r\n\t\r\n\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\r\n\t\r\n\t\t\t\tnewShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };\r\n\t\t\t\tnewShapes[ mainIdx ].s.actions = tmpPath.actions;\r\n\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\r\n\t\r\n\t\t\t\tif ( holesFirst )\tmainIdx ++;\r\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\r\n\t\r\n\t\t\t\t//console.log('cw', i);\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\r\n\t\r\n\t\t\t\t//console.log('ccw', i);\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// only Holes? -> probably all Shapes with wrong orientation\r\n\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\r\n\t\r\n\t\r\n\t\tif ( newShapes.length > 1 ) {\r\n\t\r\n\t\t\tvar ambiguous = false;\r\n\t\t\tvar toChange = [];\r\n\t\r\n\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\t\r\n\t\t\t\tbetterShapeHoles[ sIdx ] = [];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\t\r\n\t\t\t\tvar sho = newShapeHoles[ sIdx ];\r\n\t\r\n\t\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\r\n\t\r\n\t\t\t\t\tvar ho = sho[ hIdx ];\r\n\t\t\t\t\tvar hole_unassigned = true;\r\n\t\r\n\t\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\r\n\t\r\n\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\r\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\r\n\t\r\n\t\t\t\t\t\t\t\thole_unassigned = false;\r\n\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\tambiguous = true;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( hole_unassigned ) {\r\n\t\r\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\t\t// console.log(\"ambiguous: \", ambiguous);\r\n\t\t\tif ( toChange.length > 0 ) {\r\n\t\r\n\t\t\t\t// console.log(\"to change: \", toChange);\r\n\t\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar tmpHoles;\r\n\t\r\n\t\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\r\n\t\r\n\t\t\ttmpShape = newShapes[ i ].s;\r\n\t\t\tshapes.push( tmpShape );\r\n\t\t\ttmpHoles = newShapeHoles[ i ];\r\n\t\r\n\t\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t//console.log(\"shape\", shapes);\r\n\t\r\n\t\treturn shapes;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/core/Shape.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * Defines a 2d shape plane using paths.\r\n\t **/\r\n\t\r\n\t// STEP 1 Create a path.\r\n\t// STEP 2 Turn path into shape.\r\n\t// STEP 3 ExtrudeGeometry takes in Shape/Shapes\r\n\t// STEP 3a - Extract points from each shape, turn to vertices\r\n\t// STEP 3b - Triangulate each shape, add faces.\r\n\t\r\n\tTHREE.Shape = function () {\r\n\t\r\n\t\tTHREE.Path.apply( this, arguments );\r\n\t\r\n\t\tthis.holes = [];\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Shape.prototype = Object.create( THREE.Path.prototype );\r\n\tTHREE.Shape.prototype.constructor = THREE.Shape;\r\n\t\r\n\t// Convenience method to return ExtrudeGeometry\r\n\t\r\n\tTHREE.Shape.prototype.extrude = function ( options ) {\r\n\t\r\n\t\treturn new THREE.ExtrudeGeometry( this, options );\r\n\t\r\n\t};\r\n\t\r\n\t// Convenience method to return ShapeGeometry\r\n\t\r\n\tTHREE.Shape.prototype.makeGeometry = function ( options ) {\r\n\t\r\n\t\treturn new THREE.ShapeGeometry( this, options );\r\n\t\r\n\t};\r\n\t\r\n\t// Get points of holes\r\n\t\r\n\tTHREE.Shape.prototype.getPointsHoles = function ( divisions ) {\r\n\t\r\n\t\tvar holesPts = [];\r\n\t\r\n\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn holesPts;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// Get points of shape and holes (keypoints based on segments parameter)\r\n\t\r\n\tTHREE.Shape.prototype.extractAllPoints = function ( divisions ) {\r\n\t\r\n\t\treturn {\r\n\t\r\n\t\t\tshape: this.getPoints( divisions ),\r\n\t\t\tholes: this.getPointsHoles( divisions )\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Shape.prototype.extractPoints = function ( divisions ) {\r\n\t\r\n\t\treturn this.extractAllPoints( divisions );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/curves/LineCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tLine\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.LineCurve = function ( v1, v2 ) {\r\n\t\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.LineCurve.prototype.constructor = THREE.LineCurve;\r\n\t\r\n\tTHREE.LineCurve.prototype.getPoint = function ( t ) {\r\n\t\r\n\t\tvar point = this.v2.clone().sub( this.v1 );\r\n\t\tpoint.multiplyScalar( t ).add( this.v1 );\r\n\t\r\n\t\treturn point;\r\n\t\r\n\t};\r\n\t\r\n\t// Line curve is linear, so we can overwrite default getPointAt\r\n\t\r\n\tTHREE.LineCurve.prototype.getPointAt = function ( u ) {\r\n\t\r\n\t\treturn this.getPoint( u );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LineCurve.prototype.getTangent = function( t ) {\r\n\t\r\n\t\tvar tangent = this.v2.clone().sub( this.v1 );\r\n\t\r\n\t\treturn tangent.normalize();\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/curves/QuadraticBezierCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tQuadratic Bezier curve\r\n\t **************************************************************/\r\n\t\r\n\t\r\n\tTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\r\n\t\r\n\t\tthis.v0 = v0;\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;\r\n\t\r\n\t\r\n\tTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\r\n\t\r\n\t\tvar b2 = THREE.ShapeUtils.b2;\r\n\t\r\n\t\treturn new THREE.Vector2(\r\n\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\r\n\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y )\r\n\t\t);\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\r\n\t\r\n\t\tvar tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;\r\n\t\r\n\t\treturn new THREE.Vector2(\r\n\t\t\ttangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),\r\n\t\t\ttangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )\r\n\t\t).normalize();\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/curves/CubicBezierCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tCubic Bezier curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\r\n\t\r\n\t\tthis.v0 = v0;\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\t\tthis.v3 = v3;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;\r\n\t\r\n\tTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\r\n\t\r\n\t\tvar b3 = THREE.ShapeUtils.b3;\r\n\t\r\n\t\treturn new THREE.Vector2( \r\n\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\r\n\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\r\n\t\t);\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\r\n\t\r\n\t\tvar tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;\r\n\t\r\n\t\treturn new THREE.Vector2( \r\n\t\t\ttangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\r\n\t\t\ttangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\r\n\t\t).normalize();\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/curves/SplineCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tSpline curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\r\n\t\r\n\t\tthis.points = ( points == undefined ) ? [] : points;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.SplineCurve.prototype.constructor = THREE.SplineCurve;\r\n\t\r\n\tTHREE.SplineCurve.prototype.getPoint = function ( t ) {\r\n\t\r\n\t\tvar points = this.points;\r\n\t\tvar point = ( points.length - 1 ) * t;\r\n\t\r\n\t\tvar intPoint = Math.floor( point );\r\n\t\tvar weight = point - intPoint;\r\n\t\r\n\t\tvar point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\r\n\t\tvar point1 = points[ intPoint ];\r\n\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\r\n\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\r\n\t\r\n\t\tvar interpolate = THREE.CurveUtils.interpolate;\r\n\t\r\n\t\treturn new THREE.Vector2(\r\n\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\r\n\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight )\r\n\t\t);\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/curves/EllipseCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tEllipse curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\t\r\n\t\tthis.aX = aX;\r\n\t\tthis.aY = aY;\r\n\t\r\n\t\tthis.xRadius = xRadius;\r\n\t\tthis.yRadius = yRadius;\r\n\t\r\n\t\tthis.aStartAngle = aStartAngle;\r\n\t\tthis.aEndAngle = aEndAngle;\r\n\t\r\n\t\tthis.aClockwise = aClockwise;\r\n\t\t\r\n\t\tthis.aRotation = aRotation || 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;\r\n\t\r\n\tTHREE.EllipseCurve.prototype.getPoint = function ( t ) {\r\n\t\r\n\t\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\r\n\t\r\n\t\tif ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;\r\n\t\tif ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;\r\n\t\r\n\t\tvar angle;\r\n\t\r\n\t\tif ( this.aClockwise === true ) {\r\n\t\r\n\t\t\tangle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tangle = this.aStartAngle + t * deltaAngle;\r\n\t\r\n\t\t}\r\n\t\t\r\n\t\tvar x = this.aX + this.xRadius * Math.cos( angle );\r\n\t\tvar y = this.aY + this.yRadius * Math.sin( angle );\r\n\t\r\n\t\tif ( this.aRotation !== 0 ) {\r\n\t\r\n\t\t\tvar cos = Math.cos( this.aRotation );\r\n\t\t\tvar sin = Math.sin( this.aRotation );\r\n\t\r\n\t\t\tvar tx = x, ty = y;\r\n\t\r\n\t\t\t// Rotate the point about the center of the ellipse.\r\n\t\t\tx = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;\r\n\t\t\ty = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn new THREE.Vector2( x, y );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/curves/ArcCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tArc curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\t\r\n\t\tTHREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\r\n\tTHREE.ArcCurve.prototype.constructor = THREE.ArcCurve;\r\n\t\r\n\t// File:src/extras/curves/LineCurve3.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tLine3D\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.LineCurve3 = THREE.Curve.create(\r\n\t\r\n\t\tfunction ( v1, v2 ) {\r\n\t\r\n\t\t\tthis.v1 = v1;\r\n\t\t\tthis.v2 = v2;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfunction ( t ) {\r\n\t\r\n\t\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\t\tvector.subVectors( this.v2, this.v1 ); // diff\r\n\t\t\tvector.multiplyScalar( t );\r\n\t\t\tvector.add( this.v1 );\r\n\t\r\n\t\t\treturn vector;\r\n\t\r\n\t\t}\r\n\t\r\n\t);\r\n\t\r\n\t// File:src/extras/curves/QuadraticBezierCurve3.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tQuadratic Bezier 3D curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\r\n\t\r\n\t\tfunction ( v0, v1, v2 ) {\r\n\t\r\n\t\t\tthis.v0 = v0;\r\n\t\t\tthis.v1 = v1;\r\n\t\t\tthis.v2 = v2;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfunction ( t ) {\r\n\t\r\n\t\t\tvar b2 = THREE.ShapeUtils.b2;\t\t\r\n\t\r\n\t\t\treturn new THREE.Vector3(\r\n\t\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\r\n\t\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y ),\r\n\t\t\t\tb2( t, this.v0.z, this.v1.z, this.v2.z )\r\n\t\t\t);\r\n\t\r\n\t\t}\r\n\t\r\n\t);\r\n\t\r\n\t// File:src/extras/curves/CubicBezierCurve3.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tCubic Bezier 3D curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.CubicBezierCurve3 = THREE.Curve.create(\r\n\t\r\n\t\tfunction ( v0, v1, v2, v3 ) {\r\n\t\r\n\t\t\tthis.v0 = v0;\r\n\t\t\tthis.v1 = v1;\r\n\t\t\tthis.v2 = v2;\r\n\t\t\tthis.v3 = v3;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfunction ( t ) {\r\n\t\r\n\t\t\tvar b3 = THREE.ShapeUtils.b3;\r\n\t\r\n\t\t\treturn new THREE.Vector3(\r\n\t\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\r\n\t\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),\r\n\t\t\t\tb3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )\r\n\t\t\t);\r\n\t\r\n\t\t}\r\n\t\r\n\t);\r\n\t\r\n\t// File:src/extras/curves/SplineCurve3.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tSpline 3D curve\r\n\t **************************************************************/\r\n\t\r\n\t\r\n\tTHREE.SplineCurve3 = THREE.Curve.create(\r\n\t\r\n\t\tfunction ( points /* array of Vector3 */ ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );\r\n\t\t\tthis.points = ( points == undefined ) ? [] : points;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfunction ( t ) {\r\n\t\r\n\t\t\tvar points = this.points;\r\n\t\t\tvar point = ( points.length - 1 ) * t;\r\n\t\r\n\t\t\tvar intPoint = Math.floor( point );\r\n\t\t\tvar weight = point - intPoint;\r\n\t\r\n\t\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\r\n\t\t\tvar point1 = points[ intPoint ];\r\n\t\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\r\n\t\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\r\n\t\r\n\t\t\tvar interpolate = THREE.CurveUtils.interpolate;\r\n\t\r\n\t\t\treturn new THREE.Vector3(\r\n\t\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\r\n\t\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight ),\r\n\t\t\t\tinterpolate( point0.z, point1.z, point2.z, point3.z, weight )\r\n\t\t\t);\r\n\t\r\n\t\t}\r\n\t\r\n\t);\r\n\t\r\n\t// File:src/extras/curves/CatmullRomCurve3.js\r\n\t\r\n\t/**\r\n\t * @author zz85 https://github.com/zz85\r\n\t *\r\n\t * Centripetal CatmullRom Curve - which is useful for avoiding\r\n\t * cusps and self-intersections in non-uniform catmull rom curves.\r\n\t * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\r\n\t *\r\n\t * curve.type accepts centripetal(default), chordal and catmullrom\r\n\t * curve.tension is used for catmullrom which defaults to 0.5\r\n\t */\r\n\t\r\n\tTHREE.CatmullRomCurve3 = ( function() {\r\n\t\r\n\t\tvar\r\n\t\t\ttmp = new THREE.Vector3(),\r\n\t\t\tpx = new CubicPoly(),\r\n\t\t\tpy = new CubicPoly(),\r\n\t\t\tpz = new CubicPoly();\r\n\t\r\n\t\t/*\r\n\t\tBased on an optimized c++ solution in\r\n\t\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\r\n\t\t - http://ideone.com/NoEbVM\r\n\t\r\n\t\tThis CubicPoly class could be used for reusing some variables and calculations,\r\n\t\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\r\n\t\twhich can be placed in CurveUtils.\r\n\t\t*/\r\n\t\r\n\t\tfunction CubicPoly() {\r\n\t\r\n\t\t}\r\n\t\r\n\t\t/*\r\n\t\t * Compute coefficients for a cubic polynomial\r\n\t\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\r\n\t\t * such that\r\n\t\t *   p(0) = x0, p(1) = x1\r\n\t\t *  and\r\n\t\t *   p'(0) = t0, p'(1) = t1.\r\n\t\t */\r\n\t\tCubicPoly.prototype.init = function( x0, x1, t0, t1 ) {\r\n\t\r\n\t\t\tthis.c0 = x0;\r\n\t\t\tthis.c1 = t0;\r\n\t\t\tthis.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\r\n\t\t\tthis.c3 = 2 * x0 - 2 * x1 + t0 + t1;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tCubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {\r\n\t\r\n\t\t\t// compute tangents when parameterized in [t1,t2]\r\n\t\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\r\n\t\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\r\n\t\r\n\t\t\t// rescale tangents for parametrization in [0,1]\r\n\t\t\tt1 *= dt1;\r\n\t\t\tt2 *= dt1;\r\n\t\r\n\t\t\t// initCubicPoly\r\n\t\t\tthis.init( x1, x2, t1, t2 );\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4\r\n\t\tCubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {\r\n\t\r\n\t\t\tthis.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tCubicPoly.prototype.calc = function( t ) {\r\n\t\r\n\t\t\tvar t2 = t * t;\r\n\t\t\tvar t3 = t2 * t;\r\n\t\t\treturn this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Subclass Three.js curve\r\n\t\treturn THREE.Curve.create(\r\n\t\r\n\t\t\tfunction ( p /* array of Vector3 */ ) {\r\n\t\r\n\t\t\t\tthis.points = p || [];\r\n\t\t\t\tthis.closed = false;\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tfunction ( t ) {\r\n\t\r\n\t\t\t\tvar points = this.points,\r\n\t\t\t\t\tpoint, intPoint, weight, l;\r\n\t\r\n\t\t\t\tl = points.length;\r\n\t\r\n\t\t\t\tif ( l < 2 ) console.log( 'duh, you need at least 2 points' );\r\n\t\r\n\t\t\t\tpoint = ( l - ( this.closed ? 0 : 1 ) ) * t;\r\n\t\t\t\tintPoint = Math.floor( point );\r\n\t\t\t\tweight = point - intPoint;\r\n\t\r\n\t\t\t\tif ( this.closed ) {\r\n\t\r\n\t\t\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\r\n\t\r\n\t\t\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\r\n\t\r\n\t\t\t\t\tintPoint = l - 2;\r\n\t\t\t\t\tweight = 1;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar p0, p1, p2, p3; // 4 points\r\n\t\r\n\t\t\t\tif ( this.closed || intPoint > 0 ) {\r\n\t\r\n\t\t\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// extrapolate first point\r\n\t\t\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\r\n\t\t\t\t\tp0 = tmp;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tp1 = points[ intPoint % l ];\r\n\t\t\t\tp2 = points[ ( intPoint + 1 ) % l ];\r\n\t\r\n\t\t\t\tif ( this.closed || intPoint + 2 < l ) {\r\n\t\r\n\t\t\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// extrapolate last point\r\n\t\t\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\r\n\t\t\t\t\tp3 = tmp;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {\r\n\t\r\n\t\t\t\t\t// init Centripetal / Chordal Catmull-Rom\r\n\t\t\t\t\tvar pow = this.type === 'chordal' ? 0.5 : 0.25;\r\n\t\t\t\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\r\n\t\t\t\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\r\n\t\t\t\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\r\n\t\r\n\t\t\t\t\t// safety check for repeated points\r\n\t\t\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\r\n\t\t\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\r\n\t\t\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\r\n\t\r\n\t\t\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\r\n\t\t\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\r\n\t\t\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\r\n\t\r\n\t\t\t\t} else if ( this.type === 'catmullrom' ) {\r\n\t\r\n\t\t\t\t\tvar tension = this.tension !== undefined ? this.tension : 0.5;\r\n\t\t\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );\r\n\t\t\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );\r\n\t\t\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar v = new THREE.Vector3(\r\n\t\t\t\t\tpx.calc( weight ),\r\n\t\t\t\t\tpy.calc( weight ),\r\n\t\t\t\t\tpz.calc( weight )\r\n\t\t\t\t);\r\n\t\r\n\t\t\t\treturn v;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t);\r\n\t\r\n\t} )();\r\n\t\r\n\t// File:src/extras/curves/ClosedSplineCurve3.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tClosed Spline 3D curve\r\n\t **************************************************************/\r\n\t\r\n\t\r\n\tTHREE.ClosedSplineCurve3 = function ( points ) {\r\n\t\r\n\t\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );\r\n\t\r\n\t\tTHREE.CatmullRomCurve3.call( this, points );\r\n\t\tthis.type = 'catmullrom';\r\n\t\tthis.closed = true;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ClosedSplineCurve3.prototype = Object.create( THREE.CatmullRomCurve3.prototype );\r\n\t\r\n\t// File:src/extras/geometries/BoxGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\r\n\t */\r\n\t\r\n\tTHREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'BoxGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\twidth: width,\r\n\t\t\theight: height,\r\n\t\t\tdepth: depth,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\tdepthSegments: depthSegments\r\n\t\t};\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\r\n\t\tthis.mergeVertices();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;\r\n\t\r\n\tTHREE.CubeGeometry = THREE.BoxGeometry;\r\n\t\r\n\t// File:src/extras/geometries/BoxBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Mugen87 / https://github.com/Mugen87\r\n\t */\r\n\t\r\n\tTHREE.BoxBufferGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'BoxBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\twidth: width,\r\n\t\t\theight: height,\r\n\t\t\tdepth: depth,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\tdepthSegments: depthSegments\r\n\t\t};\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\t// segments\r\n\t\twidthSegments = Math.floor( widthSegments ) || 1;\r\n\t\theightSegments = Math.floor( heightSegments ) || 1;\r\n\t\tdepthSegments = Math.floor( depthSegments ) || 1;\r\n\t\r\n\t\t// these are used to calculate buffer length\r\n\t\tvar vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );\r\n\t\tvar indexCount = ( vertexCount / 4 ) * 6;\r\n\t\r\n\t\t// buffers\r\n\t\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\r\n\t\tvar vertices = new Float32Array( vertexCount * 3 );\r\n\t\tvar normals = new Float32Array( vertexCount * 3 );\r\n\t\tvar uvs = new Float32Array( vertexCount * 2 );\r\n\t\r\n\t\t// offset variables\r\n\t\tvar vertexBufferOffset = 0;\r\n\t\tvar uvBufferOffset = 0;\r\n\t\tvar indexBufferOffset = 0;\r\n\t\tvar numberOfVertices = 0;\r\n\t\r\n\t\t// group variables\r\n\t\tvar groupStart = 0;\r\n\t\r\n\t\t// build each side of the box geometry\r\n\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px\r\n\t\tbuildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx\r\n\t\tbuildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py\r\n\t\tbuildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny\r\n\t\tbuildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz\r\n\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz\r\n\t\r\n\t\t// build geometry\r\n\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\t\r\n\t\t// helper functions\r\n\t\r\n\t\tfunction calculateVertexCount ( w, h, d ) {\r\n\t\r\n\t\t\tvar segments = 0;\r\n\t\r\n\t\t\t// calculate the amount of segments for each side\r\n\t\t\tsegments += w * h * 2; // xy\r\n\t\t\tsegments += w * d * 2; // xz\r\n\t\t\tsegments += d * h * 2; // zy\r\n\t\r\n\t\t\treturn segments * 4; // four vertices per segments\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction buildPlane ( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\r\n\t\r\n\t\t\tvar segmentWidth\t= width / gridX;\r\n\t\t\tvar segmentHeight = height / gridY;\r\n\t\r\n\t\t\tvar widthHalf = width / 2;\r\n\t\t\tvar heightHalf = height / 2;\r\n\t\t\tvar depthHalf = depth / 2;\r\n\t\r\n\t\t\tvar gridX1 = gridX + 1;\r\n\t\t\tvar gridY1 = gridY + 1;\r\n\t\r\n\t\t\tvar vertexCounter = 0;\r\n\t\t\tvar groupCount = 0;\r\n\t\r\n\t\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\t\t// generate vertices, normals and uvs\r\n\t\r\n\t\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\r\n\t\r\n\t\t\t\tvar y = iy * segmentHeight - heightHalf;\r\n\t\r\n\t\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\r\n\t\r\n\t\t\t\t\tvar x = ix * segmentWidth - widthHalf;\r\n\t\r\n\t\t\t\t\t// set values to correct vector component\r\n\t\t\t\t\tvector[ u ] = x * udir;\r\n\t\t\t\t\tvector[ v ] = y * vdir;\r\n\t\t\t\t\tvector[ w ] = depthHalf;\r\n\t\r\n\t\t\t\t\t// now apply vector to vertex buffer\r\n\t\t\t\t\tvertices[ vertexBufferOffset ] = vector.x;\r\n\t\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vector.y;\r\n\t\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vector.z;\r\n\t\r\n\t\t\t\t\t// set values to correct vector component\r\n\t\t\t\t\tvector[ u ] = 0;\r\n\t\t\t\t\tvector[ v ] = 0;\r\n\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\r\n\t\r\n\t\t\t\t\t// now apply vector to normal buffer\r\n\t\t\t\t\tnormals[ vertexBufferOffset ] = vector.x;\r\n\t\t\t\t\tnormals[ vertexBufferOffset + 1 ] = vector.y;\r\n\t\t\t\t\tnormals[ vertexBufferOffset + 2 ] = vector.z;\r\n\t\r\n\t\t\t\t\t// uvs\r\n\t\t\t\t\tuvs[ uvBufferOffset ] = ix / gridX;\r\n\t\t\t\t\tuvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );\r\n\t\r\n\t\t\t\t\t// update offsets and counters\r\n\t\t\t\t\tvertexBufferOffset += 3;\r\n\t\t\t\t\tuvBufferOffset += 2;\r\n\t\t\t\t\tvertexCounter += 1;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// 1. you need three indices to draw a single face\r\n\t\t\t// 2. a single segment consists of two faces\r\n\t\t\t// 3. so we need to generate six (2*3) indices per segment\r\n\t\r\n\t\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\r\n\t\r\n\t\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\r\n\t\r\n\t\t\t\t\t// indices\r\n\t\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\r\n\t\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\r\n\t\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\r\n\t\r\n\t\t\t\t\t// face one\r\n\t\t\t\t\tindices[ indexBufferOffset ] = a;\r\n\t\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\r\n\t\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\r\n\t\r\n\t\t\t\t\t// face two\r\n\t\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\r\n\t\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\r\n\t\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\r\n\t\r\n\t\t\t\t\t// update offsets and counters\r\n\t\t\t\t\tindexBufferOffset += 6;\r\n\t\t\t\t\tgroupCount += 6;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// add a group to the geometry. this will ensure multi material support\r\n\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\r\n\t\r\n\t\t\t// calculate new start value for groups\r\n\t\t\tgroupStart += groupCount;\r\n\t\r\n\t\t\t// update total number of vertices\r\n\t\t\tnumberOfVertices += vertexCounter;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BoxBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.BoxBufferGeometry.prototype.constructor = THREE.BoxBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/CircleGeometry.js\r\n\t\r\n\t/**\r\n\t * @author hughes\r\n\t */\r\n\t\r\n\tTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'CircleGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tsegments: segments,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;\r\n\t\r\n\t// File:src/extras/geometries/CircleBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author benaadams / https://twitter.com/ben_a_adams\r\n\t */\r\n\t\r\n\tTHREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'CircleBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tsegments: segments,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tradius = radius || 50;\r\n\t\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\r\n\t\r\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\t\r\n\t\tvar vertices = segments + 2;\r\n\t\r\n\t\tvar positions = new Float32Array( vertices * 3 );\r\n\t\tvar normals = new Float32Array( vertices * 3 );\r\n\t\tvar uvs = new Float32Array( vertices * 2 );\r\n\t\r\n\t\t// center data is already zero, but need to set a few extras\r\n\t\tnormals[ 2 ] = 1.0;\r\n\t\tuvs[ 0 ] = 0.5;\r\n\t\tuvs[ 1 ] = 0.5;\r\n\t\r\n\t\tfor ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {\r\n\t\r\n\t\t\tvar segment = thetaStart + s / segments * thetaLength;\r\n\t\r\n\t\t\tpositions[ i ] = radius * Math.cos( segment );\r\n\t\t\tpositions[ i + 1 ] = radius * Math.sin( segment );\r\n\t\r\n\t\t\tnormals[ i + 2 ] = 1; // normal z\r\n\t\r\n\t\t\tuvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;\r\n\t\t\tuvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar indices = [];\r\n\t\r\n\t\tfor ( var i = 1; i <= segments; i ++ ) {\r\n\t\r\n\t\t\tindices.push( i, i + 1, 0 );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );\r\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\r\n\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\t\r\n\t\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/CylinderBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Mugen87 / https://github.com/Mugen87\r\n\t */\r\n\t\r\n\tTHREE.CylinderBufferGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'CylinderBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradiusTop: radiusTop,\r\n\t\t\tradiusBottom: radiusBottom,\r\n\t\t\theight: height,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\topenEnded: openEnded,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\r\n\t\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\r\n\t\theight = height !== undefined ? height : 100;\r\n\t\r\n\t\tradialSegments = Math.floor( radialSegments )  || 8;\r\n\t\theightSegments = Math.floor( heightSegments ) || 1;\r\n\t\r\n\t\topenEnded = openEnded !== undefined ? openEnded : false;\r\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;\r\n\t\r\n\t\t// used to calculate buffer length\r\n\t\r\n\t\tvar vertexCount = calculateVertexCount();\r\n\t\tvar indexCount = calculateIndexCount();\r\n\t\r\n\t\t// buffers\r\n\t\r\n\t\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\r\n\t\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\t\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\t\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\t\r\n\t\t// helper variables\r\n\t\r\n\t\tvar index = 0, indexOffset = 0, indexArray = [], halfHeight = height / 2;\r\n\t\r\n\t\t// generate geometry\r\n\t\r\n\t\tgenerateTorso();\r\n\t\r\n\t\tif( openEnded === false ) {\r\n\t\r\n\t\t\tif( radiusTop > 0 ) {\r\n\t\r\n\t\t\t\tgenerateCap( true );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif( radiusBottom > 0 ) {\r\n\t\r\n\t\t\t\tgenerateCap( false );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// build geometry\r\n\t\r\n\t\tthis.setIndex( indices );\r\n\t\tthis.addAttribute( 'position', vertices );\r\n\t\tthis.addAttribute( 'normal', normals );\r\n\t\tthis.addAttribute( 'uv', uvs );\r\n\t\r\n\t\t// helper functions\r\n\t\r\n\t\tfunction calculateVertexCount () {\r\n\t\r\n\t\t\tvar count = ( radialSegments + 1 ) * ( heightSegments + 1 );\r\n\t\r\n\t\t\tif ( openEnded === false ) {\r\n\t\r\n\t\t\t\tcount += ( ( radialSegments + 1 ) * 2 ) + ( radialSegments * 2 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn count;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction calculateIndexCount () {\r\n\t\r\n\t\t\tvar count = radialSegments * heightSegments * 2 * 3;\r\n\t\r\n\t\t\tif ( openEnded === false ) {\r\n\t\r\n\t\t\t\tcount += radialSegments * 2 * 3;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn count;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction generateTorso () {\r\n\t\r\n\t\t\tvar x, y;\r\n\t\t\tvar normal = new THREE.Vector3();\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\t\r\n\t\t\t// this will be used to calculate the normal\r\n\t\t\tvar tanTheta = ( radiusBottom - radiusTop ) / height;\r\n\t\r\n\t\t\t// generate vertices, normals and uvs\r\n\t\r\n\t\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\r\n\t\r\n\t\t\t\tvar indexRow = [];\r\n\t\r\n\t\t\t\tvar v = y / heightSegments;\r\n\t\r\n\t\t\t\t// calculate the radius of the current row\r\n\t\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\r\n\t\r\n\t\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\r\n\t\r\n\t\t\t\t\tvar u = x / radialSegments;\r\n\t\r\n\t\t\t\t\t// vertex\r\n\t\t\t\t\tvertex.x = radius * Math.sin( u * thetaLength + thetaStart );\r\n\t\t\t\t\tvertex.y = - v * height + halfHeight;\r\n\t\t\t\t\tvertex.z = radius * Math.cos( u * thetaLength + thetaStart );\r\n\t\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\t\r\n\t\t\t\t\t// normal\r\n\t\t\t\t\tnormal.copy( vertex );\r\n\t\r\n\t\t\t\t\t// handle special case if radiusTop/radiusBottom is zero\r\n\t\t\t\t\tif( ( radiusTop === 0  && y === 0 ) || ( radiusBottom === 0  && y === heightSegments ) ) {\r\n\t\r\n\t\t\t\t\t\tnormal.x = Math.sin( u * thetaLength + thetaStart );\r\n\t\t\t\t\t\tnormal.z = Math.cos( u * thetaLength + thetaStart );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tnormal.setY( Math.sqrt( normal.x * normal.x + normal.z * normal.z ) * tanTheta ).normalize();\r\n\t\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\r\n\t\r\n\t\t\t\t\t// uv\r\n\t\t\t\t\tuvs.setXY( index, u, 1 - v );\r\n\t\r\n\t\t\t\t\t// save index of vertex in respective row\r\n\t\t\t\t\tindexRow.push( index );\r\n\t\r\n\t\t\t\t\t// increase index\r\n\t\t\t\t\tindex ++;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// now save vertices of the row in our index array\r\n\t\t\t\tindexArray.push( indexRow );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// generate indices\r\n\t\r\n\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\t\r\n\t\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\r\n\t\r\n\t\t\t\t\t// we use the index array to access the correct indices\r\n\t\t\t\t\tvar i1 = indexArray[ y ][ x ];\r\n\t\t\t\t\tvar i2 = indexArray[ y + 1 ][ x ];\r\n\t\t\t\t\tvar i3 = indexArray[ y + 1 ][ x + 1 ];\r\n\t\t\t\t\tvar i4 = indexArray[ y ][ x + 1 ];\r\n\t\r\n\t\t\t\t\t// face one\r\n\t\t\t\t\tindices.setX( indexOffset, i1 ); indexOffset++;\r\n\t\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset++;\r\n\t\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset++;\r\n\t\r\n\t\t\t\t\t// face two\r\n\t\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset++;\r\n\t\t\t\t\tindices.setX( indexOffset, i3 ); indexOffset++;\r\n\t\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset++;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction generateCap ( top ) {\r\n\t\r\n\t\t\tvar x, centerIndexStart, centerIndexEnd;\r\n\t\t\tvar uv = new THREE.Vector2();\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\t\r\n\t\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\r\n\t\t\tvar sign = ( top === true ) ? 1 : - 1;\r\n\t\r\n\t\t\t// save the index of the first center vertex\r\n\t\t\tcenterIndexStart = index;\r\n\t\r\n\t\t\t// first we generate the center vertex data of the cap.\r\n\t\t\t// because the geometry needs one set of uvs per face,\r\n\t\t\t// we must generate a center vertex per face/segment\r\n\t\r\n\t\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\r\n\t\r\n\t\t\t\t// vertex\r\n\t\t\t\tvertices.setXYZ( index, 0, halfHeight * sign, 0 );\r\n\t\r\n\t\t\t\t// normal\r\n\t\t\t\tnormals.setXYZ( index, 0, sign, 0 );\r\n\t\r\n\t\t\t\t// uv\r\n\t\t\t\tif( top === true ) {\r\n\t\r\n\t\t\t\t\tuv.x = x / radialSegments;\r\n\t\t\t\t\tuv.y = 0;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tuv.x = ( x - 1 ) / radialSegments;\r\n\t\t\t\t\tuv.y = 1;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\r\n\t\r\n\t\t\t\t// increase index\r\n\t\t\t\tindex++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// save the index of the last center vertex\r\n\t\t\tcenterIndexEnd = index;\r\n\t\r\n\t\t\t// now we generate the surrounding vertices, normals and uvs\r\n\t\r\n\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\r\n\t\r\n\t\t\t\tvar u = x / radialSegments;\r\n\t\r\n\t\t\t\t// vertex\r\n\t\t\t\tvertex.x = radius * Math.sin( u * thetaLength + thetaStart );\r\n\t\t\t\tvertex.y = halfHeight * sign;\r\n\t\t\t\tvertex.z = radius * Math.cos( u * thetaLength + thetaStart );\r\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\t\r\n\t\t\t\t// normal\r\n\t\t\t\tnormals.setXYZ( index, 0, sign, 0 );\r\n\t\r\n\t\t\t\t// uv\r\n\t\t\t\tuvs.setXY( index, u, ( top === true ) ? 1 : 0 );\r\n\t\r\n\t\t\t\t// increase index\r\n\t\t\t\tindex ++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// generate indices\r\n\t\r\n\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\t\r\n\t\t\t\tvar c = centerIndexStart + x;\r\n\t\t\t\tvar i = centerIndexEnd + x;\r\n\t\r\n\t\t\t\tif( top === true ) {\r\n\t\r\n\t\t\t\t\t// face top\r\n\t\t\t\t\tindices.setX( indexOffset, i ); indexOffset++;\r\n\t\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset++;\r\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// face bottom\r\n\t\t\t\t\tindices.setX( indexOffset, i + 1); indexOffset++;\r\n\t\t\t\t\tindices.setX( indexOffset, i ); indexOffset++;\r\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CylinderBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.CylinderBufferGeometry.prototype.constructor = THREE.CylinderBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/CylinderGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'CylinderGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradiusTop: radiusTop,\r\n\t\t\tradiusBottom: radiusBottom,\r\n\t\t\theight: height,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\topenEnded: openEnded,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\r\n\t\tthis.mergeVertices();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;\r\n\t\r\n\t// File:src/extras/geometries/EdgesGeometry.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.EdgesGeometry = function ( geometry, thresholdAngle ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\r\n\t\r\n\t\tvar thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );\r\n\t\r\n\t\tvar edge = [ 0, 0 ], hash = {};\r\n\t\r\n\t\tfunction sortFunction( a, b ) {\r\n\t\r\n\t\t\treturn a - b;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar keys = [ 'a', 'b', 'c' ];\r\n\t\r\n\t\tvar geometry2;\r\n\t\r\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\tgeometry2 = new THREE.Geometry();\r\n\t\t\tgeometry2.fromBufferGeometry( geometry );\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tgeometry2 = geometry.clone();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tgeometry2.mergeVertices();\r\n\t\tgeometry2.computeFaceNormals();\r\n\t\r\n\t\tvar vertices = geometry2.vertices;\r\n\t\tvar faces = geometry2.faces;\r\n\t\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\t\r\n\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\r\n\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n\t\t\t\tedge.sort( sortFunction );\r\n\t\r\n\t\t\t\tvar key = edge.toString();\r\n\t\r\n\t\t\t\tif ( hash[ key ] === undefined ) {\r\n\t\r\n\t\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\thash[ key ].face2 = i;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar coords = [];\r\n\t\r\n\t\tfor ( var key in hash ) {\r\n\t\r\n\t\t\tvar h = hash[ key ];\r\n\t\r\n\t\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\r\n\t\r\n\t\t\t\tvar vertex = vertices[ h.vert1 ];\r\n\t\t\t\tcoords.push( vertex.x );\r\n\t\t\t\tcoords.push( vertex.y );\r\n\t\t\t\tcoords.push( vertex.z );\r\n\t\r\n\t\t\t\tvertex = vertices[ h.vert2 ];\r\n\t\t\t\tcoords.push( vertex.x );\r\n\t\t\t\tcoords.push( vertex.y );\r\n\t\t\t\tcoords.push( vertex.z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;\r\n\t\r\n\t// File:src/extras/geometries/ExtrudeGeometry.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t *\r\n\t * Creates extruded geometry from a path shape.\r\n\t *\r\n\t * parameters = {\r\n\t *\r\n\t *  curveSegments: <int>, // number of points on the curves\r\n\t *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\r\n\t *  amount: <int>, // Depth to extrude the shape\r\n\t *\r\n\t *  bevelEnabled: <bool>, // turn on bevel\r\n\t *  bevelThickness: <float>, // how deep into the original shape bevel goes\r\n\t *  bevelSize: <float>, // how far from shape outline is bevel\r\n\t *  bevelSegments: <int>, // number of bevel layers\r\n\t *\r\n\t *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\r\n\t *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\r\n\t *\r\n\t *  uvGenerator: <Object> // object that provides UV generator functions\r\n\t *\r\n\t * }\r\n\t **/\r\n\t\r\n\tTHREE.ExtrudeGeometry = function ( shapes, options ) {\r\n\t\r\n\t\tif ( typeof( shapes ) === \"undefined\" ) {\r\n\t\r\n\t\t\tshapes = [];\r\n\t\t\treturn;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'ExtrudeGeometry';\r\n\t\r\n\t\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\r\n\t\r\n\t\tthis.addShapeList( shapes, options );\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\r\n\t\t// can't really use automatic vertex normals\r\n\t\t// as then front and back sides get smoothed too\r\n\t\t// should do separate smoothing just for sides\r\n\t\r\n\t\t//this.computeVertexNormals();\r\n\t\r\n\t\t//console.log( \"took\", ( Date.now() - startTime ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;\r\n\t\r\n\tTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\t\r\n\t\tvar sl = shapes.length;\r\n\t\r\n\t\tfor ( var s = 0; s < sl; s ++ ) {\r\n\t\r\n\t\t\tvar shape = shapes[ s ];\r\n\t\t\tthis.addShape( shape, options );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\r\n\t\r\n\t\tvar amount = options.amount !== undefined ? options.amount : 100;\r\n\t\r\n\t\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\r\n\t\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\r\n\t\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\r\n\t\r\n\t\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\r\n\t\r\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\t\r\n\t\tvar steps = options.steps !== undefined ? options.steps : 1;\r\n\t\r\n\t\tvar extrudePath = options.extrudePath;\r\n\t\tvar extrudePts, extrudeByPath = false;\r\n\t\r\n\t\t// Use default WorldUVGenerator if no UV generators are specified.\r\n\t\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\r\n\t\r\n\t\tvar splineTube, binormal, normal, position2;\r\n\t\tif ( extrudePath ) {\r\n\t\r\n\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\r\n\t\r\n\t\t\textrudeByPath = true;\r\n\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\r\n\t\r\n\t\t\t// SETUP TNB variables\r\n\t\r\n\t\t\t// Reuse TNB from TubeGeomtry for now.\r\n\t\t\t// TODO1 - have a .isClosed in spline?\r\n\t\r\n\t\t\tsplineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );\r\n\t\r\n\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\r\n\t\r\n\t\t\tbinormal = new THREE.Vector3();\r\n\t\t\tnormal = new THREE.Vector3();\r\n\t\t\tposition2 = new THREE.Vector3();\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Safeguards if bevels are not enabled\r\n\t\r\n\t\tif ( ! bevelEnabled ) {\r\n\t\r\n\t\t\tbevelSegments = 0;\r\n\t\t\tbevelThickness = 0;\r\n\t\t\tbevelSize = 0;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Variables initialization\r\n\t\r\n\t\tvar ahole, h, hl; // looping of holes\r\n\t\tvar scope = this;\r\n\t\r\n\t\tvar shapesOffset = this.vertices.length;\r\n\t\r\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\t\r\n\t\tvar vertices = shapePoints.shape;\r\n\t\tvar holes = shapePoints.holes;\r\n\t\r\n\t\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\r\n\t\r\n\t\tif ( reverse ) {\r\n\t\r\n\t\t\tvertices = vertices.reverse();\r\n\t\r\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\r\n\t\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tahole = holes[ h ];\r\n\t\r\n\t\t\t\tif ( THREE.ShapeUtils.isClockWise( ahole ) ) {\r\n\t\r\n\t\t\t\t\tholes[ h ] = ahole.reverse();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\r\n\t\r\n\t\t/* Vertices */\r\n\t\r\n\t\tvar contour = vertices; // vertices has all points but contour has only points of circumference\r\n\t\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\tahole = holes[ h ];\r\n\t\r\n\t\t\tvertices = vertices.concat( ahole );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\tfunction scalePt2 ( pt, vec, size ) {\r\n\t\r\n\t\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\r\n\t\r\n\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar b, bs, t, z,\r\n\t\t\tvert, vlen = vertices.length,\r\n\t\t\tface, flen = faces.length;\r\n\t\r\n\t\r\n\t\t// Find directions for point movement\r\n\t\r\n\t\r\n\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\r\n\t\r\n\t\t\t// computes for inPt the corresponding point inPt' on a new contour\r\n\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\r\n\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\r\n\t\t\t//\r\n\t\t\t// inPt' is the intersection of the two lines parallel to the two\r\n\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\r\n\t\r\n\t\t\tvar v_trans_x, v_trans_y, shrink_by = 1;\t\t// resulting translation vector for inPt\r\n\t\r\n\t\t\t// good reading for geometry algorithms (here: line-line intersection)\r\n\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\r\n\t\r\n\t\t\tvar v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\r\n\t\t\tvar v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\r\n\t\r\n\t\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\r\n\t\r\n\t\t\t// check for collinear edges\r\n\t\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\t\r\n\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\r\n\t\r\n\t\t\t\t// not collinear\r\n\t\r\n\t\t\t\t// length of vectors for normalizing\r\n\t\r\n\t\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\r\n\t\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\r\n\t\r\n\t\t\t\t// shift adjacent points by unit vectors to the left\r\n\t\r\n\t\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\r\n\t\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\r\n\t\r\n\t\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\r\n\t\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\r\n\t\r\n\t\t\t\t// scaling factor for v_prev to intersection point\r\n\t\r\n\t\t\t\tvar sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\r\n\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\r\n\t\t\t\t\t\t  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\t\r\n\t\t\t\t// vector from inPt to intersection point\r\n\t\r\n\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\r\n\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\r\n\t\r\n\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\r\n\t\t\t\t//  but prevent crazy spikes\r\n\t\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\r\n\t\t\t\tif ( v_trans_lensq <= 2 ) {\r\n\t\r\n\t\t\t\t\treturn\tnew THREE.Vector2( v_trans_x, v_trans_y );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// handle special case of collinear edges\r\n\t\r\n\t\t\t\tvar direction_eq = false;\t\t// assumes: opposite\r\n\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\r\n\t\r\n\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\r\n\t\r\n\t\t\t\t\t\tdirection_eq = true;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\r\n\t\r\n\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\r\n\t\r\n\t\t\t\t\t\t\tdirection_eq = true;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\r\n\t\r\n\t\t\t\t\t\t\tdirection_eq = true;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( direction_eq ) {\r\n\t\r\n\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\r\n\t\t\t\t\tv_trans_x = - v_prev_y;\r\n\t\t\t\t\tv_trans_y =  v_prev_x;\r\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\r\n\t\t\t\t\tv_trans_x = v_prev_x;\r\n\t\t\t\t\tv_trans_y = v_prev_y;\r\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn\tnew THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\tvar contourMovements = [];\r\n\t\r\n\t\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\t\r\n\t\t\tif ( j === il ) j = 0;\r\n\t\t\tif ( k === il ) k = 0;\r\n\t\r\n\t\t\t//  (j)---(i)---(k)\r\n\t\t\t// console.log('i,j,k', i, j , k)\r\n\t\r\n\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\r\n\t\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\tahole = holes[ h ];\r\n\t\r\n\t\t\toneHoleMovements = [];\r\n\t\r\n\t\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\t\r\n\t\t\t\tif ( j === il ) j = 0;\r\n\t\t\t\tif ( k === il ) k = 0;\r\n\t\r\n\t\t\t\t//  (j)---(i)---(k)\r\n\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tholesMovements.push( oneHoleMovements );\r\n\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Loop bevelSegments, 1 for the front, 1 for the back\r\n\t\r\n\t\tfor ( b = 0; b < bevelSegments; b ++ ) {\r\n\t\r\n\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\r\n\t\r\n\t\t\tt = b / bevelSegments;\r\n\t\t\tz = bevelThickness * ( 1 - t );\r\n\t\r\n\t\t\t//z = bevelThickness * t;\r\n\t\t\tbs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved\r\n\t\t\t//bs = bevelSize * t; // linear\r\n\t\r\n\t\t\t// contract shape\r\n\t\r\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\t\r\n\t\t\t\tv( vert.x, vert.y,  - z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// expand holes\r\n\t\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tahole = holes[ h ];\r\n\t\t\t\toneHoleMovements = holesMovements[ h ];\r\n\t\r\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\t\r\n\t\t\t\t\tv( vert.x, vert.y,  - z );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tbs = bevelSize;\r\n\t\r\n\t\t// Back facing vertices\r\n\t\r\n\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\t\r\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\t\r\n\t\t\tif ( ! extrudeByPath ) {\r\n\t\r\n\t\t\t\tv( vert.x, vert.y, 0 );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\r\n\t\r\n\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\r\n\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\r\n\t\r\n\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\r\n\t\r\n\t\t\t\tv( position2.x, position2.y, position2.z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Add stepped vertices...\r\n\t\t// Including front facing vertices\r\n\t\r\n\t\tvar s;\r\n\t\r\n\t\tfor ( s = 1; s <= steps; s ++ ) {\r\n\t\r\n\t\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\t\r\n\t\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\t\r\n\t\t\t\tif ( ! extrudeByPath ) {\r\n\t\r\n\t\t\t\t\tv( vert.x, vert.y, amount / steps * s );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\r\n\t\r\n\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\r\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\r\n\t\r\n\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\r\n\t\r\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Add bevel segments planes\r\n\t\r\n\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\r\n\t\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\r\n\t\r\n\t\t\tt = b / bevelSegments;\r\n\t\t\tz = bevelThickness * ( 1 - t );\r\n\t\t\t//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\r\n\t\t\tbs = bevelSize * Math.sin ( t * Math.PI / 2 );\r\n\t\r\n\t\t\t// contract shape\r\n\t\r\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\t\t\t\tv( vert.x, vert.y,  amount + z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// expand holes\r\n\t\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tahole = holes[ h ];\r\n\t\t\t\toneHoleMovements = holesMovements[ h ];\r\n\t\r\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\t\r\n\t\t\t\t\tif ( ! extrudeByPath ) {\r\n\t\r\n\t\t\t\t\t\tv( vert.x, vert.y,  amount + z );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t/* Faces */\r\n\t\r\n\t\t// Top and bottom faces\r\n\t\r\n\t\tbuildLidFaces();\r\n\t\r\n\t\t// Sides faces\r\n\t\r\n\t\tbuildSideFaces();\r\n\t\r\n\t\r\n\t\t/////  Internal functions\r\n\t\r\n\t\tfunction buildLidFaces() {\r\n\t\r\n\t\t\tif ( bevelEnabled ) {\r\n\t\r\n\t\t\t\tvar layer = 0; // steps + 1\r\n\t\t\t\tvar offset = vlen * layer;\r\n\t\r\n\t\t\t\t// Bottom faces\r\n\t\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\t\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tlayer = steps + bevelSegments * 2;\r\n\t\t\t\toffset = vlen * layer;\r\n\t\r\n\t\t\t\t// Top faces\r\n\t\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\t\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// Bottom faces\r\n\t\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\t\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// Top faces\r\n\t\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\t\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Create faces for the z-sides of the shape\r\n\t\r\n\t\tfunction buildSideFaces() {\r\n\t\r\n\t\t\tvar layeroffset = 0;\r\n\t\t\tsidewalls( contour, layeroffset );\r\n\t\t\tlayeroffset += contour.length;\r\n\t\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tahole = holes[ h ];\r\n\t\t\t\tsidewalls( ahole, layeroffset );\r\n\t\r\n\t\t\t\t//, true\r\n\t\t\t\tlayeroffset += ahole.length;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction sidewalls( contour, layeroffset ) {\r\n\t\r\n\t\t\tvar j, k;\r\n\t\t\ti = contour.length;\r\n\t\r\n\t\t\twhile ( -- i >= 0 ) {\r\n\t\r\n\t\t\t\tj = i;\r\n\t\t\t\tk = i - 1;\r\n\t\t\t\tif ( k < 0 ) k = contour.length - 1;\r\n\t\r\n\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\r\n\t\r\n\t\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\r\n\t\r\n\t\t\t\tfor ( s = 0; s < sl; s ++ ) {\r\n\t\r\n\t\t\t\t\tvar slen1 = vlen * s;\r\n\t\t\t\t\tvar slen2 = vlen * ( s + 1 );\r\n\t\r\n\t\t\t\t\tvar a = layeroffset + j + slen1,\r\n\t\t\t\t\t\tb = layeroffset + k + slen1,\r\n\t\t\t\t\t\tc = layeroffset + k + slen2,\r\n\t\t\t\t\t\td = layeroffset + j + slen2;\r\n\t\r\n\t\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\tfunction v( x, y, z ) {\r\n\t\r\n\t\t\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction f3( a, b, c ) {\r\n\t\r\n\t\t\ta += shapesOffset;\r\n\t\t\tb += shapesOffset;\r\n\t\t\tc += shapesOffset;\r\n\t\r\n\t\t\tscope.faces.push( new THREE.Face3( a, b, c, null, null, 0 ) );\r\n\t\r\n\t\t\tvar uvs = uvgen.generateTopUV( scope, a, b, c );\r\n\t\r\n\t\t\tscope.faceVertexUvs[ 0 ].push( uvs );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\r\n\t\r\n\t\t\ta += shapesOffset;\r\n\t\t\tb += shapesOffset;\r\n\t\t\tc += shapesOffset;\r\n\t\t\td += shapesOffset;\r\n\t\r\n\t\t\tscope.faces.push( new THREE.Face3( a, b, d, null, null, 1 ) );\r\n\t\t\tscope.faces.push( new THREE.Face3( b, c, d, null, null, 1 ) );\r\n\t\r\n\t\t\tvar uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\r\n\t\r\n\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\r\n\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ExtrudeGeometry.WorldUVGenerator = {\r\n\t\r\n\t\tgenerateTopUV: function ( geometry, indexA, indexB, indexC ) {\r\n\t\r\n\t\t\tvar vertices = geometry.vertices;\r\n\t\r\n\t\t\tvar a = vertices[ indexA ];\r\n\t\t\tvar b = vertices[ indexB ];\r\n\t\t\tvar c = vertices[ indexC ];\r\n\t\r\n\t\t\treturn [\r\n\t\t\t\tnew THREE.Vector2( a.x, a.y ),\r\n\t\t\t\tnew THREE.Vector2( b.x, b.y ),\r\n\t\t\t\tnew THREE.Vector2( c.x, c.y )\r\n\t\t\t];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgenerateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\r\n\t\r\n\t\t\tvar vertices = geometry.vertices;\r\n\t\r\n\t\t\tvar a = vertices[ indexA ];\r\n\t\t\tvar b = vertices[ indexB ];\r\n\t\t\tvar c = vertices[ indexC ];\r\n\t\t\tvar d = vertices[ indexD ];\r\n\t\r\n\t\t\tif ( Math.abs( a.y - b.y ) < 0.01 ) {\r\n\t\r\n\t\t\t\treturn [\r\n\t\t\t\t\tnew THREE.Vector2( a.x, 1 - a.z ),\r\n\t\t\t\t\tnew THREE.Vector2( b.x, 1 - b.z ),\r\n\t\t\t\t\tnew THREE.Vector2( c.x, 1 - c.z ),\r\n\t\t\t\t\tnew THREE.Vector2( d.x, 1 - d.z )\r\n\t\t\t\t];\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\treturn [\r\n\t\t\t\t\tnew THREE.Vector2( a.y, 1 - a.z ),\r\n\t\t\t\t\tnew THREE.Vector2( b.y, 1 - b.z ),\r\n\t\t\t\t\tnew THREE.Vector2( c.y, 1 - c.z ),\r\n\t\t\t\t\tnew THREE.Vector2( d.y, 1 - d.z )\r\n\t\t\t\t];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t};\r\n\t\r\n\t// File:src/extras/geometries/ShapeGeometry.js\r\n\t\r\n\t/**\r\n\t * @author jonobr1 / http://jonobr1.com\r\n\t *\r\n\t * Creates a one-sided polygonal geometry from a path shape. Similar to\r\n\t * ExtrudeGeometry.\r\n\t *\r\n\t * parameters = {\r\n\t *\r\n\t *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\r\n\t *\r\n\t *\tmaterial: <int> // material index for front and back faces\r\n\t *\tuvGenerator: <Object> // object that provides UV generator functions\r\n\t *\r\n\t * }\r\n\t **/\r\n\t\r\n\tTHREE.ShapeGeometry = function ( shapes, options ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'ShapeGeometry';\r\n\t\r\n\t\tif ( Array.isArray( shapes ) === false ) shapes = [ shapes ];\r\n\t\r\n\t\tthis.addShapeList( shapes, options );\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;\r\n\t\r\n\t/**\r\n\t * Add an array of shapes to THREE.ShapeGeometry.\r\n\t */\r\n\tTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\t\r\n\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tthis.addShape( shapes[ i ], options );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t/**\r\n\t * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\r\n\t */\r\n\tTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\r\n\t\r\n\t\tif ( options === undefined ) options = {};\r\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\t\r\n\t\tvar material = options.material;\r\n\t\tvar uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar i, l, hole;\r\n\t\r\n\t\tvar shapesOffset = this.vertices.length;\r\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\t\r\n\t\tvar vertices = shapePoints.shape;\r\n\t\tvar holes = shapePoints.holes;\r\n\t\r\n\t\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\r\n\t\r\n\t\tif ( reverse ) {\r\n\t\r\n\t\t\tvertices = vertices.reverse();\r\n\t\r\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\r\n\t\r\n\t\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\thole = holes[ i ];\r\n\t\r\n\t\t\t\tif ( THREE.ShapeUtils.isClockWise( hole ) ) {\r\n\t\r\n\t\t\t\t\tholes[ i ] = hole.reverse();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treverse = false;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\r\n\t\r\n\t\t// Vertices\r\n\t\r\n\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\r\n\t\r\n\t\t\thole = holes[ i ];\r\n\t\t\tvertices = vertices.concat( hole );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar vert, vlen = vertices.length;\r\n\t\tvar face, flen = faces.length;\r\n\t\r\n\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\t\r\n\t\t\tvert = vertices[ i ];\r\n\t\r\n\t\t\tthis.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\t\r\n\t\t\tface = faces[ i ];\r\n\t\r\n\t\t\tvar a = face[ 0 ] + shapesOffset;\r\n\t\t\tvar b = face[ 1 ] + shapesOffset;\r\n\t\t\tvar c = face[ 2 ] + shapesOffset;\r\n\t\r\n\t\t\tthis.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/geometries/LatheBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Mugen87 / https://github.com/Mugen87\r\n\t */\r\n\t\r\n\t // points - to create a closed torus, one must use a set of points\r\n\t //    like so: [ a, b, c, d, a ], see first is the same as last.\r\n\t // segments - the number of circumference segments to create\r\n\t // phiStart - the starting radian\r\n\t // phiLength - the radian (0 to 2PI) range of the lathed section\r\n\t //    2PI is a closed lathe, less than 2PI is a portion.\r\n\t\r\n\tTHREE.LatheBufferGeometry = function ( points, segments, phiStart, phiLength ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'LatheBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tpoints: points,\r\n\t\t\tsegments: segments,\r\n\t\t\tphiStart: phiStart,\r\n\t\t\tphiLength: phiLength\r\n\t\t};\r\n\t\r\n\t\tsegments = Math.floor( segments ) || 12;\r\n\t\tphiStart = phiStart || 0;\r\n\t\tphiLength = phiLength || Math.PI * 2;\r\n\t\r\n\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\r\n\t\tphiLength = THREE.Math.clamp( phiLength, 0, Math.PI * 2 );\r\n\t\r\n\t\t// these are used to calculate buffer length\r\n\t\tvar vertexCount = ( segments + 1 ) * points.length;\r\n\t\tvar indexCount = segments * points.length * 2 * 3;\r\n\t\r\n\t\t// buffers\r\n\t\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\r\n\t\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\t\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\t\r\n\t\t// helper variables\r\n\t\tvar index = 0, indexOffset = 0, base;\r\n\t\tvar inversePointLength = 1.0 / ( points.length - 1 );\r\n\t\tvar inverseSegments = 1.0 / segments;\r\n\t\tvar vertex = new THREE.Vector3();\r\n\t\tvar uv = new THREE.Vector2();\r\n\t\tvar i, j;\r\n\t\r\n\t\t// generate vertices and uvs\r\n\t\r\n\t\tfor ( i = 0; i <= segments; i ++ ) {\r\n\t\r\n\t\t\tvar phi = phiStart + i * inverseSegments * phiLength;\r\n\t\r\n\t\t\tvar sin = Math.sin( phi );\r\n\t\t\tvar cos = Math.cos( phi );\r\n\t\r\n\t\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\r\n\t\r\n\t\t\t\t// vertex\r\n\t\t\t\tvertex.x = points[ j ].x * sin;\r\n\t\t\t\tvertex.y = points[ j ].y;\r\n\t\t\t\tvertex.z = points[ j ].x * cos;\r\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\t\r\n\t\t\t\t// uv\r\n\t\t\t\tuv.x = i / segments;\r\n\t\t\t\tuv.y = j / ( points.length - 1 );\r\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\r\n\t\r\n\t\t\t\t// increase index\r\n\t\t\t\tindex ++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// generate indices\r\n\t\r\n\t\tfor ( i = 0; i < segments; i ++ ) {\r\n\t\r\n\t\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\r\n\t\r\n\t\t\t\tbase = j + i * points.length;\r\n\t\r\n\t\t\t\t// indices\r\n\t\t\t\tvar a = base;\r\n\t\t\t\tvar b = base + points.length;\r\n\t\t\t\tvar c = base + points.length + 1;\r\n\t\t\t\tvar d = base + 1;\r\n\t\r\n\t\t\t\t// face one\r\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\t\r\n\t\t\t\t// face two\r\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// build geometry\r\n\t\r\n\t\tthis.setIndex( indices );\r\n\t\tthis.addAttribute( 'position', vertices );\r\n\t\tthis.addAttribute( 'uv', uvs );\r\n\t\r\n\t\t// generate normals\r\n\t\r\n\t\tthis.computeVertexNormals();\r\n\t\r\n\t\t// if the geometry is closed, we need to average the normals along the seam.\r\n\t\t// because the corresponding vertices are identical (but still have different UVs).\r\n\t\r\n\t\tif( phiLength === Math.PI * 2 ) {\r\n\t\r\n\t\t\tvar normals = this.attributes.normal.array;\r\n\t\t\tvar n1 = new THREE.Vector3();\r\n\t\t\tvar n2 = new THREE.Vector3();\r\n\t\t\tvar n = new THREE.Vector3();\r\n\t\r\n\t\t\t// this is the buffer offset for the last line of vertices\r\n\t\t\tbase = segments * points.length * 3;\r\n\t\r\n\t\t\tfor( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\r\n\t\r\n\t\t\t\t// select the normal of the vertex in the first line\r\n\t\t\t\tn1.x = normals[ j + 0 ];\r\n\t\t\t\tn1.y = normals[ j + 1 ];\r\n\t\t\t\tn1.z = normals[ j + 2 ];\r\n\t\r\n\t\t\t\t// select the normal of the vertex in the last line\r\n\t\t\t\tn2.x = normals[ base + j + 0 ];\r\n\t\t\t\tn2.y = normals[ base + j + 1 ];\r\n\t\t\t\tn2.z = normals[ base + j + 2 ];\r\n\t\r\n\t\t\t\t// average normals\r\n\t\t\t\tn.addVectors( n1, n2 ).normalize();\r\n\t\r\n\t\t\t\t// assign the new values to both normals\r\n\t\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\r\n\t\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\r\n\t\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\r\n\t\r\n\t\t\t} // next row\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LatheBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.LatheBufferGeometry.prototype.constructor = THREE.LatheBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/LatheGeometry.js\r\n\t\r\n\t/**\r\n\t * @author astrodud / http://astrodud.isgreat.org/\r\n\t * @author zz85 / https://github.com/zz85\r\n\t * @author bhouston / http://clara.io\r\n\t */\r\n\t\r\n\t// points - to create a closed torus, one must use a set of points\r\n\t//    like so: [ a, b, c, d, a ], see first is the same as last.\r\n\t// segments - the number of circumference segments to create\r\n\t// phiStart - the starting radian\r\n\t// phiLength - the radian (0 to 2PI) range of the lathed section\r\n\t//    2PI is a closed lathe, less than 2PI is a portion.\r\n\t\r\n\tTHREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'LatheGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tpoints: points,\r\n\t\t\tsegments: segments,\r\n\t\t\tphiStart: phiStart,\r\n\t\t\tphiLength: phiLength\r\n\t\t};\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.LatheBufferGeometry( points, segments, phiStart, phiLength ) );\r\n\t\tthis.mergeVertices();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;\r\n\t\r\n\t// File:src/extras/geometries/PlaneGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n\t */\r\n\t\r\n\tTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'PlaneGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\twidth: width,\r\n\t\t\theight: height,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments\r\n\t\t};\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;\r\n\t\r\n\t// File:src/extras/geometries/PlaneBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n\t */\r\n\t\r\n\tTHREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'PlaneBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\twidth: width,\r\n\t\t\theight: height,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments\r\n\t\t};\r\n\t\r\n\t\tvar width_half = width / 2;\r\n\t\tvar height_half = height / 2;\r\n\t\r\n\t\tvar gridX = Math.floor( widthSegments ) || 1;\r\n\t\tvar gridY = Math.floor( heightSegments ) || 1;\r\n\t\r\n\t\tvar gridX1 = gridX + 1;\r\n\t\tvar gridY1 = gridY + 1;\r\n\t\r\n\t\tvar segment_width = width / gridX;\r\n\t\tvar segment_height = height / gridY;\r\n\t\r\n\t\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\r\n\t\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\r\n\t\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\r\n\t\r\n\t\tvar offset = 0;\r\n\t\tvar offset2 = 0;\r\n\t\r\n\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\r\n\t\r\n\t\t\tvar y = iy * segment_height - height_half;\r\n\t\r\n\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\r\n\t\r\n\t\t\t\tvar x = ix * segment_width - width_half;\r\n\t\r\n\t\t\t\tvertices[ offset ] = x;\r\n\t\t\t\tvertices[ offset + 1 ] = - y;\r\n\t\r\n\t\t\t\tnormals[ offset + 2 ] = 1;\r\n\t\r\n\t\t\t\tuvs[ offset2 ] = ix / gridX;\r\n\t\t\t\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\r\n\t\r\n\t\t\t\toffset += 3;\r\n\t\t\t\toffset2 += 2;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\toffset = 0;\r\n\t\r\n\t\tvar indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\r\n\t\r\n\t\tfor ( var iy = 0; iy < gridY; iy ++ ) {\r\n\t\r\n\t\t\tfor ( var ix = 0; ix < gridX; ix ++ ) {\r\n\t\r\n\t\t\t\tvar a = ix + gridX1 * iy;\r\n\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\r\n\t\r\n\t\t\t\tindices[ offset ] = a;\r\n\t\t\t\tindices[ offset + 1 ] = b;\r\n\t\t\t\tindices[ offset + 2 ] = d;\r\n\t\r\n\t\t\t\tindices[ offset + 3 ] = b;\r\n\t\t\t\tindices[ offset + 4 ] = c;\r\n\t\t\t\tindices[ offset + 5 ] = d;\r\n\t\r\n\t\t\t\toffset += 6;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/RingBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Mugen87 / https://github.com/Mugen87\r\n\t */\r\n\t\r\n\tTHREE.RingBufferGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'RingBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tinnerRadius: innerRadius,\r\n\t\t\touterRadius: outerRadius,\r\n\t\t\tthetaSegments: thetaSegments,\r\n\t\t\tphiSegments: phiSegments,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tinnerRadius = innerRadius || 20;\r\n\t\touterRadius = outerRadius || 50;\r\n\t\r\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\t\r\n\t\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\r\n\t\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\r\n\t\r\n\t\t// these are used to calculate buffer length\r\n\t\tvar vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );\r\n\t\tvar indexCount = thetaSegments * phiSegments * 2 * 3;\r\n\t\r\n\t\t// buffers\r\n\t\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\r\n\t\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\t\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\t\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\t\r\n\t\t// some helper variables\r\n\t\tvar index = 0, indexOffset = 0, segment;\r\n\t\tvar radius = innerRadius;\r\n\t\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\r\n\t\tvar vertex = new THREE.Vector3();\r\n\t\tvar uv = new THREE.Vector2();\r\n\t\tvar j, i;\r\n\t\r\n\t\t// generate vertices, normals and uvs\r\n\t\r\n\t\t// values are generate from the inside of the ring to the outside\r\n\t\r\n\t\tfor ( j = 0; j <= phiSegments; j ++ ) {\r\n\t\r\n\t\t\tfor ( i = 0; i <= thetaSegments; i ++ ) {\r\n\t\r\n\t\t\t\tsegment = thetaStart + i / thetaSegments * thetaLength;\r\n\t\r\n\t\t\t\t// vertex\r\n\t\t\t\tvertex.x = radius * Math.cos( segment );\r\n\t\t\t\tvertex.y = radius * Math.sin( segment );\r\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\t\r\n\t\t\t\t// normal\r\n\t\t\t\tnormals.setXYZ( index, 0, 0, 1 );\r\n\t\r\n\t\t\t\t// uv\r\n\t\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\r\n\t\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\r\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\r\n\t\r\n\t\t\t\t// increase index\r\n\t\t\t\tindex++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// increase the radius for next row of vertices\r\n\t\t\tradius += radiusStep;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// generate indices\r\n\t\r\n\t\tfor ( j = 0; j < phiSegments; j ++ ) {\r\n\t\r\n\t\t\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\r\n\t\r\n\t\t\tfor ( i = 0; i < thetaSegments; i ++ ) {\r\n\t\r\n\t\t\t\tsegment = i + thetaSegmentLevel;\r\n\t\r\n\t\t\t\t// indices\r\n\t\t\t\tvar a = segment;\r\n\t\t\t\tvar b = segment + thetaSegments + 1;\r\n\t\t\t\tvar c = segment + thetaSegments + 2;\r\n\t\t\t\tvar d = segment + 1;\r\n\t\r\n\t\t\t\t// face one\r\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\t\r\n\t\t\t\t// face two\r\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// build geometry\r\n\t\r\n\t\tthis.setIndex( indices );\r\n\t\tthis.addAttribute( 'position', vertices );\r\n\t\tthis.addAttribute( 'normal', normals );\r\n\t\tthis.addAttribute( 'uv', uvs );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.RingBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.RingBufferGeometry.prototype.constructor = THREE.RingBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/RingGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Kaleb Murphy\r\n\t */\r\n\t\r\n\tTHREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'RingGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tinnerRadius: innerRadius,\r\n\t\t\touterRadius: outerRadius,\r\n\t\t\tthetaSegments: thetaSegments,\r\n\t\t\tphiSegments: phiSegments,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.RingGeometry.prototype.constructor = THREE.RingGeometry;\r\n\t\r\n\t// File:src/extras/geometries/SphereGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'SphereGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\tphiStart: phiStart,\r\n\t\t\tphiLength: phiLength,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;\r\n\t\r\n\t// File:src/extras/geometries/SphereBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author benaadams / https://twitter.com/ben_a_adams\r\n\t * based on THREE.SphereGeometry\r\n\t */\r\n\t\r\n\tTHREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'SphereBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\tphiStart: phiStart,\r\n\t\t\tphiLength: phiLength,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tradius = radius || 50;\r\n\t\r\n\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\r\n\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\r\n\t\r\n\t\tphiStart = phiStart !== undefined ? phiStart : 0;\r\n\t\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\r\n\t\r\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\r\n\t\r\n\t\tvar thetaEnd = thetaStart + thetaLength;\r\n\t\r\n\t\tvar vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );\r\n\t\r\n\t\tvar positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\t\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\t\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\t\r\n\t\tvar index = 0, vertices = [], normal = new THREE.Vector3();\r\n\t\r\n\t\tfor ( var y = 0; y <= heightSegments; y ++ ) {\r\n\t\r\n\t\t\tvar verticesRow = [];\r\n\t\r\n\t\t\tvar v = y / heightSegments;\r\n\t\r\n\t\t\tfor ( var x = 0; x <= widthSegments; x ++ ) {\r\n\t\r\n\t\t\t\tvar u = x / widthSegments;\r\n\t\r\n\t\t\t\tvar px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\t\t\t\tvar py = radius * Math.cos( thetaStart + v * thetaLength );\r\n\t\t\t\tvar pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\t\r\n\t\t\t\tnormal.set( px, py, pz ).normalize();\r\n\t\r\n\t\t\t\tpositions.setXYZ( index, px, py, pz );\r\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\r\n\t\t\t\tuvs.setXY( index, u, 1 - v );\r\n\t\r\n\t\t\t\tverticesRow.push( index );\r\n\t\r\n\t\t\t\tindex ++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvertices.push( verticesRow );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar indices = [];\r\n\t\r\n\t\tfor ( var y = 0; y < heightSegments; y ++ ) {\r\n\t\r\n\t\t\tfor ( var x = 0; x < widthSegments; x ++ ) {\r\n\t\r\n\t\t\t\tvar v1 = vertices[ y ][ x + 1 ];\r\n\t\t\t\tvar v2 = vertices[ y ][ x ];\r\n\t\t\t\tvar v3 = vertices[ y + 1 ][ x ];\r\n\t\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\r\n\t\r\n\t\t\t\tif ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );\r\n\t\t\t\tif ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.setIndex( new ( positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute )( indices, 1 ) );\r\n\t\tthis.addAttribute( 'position', positions );\r\n\t\tthis.addAttribute( 'normal', normals );\r\n\t\tthis.addAttribute( 'uv', uvs );\r\n\t\r\n\t\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TextGeometry.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * Text = 3D Text\r\n\t *\r\n\t * parameters = {\r\n\t *  font: <THREE.Font>, // font\r\n\t *\r\n\t *  size: <float>, // size of the text\r\n\t *  height: <float>, // thickness to extrude text\r\n\t *  curveSegments: <int>, // number of points on the curves\r\n\t *\r\n\t *  bevelEnabled: <bool>, // turn on bevel\r\n\t *  bevelThickness: <float>, // how deep into text bevel goes\r\n\t *  bevelSize: <float> // how far from text outline is bevel\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.TextGeometry = function ( text, parameters ) {\r\n\t\r\n\t\tparameters = parameters || {};\r\n\t\r\n\t\tvar font = parameters.font;\r\n\t\r\n\t\tif ( font instanceof THREE.Font === false ) {\r\n\t\r\n\t\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\r\n\t\t\treturn new THREE.Geometry();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\r\n\t\r\n\t\t// translate parameters to ExtrudeGeometry API\r\n\t\r\n\t\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\r\n\t\r\n\t\t// defaults\r\n\t\r\n\t\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\r\n\t\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\r\n\t\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\r\n\t\r\n\t\tTHREE.ExtrudeGeometry.call( this, shapes, parameters );\r\n\t\r\n\t\tthis.type = 'TextGeometry';\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\r\n\tTHREE.TextGeometry.prototype.constructor = THREE.TextGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TorusBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Mugen87 / https://github.com/Mugen87\r\n\t */\r\n\t\r\n\tTHREE.TorusBufferGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'TorusBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\ttube: tube,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\ttubularSegments: tubularSegments,\r\n\t\t\tarc: arc\r\n\t\t};\r\n\t\r\n\t\tradius = radius || 100;\r\n\t\ttube = tube || 40;\r\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\r\n\t\ttubularSegments = Math.floor( tubularSegments ) || 6;\r\n\t\tarc = arc || Math.PI * 2;\r\n\t\r\n\t\t// used to calculate buffer length\r\n\t\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\r\n\t\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\r\n\t\r\n\t\t// buffers\r\n\t\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\r\n\t\tvar vertices = new Float32Array( vertexCount * 3 );\r\n\t\tvar normals = new Float32Array( vertexCount * 3 );\r\n\t\tvar uvs = new Float32Array( vertexCount * 2 );\r\n\t\r\n\t\t// offset variables\r\n\t\tvar vertexBufferOffset = 0;\r\n\t\tvar uvBufferOffset = 0;\r\n\t\tvar indexBufferOffset = 0;\r\n\t\r\n\t\t// helper variables\r\n\t\tvar center = new THREE.Vector3();\r\n\t\tvar vertex = new THREE.Vector3();\r\n\t\tvar normal = new THREE.Vector3();\r\n\t\r\n\t\tvar j, i;\r\n\t\r\n\t\t// generate vertices, normals and uvs\r\n\t\r\n\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\r\n\t\r\n\t\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\r\n\t\r\n\t\t\t\tvar u = i / tubularSegments * arc;\r\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\r\n\t\r\n\t\t\t\t// vertex\r\n\t\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\r\n\t\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\r\n\t\t\t\tvertex.z = tube * Math.sin( v );\r\n\t\r\n\t\t\t\tvertices[ vertexBufferOffset ] = vertex.x;\r\n\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vertex.y;\r\n\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vertex.z;\r\n\t\r\n\t\t\t\t// this vector is used to calculate the normal\r\n\t\t\t\tcenter.x = radius * Math.cos( u );\r\n\t\t\t\tcenter.y = radius * Math.sin( u );\r\n\t\r\n\t\t\t\t// normal\r\n\t\t\t\tnormal.subVectors( vertex, center ).normalize();\r\n\t\r\n\t\t\t\tnormals[ vertexBufferOffset ] = normal.x;\r\n\t\t\t\tnormals[ vertexBufferOffset + 1 ] = normal.y;\r\n\t\t\t\tnormals[ vertexBufferOffset + 2 ] = normal.z;\r\n\t\r\n\t\t\t\t// uv\r\n\t\t\t\tuvs[ uvBufferOffset ] = i / tubularSegments;\r\n\t\t\t\tuvs[ uvBufferOffset + 1 ] = j / radialSegments;\r\n\t\r\n\t\t\t\t// update offsets\r\n\t\t\t\tvertexBufferOffset += 3;\r\n\t\t\t\tuvBufferOffset += 2;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// generate indices\r\n\t\r\n\t\tfor ( j = 1; j <= radialSegments; j ++ ) {\r\n\t\r\n\t\t\tfor ( i = 1; i <= tubularSegments; i ++ ) {\r\n\t\r\n\t\t\t\t// indices\r\n\t\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\r\n\t\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\r\n\t\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\r\n\t\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\r\n\t\r\n\t\t\t\t// face one\r\n\t\t\t\tindices[ indexBufferOffset ] = a;\r\n\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\r\n\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\r\n\t\r\n\t\t\t\t// face two\r\n\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\r\n\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\r\n\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\r\n\t\r\n\t\t\t\t// update offset\r\n\t\t\t\tindexBufferOffset += 6;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// build geometry\r\n\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TorusBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.TorusBufferGeometry.prototype.constructor = THREE.TorusBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TorusGeometry.js\r\n\t\r\n\t/**\r\n\t * @author oosmoxiecode\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\r\n\t */\r\n\t\r\n\tTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'TorusGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\ttube: tube,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\ttubularSegments: tubularSegments,\r\n\t\t\tarc: arc\r\n\t\t};\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TorusKnotBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Mugen87 / https://github.com/Mugen87\r\n\t *\r\n\t * see: http://www.blackpawn.com/texts/pqtorus/\r\n\t */\r\n\tTHREE.TorusKnotBufferGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'TorusKnotBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\ttube: tube,\r\n\t\t\ttubularSegments: tubularSegments,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\tp: p,\r\n\t\t\tq: q\r\n\t\t};\r\n\t\r\n\t\tradius = radius || 100;\r\n\t\ttube = tube || 40;\r\n\t\ttubularSegments = Math.floor( tubularSegments ) || 64;\r\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\r\n\t\tp = p || 2;\r\n\t\tq = q || 3;\r\n\t\r\n\t\t// used to calculate buffer length\r\n\t\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\r\n\t\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\r\n\t\r\n\t\t// buffers\r\n\t\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\r\n\t\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\t\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\t\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\t\r\n\t\t// helper variables\r\n\t\tvar i, j, index = 0, indexOffset = 0;\r\n\t\r\n\t\tvar vertex = new THREE.Vector3();\r\n\t\tvar normal = new THREE.Vector3();\r\n\t\tvar uv = new THREE.Vector2();\r\n\t\r\n\t\tvar P1 = new THREE.Vector3();\r\n\t\tvar P2 = new THREE.Vector3();\r\n\t\r\n\t\tvar B = new THREE.Vector3();\r\n\t\tvar T = new THREE.Vector3();\r\n\t\tvar N = new THREE.Vector3();\r\n\t\r\n\t\t// generate vertices, normals and uvs\r\n\t\r\n\t\tfor ( i = 0; i <= tubularSegments; ++ i ) {\r\n\t\r\n\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\r\n\t\r\n\t\t\tvar u = i / tubularSegments * p * Math.PI * 2;\r\n\t\r\n\t\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\r\n\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\r\n\t\r\n\t\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\r\n\t\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\r\n\t\r\n\t\t\t// calculate orthonormal basis\r\n\t\r\n\t\t\tT.subVectors( P2, P1 );\r\n\t\t\tN.addVectors( P2, P1 );\r\n\t\t\tB.crossVectors( T, N );\r\n\t\t\tN.crossVectors( B, T );\r\n\t\r\n\t\t\t// normalize B, N. T can be ignored, we don't use it\r\n\t\r\n\t\t\tB.normalize();\r\n\t\t\tN.normalize();\r\n\t\r\n\t\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\r\n\t\r\n\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\r\n\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\r\n\t\r\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\r\n\t\t\t\tvar cx = - tube * Math.cos( v );\r\n\t\t\t\tvar cy = tube * Math.sin( v );\r\n\t\r\n\t\t\t\t// now calculate the final vertex position.\r\n\t\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\r\n\t\r\n\t\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\r\n\t\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\r\n\t\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\r\n\t\r\n\t\t\t\t// vertex\r\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\t\r\n\t\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\r\n\t\t\t\tnormal.subVectors( vertex, P1 ).normalize();\r\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\r\n\t\r\n\t\t\t\t// uv\r\n\t\t\t\tuv.x = i / tubularSegments;\r\n\t\t\t\tuv.y = j / radialSegments;\r\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\r\n\t\r\n\t\t\t\t// increase index\r\n\t\t\t\tindex ++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// generate indices\r\n\t\r\n\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\r\n\t\r\n\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\r\n\t\r\n\t\t\t\t// indices\r\n\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\r\n\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\r\n\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\r\n\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\r\n\t\r\n\t\t\t\t// face one\r\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\t\r\n\t\t\t\t// face two\r\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// build geometry\r\n\t\r\n\t\tthis.setIndex( indices );\r\n\t\tthis.addAttribute( 'position', vertices );\r\n\t\tthis.addAttribute( 'normal', normals );\r\n\t\tthis.addAttribute( 'uv', uvs );\r\n\t\r\n\t\t// this function calculates the current position on the torus curve\r\n\t\r\n\t\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\r\n\t\r\n\t\t\tvar cu = Math.cos( u );\r\n\t\t\tvar su = Math.sin( u );\r\n\t\t\tvar quOverP = q / p * u;\r\n\t\t\tvar cs = Math.cos( quOverP );\r\n\t\r\n\t\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\r\n\t\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\r\n\t\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TorusKnotBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.TorusKnotBufferGeometry.prototype.constructor = THREE.TorusKnotBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TorusKnotGeometry.js\r\n\t\r\n\t/**\r\n\t * @author oosmoxiecode\r\n\t */\r\n\t\r\n\tTHREE.TorusKnotGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'TorusKnotGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\ttube: tube,\r\n\t\t\ttubularSegments: tubularSegments,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\tp: p,\r\n\t\t\tq: q\r\n\t\t};\r\n\t\r\n\t\tif( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\r\n\t\tthis.mergeVertices();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TubeGeometry.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / https://github.com/WestLangley\r\n\t * @author zz85 / https://github.com/zz85\r\n\t * @author miningold / https://github.com/miningold\r\n\t * @author jonobr1 / https://github.com/jonobr1\r\n\t *\r\n\t * Modified from the TorusKnotGeometry by @oosmoxiecode\r\n\t *\r\n\t * Creates a tube which extrudes along a 3d spline\r\n\t *\r\n\t * Uses parallel transport frames as described in\r\n\t * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\r\n\t */\r\n\t\r\n\tTHREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'TubeGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tpath: path,\r\n\t\t\tsegments: segments,\r\n\t\t\tradius: radius,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\tclosed: closed,\r\n\t\t\ttaper: taper\r\n\t\t};\r\n\t\r\n\t\tsegments = segments || 64;\r\n\t\tradius = radius || 1;\r\n\t\tradialSegments = radialSegments || 8;\r\n\t\tclosed = closed || false;\r\n\t\ttaper = taper || THREE.TubeGeometry.NoTaper;\r\n\t\r\n\t\tvar grid = [];\r\n\t\r\n\t\tvar scope = this,\r\n\t\r\n\t\t\ttangent,\r\n\t\t\tnormal,\r\n\t\t\tbinormal,\r\n\t\r\n\t\t\tnumpoints = segments + 1,\r\n\t\r\n\t\t\tu, v, r,\r\n\t\r\n\t\t\tcx, cy,\r\n\t\t\tpos, pos2 = new THREE.Vector3(),\r\n\t\t\ti, j,\r\n\t\t\tip, jp,\r\n\t\t\ta, b, c, d,\r\n\t\t\tuva, uvb, uvc, uvd;\r\n\t\r\n\t\tvar frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),\r\n\t\t\ttangents = frames.tangents,\r\n\t\t\tnormals = frames.normals,\r\n\t\t\tbinormals = frames.binormals;\r\n\t\r\n\t\t// proxy internals\r\n\t\tthis.tangents = tangents;\r\n\t\tthis.normals = normals;\r\n\t\tthis.binormals = binormals;\r\n\t\r\n\t\tfunction vert( x, y, z ) {\r\n\t\r\n\t\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// construct the grid\r\n\t\r\n\t\tfor ( i = 0; i < numpoints; i ++ ) {\r\n\t\r\n\t\t\tgrid[ i ] = [];\r\n\t\r\n\t\t\tu = i / ( numpoints - 1 );\r\n\t\r\n\t\t\tpos = path.getPointAt( u );\r\n\t\r\n\t\t\ttangent = tangents[ i ];\r\n\t\t\tnormal = normals[ i ];\r\n\t\t\tbinormal = binormals[ i ];\r\n\t\r\n\t\t\tr = radius * taper( u );\r\n\t\r\n\t\t\tfor ( j = 0; j < radialSegments; j ++ ) {\r\n\t\r\n\t\t\t\tv = j / radialSegments * 2 * Math.PI;\r\n\t\r\n\t\t\t\tcx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\r\n\t\t\t\tcy = r * Math.sin( v );\r\n\t\r\n\t\t\t\tpos2.copy( pos );\r\n\t\t\t\tpos2.x += cx * normal.x + cy * binormal.x;\r\n\t\t\t\tpos2.y += cx * normal.y + cy * binormal.y;\r\n\t\t\t\tpos2.z += cx * normal.z + cy * binormal.z;\r\n\t\r\n\t\t\t\tgrid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// construct the mesh\r\n\t\r\n\t\tfor ( i = 0; i < segments; i ++ ) {\r\n\t\r\n\t\t\tfor ( j = 0; j < radialSegments; j ++ ) {\r\n\t\r\n\t\t\t\tip = ( closed ) ? ( i + 1 ) % segments : i + 1;\r\n\t\t\t\tjp = ( j + 1 ) % radialSegments;\r\n\t\r\n\t\t\t\ta = grid[ i ][ j ];\t\t// *** NOT NECESSARILY PLANAR ! ***\r\n\t\t\t\tb = grid[ ip ][ j ];\r\n\t\t\t\tc = grid[ ip ][ jp ];\r\n\t\t\t\td = grid[ i ][ jp ];\r\n\t\r\n\t\t\t\tuva = new THREE.Vector2( i / segments, j / radialSegments );\r\n\t\t\t\tuvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );\r\n\t\t\t\tuvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );\r\n\t\t\t\tuvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\tthis.computeVertexNormals();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;\r\n\t\r\n\tTHREE.TubeGeometry.NoTaper = function ( u ) {\r\n\t\r\n\t\treturn 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TubeGeometry.SinusoidalTaper = function ( u ) {\r\n\t\r\n\t\treturn Math.sin( Math.PI * u );\r\n\t\r\n\t};\r\n\t\r\n\t// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\r\n\tTHREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {\r\n\t\r\n\t\tvar\tnormal = new THREE.Vector3(),\r\n\t\r\n\t\t\ttangents = [],\r\n\t\t\tnormals = [],\r\n\t\t\tbinormals = [],\r\n\t\r\n\t\t\tvec = new THREE.Vector3(),\r\n\t\t\tmat = new THREE.Matrix4(),\r\n\t\r\n\t\t\tnumpoints = segments + 1,\r\n\t\t\ttheta,\r\n\t\t\tsmallest,\r\n\t\r\n\t\t\ttx, ty, tz,\r\n\t\t\ti, u;\r\n\t\r\n\t\r\n\t\t// expose internals\r\n\t\tthis.tangents = tangents;\r\n\t\tthis.normals = normals;\r\n\t\tthis.binormals = binormals;\r\n\t\r\n\t\t// compute the tangent vectors for each segment on the path\r\n\t\r\n\t\tfor ( i = 0; i < numpoints; i ++ ) {\r\n\t\r\n\t\t\tu = i / ( numpoints - 1 );\r\n\t\r\n\t\t\ttangents[ i ] = path.getTangentAt( u );\r\n\t\t\ttangents[ i ].normalize();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tinitialNormal3();\r\n\t\r\n\t\t/*\r\n\t\tfunction initialNormal1(lastBinormal) {\r\n\t\t\t// fixed start binormal. Has dangers of 0 vectors\r\n\t\t\tnormals[ 0 ] = new THREE.Vector3();\r\n\t\t\tbinormals[ 0 ] = new THREE.Vector3();\r\n\t\t\tif (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\r\n\t\t\tnormals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\r\n\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\t\t}\r\n\t\r\n\t\tfunction initialNormal2() {\r\n\t\r\n\t\t\t// This uses the Frenet-Serret formula for deriving binormal\r\n\t\t\tvar t2 = path.getTangentAt( epsilon );\r\n\t\r\n\t\t\tnormals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\r\n\t\t\tbinormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\t\r\n\t\t\tnormals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\r\n\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\t\r\n\t\t}\r\n\t\t*/\r\n\t\r\n\t\tfunction initialNormal3() {\r\n\t\r\n\t\t\t// select an initial normal vector perpendicular to the first tangent vector,\r\n\t\t\t// and in the direction of the smallest tangent xyz component\r\n\t\r\n\t\t\tnormals[ 0 ] = new THREE.Vector3();\r\n\t\t\tbinormals[ 0 ] = new THREE.Vector3();\r\n\t\t\tsmallest = Number.MAX_VALUE;\r\n\t\t\ttx = Math.abs( tangents[ 0 ].x );\r\n\t\t\tty = Math.abs( tangents[ 0 ].y );\r\n\t\t\ttz = Math.abs( tangents[ 0 ].z );\r\n\t\r\n\t\t\tif ( tx <= smallest ) {\r\n\t\r\n\t\t\t\tsmallest = tx;\r\n\t\t\t\tnormal.set( 1, 0, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( ty <= smallest ) {\r\n\t\r\n\t\t\t\tsmallest = ty;\r\n\t\t\t\tnormal.set( 0, 1, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( tz <= smallest ) {\r\n\t\r\n\t\t\t\tnormal.set( 0, 0, 1 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\r\n\t\r\n\t\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\r\n\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// compute the slowly-varying normal and binormal vectors for each segment on the path\r\n\t\r\n\t\tfor ( i = 1; i < numpoints; i ++ ) {\r\n\t\r\n\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\r\n\t\r\n\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\r\n\t\r\n\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\r\n\t\r\n\t\t\tif ( vec.length() > Number.EPSILON ) {\r\n\t\r\n\t\t\t\tvec.normalize();\r\n\t\r\n\t\t\t\ttheta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\r\n\t\r\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\r\n\t\r\n\t\tif ( closed ) {\r\n\t\r\n\t\t\ttheta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );\r\n\t\t\ttheta /= ( numpoints - 1 );\r\n\t\r\n\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {\r\n\t\r\n\t\t\t\ttheta = - theta;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( i = 1; i < numpoints; i ++ ) {\r\n\t\r\n\t\t\t\t// twist a little...\r\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\r\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/geometries/PolyhedronGeometry.js\r\n\t\r\n\t/**\r\n\t * @author clockworkgeek / https://github.com/clockworkgeek\r\n\t * @author timothypratley / https://github.com/timothypratley\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t*/\r\n\t\r\n\tTHREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'PolyhedronGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tvertices: vertices,\r\n\t\t\tindices: indices,\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\t\r\n\t\tradius = radius || 1;\r\n\t\tdetail = detail || 0;\r\n\t\r\n\t\tvar that = this;\r\n\t\r\n\t\tfor ( var i = 0, l = vertices.length; i < l; i += 3 ) {\r\n\t\r\n\t\t\tprepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar p = this.vertices;\r\n\t\r\n\t\tvar faces = [];\r\n\t\r\n\t\tfor ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {\r\n\t\r\n\t\t\tvar v1 = p[ indices[ i ] ];\r\n\t\t\tvar v2 = p[ indices[ i + 1 ] ];\r\n\t\t\tvar v3 = p[ indices[ i + 2 ] ];\r\n\t\r\n\t\t\tfaces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, j );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar centroid = new THREE.Vector3();\r\n\t\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tsubdivide( faces[ i ], detail );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Handle case when face straddles the seam\r\n\t\r\n\t\tfor ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {\r\n\t\r\n\t\t\tvar uvs = this.faceVertexUvs[ 0 ][ i ];\r\n\t\r\n\t\t\tvar x0 = uvs[ 0 ].x;\r\n\t\t\tvar x1 = uvs[ 1 ].x;\r\n\t\t\tvar x2 = uvs[ 2 ].x;\r\n\t\r\n\t\t\tvar max = Math.max( x0, x1, x2 );\r\n\t\t\tvar min = Math.min( x0, x1, x2 );\r\n\t\r\n\t\t\tif ( max > 0.9 && min < 0.1 ) {\r\n\t\r\n\t\t\t\t// 0.9 is somewhat arbitrary\r\n\t\r\n\t\t\t\tif ( x0 < 0.2 ) uvs[ 0 ].x += 1;\r\n\t\t\t\tif ( x1 < 0.2 ) uvs[ 1 ].x += 1;\r\n\t\t\t\tif ( x2 < 0.2 ) uvs[ 2 ].x += 1;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Apply radius\r\n\t\r\n\t\tfor ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tthis.vertices[ i ].multiplyScalar( radius );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Merge vertices\r\n\t\r\n\t\tthis.mergeVertices();\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\r\n\t\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\t\r\n\t\r\n\t\t// Project vector onto sphere's surface\r\n\t\r\n\t\tfunction prepare( vector ) {\r\n\t\r\n\t\t\tvar vertex = vector.normalize().clone();\r\n\t\t\tvertex.index = that.vertices.push( vertex ) - 1;\r\n\t\r\n\t\t\t// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\r\n\t\r\n\t\t\tvar u = azimuth( vector ) / 2 / Math.PI + 0.5;\r\n\t\t\tvar v = inclination( vector ) / Math.PI + 0.5;\r\n\t\t\tvertex.uv = new THREE.Vector2( u, 1 - v );\r\n\t\r\n\t\t\treturn vertex;\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Approximate a curved face with recursively sub-divided triangles.\r\n\t\r\n\t\tfunction make( v1, v2, v3, materialIndex ) {\r\n\t\r\n\t\t\tvar face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, materialIndex );\r\n\t\t\tthat.faces.push( face );\r\n\t\r\n\t\t\tcentroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\r\n\t\r\n\t\t\tvar azi = azimuth( centroid );\r\n\t\r\n\t\t\tthat.faceVertexUvs[ 0 ].push( [\r\n\t\t\t\tcorrectUV( v1.uv, v1, azi ),\r\n\t\t\t\tcorrectUV( v2.uv, v2, azi ),\r\n\t\t\t\tcorrectUV( v3.uv, v3, azi )\r\n\t\t\t] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Analytically subdivide a face to the required detail level.\r\n\t\r\n\t\tfunction subdivide( face, detail ) {\r\n\t\r\n\t\t\tvar cols = Math.pow( 2, detail );\r\n\t\t\tvar a = prepare( that.vertices[ face.a ] );\r\n\t\t\tvar b = prepare( that.vertices[ face.b ] );\r\n\t\t\tvar c = prepare( that.vertices[ face.c ] );\r\n\t\t\tvar v = [];\r\n\t\r\n\t\t\tvar materialIndex = face.materialIndex;\r\n\t\r\n\t\t\t// Construct all of the vertices for this subdivision.\r\n\t\r\n\t\t\tfor ( var i = 0 ; i <= cols; i ++ ) {\r\n\t\r\n\t\t\t\tv[ i ] = [];\r\n\t\r\n\t\t\t\tvar aj = prepare( a.clone().lerp( c, i / cols ) );\r\n\t\t\t\tvar bj = prepare( b.clone().lerp( c, i / cols ) );\r\n\t\t\t\tvar rows = cols - i;\r\n\t\r\n\t\t\t\tfor ( var j = 0; j <= rows; j ++ ) {\r\n\t\r\n\t\t\t\t\tif ( j === 0 && i === cols ) {\r\n\t\r\n\t\t\t\t\t\tv[ i ][ j ] = aj;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tv[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Construct all of the faces.\r\n\t\r\n\t\t\tfor ( var i = 0; i < cols ; i ++ ) {\r\n\t\r\n\t\t\t\tfor ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar k = Math.floor( j / 2 );\r\n\t\r\n\t\t\t\t\tif ( j % 2 === 0 ) {\r\n\t\r\n\t\t\t\t\t\tmake(\r\n\t\t\t\t\t\t\tv[ i ][ k + 1 ],\r\n\t\t\t\t\t\t\tv[ i + 1 ][ k ],\r\n\t\t\t\t\t\t\tv[ i ][ k ],\r\n\t\t\t\t\t\t\tmaterialIndex\r\n\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tmake(\r\n\t\t\t\t\t\t\tv[ i ][ k + 1 ],\r\n\t\t\t\t\t\t\tv[ i + 1 ][ k + 1 ],\r\n\t\t\t\t\t\t\tv[ i + 1 ][ k ],\r\n\t\t\t\t\t\t\tmaterialIndex\r\n\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Angle around the Y axis, counter-clockwise when looking from above.\r\n\t\r\n\t\tfunction azimuth( vector ) {\r\n\t\r\n\t\t\treturn Math.atan2( vector.z, - vector.x );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Angle above the XZ plane.\r\n\t\r\n\t\tfunction inclination( vector ) {\r\n\t\r\n\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Texture fixing helper. Spheres have some odd behaviours.\r\n\t\r\n\t\tfunction correctUV( uv, vector, azimuth ) {\r\n\t\r\n\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\r\n\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\r\n\t\t\treturn uv.clone();\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;\r\n\t\r\n\t// File:src/extras/geometries/DodecahedronGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Abe Pazos / https://hamoid.com\r\n\t */\r\n\t\r\n\tTHREE.DodecahedronGeometry = function ( radius, detail ) {\r\n\t\r\n\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\t\tvar r = 1 / t;\r\n\t\r\n\t\tvar vertices = [\r\n\t\r\n\t\t\t// (1, 1, 1)\r\n\t\t\t- 1, - 1, - 1,    - 1, - 1,  1,\r\n\t\t\t- 1,  1, - 1,    - 1,  1,  1,\r\n\t\t\t 1, - 1, - 1,     1, - 1,  1,\r\n\t\t\t 1,  1, - 1,     1,  1,  1,\r\n\t\r\n\t\t\t// (0, 1/, )\r\n\t\t\t 0, - r, - t,     0, - r,  t,\r\n\t\t\t 0,  r, - t,     0,  r,  t,\r\n\t\r\n\t\t\t// (1/, , 0)\r\n\t\t\t- r, - t,  0,    - r,  t,  0,\r\n\t\t\t r, - t,  0,     r,  t,  0,\r\n\t\r\n\t\t\t// (, 0, 1/)\r\n\t\t\t- t,  0, - r,     t,  0, - r,\r\n\t\t\t- t,  0,  r,     t,  0,  r\r\n\t\t];\r\n\t\r\n\t\tvar indices = [\r\n\t\t\t 3, 11,  7,      3,  7, 15,      3, 15, 13,\r\n\t\t\t 7, 19, 17,      7, 17,  6,      7,  6, 15,\r\n\t\t\t17,  4,  8,     17,  8, 10,     17, 10,  6,\r\n\t\t\t 8,  0, 16,      8, 16,  2,      8,  2, 10,\r\n\t\t\t 0, 12,  1,      0,  1, 18,      0, 18, 16,\r\n\t\t\t 6, 10,  2,      6,  2, 13,      6, 13, 15,\r\n\t\t\t 2, 16, 18,      2, 18,  3,      2,  3, 13,\r\n\t\t\t18,  1,  9,     18,  9, 11,     18, 11,  3,\r\n\t\t\t 4, 14, 12,      4, 12,  0,      4,  0,  8,\r\n\t\t\t11,  9,  5,     11,  5, 19,     11, 19,  7,\r\n\t\t\t19,  5, 14,     19, 14,  4,     19,  4, 17,\r\n\t\t\t 1, 12, 14,      1, 14,  5,      1,  5,  9\r\n\t\t];\r\n\t\r\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\t\r\n\t\tthis.type = 'DodecahedronGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\n\tTHREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;\r\n\t\r\n\t// File:src/extras/geometries/IcosahedronGeometry.js\r\n\t\r\n\t/**\r\n\t * @author timothypratley / https://github.com/timothypratley\r\n\t */\r\n\t\r\n\tTHREE.IcosahedronGeometry = function ( radius, detail ) {\r\n\t\r\n\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\t\r\n\t\tvar vertices = [\r\n\t\t\t- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\r\n\t\t\t 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\r\n\t\t\t t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\r\n\t\t];\r\n\t\r\n\t\tvar indices = [\r\n\t\t\t 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\r\n\t\t\t 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\r\n\t\t\t 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\r\n\t\t\t 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\r\n\t\t];\r\n\t\r\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\t\r\n\t\tthis.type = 'IcosahedronGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\n\tTHREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;\r\n\t\r\n\t// File:src/extras/geometries/OctahedronGeometry.js\r\n\t\r\n\t/**\r\n\t * @author timothypratley / https://github.com/timothypratley\r\n\t */\r\n\t\r\n\tTHREE.OctahedronGeometry = function ( radius, detail ) {\r\n\t\r\n\t\tvar vertices = [\r\n\t\t\t1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1\r\n\t\t];\r\n\t\r\n\t\tvar indices = [\r\n\t\t\t0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\r\n\t\t];\r\n\t\r\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\t\r\n\t\tthis.type = 'OctahedronGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\n\tTHREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TetrahedronGeometry.js\r\n\t\r\n\t/**\r\n\t * @author timothypratley / https://github.com/timothypratley\r\n\t */\r\n\t\r\n\tTHREE.TetrahedronGeometry = function ( radius, detail ) {\r\n\t\r\n\t\tvar vertices = [\r\n\t\t\t 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\r\n\t\t];\r\n\t\r\n\t\tvar indices = [\r\n\t\t\t 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\r\n\t\t];\r\n\t\r\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\t\r\n\t\tthis.type = 'TetrahedronGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\n\tTHREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;\r\n\t\r\n\t// File:src/extras/geometries/ParametricGeometry.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / https://github.com/zz85\r\n\t * Parametric Surfaces Geometry\r\n\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\r\n\t *\r\n\t * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );\r\n\t *\r\n\t */\r\n\t\r\n\tTHREE.ParametricGeometry = function ( func, slices, stacks ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'ParametricGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tfunc: func,\r\n\t\t\tslices: slices,\r\n\t\t\tstacks: stacks\r\n\t\t};\r\n\t\r\n\t\tvar verts = this.vertices;\r\n\t\tvar faces = this.faces;\r\n\t\tvar uvs = this.faceVertexUvs[ 0 ];\r\n\t\r\n\t\tvar i, j, p;\r\n\t\tvar u, v;\r\n\t\r\n\t\tvar sliceCount = slices + 1;\r\n\t\r\n\t\tfor ( i = 0; i <= stacks; i ++ ) {\r\n\t\r\n\t\t\tv = i / stacks;\r\n\t\r\n\t\t\tfor ( j = 0; j <= slices; j ++ ) {\r\n\t\r\n\t\t\t\tu = j / slices;\r\n\t\r\n\t\t\t\tp = func( u, v );\r\n\t\t\t\tverts.push( p );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar a, b, c, d;\r\n\t\tvar uva, uvb, uvc, uvd;\r\n\t\r\n\t\tfor ( i = 0; i < stacks; i ++ ) {\r\n\t\r\n\t\t\tfor ( j = 0; j < slices; j ++ ) {\r\n\t\r\n\t\t\t\ta = i * sliceCount + j;\r\n\t\t\t\tb = i * sliceCount + j + 1;\r\n\t\t\t\tc = ( i + 1 ) * sliceCount + j + 1;\r\n\t\t\t\td = ( i + 1 ) * sliceCount + j;\r\n\t\r\n\t\t\t\tuva = new THREE.Vector2( j / slices, i / stacks );\r\n\t\t\t\tuvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\r\n\t\t\t\tuvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\r\n\t\t\t\tuvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\r\n\t\r\n\t\t\t\tfaces.push( new THREE.Face3( a, b, d ) );\r\n\t\t\t\tuvs.push( [ uva, uvb, uvd ] );\r\n\t\r\n\t\t\t\tfaces.push( new THREE.Face3( b, c, d ) );\r\n\t\t\t\tuvs.push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// console.log(this);\r\n\t\r\n\t\t// magic bullet\r\n\t\t// var diff = this.mergeVertices();\r\n\t\t// console.log('removed ', diff, ' vertices by merging');\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\tthis.computeVertexNormals();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;\r\n\t\r\n\t// File:src/extras/geometries/WireframeGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.WireframeGeometry = function ( geometry ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tvar edge = [ 0, 0 ], hash = {};\r\n\t\r\n\t\tfunction sortFunction( a, b ) {\r\n\t\r\n\t\t\treturn a - b;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar keys = [ 'a', 'b', 'c' ];\r\n\t\r\n\t\tif ( geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\tvar vertices = geometry.vertices;\r\n\t\t\tvar faces = geometry.faces;\r\n\t\t\tvar numEdges = 0;\r\n\t\r\n\t\t\t// allocate maximal size\r\n\t\t\tvar edges = new Uint32Array( 6 * faces.length );\r\n\t\r\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\t\r\n\t\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\r\n\t\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n\t\t\t\t\tedge.sort( sortFunction );\r\n\t\r\n\t\t\t\t\tvar key = edge.toString();\r\n\t\r\n\t\t\t\t\tif ( hash[ key ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\r\n\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n\t\t\t\t\t\thash[ key ] = true;\r\n\t\t\t\t\t\tnumEdges ++;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\t\r\n\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j ] ];\r\n\t\r\n\t\t\t\t\tvar index = 6 * i + 3 * j;\r\n\t\t\t\t\tcoords[ index + 0 ] = vertex.x;\r\n\t\t\t\t\tcoords[ index + 1 ] = vertex.y;\r\n\t\t\t\t\tcoords[ index + 2 ] = vertex.z;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\t\r\n\t\t} else if ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\tif ( geometry.index !== null ) {\r\n\t\r\n\t\t\t\t// Indexed BufferGeometry\r\n\t\r\n\t\t\t\tvar indices = geometry.index.array;\r\n\t\t\t\tvar vertices = geometry.attributes.position;\r\n\t\t\t\tvar groups = geometry.groups;\r\n\t\t\t\tvar numEdges = 0;\r\n\t\r\n\t\t\t\tif ( groups.length === 0 ) {\r\n\t\r\n\t\t\t\t\tgeometry.addGroup( 0, indices.length );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// allocate maximal size\r\n\t\t\t\tvar edges = new Uint32Array( 2 * indices.length );\r\n\t\r\n\t\t\t\tfor ( var o = 0, ol = groups.length; o < ol; ++ o ) {\r\n\t\r\n\t\t\t\t\tvar group = groups[ o ];\r\n\t\r\n\t\t\t\t\tvar start = group.start;\r\n\t\t\t\t\tvar count = group.count;\r\n\t\r\n\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tedge[ 0 ] = indices[ i + j ];\r\n\t\t\t\t\t\t\tedge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];\r\n\t\t\t\t\t\t\tedge.sort( sortFunction );\r\n\t\r\n\t\t\t\t\t\t\tvar key = edge.toString();\r\n\t\r\n\t\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\r\n\t\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n\t\t\t\t\t\t\t\thash[ key ] = true;\r\n\t\t\t\t\t\t\t\tnumEdges ++;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar index = 6 * i + 3 * j;\r\n\t\t\t\t\t\tvar index2 = edges[ 2 * i + j ];\r\n\t\r\n\t\t\t\t\t\tcoords[ index + 0 ] = vertices.getX( index2 );\r\n\t\t\t\t\t\tcoords[ index + 1 ] = vertices.getY( index2 );\r\n\t\t\t\t\t\tcoords[ index + 2 ] = vertices.getZ( index2 );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// non-indexed BufferGeometry\r\n\t\r\n\t\t\t\tvar vertices = geometry.attributes.position.array;\r\n\t\t\t\tvar numEdges = vertices.length / 3;\r\n\t\t\t\tvar numTris = numEdges / 3;\r\n\t\r\n\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar index = 18 * i + 6 * j;\r\n\t\r\n\t\t\t\t\t\tvar index1 = 9 * i + 3 * j;\r\n\t\t\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\r\n\t\t\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\r\n\t\t\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\r\n\t\r\n\t\t\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\r\n\t\t\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\r\n\t\t\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\r\n\t\t\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;\r\n\t\r\n\t// File:src/extras/helpers/AxisHelper.js\r\n\t\r\n\t/**\r\n\t * @author sroucheray / http://sroucheray.org/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.AxisHelper = function ( size ) {\r\n\t\r\n\t\tsize = size || 1;\r\n\t\r\n\t\tvar vertices = new Float32Array( [\r\n\t\t\t0, 0, 0,  size, 0, 0,\r\n\t\t\t0, 0, 0,  0, size, 0,\r\n\t\t\t0, 0, 0,  0, 0, size\r\n\t\t] );\r\n\t\r\n\t\tvar colors = new Float32Array( [\r\n\t\t\t1, 0, 0,  1, 0.6, 0,\r\n\t\t\t0, 1, 0,  0.6, 1, 0,\r\n\t\t\t0, 0, 1,  0, 0.6, 1\r\n\t\t] );\r\n\t\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\t\tgeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\r\n\t\r\n\t\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\t\r\n\t\tTHREE.LineSegments.call( this, geometry, material );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\n\tTHREE.AxisHelper.prototype.constructor = THREE.AxisHelper;\r\n\t\r\n\t// File:src/extras/helpers/ArrowHelper.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @author zz85 / http://github.com/zz85\r\n\t * @author bhouston / http://clara.io\r\n\t *\r\n\t * Creates an arrow for visualizing directions\r\n\t *\r\n\t * Parameters:\r\n\t *  dir - Vector3\r\n\t *  origin - Vector3\r\n\t *  length - Number\r\n\t *  color - color in hex value\r\n\t *  headLength - Number\r\n\t *  headWidth - Number\r\n\t */\r\n\t\r\n\tTHREE.ArrowHelper = ( function () {\r\n\t\r\n\t\tvar lineGeometry = new THREE.Geometry();\r\n\t\tlineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );\r\n\t\r\n\t\tvar coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );\r\n\t\tconeGeometry.translate( 0, - 0.5, 0 );\r\n\t\r\n\t\treturn function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\r\n\t\r\n\t\t\t// dir is assumed to be normalized\r\n\t\r\n\t\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\t\tif ( color === undefined ) color = 0xffff00;\r\n\t\t\tif ( length === undefined ) length = 1;\r\n\t\t\tif ( headLength === undefined ) headLength = 0.2 * length;\r\n\t\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\t\r\n\t\t\tthis.position.copy( origin );\r\n\t\t\t\r\n\t\t\tthis.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );\r\n\t\t\tthis.line.matrixAutoUpdate = false;\r\n\t\t\tthis.add( this.line );\r\n\t\r\n\t\t\tthis.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );\r\n\t\t\tthis.cone.matrixAutoUpdate = false;\r\n\t\t\tthis.add( this.cone );\r\n\t\r\n\t\t\tthis.setDirection( dir );\r\n\t\t\tthis.setLength( length, headLength, headWidth );\r\n\t\r\n\t\t}\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;\r\n\t\r\n\tTHREE.ArrowHelper.prototype.setDirection = ( function () {\r\n\t\r\n\t\tvar axis = new THREE.Vector3();\r\n\t\tvar radians;\r\n\t\r\n\t\treturn function setDirection( dir ) {\r\n\t\r\n\t\t\t// dir is assumed to be normalized\r\n\t\r\n\t\t\tif ( dir.y > 0.99999 ) {\r\n\t\r\n\t\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\r\n\t\r\n\t\t\t} else if ( dir.y < - 0.99999 ) {\r\n\t\r\n\t\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\r\n\t\r\n\t\t\t\tradians = Math.acos( dir.y );\r\n\t\r\n\t\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\r\n\t\r\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\r\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\t\r\n\t\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\r\n\t\tthis.line.updateMatrix();\r\n\t\r\n\t\tthis.cone.scale.set( headWidth, headLength, headWidth );\r\n\t\tthis.cone.position.y = length;\r\n\t\tthis.cone.updateMatrix();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ArrowHelper.prototype.setColor = function ( color ) {\r\n\t\r\n\t\tthis.line.material.color.set( color );\r\n\t\tthis.cone.material.color.set( color );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/helpers/BoxHelper.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.BoxHelper = function ( object ) {\r\n\t\r\n\t\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\r\n\t\tvar positions = new Float32Array( 8 * 3 );\r\n\t\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\r\n\t\r\n\t\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ) );\r\n\t\r\n\t\tif ( object !== undefined ) {\r\n\t\r\n\t\t\tthis.update( object );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\n\tTHREE.BoxHelper.prototype.constructor = THREE.BoxHelper;\r\n\t\r\n\tTHREE.BoxHelper.prototype.update = ( function () {\r\n\t\r\n\t\tvar box = new THREE.Box3();\r\n\t\r\n\t\treturn function ( object ) {\r\n\t\r\n\t\t\tbox.setFromObject( object );\r\n\t\r\n\t\t\tif ( box.isEmpty() ) return;\r\n\t\r\n\t\t\tvar min = box.min;\r\n\t\t\tvar max = box.max;\r\n\t\r\n\t\t\t/*\r\n\t\t\t  5____4\r\n\t\t\t1/___0/|\r\n\t\t\t| 6__|_7\r\n\t\t\t2/___3/\r\n\t\r\n\t\t\t0: max.x, max.y, max.z\r\n\t\t\t1: min.x, max.y, max.z\r\n\t\t\t2: min.x, min.y, max.z\r\n\t\t\t3: max.x, min.y, max.z\r\n\t\t\t4: max.x, max.y, min.z\r\n\t\t\t5: min.x, max.y, min.z\r\n\t\t\t6: min.x, min.y, min.z\r\n\t\t\t7: max.x, min.y, min.z\r\n\t\t\t*/\r\n\t\r\n\t\t\tvar position = this.geometry.attributes.position;\r\n\t\t\tvar array = position.array;\r\n\t\r\n\t\t\tarray[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;\r\n\t\t\tarray[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;\r\n\t\t\tarray[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;\r\n\t\t\tarray[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\r\n\t\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\r\n\t\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\r\n\t\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\r\n\t\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\r\n\t\r\n\t\t\tposition.needsUpdate = true;\r\n\t\r\n\t\t\tthis.geometry.computeBoundingSphere();\r\n\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\t// File:src/extras/helpers/BoundingBoxHelper.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\t// a helper to show the world-axis-aligned bounding box for an object\r\n\t\r\n\tTHREE.BoundingBoxHelper = function ( object, hex ) {\r\n\t\r\n\t\tvar color = ( hex !== undefined ) ? hex : 0x888888;\r\n\t\r\n\t\tthis.object = object;\r\n\t\r\n\t\tthis.box = new THREE.Box3();\r\n\t\r\n\t\tTHREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );\r\n\tTHREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;\r\n\t\r\n\tTHREE.BoundingBoxHelper.prototype.update = function () {\r\n\t\r\n\t\tthis.box.setFromObject( this.object );\r\n\t\r\n\t\tthis.box.size( this.scale );\r\n\t\r\n\t\tthis.box.center( this.position );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/helpers/CameraHelper.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t *\t- shows frustum, line of sight and up of the camera\r\n\t *\t- suitable for fast updates\r\n\t * \t- based on frustum visualization in lightgl.js shadowmap example\r\n\t *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\r\n\t */\r\n\t\r\n\tTHREE.CameraHelper = function ( camera ) {\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\tvar material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\r\n\t\r\n\t\tvar pointMap = {};\r\n\t\r\n\t\t// colors\r\n\t\r\n\t\tvar hexFrustum = 0xffaa00;\r\n\t\tvar hexCone = 0xff0000;\r\n\t\tvar hexUp = 0x00aaff;\r\n\t\tvar hexTarget = 0xffffff;\r\n\t\tvar hexCross = 0x333333;\r\n\t\r\n\t\t// near\r\n\t\r\n\t\taddLine( \"n1\", \"n2\", hexFrustum );\r\n\t\taddLine( \"n2\", \"n4\", hexFrustum );\r\n\t\taddLine( \"n4\", \"n3\", hexFrustum );\r\n\t\taddLine( \"n3\", \"n1\", hexFrustum );\r\n\t\r\n\t\t// far\r\n\t\r\n\t\taddLine( \"f1\", \"f2\", hexFrustum );\r\n\t\taddLine( \"f2\", \"f4\", hexFrustum );\r\n\t\taddLine( \"f4\", \"f3\", hexFrustum );\r\n\t\taddLine( \"f3\", \"f1\", hexFrustum );\r\n\t\r\n\t\t// sides\r\n\t\r\n\t\taddLine( \"n1\", \"f1\", hexFrustum );\r\n\t\taddLine( \"n2\", \"f2\", hexFrustum );\r\n\t\taddLine( \"n3\", \"f3\", hexFrustum );\r\n\t\taddLine( \"n4\", \"f4\", hexFrustum );\r\n\t\r\n\t\t// cone\r\n\t\r\n\t\taddLine( \"p\", \"n1\", hexCone );\r\n\t\taddLine( \"p\", \"n2\", hexCone );\r\n\t\taddLine( \"p\", \"n3\", hexCone );\r\n\t\taddLine( \"p\", \"n4\", hexCone );\r\n\t\r\n\t\t// up\r\n\t\r\n\t\taddLine( \"u1\", \"u2\", hexUp );\r\n\t\taddLine( \"u2\", \"u3\", hexUp );\r\n\t\taddLine( \"u3\", \"u1\", hexUp );\r\n\t\r\n\t\t// target\r\n\t\r\n\t\taddLine( \"c\", \"t\", hexTarget );\r\n\t\taddLine( \"p\", \"c\", hexCross );\r\n\t\r\n\t\t// cross\r\n\t\r\n\t\taddLine( \"cn1\", \"cn2\", hexCross );\r\n\t\taddLine( \"cn3\", \"cn4\", hexCross );\r\n\t\r\n\t\taddLine( \"cf1\", \"cf2\", hexCross );\r\n\t\taddLine( \"cf3\", \"cf4\", hexCross );\r\n\t\r\n\t\tfunction addLine( a, b, hex ) {\r\n\t\r\n\t\t\taddPoint( a, hex );\r\n\t\t\taddPoint( b, hex );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction addPoint( id, hex ) {\r\n\t\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\tgeometry.colors.push( new THREE.Color( hex ) );\r\n\t\r\n\t\t\tif ( pointMap[ id ] === undefined ) {\r\n\t\r\n\t\t\t\tpointMap[ id ] = [];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tTHREE.LineSegments.call( this, geometry, material );\r\n\t\r\n\t\tthis.camera = camera;\r\n\t\tthis.camera.updateProjectionMatrix();\r\n\t\r\n\t\tthis.matrix = camera.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tthis.pointMap = pointMap;\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\n\tTHREE.CameraHelper.prototype.constructor = THREE.CameraHelper;\r\n\t\r\n\tTHREE.CameraHelper.prototype.update = function () {\r\n\t\r\n\t\tvar geometry, pointMap;\r\n\t\r\n\t\tvar vector = new THREE.Vector3();\r\n\t\tvar camera = new THREE.Camera();\r\n\t\r\n\t\tfunction setPoint( point, x, y, z ) {\r\n\t\r\n\t\t\tvector.set( x, y, z ).unproject( camera );\r\n\t\r\n\t\t\tvar points = pointMap[ point ];\r\n\t\r\n\t\t\tif ( points !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tgeometry.vertices[ points[ i ] ].copy( vector );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn function () {\r\n\t\r\n\t\t\tgeometry = this.geometry;\r\n\t\t\tpointMap = this.pointMap;\r\n\t\r\n\t\t\tvar w = 1, h = 1;\r\n\t\r\n\t\t\t// we need just camera projection matrix\r\n\t\t\t// world matrix must be identity\r\n\t\r\n\t\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\r\n\t\r\n\t\t\t// center / target\r\n\t\r\n\t\t\tsetPoint( \"c\", 0, 0, - 1 );\r\n\t\t\tsetPoint( \"t\", 0, 0,  1 );\r\n\t\r\n\t\t\t// near\r\n\t\r\n\t\t\tsetPoint( \"n1\", - w, - h, - 1 );\r\n\t\t\tsetPoint( \"n2\",   w, - h, - 1 );\r\n\t\t\tsetPoint( \"n3\", - w,   h, - 1 );\r\n\t\t\tsetPoint( \"n4\",   w,   h, - 1 );\r\n\t\r\n\t\t\t// far\r\n\t\r\n\t\t\tsetPoint( \"f1\", - w, - h, 1 );\r\n\t\t\tsetPoint( \"f2\",   w, - h, 1 );\r\n\t\t\tsetPoint( \"f3\", - w,   h, 1 );\r\n\t\t\tsetPoint( \"f4\",   w,   h, 1 );\r\n\t\r\n\t\t\t// up\r\n\t\r\n\t\t\tsetPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\r\n\t\t\tsetPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\r\n\t\t\tsetPoint( \"u3\",         0, h * 2,   - 1 );\r\n\t\r\n\t\t\t// cross\r\n\t\r\n\t\t\tsetPoint( \"cf1\", - w,   0, 1 );\r\n\t\t\tsetPoint( \"cf2\",   w,   0, 1 );\r\n\t\t\tsetPoint( \"cf3\",   0, - h, 1 );\r\n\t\t\tsetPoint( \"cf4\",   0,   h, 1 );\r\n\t\r\n\t\t\tsetPoint( \"cn1\", - w,   0, - 1 );\r\n\t\t\tsetPoint( \"cn2\",   w,   0, - 1 );\r\n\t\t\tsetPoint( \"cn3\",   0, - h, - 1 );\r\n\t\t\tsetPoint( \"cn4\",   0,   h, - 1 );\r\n\t\r\n\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\t// File:src/extras/helpers/DirectionalLightHelper.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.DirectionalLightHelper = function ( light, size ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.light = light;\r\n\t\tthis.light.updateMatrixWorld();\r\n\t\r\n\t\tthis.matrix = light.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tsize = size || 1;\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\tgeometry.vertices.push(\r\n\t\t\tnew THREE.Vector3( - size,   size, 0 ),\r\n\t\t\tnew THREE.Vector3(   size,   size, 0 ),\r\n\t\t\tnew THREE.Vector3(   size, - size, 0 ),\r\n\t\t\tnew THREE.Vector3( - size, - size, 0 ),\r\n\t\t\tnew THREE.Vector3( - size,   size, 0 )\r\n\t\t);\r\n\t\r\n\t\tvar material = new THREE.LineBasicMaterial( { fog: false } );\r\n\t\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\tthis.lightPlane = new THREE.Line( geometry, material );\r\n\t\tthis.add( this.lightPlane );\r\n\t\r\n\t\tgeometry = new THREE.Geometry();\r\n\t\tgeometry.vertices.push(\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3()\r\n\t\t);\r\n\t\r\n\t\tmaterial = new THREE.LineBasicMaterial( { fog: false } );\r\n\t\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\tthis.targetLine = new THREE.Line( geometry, material );\r\n\t\tthis.add( this.targetLine );\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;\r\n\t\r\n\tTHREE.DirectionalLightHelper.prototype.dispose = function () {\r\n\t\r\n\t\tthis.lightPlane.geometry.dispose();\r\n\t\tthis.lightPlane.material.dispose();\r\n\t\tthis.targetLine.geometry.dispose();\r\n\t\tthis.targetLine.material.dispose();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DirectionalLightHelper.prototype.update = function () {\r\n\t\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\t\tvar v3 = new THREE.Vector3();\r\n\t\r\n\t\treturn function () {\r\n\t\r\n\t\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\r\n\t\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n\t\t\tv3.subVectors( v2, v1 );\r\n\t\r\n\t\t\tthis.lightPlane.lookAt( v3 );\r\n\t\t\tthis.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\t\tthis.targetLine.geometry.vertices[ 1 ].copy( v3 );\r\n\t\t\tthis.targetLine.geometry.verticesNeedUpdate = true;\r\n\t\t\tthis.targetLine.material.color.copy( this.lightPlane.material.color );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\t// File:src/extras/helpers/EdgesHelper.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @param object THREE.Mesh whose geometry will be used\r\n\t * @param hex line color\r\n\t * @param thresholdAngle the minimum angle (in degrees),\r\n\t * between the face normals of adjacent faces,\r\n\t * that is required to render an edge. A value of 10 means\r\n\t * an edge is only rendered if the angle is at least 10 degrees.\r\n\t */\r\n\t\r\n\tTHREE.EdgesHelper = function ( object, hex, thresholdAngle ) {\r\n\t\r\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\t\r\n\t\tTHREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );\r\n\t\r\n\t\tthis.matrix = object.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\n\tTHREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;\r\n\t\r\n\t// File:src/extras/helpers/FaceNormalsHelper.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t*/\r\n\t\r\n\tTHREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\t\r\n\t\t// FaceNormalsHelper only supports THREE.Geometry\r\n\t\r\n\t\tthis.object = object;\r\n\t\r\n\t\tthis.size = ( size !== undefined ) ? size : 1;\r\n\t\r\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\r\n\t\r\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar nNormals = 0;\r\n\t\r\n\t\tvar objGeometry = this.object.geometry;\r\n\t\r\n\t\tif ( objGeometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\tnNormals = objGeometry.faces.length;\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\r\n\t\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\r\n\t\r\n\t\tgeometry.addAttribute( 'position', positions );\r\n\t\r\n\t\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\r\n\t\r\n\t\t//\r\n\t\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\n\tTHREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;\r\n\t\r\n\tTHREE.FaceNormalsHelper.prototype.update = ( function () {\r\n\t\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\t\tvar normalMatrix = new THREE.Matrix3();\r\n\t\r\n\t\treturn function update() {\r\n\t\r\n\t\t\tthis.object.updateMatrixWorld( true );\r\n\t\r\n\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\r\n\t\r\n\t\t\tvar matrixWorld = this.object.matrixWorld;\r\n\t\r\n\t\t\tvar position = this.geometry.attributes.position;\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar objGeometry = this.object.geometry;\r\n\t\r\n\t\t\tvar vertices = objGeometry.vertices;\r\n\t\r\n\t\t\tvar faces = objGeometry.faces;\r\n\t\r\n\t\t\tvar idx = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\t\tvar normal = face.normal;\r\n\t\r\n\t\t\t\tv1.copy( vertices[ face.a ] )\r\n\t\t\t\t\t.add( vertices[ face.b ] )\r\n\t\t\t\t\t.add( vertices[ face.c ] )\r\n\t\t\t\t\t.divideScalar( 3 )\r\n\t\t\t\t\t.applyMatrix4( matrixWorld );\r\n\t\r\n\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\r\n\t\r\n\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\r\n\t\r\n\t\t\t\tidx = idx + 1;\r\n\t\r\n\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\r\n\t\r\n\t\t\t\tidx = idx + 1;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tposition.needsUpdate = true;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t}() );\r\n\t\r\n\t// File:src/extras/helpers/GridHelper.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.GridHelper = function ( size, step ) {\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\t\r\n\t\tthis.color1 = new THREE.Color( 0x444444 );\r\n\t\tthis.color2 = new THREE.Color( 0x888888 );\r\n\t\r\n\t\tfor ( var i = - size; i <= size; i += step ) {\r\n\t\r\n\t\t\tgeometry.vertices.push(\r\n\t\t\t\tnew THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),\r\n\t\t\t\tnew THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )\r\n\t\t\t);\r\n\t\r\n\t\t\tvar color = i === 0 ? this.color1 : this.color2;\r\n\t\r\n\t\t\tgeometry.colors.push( color, color, color, color );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tTHREE.LineSegments.call( this, geometry, material );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\n\tTHREE.GridHelper.prototype.constructor = THREE.GridHelper;\r\n\t\r\n\tTHREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {\r\n\t\r\n\t\tthis.color1.set( colorCenterLine );\r\n\t\tthis.color2.set( colorGrid );\r\n\t\r\n\t\tthis.geometry.colorsNeedUpdate = true;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/helpers/HemisphereLightHelper.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.HemisphereLightHelper = function ( light, sphereSize ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.light = light;\r\n\t\tthis.light.updateMatrixWorld();\r\n\t\r\n\t\tthis.matrix = light.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tthis.colors = [ new THREE.Color(), new THREE.Color() ];\r\n\t\r\n\t\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\r\n\t\tgeometry.rotateX( - Math.PI / 2 );\r\n\t\r\n\t\tfor ( var i = 0, il = 8; i < il; i ++ ) {\r\n\t\r\n\t\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );\r\n\t\r\n\t\tthis.lightSphere = new THREE.Mesh( geometry, material );\r\n\t\tthis.add( this.lightSphere );\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;\r\n\t\r\n\tTHREE.HemisphereLightHelper.prototype.dispose = function () {\r\n\t\r\n\t\tthis.lightSphere.geometry.dispose();\r\n\t\tthis.lightSphere.material.dispose();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.HemisphereLightHelper.prototype.update = function () {\r\n\t\r\n\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\treturn function () {\r\n\t\r\n\t\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\r\n\t\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\r\n\t\r\n\t\t}\r\n\t\r\n\t}();\r\n\t\r\n\t// File:src/extras/helpers/PointLightHelper.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.PointLightHelper = function ( light, sphereSize ) {\r\n\t\r\n\t\tthis.light = light;\r\n\t\tthis.light.updateMatrixWorld();\r\n\t\r\n\t\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\r\n\t\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\r\n\t\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\tTHREE.Mesh.call( this, geometry, material );\r\n\t\r\n\t\tthis.matrix = this.light.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\t/*\r\n\t\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\r\n\t\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\r\n\t\r\n\t\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\r\n\t\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\r\n\t\r\n\t\tvar d = light.distance;\r\n\t\r\n\t\tif ( d === 0.0 ) {\r\n\t\r\n\t\t\tthis.lightDistance.visible = false;\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.lightDistance.scale.set( d, d, d );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.add( this.lightDistance );\r\n\t\t*/\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );\r\n\tTHREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;\r\n\t\r\n\tTHREE.PointLightHelper.prototype.dispose = function () {\r\n\t\r\n\t\tthis.geometry.dispose();\r\n\t\tthis.material.dispose();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PointLightHelper.prototype.update = function () {\r\n\t\r\n\t\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\t/*\r\n\t\tvar d = this.light.distance;\r\n\t\r\n\t\tif ( d === 0.0 ) {\r\n\t\r\n\t\t\tthis.lightDistance.visible = false;\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.lightDistance.visible = true;\r\n\t\t\tthis.lightDistance.scale.set( d, d, d );\r\n\t\r\n\t\t}\r\n\t\t*/\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/helpers/SkeletonHelper.js\r\n\t\r\n\t/**\r\n\t * @author Sean Griffin / http://twitter.com/sgrif\r\n\t * @author Michael Guerrero / http://realitymeltdown.com\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author ikerr / http://verold.com\r\n\t */\r\n\t\r\n\tTHREE.SkeletonHelper = function ( object ) {\r\n\t\r\n\t\tthis.bones = this.getBoneList( object );\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\r\n\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\r\n\t\r\n\t\t\tvar bone = this.bones[ i ];\r\n\t\r\n\t\t\tif ( bone.parent instanceof THREE.Bone ) {\r\n\t\r\n\t\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\t\tgeometry.colors.push( new THREE.Color( 0, 0, 1 ) );\r\n\t\t\t\tgeometry.colors.push( new THREE.Color( 0, 1, 0 ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tgeometry.dynamic = true;\r\n\t\r\n\t\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );\r\n\t\r\n\t\tTHREE.LineSegments.call( this, geometry, material );\r\n\t\r\n\t\tthis.root = object;\r\n\t\r\n\t\tthis.matrix = object.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\n\tTHREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;\r\n\t\r\n\tTHREE.SkeletonHelper.prototype.getBoneList = function( object ) {\r\n\t\r\n\t\tvar boneList = [];\r\n\t\r\n\t\tif ( object instanceof THREE.Bone ) {\r\n\t\r\n\t\t\tboneList.push( object );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfor ( var i = 0; i < object.children.length; i ++ ) {\r\n\t\r\n\t\t\tboneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn boneList;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SkeletonHelper.prototype.update = function () {\r\n\t\r\n\t\tvar geometry = this.geometry;\r\n\t\r\n\t\tvar matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );\r\n\t\r\n\t\tvar boneMatrix = new THREE.Matrix4();\r\n\t\r\n\t\tvar j = 0;\r\n\t\r\n\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\r\n\t\r\n\t\t\tvar bone = this.bones[ i ];\r\n\t\r\n\t\t\tif ( bone.parent instanceof THREE.Bone ) {\r\n\t\r\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\r\n\t\t\t\tgeometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\r\n\t\r\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\r\n\t\t\t\tgeometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\r\n\t\r\n\t\t\t\tj += 2;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tgeometry.verticesNeedUpdate = true;\r\n\t\r\n\t\tgeometry.computeBoundingSphere();\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/helpers/SpotLightHelper.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t*/\r\n\t\r\n\tTHREE.SpotLightHelper = function ( light ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.light = light;\r\n\t\tthis.light.updateMatrixWorld();\r\n\t\r\n\t\tthis.matrix = light.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tvar geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );\r\n\t\r\n\t\tgeometry.translate( 0, - 0.5, 0 );\r\n\t\tgeometry.rotateX( - Math.PI / 2 );\r\n\t\r\n\t\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\r\n\t\r\n\t\tthis.cone = new THREE.Mesh( geometry, material );\r\n\t\tthis.add( this.cone );\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;\r\n\t\r\n\tTHREE.SpotLightHelper.prototype.dispose = function () {\r\n\t\r\n\t\tthis.cone.geometry.dispose();\r\n\t\tthis.cone.material.dispose();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SpotLightHelper.prototype.update = function () {\r\n\t\r\n\t\tvar vector = new THREE.Vector3();\r\n\t\tvar vector2 = new THREE.Vector3();\r\n\t\r\n\t\treturn function () {\r\n\t\r\n\t\t\tvar coneLength = this.light.distance ? this.light.distance : 10000;\r\n\t\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\r\n\t\r\n\t\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\r\n\t\r\n\t\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\r\n\t\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n\t\r\n\t\t\tthis.cone.lookAt( vector2.sub( vector ) );\r\n\t\r\n\t\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\t// File:src/extras/helpers/VertexNormalsHelper.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t*/\r\n\t\r\n\tTHREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\t\r\n\t\tthis.object = object;\r\n\t\r\n\t\tthis.size = ( size !== undefined ) ? size : 1;\r\n\t\r\n\t\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\r\n\t\r\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar nNormals = 0;\r\n\t\r\n\t\tvar objGeometry = this.object.geometry;\r\n\t\r\n\t\tif ( objGeometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\tnNormals = objGeometry.faces.length * 3;\r\n\t\r\n\t\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\tnNormals = objGeometry.attributes.normal.count\r\n\t\r\n\t\t}\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\r\n\t\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\r\n\t\r\n\t\tgeometry.addAttribute( 'position', positions );\r\n\t\r\n\t\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\r\n\t\r\n\t\t//\r\n\t\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\n\tTHREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;\r\n\t\r\n\tTHREE.VertexNormalsHelper.prototype.update = ( function () {\r\n\t\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\t\tvar normalMatrix = new THREE.Matrix3();\r\n\t\r\n\t\treturn function update() {\r\n\t\r\n\t\t\tvar keys = [ 'a', 'b', 'c' ];\r\n\t\r\n\t\t\tthis.object.updateMatrixWorld( true );\r\n\t\r\n\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\r\n\t\r\n\t\t\tvar matrixWorld = this.object.matrixWorld;\r\n\t\r\n\t\t\tvar position = this.geometry.attributes.position;\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar objGeometry = this.object.geometry;\r\n\t\r\n\t\t\tif ( objGeometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\tvar vertices = objGeometry.vertices;\r\n\t\r\n\t\t\t\tvar faces = objGeometry.faces;\r\n\t\r\n\t\t\t\tvar idx = 0;\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar vertex = vertices[ face[ keys[ j ] ] ];\r\n\t\r\n\t\t\t\t\t\tvar normal = face.vertexNormals[ j ];\r\n\t\r\n\t\t\t\t\t\tv1.copy( vertex ).applyMatrix4( matrixWorld );\r\n\t\r\n\t\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\r\n\t\r\n\t\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\r\n\t\r\n\t\t\t\t\t\tidx = idx + 1;\r\n\t\r\n\t\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\r\n\t\r\n\t\t\t\t\t\tidx = idx + 1;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\tvar objPos = objGeometry.attributes.position;\r\n\t\r\n\t\t\t\tvar objNorm = objGeometry.attributes.normal;\r\n\t\r\n\t\t\t\tvar idx = 0;\r\n\t\r\n\t\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\r\n\t\r\n\t\t\t\t\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\r\n\t\r\n\t\t\t\t\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\r\n\t\r\n\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\r\n\t\r\n\t\t\t\t\tidx = idx + 1;\r\n\t\r\n\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\r\n\t\r\n\t\t\t\t\tidx = idx + 1;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tposition.needsUpdate = true;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t}() );\r\n\t\r\n\t// File:src/extras/helpers/WireframeHelper.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.WireframeHelper = function ( object, hex ) {\r\n\t\r\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\t\r\n\t\tTHREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );\r\n\t\r\n\t\tthis.matrix = object.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\n\tTHREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;\r\n\t\r\n\t// File:src/extras/objects/ImmediateRenderObject.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.ImmediateRenderObject = function ( material ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.material = material;\r\n\t\tthis.render = function ( renderCallback ) {};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;\r\n\t\r\n\t// File:src/extras/objects/MorphBlendMesh.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.MorphBlendMesh = function( geometry, material ) {\r\n\t\r\n\t\tTHREE.Mesh.call( this, geometry, material );\r\n\t\r\n\t\tthis.animationsMap = {};\r\n\t\tthis.animationsList = [];\r\n\t\r\n\t\t// prepare default animation\r\n\t\t// (all frames played together in 1 second)\r\n\t\r\n\t\tvar numFrames = this.geometry.morphTargets.length;\r\n\t\r\n\t\tvar name = \"__default\";\r\n\t\r\n\t\tvar startFrame = 0;\r\n\t\tvar endFrame = numFrames - 1;\r\n\t\r\n\t\tvar fps = numFrames / 1;\r\n\t\r\n\t\tthis.createAnimation( name, startFrame, endFrame, fps );\r\n\t\tthis.setAnimationWeight( name, 1 );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\r\n\tTHREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\r\n\t\r\n\t\tvar animation = {\r\n\t\r\n\t\t\tstart: start,\r\n\t\t\tend: end,\r\n\t\r\n\t\t\tlength: end - start + 1,\r\n\t\r\n\t\t\tfps: fps,\r\n\t\t\tduration: ( end - start ) / fps,\r\n\t\r\n\t\t\tlastFrame: 0,\r\n\t\t\tcurrentFrame: 0,\r\n\t\r\n\t\t\tactive: false,\r\n\t\r\n\t\t\ttime: 0,\r\n\t\t\tdirection: 1,\r\n\t\t\tweight: 1,\r\n\t\r\n\t\t\tdirectionBackwards: false,\r\n\t\t\tmirroredLoop: false\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.animationsMap[ name ] = animation;\r\n\t\tthis.animationsList.push( animation );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\r\n\t\r\n\t\tvar pattern = /([a-z]+)_?(\\d+)/i;\r\n\t\r\n\t\tvar firstAnimation, frameRanges = {};\r\n\t\r\n\t\tvar geometry = this.geometry;\r\n\t\r\n\t\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\t\tvar chunks = morph.name.match( pattern );\r\n\t\r\n\t\t\tif ( chunks && chunks.length > 1 ) {\r\n\t\r\n\t\t\t\tvar name = chunks[ 1 ];\r\n\t\r\n\t\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\r\n\t\r\n\t\t\t\tvar range = frameRanges[ name ];\r\n\t\r\n\t\t\t\tif ( i < range.start ) range.start = i;\r\n\t\t\t\tif ( i > range.end ) range.end = i;\r\n\t\r\n\t\t\t\tif ( ! firstAnimation ) firstAnimation = name;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfor ( var name in frameRanges ) {\r\n\t\r\n\t\t\tvar range = frameRanges[ name ];\r\n\t\t\tthis.createAnimation( name, range.start, range.end, fps );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.firstAnimation = firstAnimation;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.direction = 1;\r\n\t\t\tanimation.directionBackwards = false;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.direction = - 1;\r\n\t\t\tanimation.directionBackwards = true;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.fps = fps;\r\n\t\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.duration = duration;\r\n\t\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.weight = weight;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.time = time;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\r\n\t\r\n\t\tvar time = 0;\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\ttime = animation.time;\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn time;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\r\n\t\r\n\t\tvar duration = - 1;\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tduration = animation.duration;\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn duration;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.time = 0;\r\n\t\t\tanimation.active = true;\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tconsole.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.active = false;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\r\n\t\r\n\t\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\r\n\t\r\n\t\t\tvar animation = this.animationsList[ i ];\r\n\t\r\n\t\t\tif ( ! animation.active ) continue;\r\n\t\r\n\t\t\tvar frameTime = animation.duration / animation.length;\r\n\t\r\n\t\t\tanimation.time += animation.direction * delta;\r\n\t\r\n\t\t\tif ( animation.mirroredLoop ) {\r\n\t\r\n\t\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\r\n\t\r\n\t\t\t\t\tanimation.direction *= - 1;\r\n\t\r\n\t\t\t\t\tif ( animation.time > animation.duration ) {\r\n\t\r\n\t\t\t\t\t\tanimation.time = animation.duration;\r\n\t\t\t\t\t\tanimation.directionBackwards = true;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( animation.time < 0 ) {\r\n\t\r\n\t\t\t\t\t\tanimation.time = 0;\r\n\t\t\t\t\t\tanimation.directionBackwards = false;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tanimation.time = animation.time % animation.duration;\r\n\t\r\n\t\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\r\n\t\t\tvar weight = animation.weight;\r\n\t\r\n\t\t\tif ( keyframe !== animation.currentFrame ) {\r\n\t\r\n\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\r\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\r\n\t\r\n\t\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\t\r\n\t\t\t\tanimation.lastFrame = animation.currentFrame;\r\n\t\t\t\tanimation.currentFrame = keyframe;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar mix = ( animation.time % frameTime ) / frameTime;\r\n\t\r\n\t\t\tif ( animation.directionBackwards ) mix = 1 - mix;\r\n\t\r\n\t\t\tif ( animation.currentFrame !== animation.lastFrame ) {\r\n\t\r\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\r\n\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = weight;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// Export the THREE object for **Node.js**, with\r\n\t// backwards-compatibility for the old `require()` API. If we're in\r\n\t// the browser, add `_` as a global object via a string identifier,\r\n\t// for Closure Compiler \"advanced\" mode.\r\n\tif (true) {\r\n\t  if (typeof module !== 'undefined' && module.exports) {\r\n\t    exports = module.exports = THREE;\r\n\t  }\r\n\t  exports.THREE = THREE;\r\n\t} else {\r\n\t  this['THREE'] = THREE;\r\n\t}\r\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** dist/bundle.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 30f52ee540e1c7d1a85d\n **/","\"use strict\";\r\nvar Three = require(\"three\");\r\nvar text = \"hello world!\";\r\nvar renderer = new Three.WebGLRenderer();\r\nrenderer.clearDepth();\r\ndocument.getElementById(\"main\").innerText = text;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/ts/app.ts\n ** module id = 0\n ** module chunks = 0\n **/","var self = self || {};// File:src/Three.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nvar THREE = { REVISION: '75' };\r\n\r\n//\r\n\r\nif ( typeof define === 'function' && define.amd ) {\r\n\r\n\tdefine( 'three', THREE );\r\n\r\n} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {\r\n\r\n\tmodule.exports = THREE;\r\n\r\n}\r\n\r\n//\r\n\r\nif ( Number.EPSILON === undefined ) {\r\n\r\n\tNumber.EPSILON = Math.pow( 2, - 52 );\r\n\r\n}\r\n\r\n//\r\n\r\nif ( Math.sign === undefined ) {\r\n\r\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\r\n\r\n\tMath.sign = function ( x ) {\r\n\r\n\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\r\n\r\n\t};\r\n\r\n}\r\n\r\nif ( Function.prototype.name === undefined && Object.defineProperty !== undefined ) {\r\n\r\n\t// Missing in IE9-11.\r\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\r\n\r\n\tObject.defineProperty( Function.prototype, 'name', {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this.toString().match( /^\\s*function\\s*(\\S*)\\s*\\(/ )[ 1 ];\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n}\r\n\r\nif ( Object.assign === undefined ) {\r\n\r\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\r\n\r\n\tObject.defineProperty( Object, 'assign', {\r\n\r\n\t\twritable: true,\r\n\t\tconfigurable: true,\r\n\r\n\t\tvalue: function ( target ) {\r\n\r\n\t\t\t'use strict';\r\n\r\n\t\t\tif ( target === undefined || target === null ) {\r\n\r\n\t\t\t\tthrow new TypeError( \"Cannot convert first argument to object\" );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar to = Object( target );\r\n\r\n\t\t\tfor ( var i = 1, n = arguments.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\tvar nextSource = arguments[ i ];\r\n\r\n\t\t\t\tif ( nextSource === undefined || nextSource === null ) continue;\r\n\r\n\t\t\t\tnextSource = Object( nextSource );\r\n\r\n\t\t\t\tvar keysArray = Object.keys( nextSource );\r\n\r\n\t\t\t\tfor ( var nextIndex = 0, len = keysArray.length; nextIndex !== len; ++ nextIndex ) {\r\n\r\n\t\t\t\t\tvar nextKey = keysArray[ nextIndex ];\r\n\t\t\t\t\tvar desc = Object.getOwnPropertyDescriptor( nextSource, nextKey );\r\n\r\n\t\t\t\t\tif ( desc !== undefined && desc.enumerable ) {\r\n\r\n\t\t\t\t\t\tto[ nextKey ] = nextSource[ nextKey ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn to;\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n}\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button\r\n\r\nTHREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\r\n\r\n// GL STATE CONSTANTS\r\n\r\nTHREE.CullFaceNone = 0;\r\nTHREE.CullFaceBack = 1;\r\nTHREE.CullFaceFront = 2;\r\nTHREE.CullFaceFrontBack = 3;\r\n\r\nTHREE.FrontFaceDirectionCW = 0;\r\nTHREE.FrontFaceDirectionCCW = 1;\r\n\r\n// SHADOWING TYPES\r\n\r\nTHREE.BasicShadowMap = 0;\r\nTHREE.PCFShadowMap = 1;\r\nTHREE.PCFSoftShadowMap = 2;\r\n\r\n// MATERIAL CONSTANTS\r\n\r\n// side\r\n\r\nTHREE.FrontSide = 0;\r\nTHREE.BackSide = 1;\r\nTHREE.DoubleSide = 2;\r\n\r\n// shading\r\n\r\nTHREE.FlatShading = 1;\r\nTHREE.SmoothShading = 2;\r\n\r\n// colors\r\n\r\nTHREE.NoColors = 0;\r\nTHREE.FaceColors = 1;\r\nTHREE.VertexColors = 2;\r\n\r\n// blending modes\r\n\r\nTHREE.NoBlending = 0;\r\nTHREE.NormalBlending = 1;\r\nTHREE.AdditiveBlending = 2;\r\nTHREE.SubtractiveBlending = 3;\r\nTHREE.MultiplyBlending = 4;\r\nTHREE.CustomBlending = 5;\r\n\r\n// custom blending equations\r\n// (numbers start from 100 not to clash with other\r\n// mappings to OpenGL constants defined in Texture.js)\r\n\r\nTHREE.AddEquation = 100;\r\nTHREE.SubtractEquation = 101;\r\nTHREE.ReverseSubtractEquation = 102;\r\nTHREE.MinEquation = 103;\r\nTHREE.MaxEquation = 104;\r\n\r\n// custom blending destination factors\r\n\r\nTHREE.ZeroFactor = 200;\r\nTHREE.OneFactor = 201;\r\nTHREE.SrcColorFactor = 202;\r\nTHREE.OneMinusSrcColorFactor = 203;\r\nTHREE.SrcAlphaFactor = 204;\r\nTHREE.OneMinusSrcAlphaFactor = 205;\r\nTHREE.DstAlphaFactor = 206;\r\nTHREE.OneMinusDstAlphaFactor = 207;\r\n\r\n// custom blending source factors\r\n\r\n//THREE.ZeroFactor = 200;\r\n//THREE.OneFactor = 201;\r\n//THREE.SrcAlphaFactor = 204;\r\n//THREE.OneMinusSrcAlphaFactor = 205;\r\n//THREE.DstAlphaFactor = 206;\r\n//THREE.OneMinusDstAlphaFactor = 207;\r\nTHREE.DstColorFactor = 208;\r\nTHREE.OneMinusDstColorFactor = 209;\r\nTHREE.SrcAlphaSaturateFactor = 210;\r\n\r\n// depth modes\r\n\r\nTHREE.NeverDepth = 0;\r\nTHREE.AlwaysDepth = 1;\r\nTHREE.LessDepth = 2;\r\nTHREE.LessEqualDepth = 3;\r\nTHREE.EqualDepth = 4;\r\nTHREE.GreaterEqualDepth = 5;\r\nTHREE.GreaterDepth = 6;\r\nTHREE.NotEqualDepth = 7;\r\n\r\n\r\n// TEXTURE CONSTANTS\r\n\r\nTHREE.MultiplyOperation = 0;\r\nTHREE.MixOperation = 1;\r\nTHREE.AddOperation = 2;\r\n\r\n// Tone Mapping modes\r\n\r\nTHREE.NoToneMapping = 0; // do not do any tone mapping, not even exposure (required for special purpose passes.)\r\nTHREE.LinearToneMapping = 1; // only apply exposure.\r\nTHREE.ReinhardToneMapping = 2;\r\nTHREE.Uncharted2ToneMapping = 3; // John Hable\r\nTHREE.CineonToneMapping = 4;  // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\r\n\r\n// Mapping modes\r\n\r\nTHREE.UVMapping = 300;\r\n\r\nTHREE.CubeReflectionMapping = 301;\r\nTHREE.CubeRefractionMapping = 302;\r\n\r\nTHREE.EquirectangularReflectionMapping = 303;\r\nTHREE.EquirectangularRefractionMapping = 304;\r\n\r\nTHREE.SphericalReflectionMapping = 305;\r\nTHREE.CubeUVReflectionMapping = 306;\r\nTHREE.CubeUVRefractionMapping = 307;\r\n\r\n// Wrapping modes\r\n\r\nTHREE.RepeatWrapping = 1000;\r\nTHREE.ClampToEdgeWrapping = 1001;\r\nTHREE.MirroredRepeatWrapping = 1002;\r\n\r\n// Filters\r\n\r\nTHREE.NearestFilter = 1003;\r\nTHREE.NearestMipMapNearestFilter = 1004;\r\nTHREE.NearestMipMapLinearFilter = 1005;\r\nTHREE.LinearFilter = 1006;\r\nTHREE.LinearMipMapNearestFilter = 1007;\r\nTHREE.LinearMipMapLinearFilter = 1008;\r\n\r\n// Data types\r\n\r\nTHREE.UnsignedByteType = 1009;\r\nTHREE.ByteType = 1010;\r\nTHREE.ShortType = 1011;\r\nTHREE.UnsignedShortType = 1012;\r\nTHREE.IntType = 1013;\r\nTHREE.UnsignedIntType = 1014;\r\nTHREE.FloatType = 1015;\r\nTHREE.HalfFloatType = 1025;\r\n\r\n// Pixel types\r\n\r\n//THREE.UnsignedByteType = 1009;\r\nTHREE.UnsignedShort4444Type = 1016;\r\nTHREE.UnsignedShort5551Type = 1017;\r\nTHREE.UnsignedShort565Type = 1018;\r\n\r\n// Pixel formats\r\n\r\nTHREE.AlphaFormat = 1019;\r\nTHREE.RGBFormat = 1020;\r\nTHREE.RGBAFormat = 1021;\r\nTHREE.LuminanceFormat = 1022;\r\nTHREE.LuminanceAlphaFormat = 1023;\r\n// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders\r\nTHREE.RGBEFormat = THREE.RGBAFormat; //1024;\r\n\r\n// DDS / ST3C Compressed texture formats\r\n\r\nTHREE.RGB_S3TC_DXT1_Format = 2001;\r\nTHREE.RGBA_S3TC_DXT1_Format = 2002;\r\nTHREE.RGBA_S3TC_DXT3_Format = 2003;\r\nTHREE.RGBA_S3TC_DXT5_Format = 2004;\r\n\r\n\r\n// PVRTC compressed texture formats\r\n\r\nTHREE.RGB_PVRTC_4BPPV1_Format = 2100;\r\nTHREE.RGB_PVRTC_2BPPV1_Format = 2101;\r\nTHREE.RGBA_PVRTC_4BPPV1_Format = 2102;\r\nTHREE.RGBA_PVRTC_2BPPV1_Format = 2103;\r\n\r\n// ETC compressed texture formats\r\n\r\nTHREE.RGB_ETC1_Format = 2151;\r\n\r\n// Loop styles for AnimationAction\r\n\r\nTHREE.LoopOnce = 2200;\r\nTHREE.LoopRepeat = 2201;\r\nTHREE.LoopPingPong = 2202;\r\n\r\n// Interpolation\r\n\r\nTHREE.InterpolateDiscrete = 2300;\r\nTHREE.InterpolateLinear = 2301;\r\nTHREE.InterpolateSmooth = 2302;\r\n\r\n// Interpolant ending modes\r\n\r\nTHREE.ZeroCurvatureEnding = 2400;\r\nTHREE.ZeroSlopeEnding = 2401;\r\nTHREE.WrapAroundEnding = 2402;\r\n\r\n// Triangle Draw modes\r\n\r\nTHREE.TrianglesDrawMode = 0;\r\nTHREE.TriangleStripDrawMode = 1;\r\nTHREE.TriangleFanDrawMode = 2;\r\n\r\n// Texture Encodings\r\n\r\nTHREE.LinearEncoding = 3000; // No encoding at all.\r\nTHREE.sRGBEncoding = 3001;\r\nTHREE.GammaEncoding = 3007; // uses GAMMA_FACTOR, for backwards compatibility with WebGLRenderer.gammaInput/gammaOutput\r\n\r\n// The following Texture Encodings are for RGB-only (no alpha) HDR light emission sources.\r\n// These encodings should not specified as output encodings except in rare situations.\r\nTHREE.RGBEEncoding = 3002; // AKA Radiance.\r\nTHREE.LogLuvEncoding = 3003;\r\nTHREE.RGBM7Encoding = 3004;\r\nTHREE.RGBM16Encoding = 3005;\r\nTHREE.RGBDEncoding = 3006; // MaxRange is 256.\r\n\r\n// File:src/math/Color.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Color = function ( color ) {\r\n\r\n\tif ( arguments.length === 3 ) {\r\n\r\n\t\treturn this.fromArray( arguments );\r\n\r\n\t}\r\n\r\n\treturn this.set( color );\r\n\r\n};\r\n\r\nTHREE.Color.prototype = {\r\n\r\n\tconstructor: THREE.Color,\r\n\r\n\tr: 1, g: 1, b: 1,\r\n\r\n\tset: function ( value ) {\r\n\r\n\t\tif ( value instanceof THREE.Color ) {\r\n\r\n\t\t\tthis.copy( value );\r\n\r\n\t\t} else if ( typeof value === 'number' ) {\r\n\r\n\t\t\tthis.setHex( value );\r\n\r\n\t\t} else if ( typeof value === 'string' ) {\r\n\r\n\t\t\tthis.setStyle( value );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetScalar: function ( scalar ) {\r\n\r\n\t\tthis.r = scalar;\r\n\t\tthis.g = scalar;\r\n\t\tthis.b = scalar;\r\n\r\n\t},\r\n\r\n\tsetHex: function ( hex ) {\r\n\r\n\t\thex = Math.floor( hex );\r\n\r\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\r\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\r\n\t\tthis.b = ( hex & 255 ) / 255;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetRGB: function ( r, g, b ) {\r\n\r\n\t\tthis.r = r;\r\n\t\tthis.g = g;\r\n\t\tthis.b = b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetHSL: function () {\r\n\r\n\t\tfunction hue2rgb( p, q, t ) {\r\n\r\n\t\t\tif ( t < 0 ) t += 1;\r\n\t\t\tif ( t > 1 ) t -= 1;\r\n\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\r\n\t\t\tif ( t < 1 / 2 ) return q;\r\n\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\r\n\t\t\treturn p;\r\n\r\n\t\t}\r\n\r\n\t\treturn function ( h, s, l ) {\r\n\r\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\t\t\th = THREE.Math.euclideanModulo( h, 1 );\r\n\t\t\ts = THREE.Math.clamp( s, 0, 1 );\r\n\t\t\tl = THREE.Math.clamp( l, 0, 1 );\r\n\r\n\t\t\tif ( s === 0 ) {\r\n\r\n\t\t\t\tthis.r = this.g = this.b = l;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\r\n\t\t\t\tvar q = ( 2 * l ) - p;\r\n\r\n\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\r\n\t\t\t\tthis.g = hue2rgb( q, p, h );\r\n\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetStyle: function ( style ) {\r\n\r\n\t\tfunction handleAlpha( string ) {\r\n\r\n\t\t\tif ( string === undefined ) return;\r\n\r\n\t\t\tif ( parseFloat( string ) < 1 ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\tvar m;\r\n\r\n\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\r\n\r\n\t\t\t// rgb / hsl\r\n\r\n\t\t\tvar color;\r\n\t\t\tvar name = m[ 1 ];\r\n\t\t\tvar components = m[ 2 ];\r\n\r\n\t\t\tswitch ( name ) {\r\n\r\n\t\t\t\tcase 'rgb':\r\n\t\t\t\tcase 'rgba':\r\n\r\n\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\r\n\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\r\n\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\r\n\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\r\n\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\r\n\r\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\r\n\r\n\t\t\t\t\t\treturn this;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\r\n\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\r\n\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\r\n\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\r\n\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\r\n\r\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\r\n\r\n\t\t\t\t\t\treturn this;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'hsl':\r\n\t\t\t\tcase 'hsla':\r\n\r\n\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\r\n\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\r\n\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\r\n\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\r\n\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\r\n\r\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\r\n\r\n\t\t\t\t\t\treturn this.setHSL( h, s, l );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\r\n\r\n\t\t\t// hex color\r\n\r\n\t\t\tvar hex = m[ 1 ];\r\n\t\t\tvar size = hex.length;\r\n\r\n\t\t\tif ( size === 3 ) {\r\n\r\n\t\t\t\t// #ff0\r\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\r\n\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\r\n\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\r\n\r\n\t\t\t\treturn this;\r\n\r\n\t\t\t} else if ( size === 6 ) {\r\n\r\n\t\t\t\t// #ff0000\r\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\r\n\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\r\n\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\r\n\r\n\t\t\t\treturn this;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( style && style.length > 0 ) {\r\n\r\n\t\t\t// color keywords\r\n\t\t\tvar hex = THREE.ColorKeywords[ style ];\r\n\r\n\t\t\tif ( hex !== undefined ) {\r\n\r\n\t\t\t\t// red\r\n\t\t\t\tthis.setHex( hex );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// unknown color\r\n\t\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.r, this.g, this.b );\r\n\r\n\t},\r\n\r\n\tcopy: function ( color ) {\r\n\r\n\t\tthis.r = color.r;\r\n\t\tthis.g = color.g;\r\n\t\tthis.b = color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyGammaToLinear: function ( color, gammaFactor ) {\r\n\r\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\r\n\t\tthis.r = Math.pow( color.r, gammaFactor );\r\n\t\tthis.g = Math.pow( color.g, gammaFactor );\r\n\t\tthis.b = Math.pow( color.b, gammaFactor );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyLinearToGamma: function ( color, gammaFactor ) {\r\n\r\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\r\n\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\r\n\r\n\t\tthis.r = Math.pow( color.r, safeInverse );\r\n\t\tthis.g = Math.pow( color.g, safeInverse );\r\n\t\tthis.b = Math.pow( color.b, safeInverse );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconvertGammaToLinear: function () {\r\n\r\n\t\tvar r = this.r, g = this.g, b = this.b;\r\n\r\n\t\tthis.r = r * r;\r\n\t\tthis.g = g * g;\r\n\t\tthis.b = b * b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconvertLinearToGamma: function () {\r\n\r\n\t\tthis.r = Math.sqrt( this.r );\r\n\t\tthis.g = Math.sqrt( this.g );\r\n\t\tthis.b = Math.sqrt( this.b );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetHex: function () {\r\n\r\n\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\r\n\r\n\t},\r\n\r\n\tgetHexString: function () {\r\n\r\n\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\r\n\r\n\t},\r\n\r\n\tgetHSL: function ( optionalTarget ) {\r\n\r\n\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\r\n\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\r\n\r\n\t\tvar r = this.r, g = this.g, b = this.b;\r\n\r\n\t\tvar max = Math.max( r, g, b );\r\n\t\tvar min = Math.min( r, g, b );\r\n\r\n\t\tvar hue, saturation;\r\n\t\tvar lightness = ( min + max ) / 2.0;\r\n\r\n\t\tif ( min === max ) {\r\n\r\n\t\t\thue = 0;\r\n\t\t\tsaturation = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar delta = max - min;\r\n\r\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\r\n\r\n\t\t\tswitch ( max ) {\r\n\r\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\r\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\r\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\r\n\r\n\t\t\t}\r\n\r\n\t\t\thue /= 6;\r\n\r\n\t\t}\r\n\r\n\t\thsl.h = hue;\r\n\t\thsl.s = saturation;\r\n\t\thsl.l = lightness;\r\n\r\n\t\treturn hsl;\r\n\r\n\t},\r\n\r\n\tgetStyle: function () {\r\n\r\n\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\r\n\r\n\t},\r\n\r\n\toffsetHSL: function ( h, s, l ) {\r\n\r\n\t\tvar hsl = this.getHSL();\r\n\r\n\t\thsl.h += h; hsl.s += s; hsl.l += l;\r\n\r\n\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( color ) {\r\n\r\n\t\tthis.r += color.r;\r\n\t\tthis.g += color.g;\r\n\t\tthis.b += color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddColors: function ( color1, color2 ) {\r\n\r\n\t\tthis.r = color1.r + color2.r;\r\n\t\tthis.g = color1.g + color2.g;\r\n\t\tthis.b = color1.b + color2.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.r += s;\r\n\t\tthis.g += s;\r\n\t\tthis.b += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( color ) {\r\n\r\n\t\tthis.r *= color.r;\r\n\t\tthis.g *= color.g;\r\n\t\tthis.b *= color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tthis.r *= s;\r\n\t\tthis.g *= s;\r\n\t\tthis.b *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerp: function ( color, alpha ) {\r\n\r\n\t\tthis.r += ( color.r - this.r ) * alpha;\r\n\t\tthis.g += ( color.g - this.g ) * alpha;\r\n\t\tthis.b += ( color.b - this.b ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( c ) {\r\n\r\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.r = array[ offset ];\r\n\t\tthis.g = array[ offset + 1 ];\r\n\t\tthis.b = array[ offset + 2 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.r;\r\n\t\tarray[ offset + 1 ] = this.g;\r\n\t\tarray[ offset + 2 ] = this.b;\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\r\n'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\r\n'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\r\n'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\r\n'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\r\n'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\r\n'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\r\n'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\r\n'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\r\n'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\r\n'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\r\n'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\r\n'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\r\n'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\r\n'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\r\n'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\r\n'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\r\n'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\r\n'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\r\n'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\r\n'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\r\n'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\r\n'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\r\n'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\r\n\r\n// File:src/math/Quaternion.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Quaternion = function ( x, y, z, w ) {\r\n\r\n\tthis._x = x || 0;\r\n\tthis._y = y || 0;\r\n\tthis._z = z || 0;\r\n\tthis._w = ( w !== undefined ) ? w : 1;\r\n\r\n};\r\n\r\nTHREE.Quaternion.prototype = {\r\n\r\n\tconstructor: THREE.Quaternion,\r\n\r\n\tget x () {\r\n\r\n\t\treturn this._x;\r\n\r\n\t},\r\n\r\n\tset x ( value ) {\r\n\r\n\t\tthis._x = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget y () {\r\n\r\n\t\treturn this._y;\r\n\r\n\t},\r\n\r\n\tset y ( value ) {\r\n\r\n\t\tthis._y = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget z () {\r\n\r\n\t\treturn this._z;\r\n\r\n\t},\r\n\r\n\tset z ( value ) {\r\n\r\n\t\tthis._z = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget w () {\r\n\r\n\t\treturn this._w;\r\n\r\n\t},\r\n\r\n\tset w ( value ) {\r\n\r\n\t\tthis._w = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tset: function ( x, y, z, w ) {\r\n\r\n\t\tthis._x = x;\r\n\t\tthis._y = y;\r\n\t\tthis._z = z;\r\n\t\tthis._w = w;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\r\n\r\n\t},\r\n\r\n\tcopy: function ( quaternion ) {\r\n\r\n\t\tthis._x = quaternion.x;\r\n\t\tthis._y = quaternion.y;\r\n\t\tthis._z = quaternion.z;\r\n\t\tthis._w = quaternion.w;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromEuler: function ( euler, update ) {\r\n\r\n\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\r\n\t\t}\r\n\r\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\r\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\r\n\t\t//\tcontent/SpinCalc.m\r\n\r\n\t\tvar c1 = Math.cos( euler._x / 2 );\r\n\t\tvar c2 = Math.cos( euler._y / 2 );\r\n\t\tvar c3 = Math.cos( euler._z / 2 );\r\n\t\tvar s1 = Math.sin( euler._x / 2 );\r\n\t\tvar s2 = Math.sin( euler._y / 2 );\r\n\t\tvar s3 = Math.sin( euler._z / 2 );\r\n\r\n\t\tvar order = euler.order;\r\n\r\n\t\tif ( order === 'XYZ' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'YXZ' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'ZXY' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'ZYX' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'YZX' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'XZY' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t}\r\n\r\n\t\tif ( update !== false ) this.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromAxisAngle: function ( axis, angle ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\r\n\r\n\t\t// assumes axis is normalized\r\n\r\n\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\r\n\r\n\t\tthis._x = axis.x * s;\r\n\t\tthis._y = axis.y * s;\r\n\t\tthis._z = axis.z * s;\r\n\t\tthis._w = Math.cos( halfAngle );\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromRotationMatrix: function ( m ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar te = m.elements,\r\n\r\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\r\n\r\n\t\t\ttrace = m11 + m22 + m33,\r\n\t\t\ts;\r\n\r\n\t\tif ( trace > 0 ) {\r\n\r\n\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\r\n\r\n\t\t\tthis._w = 0.25 / s;\r\n\t\t\tthis._x = ( m32 - m23 ) * s;\r\n\t\t\tthis._y = ( m13 - m31 ) * s;\r\n\t\t\tthis._z = ( m21 - m12 ) * s;\r\n\r\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\r\n\r\n\t\t\tthis._w = ( m32 - m23 ) / s;\r\n\t\t\tthis._x = 0.25 * s;\r\n\t\t\tthis._y = ( m12 + m21 ) / s;\r\n\t\t\tthis._z = ( m13 + m31 ) / s;\r\n\r\n\t\t} else if ( m22 > m33 ) {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\r\n\r\n\t\t\tthis._w = ( m13 - m31 ) / s;\r\n\t\t\tthis._x = ( m12 + m21 ) / s;\r\n\t\t\tthis._y = 0.25 * s;\r\n\t\t\tthis._z = ( m23 + m32 ) / s;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\r\n\r\n\t\t\tthis._w = ( m21 - m12 ) / s;\r\n\t\t\tthis._x = ( m13 + m31 ) / s;\r\n\t\t\tthis._y = ( m23 + m32 ) / s;\r\n\t\t\tthis._z = 0.25 * s;\r\n\r\n\t\t}\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromUnitVectors: function () {\r\n\r\n\t\t// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\r\n\r\n\t\t// assumes direction vectors vFrom and vTo are normalized\r\n\r\n\t\tvar v1, r;\r\n\r\n\t\tvar EPS = 0.000001;\r\n\r\n\t\treturn function ( vFrom, vTo ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n\t\t\tr = vFrom.dot( vTo ) + 1;\r\n\r\n\t\t\tif ( r < EPS ) {\r\n\r\n\t\t\t\tr = 0;\r\n\r\n\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\r\n\r\n\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tv1.crossVectors( vFrom, vTo );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis._x = v1.x;\r\n\t\t\tthis._y = v1.y;\r\n\t\t\tthis._z = v1.z;\r\n\t\t\tthis._w = r;\r\n\r\n\t\t\tthis.normalize();\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tinverse: function () {\r\n\r\n\t\tthis.conjugate().normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconjugate: function () {\r\n\r\n\t\tthis._x *= - 1;\r\n\t\tthis._y *= - 1;\r\n\t\tthis._z *= - 1;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\tvar l = this.length();\r\n\r\n\t\tif ( l === 0 ) {\r\n\r\n\t\t\tthis._x = 0;\r\n\t\t\tthis._y = 0;\r\n\t\t\tthis._z = 0;\r\n\t\t\tthis._w = 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tl = 1 / l;\r\n\r\n\t\t\tthis._x = this._x * l;\r\n\t\t\tthis._y = this._y * l;\r\n\t\t\tthis._z = this._z * l;\r\n\t\t\tthis._w = this._w * l;\r\n\r\n\t\t}\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( q, p ) {\r\n\r\n\t\tif ( p !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\r\n\t\t\treturn this.multiplyQuaternions( q, p );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.multiplyQuaternions( this, q );\r\n\r\n\t},\r\n\r\n\tmultiplyQuaternions: function ( a, b ) {\r\n\r\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\r\n\r\n\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\r\n\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\r\n\r\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\r\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\r\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\r\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tslerp: function ( qb, t ) {\r\n\r\n\t\tif ( t === 0 ) return this;\r\n\t\tif ( t === 1 ) return this.copy( qb );\r\n\r\n\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\r\n\r\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\r\n\r\n\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\r\n\r\n\t\tif ( cosHalfTheta < 0 ) {\r\n\r\n\t\t\tthis._w = - qb._w;\r\n\t\t\tthis._x = - qb._x;\r\n\t\t\tthis._y = - qb._y;\r\n\t\t\tthis._z = - qb._z;\r\n\r\n\t\t\tcosHalfTheta = - cosHalfTheta;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.copy( qb );\r\n\r\n\t\t}\r\n\r\n\t\tif ( cosHalfTheta >= 1.0 ) {\r\n\r\n\t\t\tthis._w = w;\r\n\t\t\tthis._x = x;\r\n\t\t\tthis._y = y;\r\n\t\t\tthis._z = z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\r\n\r\n\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\r\n\r\n\t\t\tthis._w = 0.5 * ( w + this._w );\r\n\t\t\tthis._x = 0.5 * ( x + this._x );\r\n\t\t\tthis._y = 0.5 * ( y + this._y );\r\n\t\t\tthis._z = 0.5 * ( z + this._z );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\r\n\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\r\n\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\r\n\r\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\r\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\r\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\r\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( quaternion ) {\r\n\r\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis._x = array[ offset ];\r\n\t\tthis._y = array[ offset + 1 ];\r\n\t\tthis._z = array[ offset + 2 ];\r\n\t\tthis._w = array[ offset + 3 ];\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this._x;\r\n\t\tarray[ offset + 1 ] = this._y;\r\n\t\tarray[ offset + 2 ] = this._z;\r\n\t\tarray[ offset + 3 ] = this._w;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tonChange: function ( callback ) {\r\n\r\n\t\tthis.onChangeCallback = callback;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tonChangeCallback: function () {}\r\n\r\n};\r\n\r\nObject.assign( THREE.Quaternion, {\r\n\r\n\tslerp: function( qa, qb, qm, t ) {\r\n\r\n\t\treturn qm.copy( qa ).slerp( qb, t );\r\n\r\n\t},\r\n\r\n\tslerpFlat: function(\r\n\t\t\tdst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\r\n\r\n\t\t// fuzz-free, array-based Quaternion SLERP operation\r\n\r\n\t\tvar x0 = src0[ srcOffset0 + 0 ],\r\n\t\t\ty0 = src0[ srcOffset0 + 1 ],\r\n\t\t\tz0 = src0[ srcOffset0 + 2 ],\r\n\t\t\tw0 = src0[ srcOffset0 + 3 ],\r\n\r\n\t\t\tx1 = src1[ srcOffset1 + 0 ],\r\n\t\t\ty1 = src1[ srcOffset1 + 1 ],\r\n\t\t\tz1 = src1[ srcOffset1 + 2 ],\r\n\t\t\tw1 = src1[ srcOffset1 + 3 ];\r\n\r\n\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\r\n\r\n\t\t\tvar s = 1 - t,\r\n\r\n\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\r\n\r\n\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\r\n\t\t\t\tsqrSin = 1 - cos * cos;\r\n\r\n\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\r\n\t\t\tif ( sqrSin > Number.EPSILON ) {\r\n\r\n\t\t\t\tvar sin = Math.sqrt( sqrSin ),\r\n\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\r\n\r\n\t\t\t\ts = Math.sin( s * len ) / sin;\r\n\t\t\t\tt = Math.sin( t * len ) / sin;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar tDir = t * dir;\r\n\r\n\t\t\tx0 = x0 * s + x1 * tDir;\r\n\t\t\ty0 = y0 * s + y1 * tDir;\r\n\t\t\tz0 = z0 * s + z1 * tDir;\r\n\t\t\tw0 = w0 * s + w1 * tDir;\r\n\r\n\t\t\t// Normalize in case we just did a lerp:\r\n\t\t\tif ( s === 1 - t ) {\r\n\r\n\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\r\n\r\n\t\t\t\tx0 *= f;\r\n\t\t\t\ty0 *= f;\r\n\t\t\t\tz0 *= f;\r\n\t\t\t\tw0 *= f;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tdst[ dstOffset ] = x0;\r\n\t\tdst[ dstOffset + 1 ] = y0;\r\n\t\tdst[ dstOffset + 2 ] = z0;\r\n\t\tdst[ dstOffset + 3 ] = w0;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/math/Vector2.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author egraether / http://egraether.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.Vector2 = function ( x, y ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\r\n};\r\n\r\nTHREE.Vector2.prototype = {\r\n\r\n\tconstructor: THREE.Vector2,\r\n\r\n\tget width() {\r\n\r\n\t\treturn this.x;\r\n\r\n\t},\r\n\r\n\tset width( value ) {\r\n\r\n\t\tthis.x = value;\r\n\r\n\t},\r\n\r\n\tget height() {\r\n\r\n\t\treturn this.y;\r\n\r\n\t},\r\n\r\n\tset height( value ) {\r\n\r\n\t\tthis.y = value;\r\n\r\n\t},\r\n\r\n\t//\r\n\r\n\tset: function ( x, y ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetScalar: function ( scalar ) {\r\n\r\n\t\tthis.x = scalar;\r\n\t\tthis.y = scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.x, this.y );\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScaledVector: function ( v, s ) {\r\n\r\n\t\tthis.x += v.x * s;\r\n\t\tthis.y += v.y * s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubScalar: function ( s ) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( v ) {\r\n\r\n\t\tthis.x *= v.x;\r\n\t\tthis.y *= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( scalar ) {\r\n\r\n\t\tif ( isFinite( scalar ) ) {\r\n\r\n\t\t\tthis.x *= scalar;\r\n\t\t\tthis.y *= scalar;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivide: function ( v ) {\r\n\r\n\t\tthis.x /= v.x;\r\n\t\tthis.y /= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( scalar ) {\r\n\r\n\t\treturn this.multiplyScalar( 1 / scalar );\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tthis.x = Math.min( this.x, v.x );\r\n\t\tthis.y = Math.min( this.y, v.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tthis.x = Math.max( this.x, v.x );\r\n\t\tthis.y = Math.max( this.y, v.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclampScalar: function () {\r\n\r\n\t\tvar min, max;\r\n\r\n\t\treturn function clampScalar( minVal, maxVal ) {\r\n\r\n\t\t\tif ( min === undefined ) {\r\n\r\n\t\t\t\tmin = new THREE.Vector2();\r\n\t\t\t\tmax = new THREE.Vector2();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmin.set( minVal, minVal );\r\n\t\t\tmax.set( maxVal, maxVal );\r\n\r\n\t\t\treturn this.clamp( min, max );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclampLength: function ( min, max ) {\r\n\r\n\t\tvar length = this.length();\r\n\r\n\t\tthis.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tfloor: function () {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tceil: function () {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tround: function () {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\troundToZero: function () {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.x = - this.x;\r\n\t\tthis.y = - this.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\r\n\r\n\t},\r\n\r\n\tlengthManhattan: function() {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() );\r\n\r\n\t},\r\n\r\n\tangle: function () {\r\n\r\n\t\t// computes the angle in radians with respect to the positive x-axis\r\n\r\n\t\tvar angle = Math.atan2( this.y, this.x );\r\n\r\n\t\tif ( angle < 0 ) angle += 2 * Math.PI;\r\n\r\n\t\treturn angle;\r\n\r\n\t},\r\n\r\n\tdistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n\t},\r\n\r\n\tdistanceToSquared: function ( v ) {\r\n\r\n\t\tvar dx = this.x - v.x, dy = this.y - v.y;\r\n\t\treturn dx * dx + dy * dy;\r\n\r\n\t},\r\n\r\n\tsetLength: function ( length ) {\r\n\r\n\t\treturn this.multiplyScalar( length / this.length() );\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerpVectors: function ( v1, v2, alpha ) {\r\n\r\n\t\tthis.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.x = array[ offset ];\r\n\t\tthis.y = array[ offset + 1 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tfromAttribute: function ( attribute, index, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tindex = index * attribute.itemSize + offset;\r\n\r\n\t\tthis.x = attribute.array[ index ];\r\n\t\tthis.y = attribute.array[ index + 1 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotateAround: function ( center, angle ) {\r\n\r\n\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\r\n\r\n\t\tvar x = this.x - center.x;\r\n\t\tvar y = this.y - center.y;\r\n\r\n\t\tthis.x = x * c - y * s + center.x;\r\n\t\tthis.y = x * s + y * c + center.y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Vector3.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author *kile / http://kile.stravaganza.org/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Vector3 = function ( x, y, z ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\tthis.z = z || 0;\r\n\r\n};\r\n\r\nTHREE.Vector3.prototype = {\r\n\r\n\tconstructor: THREE.Vector3,\r\n\r\n\tset: function ( x, y, z ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetScalar: function ( scalar ) {\r\n\r\n\t\tthis.x = scalar;\r\n\t\tthis.y = scalar;\r\n\t\tthis.z = scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( z ) {\r\n\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tcase 2: this.z = value; break;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tcase 2: return this.z;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.x, this.y, this.z );\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\t\tthis.z = v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\t\tthis.z += v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\t\tthis.z += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\t\tthis.z = a.z + b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScaledVector: function ( v, s ) {\r\n\r\n\t\tthis.x += v.x * s;\r\n\t\tthis.y += v.y * s;\r\n\t\tthis.z += v.z * s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\t\tthis.z -= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubScalar: function ( s ) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\t\tthis.z -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\t\tthis.z = a.z - b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\r\n\t\t\treturn this.multiplyVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x *= v.x;\r\n\t\tthis.y *= v.y;\r\n\t\tthis.z *= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( scalar ) {\r\n\r\n\t\tif ( isFinite( scalar ) ) {\r\n\r\n\t\t\tthis.x *= scalar;\r\n\t\t\tthis.y *= scalar;\r\n\t\t\tthis.z *= scalar;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.z = 0;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x * b.x;\r\n\t\tthis.y = a.y * b.y;\r\n\t\tthis.z = a.z * b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyEuler: function () {\r\n\r\n\t\tvar quaternion;\r\n\r\n\t\treturn function applyEuler( euler ) {\r\n\r\n\t\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\r\n\t\t\tthis.applyQuaternion( quaternion.setFromEuler( euler ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyAxisAngle: function () {\r\n\r\n\t\tvar quaternion;\r\n\r\n\t\treturn function applyAxisAngle( axis, angle ) {\r\n\r\n\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\r\n\t\t\tthis.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyMatrix3: function ( m ) {\r\n\r\n\t\tvar x = this.x;\r\n\t\tvar y = this.y;\r\n\t\tvar z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\r\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\r\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4 affine matrix\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\r\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\r\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyProjection: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4 projection matrix\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\t\tvar d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\r\n\r\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\r\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\r\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyQuaternion: function ( q ) {\r\n\r\n\t\tvar x = this.x;\r\n\t\tvar y = this.y;\r\n\t\tvar z = this.z;\r\n\r\n\t\tvar qx = q.x;\r\n\t\tvar qy = q.y;\r\n\t\tvar qz = q.z;\r\n\t\tvar qw = q.w;\r\n\r\n\t\t// calculate quat * vector\r\n\r\n\t\tvar ix =  qw * x + qy * z - qz * y;\r\n\t\tvar iy =  qw * y + qz * x - qx * z;\r\n\t\tvar iz =  qw * z + qx * y - qy * x;\r\n\t\tvar iw = - qx * x - qy * y - qz * z;\r\n\r\n\t\t// calculate result * inverse quat\r\n\r\n\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\r\n\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\r\n\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tproject: function () {\r\n\r\n\t\tvar matrix;\r\n\r\n\t\treturn function project( camera ) {\r\n\r\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\r\n\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\r\n\t\t\treturn this.applyProjection( matrix );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tunproject: function () {\r\n\r\n\t\tvar matrix;\r\n\r\n\t\treturn function unproject( camera ) {\r\n\r\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\r\n\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\r\n\t\t\treturn this.applyProjection( matrix );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttransformDirection: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4 affine matrix\r\n\t\t// vector interpreted as a direction\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\r\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\r\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\r\n\r\n\t\tthis.normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivide: function ( v ) {\r\n\r\n\t\tthis.x /= v.x;\r\n\t\tthis.y /= v.y;\r\n\t\tthis.z /= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( scalar ) {\r\n\r\n\t\treturn this.multiplyScalar( 1 / scalar );\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tthis.x = Math.min( this.x, v.x );\r\n\t\tthis.y = Math.min( this.y, v.y );\r\n\t\tthis.z = Math.min( this.z, v.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tthis.x = Math.max( this.x, v.x );\r\n\t\tthis.y = Math.max( this.y, v.y );\r\n\t\tthis.z = Math.max( this.z, v.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclampScalar: function () {\r\n\r\n\t\tvar min, max;\r\n\r\n\t\treturn function clampScalar( minVal, maxVal ) {\r\n\r\n\t\t\tif ( min === undefined ) {\r\n\r\n\t\t\t\tmin = new THREE.Vector3();\r\n\t\t\t\tmax = new THREE.Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmin.set( minVal, minVal, minVal );\r\n\t\t\tmax.set( maxVal, maxVal, maxVal );\r\n\r\n\t\t\treturn this.clamp( min, max );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclampLength: function ( min, max ) {\r\n\r\n\t\tvar length = this.length();\r\n\r\n\t\tthis.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tfloor: function () {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\t\tthis.z = Math.floor( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tceil: function () {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\t\tthis.z = Math.ceil( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tround: function () {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\t\tthis.z = Math.round( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\troundToZero: function () {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.x = - this.x;\r\n\t\tthis.y = - this.y;\r\n\t\tthis.z = - this.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\r\n\r\n\t},\r\n\r\n\tlengthManhattan: function () {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() );\r\n\r\n\t},\r\n\r\n\tsetLength: function ( length ) {\r\n\r\n\t\treturn this.multiplyScalar( length / this.length() );\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerpVectors: function ( v1, v2, alpha ) {\r\n\r\n\t\tthis.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcross: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\r\n\t\t\treturn this.crossVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tthis.x = y * v.z - z * v.y;\r\n\t\tthis.y = z * v.x - x * v.z;\r\n\t\tthis.z = x * v.y - y * v.x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcrossVectors: function ( a, b ) {\r\n\r\n\t\tvar ax = a.x, ay = a.y, az = a.z;\r\n\t\tvar bx = b.x, by = b.y, bz = b.z;\r\n\r\n\t\tthis.x = ay * bz - az * by;\r\n\t\tthis.y = az * bx - ax * bz;\r\n\t\tthis.z = ax * by - ay * bx;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tprojectOnVector: function () {\r\n\r\n\t\tvar v1, dot;\r\n\r\n\t\treturn function projectOnVector( vector ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n\t\t\tv1.copy( vector ).normalize();\r\n\r\n\t\t\tdot = this.dot( v1 );\r\n\r\n\t\t\treturn this.copy( v1 ).multiplyScalar( dot );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tprojectOnPlane: function () {\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function projectOnPlane( planeNormal ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n\t\t\tv1.copy( this ).projectOnVector( planeNormal );\r\n\r\n\t\t\treturn this.sub( v1 );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\treflect: function () {\r\n\r\n\t\t// reflect incident vector off plane orthogonal to normal\r\n\t\t// normal is assumed to have unit length\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function reflect( normal ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tangleTo: function ( v ) {\r\n\r\n\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\r\n\r\n\t\t// clamp, to handle numerical problems\r\n\r\n\t\treturn Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );\r\n\r\n\t},\r\n\r\n\tdistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n\t},\r\n\r\n\tdistanceToSquared: function ( v ) {\r\n\r\n\t\tvar dx = this.x - v.x;\r\n\t\tvar dy = this.y - v.y;\r\n\t\tvar dz = this.z - v.z;\r\n\r\n\t\treturn dx * dx + dy * dy + dz * dz;\r\n\r\n\t},\r\n\r\n\tsetFromSpherical: function( s ) {\r\n\r\n\t\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\r\n\r\n\t\tthis.x = sinPhiRadius * Math.sin( s.theta );\r\n\t\tthis.y = Math.cos( s.phi ) * s.radius;\r\n\t\tthis.z = sinPhiRadius * Math.cos( s.theta );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrixPosition: function ( m ) {\r\n\r\n\t\treturn this.setFromMatrixColumn( m, 3 );\r\n\r\n\t},\r\n\r\n\tsetFromMatrixScale: function ( m ) {\r\n\r\n\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\r\n\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\r\n\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\r\n\r\n\t\tthis.x = sx;\r\n\t\tthis.y = sy;\r\n\t\tthis.z = sz;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrixColumn: function ( m, index ) {\r\n\r\n\t\tif ( typeof m === 'number' ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );\r\n\r\n\t\t\tm = arguments[ 1 ];\r\n\t\t\tindex = arguments[ 0 ];\r\n\r\n\t\t}\r\n\r\n\t\treturn this.fromArray( m.elements, index * 4 );\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.x = array[ offset ];\r\n\t\tthis.y = array[ offset + 1 ];\r\n\t\tthis.z = array[ offset + 2 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\t\tarray[ offset + 2 ] = this.z;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tfromAttribute: function ( attribute, index, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tindex = index * attribute.itemSize + offset;\r\n\r\n\t\tthis.x = attribute.array[ index ];\r\n\t\tthis.y = attribute.array[ index + 1 ];\r\n\t\tthis.z = attribute.array[ index + 2 ];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Vector4.js\r\n\r\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Vector4 = function ( x, y, z, w ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\tthis.z = z || 0;\r\n\tthis.w = ( w !== undefined ) ? w : 1;\r\n\r\n};\r\n\r\nTHREE.Vector4.prototype = {\r\n\r\n\tconstructor: THREE.Vector4,\r\n\r\n\tset: function ( x, y, z, w ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\t\tthis.w = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetScalar: function ( scalar ) {\r\n\r\n\t\tthis.x = scalar;\r\n\t\tthis.y = scalar;\r\n\t\tthis.z = scalar;\r\n\t\tthis.w = scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( z ) {\r\n\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetW: function ( w ) {\r\n\r\n\t\tthis.w = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tcase 2: this.z = value; break;\r\n\t\t\tcase 3: this.w = value; break;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tcase 2: return this.z;\r\n\t\t\tcase 3: return this.w;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\t\tthis.z = v.z;\r\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\t\tthis.z += v.z;\r\n\t\tthis.w += v.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\t\tthis.z += s;\r\n\t\tthis.w += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\t\tthis.z = a.z + b.z;\r\n\t\tthis.w = a.w + b.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScaledVector: function ( v, s ) {\r\n\r\n\t\tthis.x += v.x * s;\r\n\t\tthis.y += v.y * s;\r\n\t\tthis.z += v.z * s;\r\n\t\tthis.w += v.w * s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\t\tthis.z -= v.z;\r\n\t\tthis.w -= v.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubScalar: function ( s ) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\t\tthis.z -= s;\r\n\t\tthis.w -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\t\tthis.z = a.z - b.z;\r\n\t\tthis.w = a.w - b.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( scalar ) {\r\n\r\n\t\tif ( isFinite( scalar ) ) {\r\n\r\n\t\t\tthis.x *= scalar;\r\n\t\t\tthis.y *= scalar;\r\n\t\t\tthis.z *= scalar;\r\n\t\t\tthis.w *= scalar;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.z = 0;\r\n\t\t\tthis.w = 0;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( m ) {\r\n\r\n\t\tvar x = this.x;\r\n\t\tvar y = this.y;\r\n\t\tvar z = this.z;\r\n\t\tvar w = this.w;\r\n\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\r\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\r\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\r\n\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( scalar ) {\r\n\r\n\t\treturn this.multiplyScalar( 1 / scalar );\r\n\r\n\t},\r\n\r\n\tsetAxisAngleFromQuaternion: function ( q ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\r\n\r\n\t\t// q is assumed to be normalized\r\n\r\n\t\tthis.w = 2 * Math.acos( q.w );\r\n\r\n\t\tvar s = Math.sqrt( 1 - q.w * q.w );\r\n\r\n\t\tif ( s < 0.0001 ) {\r\n\r\n\t\t\t this.x = 1;\r\n\t\t\t this.y = 0;\r\n\t\t\t this.z = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t this.x = q.x / s;\r\n\t\t\t this.y = q.y / s;\r\n\t\t\t this.z = q.z / s;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetAxisAngleFromRotationMatrix: function ( m ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar angle, x, y, z,\t\t// variables for result\r\n\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\r\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\r\n\r\n\t\t\tte = m.elements,\r\n\r\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\r\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon )\r\n\t\t   && ( Math.abs( m13 - m31 ) < epsilon )\r\n\t\t   && ( Math.abs( m23 - m32 ) < epsilon ) ) {\r\n\r\n\t\t\t// singularity found\r\n\t\t\t// first check for identity matrix which must have +1 for all terms\r\n\t\t\t// in leading diagonal and zero in other terms\r\n\r\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 )\r\n\t\t\t   && ( Math.abs( m13 + m31 ) < epsilon2 )\r\n\t\t\t   && ( Math.abs( m23 + m32 ) < epsilon2 )\r\n\t\t\t   && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\r\n\r\n\t\t\t\t// this singularity is identity matrix so angle = 0\r\n\r\n\t\t\t\tthis.set( 1, 0, 0, 0 );\r\n\r\n\t\t\t\treturn this; // zero angle, arbitrary axis\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// otherwise this singularity is angle = 180\r\n\r\n\t\t\tangle = Math.PI;\r\n\r\n\t\t\tvar xx = ( m11 + 1 ) / 2;\r\n\t\t\tvar yy = ( m22 + 1 ) / 2;\r\n\t\t\tvar zz = ( m33 + 1 ) / 2;\r\n\t\t\tvar xy = ( m12 + m21 ) / 4;\r\n\t\t\tvar xz = ( m13 + m31 ) / 4;\r\n\t\t\tvar yz = ( m23 + m32 ) / 4;\r\n\r\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\r\n\r\n\t\t\t\t// m11 is the largest diagonal term\r\n\r\n\t\t\t\tif ( xx < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0;\r\n\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tx = Math.sqrt( xx );\r\n\t\t\t\t\ty = xy / x;\r\n\t\t\t\t\tz = xz / x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( yy > zz ) {\r\n\r\n\t\t\t\t// m22 is the largest diagonal term\r\n\r\n\t\t\t\tif ( yy < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\ty = 0;\r\n\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ty = Math.sqrt( yy );\r\n\t\t\t\t\tx = xy / y;\r\n\t\t\t\t\tz = yz / y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// m33 is the largest diagonal term so base result on this\r\n\r\n\t\t\t\tif ( zz < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\tz = 0;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tz = Math.sqrt( zz );\r\n\t\t\t\t\tx = xz / z;\r\n\t\t\t\t\ty = yz / z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.set( x, y, z, angle );\r\n\r\n\t\t\treturn this; // return 180 deg rotation\r\n\r\n\t\t}\r\n\r\n\t\t// as we have reached here there are no singularities so we can handle normally\r\n\r\n\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )\r\n\t\t\t\t\t\t  + ( m13 - m31 ) * ( m13 - m31 )\r\n\t\t\t\t\t\t  + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\r\n\r\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\r\n\r\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\r\n\t\t// caught by singularity test above, but I've left it in just in case\r\n\r\n\t\tthis.x = ( m32 - m23 ) / s;\r\n\t\tthis.y = ( m13 - m31 ) / s;\r\n\t\tthis.z = ( m21 - m12 ) / s;\r\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tthis.x = Math.min( this.x, v.x );\r\n\t\tthis.y = Math.min( this.y, v.y );\r\n\t\tthis.z = Math.min( this.z, v.z );\r\n\t\tthis.w = Math.min( this.w, v.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tthis.x = Math.max( this.x, v.x );\r\n\t\tthis.y = Math.max( this.y, v.y );\r\n\t\tthis.z = Math.max( this.z, v.z );\r\n\t\tthis.w = Math.max( this.w, v.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\r\n\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclampScalar: function () {\r\n\r\n\t\tvar min, max;\r\n\r\n\t\treturn function clampScalar( minVal, maxVal ) {\r\n\r\n\t\t\tif ( min === undefined ) {\r\n\r\n\t\t\t\tmin = new THREE.Vector4();\r\n\t\t\t\tmax = new THREE.Vector4();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmin.set( minVal, minVal, minVal, minVal );\r\n\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\r\n\r\n\t\t\treturn this.clamp( min, max );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tfloor: function () {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\t\tthis.z = Math.floor( this.z );\r\n\t\tthis.w = Math.floor( this.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tceil: function () {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\t\tthis.z = Math.ceil( this.z );\r\n\t\tthis.w = Math.ceil( this.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tround: function () {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\t\tthis.z = Math.round( this.z );\r\n\t\tthis.w = Math.round( this.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\troundToZero: function () {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.x = - this.x;\r\n\t\tthis.y = - this.y;\r\n\t\tthis.z = - this.z;\r\n\t\tthis.w = - this.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\r\n\r\n\t},\r\n\r\n\tlengthManhattan: function () {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() );\r\n\r\n\t},\r\n\r\n\tsetLength: function ( length ) {\r\n\r\n\t\treturn this.multiplyScalar( length / this.length() );\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\t\tthis.w += ( v.w - this.w ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerpVectors: function ( v1, v2, alpha ) {\r\n\r\n\t\tthis.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.x = array[ offset ];\r\n\t\tthis.y = array[ offset + 1 ];\r\n\t\tthis.z = array[ offset + 2 ];\r\n\t\tthis.w = array[ offset + 3 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\t\tarray[ offset + 2 ] = this.z;\r\n\t\tarray[ offset + 3 ] = this.w;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tfromAttribute: function ( attribute, index, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tindex = index * attribute.itemSize + offset;\r\n\r\n\t\tthis.x = attribute.array[ index ];\r\n\t\tthis.y = attribute.array[ index + 1 ];\r\n\t\tthis.z = attribute.array[ index + 2 ];\r\n\t\tthis.w = attribute.array[ index + 3 ];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Euler.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Euler = function ( x, y, z, order ) {\r\n\r\n\tthis._x = x || 0;\r\n\tthis._y = y || 0;\r\n\tthis._z = z || 0;\r\n\tthis._order = order || THREE.Euler.DefaultOrder;\r\n\r\n};\r\n\r\nTHREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\r\n\r\nTHREE.Euler.DefaultOrder = 'XYZ';\r\n\r\nTHREE.Euler.prototype = {\r\n\r\n\tconstructor: THREE.Euler,\r\n\r\n\tget x () {\r\n\r\n\t\treturn this._x;\r\n\r\n\t},\r\n\r\n\tset x ( value ) {\r\n\r\n\t\tthis._x = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget y () {\r\n\r\n\t\treturn this._y;\r\n\r\n\t},\r\n\r\n\tset y ( value ) {\r\n\r\n\t\tthis._y = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget z () {\r\n\r\n\t\treturn this._z;\r\n\r\n\t},\r\n\r\n\tset z ( value ) {\r\n\r\n\t\tthis._z = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget order () {\r\n\r\n\t\treturn this._order;\r\n\r\n\t},\r\n\r\n\tset order ( value ) {\r\n\r\n\t\tthis._order = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tset: function ( x, y, z, order ) {\r\n\r\n\t\tthis._x = x;\r\n\t\tthis._y = y;\r\n\t\tthis._z = z;\r\n\t\tthis._order = order || this._order;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\r\n\r\n\t},\r\n\r\n\tcopy: function ( euler ) {\r\n\r\n\t\tthis._x = euler._x;\r\n\t\tthis._y = euler._y;\r\n\t\tthis._z = euler._z;\r\n\t\tthis._order = euler._order;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromRotationMatrix: function ( m, order, update ) {\r\n\r\n\t\tvar clamp = THREE.Math.clamp;\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar te = m.elements;\r\n\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\r\n\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\r\n\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\r\n\t\torder = order || this._order;\r\n\r\n\t\tif ( order === 'XYZ' ) {\r\n\r\n\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\tthis._z = Math.atan2( - m12, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\tthis._z = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'YXZ' ) {\r\n\r\n\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\t\t\t\tthis._z = Math.atan2( m21, m22 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\t\t\t\tthis._z = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'ZXY' ) {\r\n\r\n\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._y = Math.atan2( - m31, m33 );\r\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._y = 0;\r\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'ZYX' ) {\r\n\r\n\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( m32, m33 );\r\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = 0;\r\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'YZX' ) {\r\n\r\n\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( - m23, m22 );\r\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = 0;\r\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'XZY' ) {\r\n\r\n\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\tthis._y = Math.atan2( m13, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\tthis._y = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )\r\n\r\n\t\t}\r\n\r\n\t\tthis._order = order;\r\n\r\n\t\tif ( update !== false ) this.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromQuaternion: function () {\r\n\r\n\t\tvar matrix;\r\n\r\n\t\treturn function ( q, order, update ) {\r\n\r\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\t\t\tmatrix.makeRotationFromQuaternion( q );\r\n\t\t\tthis.setFromRotationMatrix( matrix, order, update );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetFromVector3: function ( v, order ) {\r\n\r\n\t\treturn this.set( v.x, v.y, v.z, order || this._order );\r\n\r\n\t},\r\n\r\n\treorder: function () {\r\n\r\n\t\t// WARNING: this discards revolution information -bhouston\r\n\r\n\t\tvar q = new THREE.Quaternion();\r\n\r\n\t\treturn function ( newOrder ) {\r\n\r\n\t\t\tq.setFromEuler( this );\r\n\t\t\tthis.setFromQuaternion( q, newOrder );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tequals: function ( euler ) {\r\n\r\n\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis._x = array[ 0 ];\r\n\t\tthis._y = array[ 1 ];\r\n\t\tthis._z = array[ 2 ];\r\n\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this._x;\r\n\t\tarray[ offset + 1 ] = this._y;\r\n\t\tarray[ offset + 2 ] = this._z;\r\n\t\tarray[ offset + 3 ] = this._order;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\ttoVector3: function ( optionalResult ) {\r\n\r\n\t\tif ( optionalResult ) {\r\n\r\n\t\t\treturn optionalResult.set( this._x, this._y, this._z );\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn new THREE.Vector3( this._x, this._y, this._z );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tonChange: function ( callback ) {\r\n\r\n\t\tthis.onChangeCallback = callback;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tonChangeCallback: function () {}\r\n\r\n};\r\n\r\n// File:src/math/Line3.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Line3 = function ( start, end ) {\r\n\r\n\tthis.start = ( start !== undefined ) ? start : new THREE.Vector3();\r\n\tthis.end = ( end !== undefined ) ? end : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Line3.prototype = {\r\n\r\n\tconstructor: THREE.Line3,\r\n\r\n\tset: function ( start, end ) {\r\n\r\n\t\tthis.start.copy( start );\r\n\t\tthis.end.copy( end );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( line ) {\r\n\r\n\t\tthis.start.copy( line.start );\r\n\t\tthis.end.copy( line.end );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcenter: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\r\n\r\n\t},\r\n\r\n\tdelta: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.subVectors( this.end, this.start );\r\n\r\n\t},\r\n\r\n\tdistanceSq: function () {\r\n\r\n\t\treturn this.start.distanceToSquared( this.end );\r\n\r\n\t},\r\n\r\n\tdistance: function () {\r\n\r\n\t\treturn this.start.distanceTo( this.end );\r\n\r\n\t},\r\n\r\n\tat: function ( t, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\r\n\t},\r\n\r\n\tclosestPointToPointParameter: function () {\r\n\r\n\t\tvar startP = new THREE.Vector3();\r\n\t\tvar startEnd = new THREE.Vector3();\r\n\r\n\t\treturn function ( point, clampToLine ) {\r\n\r\n\t\t\tstartP.subVectors( point, this.start );\r\n\t\t\tstartEnd.subVectors( this.end, this.start );\r\n\r\n\t\t\tvar startEnd2 = startEnd.dot( startEnd );\r\n\t\t\tvar startEnd_startP = startEnd.dot( startP );\r\n\r\n\t\t\tvar t = startEnd_startP / startEnd2;\r\n\r\n\t\t\tif ( clampToLine ) {\r\n\r\n\t\t\t\tt = THREE.Math.clamp( t, 0, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn t;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\r\n\r\n\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( matrix ) {\r\n\r\n\t\tthis.start.applyMatrix4( matrix );\r\n\t\tthis.end.applyMatrix4( matrix );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( line ) {\r\n\r\n\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Box2.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Box2 = function ( min, max ) {\r\n\r\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector2( + Infinity, + Infinity );\r\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );\r\n\r\n};\r\n\r\nTHREE.Box2.prototype = {\r\n\r\n\tconstructor: THREE.Box2,\r\n\r\n\tset: function ( min, max ) {\r\n\r\n\t\tthis.min.copy( min );\r\n\t\tthis.max.copy( max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function ( points ) {\r\n\r\n\t\tthis.makeEmpty();\r\n\r\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.expandByPoint( points[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCenterAndSize: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector2();\r\n\r\n\t\treturn function ( center, size ) {\r\n\r\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\tthis.max.copy( center ).add( halfSize );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( box ) {\r\n\r\n\t\tthis.min.copy( box.min );\r\n\t\tthis.max.copy( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeEmpty: function () {\r\n\r\n\t\tthis.min.x = this.min.y = + Infinity;\r\n\t\tthis.max.x = this.max.y = - Infinity;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tisEmpty: function () {\r\n\r\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\r\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\r\n\r\n\t},\r\n\r\n\tcenter: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\r\n\t},\r\n\r\n\tsize: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\treturn result.subVectors( this.max, this.min );\r\n\r\n\t},\r\n\r\n\texpandByPoint: function ( point ) {\r\n\r\n\t\tthis.min.min( point );\r\n\t\tthis.max.max( point );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByVector: function ( vector ) {\r\n\r\n\t\tthis.min.sub( vector );\r\n\t\tthis.max.add( vector );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByScalar: function ( scalar ) {\r\n\r\n\t\tthis.min.addScalar( - scalar );\r\n\t\tthis.max.addScalar( scalar );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\r\n\t\t     point.y < this.min.y || point.y > this.max.y ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tcontainsBox: function ( box ) {\r\n\r\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tgetParameter: function ( point, optionalTarget ) {\r\n\r\n\t\t// This can potentially have a divide by zero if the box\r\n\t\t// has a size dimension of 0.\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\r\n\t\treturn result.set(\r\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\r\n\t\t);\r\n\r\n\t},\r\n\r\n\tintersectsBox: function ( box ) {\r\n\r\n\t\t// using 6 splitting planes to rule out intersections.\r\n\r\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\treturn result.copy( point ).clamp( this.min, this.max );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector2();\r\n\r\n\t\treturn function ( point ) {\r\n\r\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\treturn clampedPoint.sub( point ).length();\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersect: function ( box ) {\r\n\r\n\t\tthis.min.max( box.min );\r\n\t\tthis.max.min( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tunion: function ( box ) {\r\n\r\n\t\tthis.min.min( box.min );\r\n\t\tthis.max.max( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.min.add( offset );\r\n\t\tthis.max.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( box ) {\r\n\r\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Box3.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Box3 = function ( min, max ) {\r\n\r\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector3( + Infinity, + Infinity, + Infinity );\r\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );\r\n\r\n};\r\n\r\nTHREE.Box3.prototype = {\r\n\r\n\tconstructor: THREE.Box3,\r\n\r\n\tset: function ( min, max ) {\r\n\r\n\t\tthis.min.copy( min );\r\n\t\tthis.max.copy( max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromArray: function ( array ) {\r\n\r\n\t\tthis.makeEmpty();\r\n\r\n\t\tvar minX = + Infinity;\r\n\t\tvar minY = + Infinity;\r\n\t\tvar minZ = + Infinity;\r\n\r\n\t\tvar maxX = - Infinity;\r\n\t\tvar maxY = - Infinity;\r\n\t\tvar maxZ = - Infinity;\r\n\r\n\t\tfor ( var i = 0, il = array.length; i < il; i += 3 ) {\r\n\r\n\t\t\tvar x = array[ i ];\r\n\t\t\tvar y = array[ i + 1 ];\r\n\t\t\tvar z = array[ i + 2 ];\r\n\r\n\t\t\tif ( x < minX ) minX = x;\r\n\t\t\tif ( y < minY ) minY = y;\r\n\t\t\tif ( z < minZ ) minZ = z;\r\n\r\n\t\t\tif ( x > maxX ) maxX = x;\r\n\t\t\tif ( y > maxY ) maxY = y;\r\n\t\t\tif ( z > maxZ ) maxZ = z;\r\n\r\n\t\t}\r\n\r\n\t\tthis.min.set( minX, minY, minZ );\r\n\t\tthis.max.set( maxX, maxY, maxZ );\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function ( points ) {\r\n\r\n\t\tthis.makeEmpty();\r\n\r\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.expandByPoint( points[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCenterAndSize: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( center, size ) {\r\n\r\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\r\n\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\tthis.max.copy( center ).add( halfSize );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetFromObject: function () {\r\n\r\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\r\n\t\t// accounting for both the object's, and children's, world transforms\r\n\r\n\t\tvar box;\r\n\r\n\t\treturn function ( object ) {\r\n\r\n\t\t\tif ( box === undefined ) box = new THREE.Box3();\r\n\r\n\t\t\tvar scope = this;\r\n\r\n\t\t\tthis.makeEmpty();\r\n\r\n\t\t\tobject.updateMatrixWorld( true );\r\n\r\n\t\t\tobject.traverse( function ( node ) {\r\n\r\n\t\t\t\tvar geometry = node.geometry;\r\n\r\n\t\t\t\tif ( geometry !== undefined ) {\r\n\r\n\t\t\t\t\tif ( geometry.boundingBox === null ) {\r\n\r\n\t\t\t\t\t\tgeometry.computeBoundingBox();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( geometry.boundingBox.isEmpty() === false ) {\r\n\r\n\t\t\t\t\t\tbox.copy( geometry.boundingBox );\r\n\t\t\t\t\t\tbox.applyMatrix4( node.matrixWorld );\r\n\t\t\t\t\t\tscope.union( box );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( box ) {\r\n\r\n\t\tthis.min.copy( box.min );\r\n\t\tthis.max.copy( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeEmpty: function () {\r\n\r\n\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\r\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tisEmpty: function () {\r\n\r\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\r\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\r\n\r\n\t},\r\n\r\n\tcenter: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\r\n\t},\r\n\r\n\tsize: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.subVectors( this.max, this.min );\r\n\r\n\t},\r\n\r\n\texpandByPoint: function ( point ) {\r\n\r\n\t\tthis.min.min( point );\r\n\t\tthis.max.max( point );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByVector: function ( vector ) {\r\n\r\n\t\tthis.min.sub( vector );\r\n\t\tthis.max.add( vector );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByScalar: function ( scalar ) {\r\n\r\n\t\tthis.min.addScalar( - scalar );\r\n\t\tthis.max.addScalar( scalar );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\r\n\t\t\t\t point.y < this.min.y || point.y > this.max.y ||\r\n\t\t\t\t point.z < this.min.z || point.z > this.max.z ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tcontainsBox: function ( box ) {\r\n\r\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\r\n\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tgetParameter: function ( point, optionalTarget ) {\r\n\r\n\t\t// This can potentially have a divide by zero if the box\r\n\t\t// has a size dimension of 0.\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\treturn result.set(\r\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\r\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\r\n\t\t);\r\n\r\n\t},\r\n\r\n\tintersectsBox: function ( box ) {\r\n\r\n\t\t// using 6 splitting planes to rule out intersections.\r\n\r\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t\t\t box.max.y < this.min.y || box.min.y > this.max.y ||\r\n\t\t\t\t box.max.z < this.min.z || box.min.z > this.max.z ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tintersectsSphere: ( function () {\r\n\r\n\t\tvar closestPoint;\r\n\r\n\t\treturn function intersectsSphere( sphere ) {\r\n\r\n\t\t\tif ( closestPoint === undefined ) closestPoint = new THREE.Vector3();\r\n\r\n\t\t\t// Find the point on the AABB closest to the sphere center.\r\n\t\t\tthis.clampPoint( sphere.center, closestPoint );\r\n\r\n\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\r\n\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\tintersectsPlane: function ( plane ) {\r\n\r\n\t\t// We compute the minimum and maximum dot product values. If those values\r\n\t\t// are on the same side (back or front) of the plane, then there is no intersection.\r\n\r\n\t\tvar min, max;\r\n\r\n\t\tif ( plane.normal.x > 0 ) {\r\n\r\n\t\t\tmin = plane.normal.x * this.min.x;\r\n\t\t\tmax = plane.normal.x * this.max.x;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmin = plane.normal.x * this.max.x;\r\n\t\t\tmax = plane.normal.x * this.min.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( plane.normal.y > 0 ) {\r\n\r\n\t\t\tmin += plane.normal.y * this.min.y;\r\n\t\t\tmax += plane.normal.y * this.max.y;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmin += plane.normal.y * this.max.y;\r\n\t\t\tmax += plane.normal.y * this.min.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( plane.normal.z > 0 ) {\r\n\r\n\t\t\tmin += plane.normal.z * this.min.z;\r\n\t\t\tmax += plane.normal.z * this.max.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmin += plane.normal.z * this.max.z;\r\n\t\t\tmax += plane.normal.z * this.min.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn ( min <= plane.constant && max >= plane.constant );\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.copy( point ).clamp( this.min, this.max );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( point ) {\r\n\r\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\treturn clampedPoint.sub( point ).length();\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetBoundingSphere: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Sphere();\r\n\r\n\t\t\tresult.center = this.center();\r\n\t\t\tresult.radius = this.size( v1 ).length() * 0.5;\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersect: function ( box ) {\r\n\r\n\t\tthis.min.max( box.min );\r\n\t\tthis.max.min( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tunion: function ( box ) {\r\n\r\n\t\tthis.min.min( box.min );\r\n\t\tthis.max.max( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function () {\r\n\r\n\t\tvar points = [\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3()\r\n\t\t];\r\n\r\n\t\treturn function ( matrix ) {\r\n\r\n\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\r\n\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\r\n\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\r\n\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\r\n\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\r\n\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\r\n\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\r\n\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\r\n\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\t// 111\r\n\r\n\t\t\tthis.makeEmpty();\r\n\t\t\tthis.setFromPoints( points );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.min.add( offset );\r\n\t\tthis.max.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( box ) {\r\n\r\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Matrix3.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://clara.io\r\n * @author tschw\r\n */\r\n\r\nTHREE.Matrix3 = function () {\r\n\r\n\tthis.elements = new Float32Array( [\r\n\r\n\t\t1, 0, 0,\r\n\t\t0, 1, 0,\r\n\t\t0, 0, 1\r\n\r\n\t] );\r\n\r\n\tif ( arguments.length > 0 ) {\r\n\r\n\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Matrix3.prototype = {\r\n\r\n\tconstructor: THREE.Matrix3,\r\n\r\n\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\r\n\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\r\n\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tidentity: function () {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0,\r\n\t\t\t0, 1, 0,\r\n\t\t\t0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().fromArray( this.elements );\r\n\r\n\t},\r\n\r\n\tcopy: function ( m ) {\r\n\r\n\t\tvar me = m.elements;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tme[ 0 ], me[ 3 ], me[ 6 ],\r\n\t\t\tme[ 1 ], me[ 4 ], me[ 7 ],\r\n\t\t\tme[ 2 ], me[ 5 ], me[ 8 ]\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrix4: function( m ) {\r\n\r\n\t\tvar me = m.elements;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tme[ 0 ], me[ 4 ], me[  8 ],\r\n\t\t\tme[ 1 ], me[ 5 ], me[  9 ],\r\n\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyToVector3Array: function () {\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function ( array, offset, length ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\tif ( length === undefined ) length = array.length;\r\n\r\n\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\r\n\r\n\t\t\t\tv1.fromArray( array, j );\r\n\t\t\t\tv1.applyMatrix3( this );\r\n\t\t\t\tv1.toArray( array, j );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyToBuffer: function () {\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function applyToBuffer( buffer, offset, length ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\r\n\r\n\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\r\n\r\n\t\t\t\tv1.x = buffer.getX( j );\r\n\t\t\t\tv1.y = buffer.getY( j );\r\n\t\t\t\tv1.z = buffer.getZ( j );\r\n\r\n\t\t\t\tv1.applyMatrix3( this );\r\n\r\n\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn buffer;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\r\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\r\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdeterminant: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\r\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\r\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\r\n\r\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\r\n\r\n\t},\r\n\r\n\tgetInverse: function ( matrix, throwOnDegenerate ) {\r\n\r\n\t\tif ( matrix instanceof THREE.Matrix4 ) {\r\n\r\n\t\t\tconsole.warn( \"THREE.Matrix3.getInverse no longer takes a Matrix4 argument.\" );\r\n\r\n\t\t}\r\n\r\n\t\tvar me = matrix.elements,\r\n\t\t\tte = this.elements,\r\n\r\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\r\n\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\r\n\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\r\n\r\n\t\t\tt11 = n33 * n22 - n32 * n23,\r\n\t\t\tt12 = n32 * n13 - n33 * n12,\r\n\t\t\tt13 = n23 * n12 - n22 * n13,\r\n\r\n\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\r\n\r\n\t\tif ( det === 0 ) {\r\n\r\n\t\t\tvar msg = \"THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0\";\r\n\r\n\t\t\tif ( throwOnDegenerate || false ) {\r\n\r\n\t\t\t\tthrow new Error( msg );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( msg );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.identity();\r\n\t\t}\r\n\r\n\t\tte[ 0 ] = t11;\r\n\t\tte[ 1 ] = n31 * n23 - n33 * n21;\r\n\t\tte[ 2 ] = n32 * n21 - n31 * n22;\r\n\r\n\t\tte[ 3 ] = t12;\r\n\t\tte[ 4 ] = n33 * n11 - n31 * n13;\r\n\t\tte[ 5 ] = n31 * n12 - n32 * n11;\r\n\r\n\t\tte[ 6 ] = t13;\r\n\t\tte[ 7 ] = n21 * n13 - n23 * n11;\r\n\t\tte[ 8 ] = n22 * n11 - n21 * n12;\r\n\r\n\t\treturn this.multiplyScalar( 1 / det );\r\n\r\n\t},\r\n\r\n\ttranspose: function () {\r\n\r\n\t\tvar tmp, m = this.elements;\r\n\r\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\r\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\r\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tflattenToArrayOffset: function ( array, offset ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tarray[ offset ] = te[ 0 ];\r\n\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\r\n\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\r\n\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\t\tarray[ offset + 8 ]  = te[ 8 ];\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tgetNormalMatrix: function ( matrix4 ) {\r\n\r\n\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\r\n\r\n\t},\r\n\r\n\ttransposeIntoArray: function ( r ) {\r\n\r\n\t\tvar m = this.elements;\r\n\r\n\t\tr[ 0 ] = m[ 0 ];\r\n\t\tr[ 1 ] = m[ 3 ];\r\n\t\tr[ 2 ] = m[ 6 ];\r\n\t\tr[ 3 ] = m[ 1 ];\r\n\t\tr[ 4 ] = m[ 4 ];\r\n\t\tr[ 5 ] = m[ 7 ];\r\n\t\tr[ 6 ] = m[ 2 ];\r\n\t\tr[ 7 ] = m[ 5 ];\r\n\t\tr[ 8 ] = m[ 8 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis.elements.set( array );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\treturn [\r\n\t\t\tte[ 0 ], te[ 1 ], te[ 2 ],\r\n\t\t\tte[ 3 ], te[ 4 ], te[ 5 ],\r\n\t\t\tte[ 6 ], te[ 7 ], te[ 8 ]\r\n\t\t];\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Matrix4.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author jordi_ros / http://plattsoft.com\r\n * @author D1plo1d / http://github.com/D1plo1d\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author timknip / http://www.floorplanner.com/\r\n * @author bhouston / http://clara.io\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Matrix4 = function () {\r\n\r\n\tthis.elements = new Float32Array( [\r\n\r\n\t\t1, 0, 0, 0,\r\n\t\t0, 1, 0, 0,\r\n\t\t0, 0, 1, 0,\r\n\t\t0, 0, 0, 1\r\n\r\n\t] );\r\n\r\n\tif ( arguments.length > 0 ) {\r\n\r\n\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Matrix4.prototype = {\r\n\r\n\tconstructor: THREE.Matrix4,\r\n\r\n\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\r\n\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\r\n\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\r\n\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tidentity: function () {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, 0,\r\n\t\t\t0, 1, 0, 0,\r\n\t\t\t0, 0, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Matrix4().fromArray( this.elements );\r\n\r\n\t},\r\n\r\n\tcopy: function ( m ) {\r\n\r\n\t\tthis.elements.set( m.elements );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyPosition: function ( m ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar me = m.elements;\r\n\r\n\t\tte[ 12 ] = me[ 12 ];\r\n\t\tte[ 13 ] = me[ 13 ];\r\n\t\tte[ 14 ] = me[ 14 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\textractBasis: function ( xAxis, yAxis, zAxis ) {\r\n\r\n\t\txAxis.setFromMatrixColumn( this, 0 );\r\n\t\tyAxis.setFromMatrixColumn( this, 1 );\r\n\t\tzAxis.setFromMatrixColumn( this, 2 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\r\n\r\n\t\tthis.set(\r\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\r\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\r\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\r\n\t\t\t0,       0,       0,       1\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\textractRotation: function () {\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function ( m ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar me = m.elements;\r\n\r\n\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\r\n\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\r\n\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\r\n\r\n\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\r\n\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\r\n\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\r\n\r\n\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\r\n\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\r\n\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\r\n\r\n\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\r\n\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\r\n\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmakeRotationFromEuler: function ( euler ) {\r\n\r\n\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\r\n\t\t\tconsole.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\r\n\t\t}\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar x = euler.x, y = euler.y, z = euler.z;\r\n\t\tvar a = Math.cos( x ), b = Math.sin( x );\r\n\t\tvar c = Math.cos( y ), d = Math.sin( y );\r\n\t\tvar e = Math.cos( z ), f = Math.sin( z );\r\n\r\n\t\tif ( euler.order === 'XYZ' ) {\r\n\r\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = - c * f;\r\n\t\t\tte[ 8 ] = d;\r\n\r\n\t\t\tte[ 1 ] = af + be * d;\r\n\t\t\tte[ 5 ] = ae - bf * d;\r\n\t\t\tte[ 9 ] = - b * c;\r\n\r\n\t\t\tte[ 2 ] = bf - ae * d;\r\n\t\t\tte[ 6 ] = be + af * d;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'YXZ' ) {\r\n\r\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\tte[ 0 ] = ce + df * b;\r\n\t\t\tte[ 4 ] = de * b - cf;\r\n\t\t\tte[ 8 ] = a * d;\r\n\r\n\t\t\tte[ 1 ] = a * f;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = - b;\r\n\r\n\t\t\tte[ 2 ] = cf * b - de;\r\n\t\t\tte[ 6 ] = df + ce * b;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'ZXY' ) {\r\n\r\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\tte[ 0 ] = ce - df * b;\r\n\t\t\tte[ 4 ] = - a * f;\r\n\t\t\tte[ 8 ] = de + cf * b;\r\n\r\n\t\t\tte[ 1 ] = cf + de * b;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = df - ce * b;\r\n\r\n\t\t\tte[ 2 ] = - a * d;\r\n\t\t\tte[ 6 ] = b;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'ZYX' ) {\r\n\r\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = be * d - af;\r\n\t\t\tte[ 8 ] = ae * d + bf;\r\n\r\n\t\t\tte[ 1 ] = c * f;\r\n\t\t\tte[ 5 ] = bf * d + ae;\r\n\t\t\tte[ 9 ] = af * d - be;\r\n\r\n\t\t\tte[ 2 ] = - d;\r\n\t\t\tte[ 6 ] = b * c;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'YZX' ) {\r\n\r\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = bd - ac * f;\r\n\t\t\tte[ 8 ] = bc * f + ad;\r\n\r\n\t\t\tte[ 1 ] = f;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = - b * e;\r\n\r\n\t\t\tte[ 2 ] = - d * e;\r\n\t\t\tte[ 6 ] = ad * f + bc;\r\n\t\t\tte[ 10 ] = ac - bd * f;\r\n\r\n\t\t} else if ( euler.order === 'XZY' ) {\r\n\r\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = - f;\r\n\t\t\tte[ 8 ] = d * e;\r\n\r\n\t\t\tte[ 1 ] = ac * f + bd;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = ad * f - bc;\r\n\r\n\t\t\tte[ 2 ] = bc * f - ad;\r\n\t\t\tte[ 6 ] = b * e;\r\n\t\t\tte[ 10 ] = bd * f + ac;\r\n\r\n\t\t}\r\n\r\n\t\t// last column\r\n\t\tte[ 3 ] = 0;\r\n\t\tte[ 7 ] = 0;\r\n\t\tte[ 11 ] = 0;\r\n\r\n\t\t// bottom row\r\n\t\tte[ 12 ] = 0;\r\n\t\tte[ 13 ] = 0;\r\n\t\tte[ 14 ] = 0;\r\n\t\tte[ 15 ] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationFromQuaternion: function ( q ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\r\n\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\r\n\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\r\n\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\r\n\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\r\n\r\n\t\tte[ 0 ] = 1 - ( yy + zz );\r\n\t\tte[ 4 ] = xy - wz;\r\n\t\tte[ 8 ] = xz + wy;\r\n\r\n\t\tte[ 1 ] = xy + wz;\r\n\t\tte[ 5 ] = 1 - ( xx + zz );\r\n\t\tte[ 9 ] = yz - wx;\r\n\r\n\t\tte[ 2 ] = xz - wy;\r\n\t\tte[ 6 ] = yz + wx;\r\n\t\tte[ 10 ] = 1 - ( xx + yy );\r\n\r\n\t\t// last column\r\n\t\tte[ 3 ] = 0;\r\n\t\tte[ 7 ] = 0;\r\n\t\tte[ 11 ] = 0;\r\n\r\n\t\t// bottom row\r\n\t\tte[ 12 ] = 0;\r\n\t\tte[ 13 ] = 0;\r\n\t\tte[ 14 ] = 0;\r\n\t\tte[ 15 ] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlookAt: function () {\r\n\r\n\t\tvar x, y, z;\r\n\r\n\t\treturn function ( eye, target, up ) {\r\n\r\n\t\t\tif ( x === undefined ) x = new THREE.Vector3();\r\n\t\t\tif ( y === undefined ) y = new THREE.Vector3();\r\n\t\t\tif ( z === undefined ) z = new THREE.Vector3();\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tz.subVectors( eye, target ).normalize();\r\n\r\n\t\t\tif ( z.lengthSq() === 0 ) {\r\n\r\n\t\t\t\tz.z = 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tx.crossVectors( up, z ).normalize();\r\n\r\n\t\t\tif ( x.lengthSq() === 0 ) {\r\n\r\n\t\t\t\tz.x += 0.0001;\r\n\t\t\t\tx.crossVectors( up, z ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t\ty.crossVectors( z, x );\r\n\r\n\r\n\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\r\n\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\r\n\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmultiply: function ( m, n ) {\r\n\r\n\t\tif ( n !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\r\n\t\t\treturn this.multiplyMatrices( m, n );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.multiplyMatrices( this, m );\r\n\r\n\t},\r\n\r\n\tmultiplyMatrices: function ( a, b ) {\r\n\r\n\t\tvar ae = a.elements;\r\n\t\tvar be = b.elements;\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\r\n\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\r\n\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\r\n\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\r\n\r\n\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\r\n\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\r\n\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\r\n\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\r\n\r\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\r\n\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\r\n\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\r\n\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\r\n\r\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\r\n\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\r\n\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\r\n\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\r\n\r\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\r\n\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\r\n\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\r\n\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\r\n\r\n\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\r\n\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\r\n\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\r\n\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyToArray: function ( a, b, r ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tthis.multiplyMatrices( a, b );\r\n\r\n\t\tr[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\r\n\t\tr[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\r\n\t\tr[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\r\n\t\tr[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\r\n\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\r\n\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\r\n\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyToVector3Array: function () {\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function ( array, offset, length ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\tif ( length === undefined ) length = array.length;\r\n\r\n\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\r\n\r\n\t\t\t\tv1.fromArray( array, j );\r\n\t\t\t\tv1.applyMatrix4( this );\r\n\t\t\t\tv1.toArray( array, j );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyToBuffer: function () {\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function applyToBuffer( buffer, offset, length ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\r\n\r\n\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\r\n\r\n\t\t\t\tv1.x = buffer.getX( j );\r\n\t\t\t\tv1.y = buffer.getY( j );\r\n\t\t\t\tv1.z = buffer.getZ( j );\r\n\r\n\t\t\t\tv1.applyMatrix4( this );\r\n\r\n\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn buffer;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tdeterminant: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\r\n\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\r\n\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\r\n\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\r\n\r\n\t\t//TODO: make this more efficient\r\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\r\n\r\n\t\treturn (\r\n\t\t\tn41 * (\r\n\t\t\t\t+ n14 * n23 * n32\r\n\t\t\t\t - n13 * n24 * n32\r\n\t\t\t\t - n14 * n22 * n33\r\n\t\t\t\t + n12 * n24 * n33\r\n\t\t\t\t + n13 * n22 * n34\r\n\t\t\t\t - n12 * n23 * n34\r\n\t\t\t) +\r\n\t\t\tn42 * (\r\n\t\t\t\t+ n11 * n23 * n34\r\n\t\t\t\t - n11 * n24 * n33\r\n\t\t\t\t + n14 * n21 * n33\r\n\t\t\t\t - n13 * n21 * n34\r\n\t\t\t\t + n13 * n24 * n31\r\n\t\t\t\t - n14 * n23 * n31\r\n\t\t\t) +\r\n\t\t\tn43 * (\r\n\t\t\t\t+ n11 * n24 * n32\r\n\t\t\t\t - n11 * n22 * n34\r\n\t\t\t\t - n14 * n21 * n32\r\n\t\t\t\t + n12 * n21 * n34\r\n\t\t\t\t + n14 * n22 * n31\r\n\t\t\t\t - n12 * n24 * n31\r\n\t\t\t) +\r\n\t\t\tn44 * (\r\n\t\t\t\t- n13 * n22 * n31\r\n\t\t\t\t - n11 * n23 * n32\r\n\t\t\t\t + n11 * n22 * n33\r\n\t\t\t\t + n13 * n21 * n32\r\n\t\t\t\t - n12 * n21 * n33\r\n\t\t\t\t + n12 * n23 * n31\r\n\t\t\t)\r\n\r\n\t\t);\r\n\r\n\t},\r\n\r\n\ttranspose: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar tmp;\r\n\r\n\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\r\n\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\r\n\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\r\n\r\n\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\r\n\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\r\n\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tflattenToArrayOffset: function ( array, offset ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tarray[ offset ] = te[ 0 ];\r\n\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\r\n\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\r\n\t\tarray[ offset + 8 ]  = te[ 8 ];\r\n\t\tarray[ offset + 9 ]  = te[ 9 ];\r\n\t\tarray[ offset + 10 ] = te[ 10 ];\r\n\t\tarray[ offset + 11 ] = te[ 11 ];\r\n\r\n\t\tarray[ offset + 12 ] = te[ 12 ];\r\n\t\tarray[ offset + 13 ] = te[ 13 ];\r\n\t\tarray[ offset + 14 ] = te[ 14 ];\r\n\t\tarray[ offset + 15 ] = te[ 15 ];\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tgetPosition: function () {\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\r\n\r\n\t\t\treturn v1.setFromMatrixColumn( this, 3 );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetPosition: function ( v ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 12 ] = v.x;\r\n\t\tte[ 13 ] = v.y;\r\n\t\tte[ 14 ] = v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetInverse: function ( m, throwOnDegenerate ) {\r\n\r\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n\t\tvar te = this.elements,\r\n\t\t\tme = m.elements,\r\n\r\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\r\n\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\r\n\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\r\n\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\r\n\r\n\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\r\n\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\r\n\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\r\n\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\r\n\r\n\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\r\n\r\n\t\tif ( det === 0 ) {\r\n\r\n\t\t\tvar msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\r\n\r\n\t\t\tif ( throwOnDegenerate || false ) {\r\n\r\n\t\t\t\tthrow new Error( msg );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( msg );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.identity();\r\n\r\n\t\t}\r\n\r\n\t\tte[ 0 ] = t11;\r\n\t\tte[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;\r\n\t\tte[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;\r\n\t\tte[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;\r\n\r\n\t\tte[ 4 ] = t12;\r\n\t\tte[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;\r\n\t\tte[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;\r\n\t\tte[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;\r\n\r\n\t\tte[ 8 ] = t13;\r\n\t\tte[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;\r\n\t\tte[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;\r\n\t\tte[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;\r\n\r\n\t\tte[ 12 ] = t14;\r\n\t\tte[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;\r\n\t\tte[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;\r\n\t\tte[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;\r\n\r\n\t\treturn this.multiplyScalar( 1 / det );\r\n\r\n\t},\r\n\r\n\tscale: function ( v ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar x = v.x, y = v.y, z = v.z;\r\n\r\n\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\r\n\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\r\n\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\r\n\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetMaxScaleOnAxis: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\r\n\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\r\n\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\r\n\r\n\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\r\n\r\n\t},\r\n\r\n\tmakeTranslation: function ( x, y, z ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, x,\r\n\t\t\t0, 1, 0, y,\r\n\t\t\t0, 0, 1, z,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationX: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0,  0, 0,\r\n\t\t\t0, c, - s, 0,\r\n\t\t\t0, s,  c, 0,\r\n\t\t\t0, 0,  0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationY: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t c, 0, s, 0,\r\n\t\t\t 0, 1, 0, 0,\r\n\t\t\t- s, 0, c, 0,\r\n\t\t\t 0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationZ: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tc, - s, 0, 0,\r\n\t\t\ts,  c, 0, 0,\r\n\t\t\t0,  0, 1, 0,\r\n\t\t\t0,  0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationAxis: function ( axis, angle ) {\r\n\r\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\r\n\r\n\t\tvar c = Math.cos( angle );\r\n\t\tvar s = Math.sin( angle );\r\n\t\tvar t = 1 - c;\r\n\t\tvar x = axis.x, y = axis.y, z = axis.z;\r\n\t\tvar tx = t * x, ty = t * y;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\r\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\r\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\t return this;\r\n\r\n\t},\r\n\r\n\tmakeScale: function ( x, y, z ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tx, 0, 0, 0,\r\n\t\t\t0, y, 0, 0,\r\n\t\t\t0, 0, z, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcompose: function ( position, quaternion, scale ) {\r\n\r\n\t\tthis.makeRotationFromQuaternion( quaternion );\r\n\t\tthis.scale( scale );\r\n\t\tthis.setPosition( position );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdecompose: function () {\r\n\r\n\t\tvar vector, matrix;\r\n\r\n\t\treturn function ( position, quaternion, scale ) {\r\n\r\n\t\t\tif ( vector === undefined ) vector = new THREE.Vector3();\r\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\r\n\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\r\n\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\r\n\r\n\t\t\t// if determine is negative, we need to invert one scale\r\n\t\t\tvar det = this.determinant();\r\n\t\t\tif ( det < 0 ) {\r\n\r\n\t\t\t\tsx = - sx;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tposition.x = te[ 12 ];\r\n\t\t\tposition.y = te[ 13 ];\r\n\t\t\tposition.z = te[ 14 ];\r\n\r\n\t\t\t// scale the rotation part\r\n\r\n\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\r\n\r\n\t\t\tvar invSX = 1 / sx;\r\n\t\t\tvar invSY = 1 / sy;\r\n\t\t\tvar invSZ = 1 / sz;\r\n\r\n\t\t\tmatrix.elements[ 0 ] *= invSX;\r\n\t\t\tmatrix.elements[ 1 ] *= invSX;\r\n\t\t\tmatrix.elements[ 2 ] *= invSX;\r\n\r\n\t\t\tmatrix.elements[ 4 ] *= invSY;\r\n\t\t\tmatrix.elements[ 5 ] *= invSY;\r\n\t\t\tmatrix.elements[ 6 ] *= invSY;\r\n\r\n\t\t\tmatrix.elements[ 8 ] *= invSZ;\r\n\t\t\tmatrix.elements[ 9 ] *= invSZ;\r\n\t\t\tmatrix.elements[ 10 ] *= invSZ;\r\n\r\n\t\t\tquaternion.setFromRotationMatrix( matrix );\r\n\r\n\t\t\tscale.x = sx;\r\n\t\t\tscale.y = sy;\r\n\t\t\tscale.z = sz;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar x = 2 * near / ( right - left );\r\n\t\tvar y = 2 * near / ( top - bottom );\r\n\r\n\t\tvar a = ( right + left ) / ( right - left );\r\n\t\tvar b = ( top + bottom ) / ( top - bottom );\r\n\t\tvar c = - ( far + near ) / ( far - near );\r\n\t\tvar d = - 2 * far * near / ( far - near );\r\n\r\n\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\r\n\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\r\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\r\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakePerspective: function ( fov, aspect, near, far ) {\r\n\r\n\t\tvar ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );\r\n\t\tvar ymin = - ymax;\r\n\t\tvar xmin = ymin * aspect;\r\n\t\tvar xmax = ymax * aspect;\r\n\r\n\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\r\n\r\n\t},\r\n\r\n\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar w = 1.0 / ( right - left );\r\n\t\tvar h = 1.0 / ( top - bottom );\r\n\t\tvar p = 1.0 / ( far - near );\r\n\r\n\t\tvar x = ( right + left ) * w;\r\n\t\tvar y = ( top + bottom ) * h;\r\n\t\tvar z = ( far + near ) * p;\r\n\r\n\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\r\n\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\r\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\r\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( matrix ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar me = matrix.elements;\r\n\r\n\t\tfor ( var i = 0; i < 16; i ++ ) {\r\n\r\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis.elements.set( array );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\treturn [\r\n\t\t\tte[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],\r\n\t\t\tte[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],\r\n\t\t\tte[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],\r\n\t\t\tte[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]\r\n\t\t];\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Ray.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Ray = function ( origin, direction ) {\r\n\r\n\tthis.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\r\n\tthis.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Ray.prototype = {\r\n\r\n\tconstructor: THREE.Ray,\r\n\r\n\tset: function ( origin, direction ) {\r\n\r\n\t\tthis.origin.copy( origin );\r\n\t\tthis.direction.copy( direction );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( ray ) {\r\n\r\n\t\tthis.origin.copy( ray.origin );\r\n\t\tthis.direction.copy( ray.direction );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tat: function ( t, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\r\n\r\n\t},\r\n\r\n\tlookAt: function ( v ) {\r\n\r\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\r\n\r\n\t},\r\n\r\n\trecast: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( t ) {\r\n\r\n\t\t\tthis.origin.copy( this.at( t, v1 ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclosestPointToPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\tresult.subVectors( point, this.origin );\r\n\t\tvar directionDistance = result.dot( this.direction );\r\n\r\n\t\tif ( directionDistance < 0 ) {\r\n\r\n\t\t\treturn result.copy( this.origin );\r\n\r\n\t\t}\r\n\r\n\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function ( point ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\r\n\r\n\t},\r\n\r\n\tdistanceSqToPoint: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( point ) {\r\n\r\n\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\r\n\r\n\t\t\t// point behind the ray\r\n\r\n\t\t\tif ( directionDistance < 0 ) {\r\n\r\n\t\t\t\treturn this.origin.distanceToSquared( point );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n\t\t\treturn v1.distanceToSquared( point );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tdistanceSqToSegment: function () {\r\n\r\n\t\tvar segCenter = new THREE.Vector3();\r\n\t\tvar segDir = new THREE.Vector3();\r\n\t\tvar diff = new THREE.Vector3();\r\n\r\n\t\treturn function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\r\n\r\n\t\t\t// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp\r\n\t\t\t// It returns the min distance between the ray and the segment\r\n\t\t\t// defined by v0 and v1\r\n\t\t\t// It can also set two optional targets :\r\n\t\t\t// - The closest point on the ray\r\n\t\t\t// - The closest point on the segment\r\n\r\n\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\r\n\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\r\n\t\t\tdiff.copy( this.origin ).sub( segCenter );\r\n\r\n\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\r\n\t\t\tvar a01 = - this.direction.dot( segDir );\r\n\t\t\tvar b0 = diff.dot( this.direction );\r\n\t\t\tvar b1 = - diff.dot( segDir );\r\n\t\t\tvar c = diff.lengthSq();\r\n\t\t\tvar det = Math.abs( 1 - a01 * a01 );\r\n\t\t\tvar s0, s1, sqrDist, extDet;\r\n\r\n\t\t\tif ( det > 0 ) {\r\n\r\n\t\t\t\t// The ray and segment are not parallel.\r\n\r\n\t\t\t\ts0 = a01 * b1 - b0;\r\n\t\t\t\ts1 = a01 * b0 - b1;\r\n\t\t\t\textDet = segExtent * det;\r\n\r\n\t\t\t\tif ( s0 >= 0 ) {\r\n\r\n\t\t\t\t\tif ( s1 >= - extDet ) {\r\n\r\n\t\t\t\t\t\tif ( s1 <= extDet ) {\r\n\r\n\t\t\t\t\t\t\t// region 0\r\n\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\r\n\r\n\t\t\t\t\t\t\tvar invDet = 1 / det;\r\n\t\t\t\t\t\t\ts0 *= invDet;\r\n\t\t\t\t\t\t\ts1 *= invDet;\r\n\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t// region 1\r\n\r\n\t\t\t\t\t\t\ts1 = segExtent;\r\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// region 5\r\n\r\n\t\t\t\t\t\ts1 = - segExtent;\r\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( s1 <= - extDet ) {\r\n\r\n\t\t\t\t\t\t// region 4\r\n\r\n\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\r\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t} else if ( s1 <= extDet ) {\r\n\r\n\t\t\t\t\t\t// region 3\r\n\r\n\t\t\t\t\t\ts0 = 0;\r\n\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// region 2\r\n\r\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\r\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Ray and segment are parallel.\r\n\r\n\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\r\n\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( optionalPointOnRay ) {\r\n\r\n\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( optionalPointOnSegment ) {\r\n\r\n\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn sqrDist;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectSphere: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( sphere, optionalTarget ) {\r\n\r\n\t\t\tv1.subVectors( sphere.center, this.origin );\r\n\t\t\tvar tca = v1.dot( this.direction );\r\n\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\r\n\t\t\tvar radius2 = sphere.radius * sphere.radius;\r\n\r\n\t\t\tif ( d2 > radius2 ) return null;\r\n\r\n\t\t\tvar thc = Math.sqrt( radius2 - d2 );\r\n\r\n\t\t\t// t0 = first intersect point - entrance on front of sphere\r\n\t\t\tvar t0 = tca - thc;\r\n\r\n\t\t\t// t1 = second intersect point - exit point on back of sphere\r\n\t\t\tvar t1 = tca + thc;\r\n\r\n\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\r\n\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\r\n\r\n\t\t\t// test to see if t0 is behind the ray:\r\n\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\r\n\t\t\t// in order to always return an intersect point that is in front of the ray.\r\n\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\r\n\r\n\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\r\n\t\t\treturn this.at( t0, optionalTarget );\r\n\r\n\t\t}\r\n\r\n\t}(),\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\r\n\r\n\t},\r\n\r\n\tdistanceToPlane: function ( plane ) {\r\n\r\n\t\tvar denominator = plane.normal.dot( this.direction );\r\n\r\n\t\tif ( denominator === 0 ) {\r\n\r\n\t\t\t// line is coplanar, return origin\r\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\r\n\r\n\t\t\t\treturn 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\r\n\r\n\t\t// Return if the ray never intersects the plane\r\n\r\n\t\treturn t >= 0 ? t :  null;\r\n\r\n\t},\r\n\r\n\tintersectPlane: function ( plane, optionalTarget ) {\r\n\r\n\t\tvar t = this.distanceToPlane( plane );\r\n\r\n\t\tif ( t === null ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\treturn this.at( t, optionalTarget );\r\n\r\n\t},\r\n\r\n\r\n\r\n\tintersectsPlane: function ( plane ) {\r\n\r\n\t\t// check if the ray lies on the plane first\r\n\r\n\t\tvar distToPoint = plane.distanceToPoint( this.origin );\r\n\r\n\t\tif ( distToPoint === 0 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\tvar denominator = plane.normal.dot( this.direction );\r\n\r\n\t\tif ( denominator * distToPoint < 0 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\t// ray origin is behind the plane (and is pointing behind it)\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tintersectBox: function ( box, optionalTarget ) {\r\n\r\n\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\r\n\r\n\t\tvar invdirx = 1 / this.direction.x,\r\n\t\t\tinvdiry = 1 / this.direction.y,\r\n\t\t\tinvdirz = 1 / this.direction.z;\r\n\r\n\t\tvar origin = this.origin;\r\n\r\n\t\tif ( invdirx >= 0 ) {\r\n\r\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\r\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\r\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\r\n\r\n\t\t}\r\n\r\n\t\tif ( invdiry >= 0 ) {\r\n\r\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\r\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\r\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\r\n\r\n\t\t// These lines also handle the case where tmin or tmax is NaN\r\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\r\n\r\n\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\r\n\r\n\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\r\n\r\n\t\tif ( invdirz >= 0 ) {\r\n\r\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\r\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\r\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\r\n\r\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\r\n\r\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\r\n\r\n\t\t//return point closest to the ray (positive side)\r\n\r\n\t\tif ( tmax < 0 ) return null;\r\n\r\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\r\n\r\n\t},\r\n\r\n\tintersectsBox: ( function () {\r\n\r\n\t\tvar v = new THREE.Vector3();\r\n\r\n\t\treturn function ( box ) {\r\n\r\n\t\t\treturn this.intersectBox( box, v ) !== null;\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\tintersectTriangle: function () {\r\n\r\n\t\t// Compute the offset origin, edges, and normal.\r\n\t\tvar diff = new THREE.Vector3();\r\n\t\tvar edge1 = new THREE.Vector3();\r\n\t\tvar edge2 = new THREE.Vector3();\r\n\t\tvar normal = new THREE.Vector3();\r\n\r\n\t\treturn function ( a, b, c, backfaceCulling, optionalTarget ) {\r\n\r\n\t\t\t// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp\r\n\r\n\t\t\tedge1.subVectors( b, a );\r\n\t\t\tedge2.subVectors( c, a );\r\n\t\t\tnormal.crossVectors( edge1, edge2 );\r\n\r\n\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\r\n\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\r\n\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\r\n\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\r\n\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\r\n\t\t\tvar DdN = this.direction.dot( normal );\r\n\t\t\tvar sign;\r\n\r\n\t\t\tif ( DdN > 0 ) {\r\n\r\n\t\t\t\tif ( backfaceCulling ) return null;\r\n\t\t\t\tsign = 1;\r\n\r\n\t\t\t} else if ( DdN < 0 ) {\r\n\r\n\t\t\t\tsign = - 1;\r\n\t\t\t\tDdN = - DdN;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdiff.subVectors( this.origin, a );\r\n\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\r\n\r\n\t\t\t// b1 < 0, no intersection\r\n\t\t\tif ( DdQxE2 < 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\r\n\r\n\t\t\t// b2 < 0, no intersection\r\n\t\t\tif ( DdE1xQ < 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// b1+b2 > 1, no intersection\r\n\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Line intersects triangle, check if ray does.\r\n\t\t\tvar QdN = - sign * diff.dot( normal );\r\n\r\n\t\t\t// t < 0, no intersection\r\n\t\t\tif ( QdN < 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Ray intersects triangle.\r\n\t\t\treturn this.at( QdN / DdN, optionalTarget );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyMatrix4: function ( matrix4 ) {\r\n\r\n\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\r\n\t\tthis.origin.applyMatrix4( matrix4 );\r\n\t\tthis.direction.sub( this.origin );\r\n\t\tthis.direction.normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( ray ) {\r\n\r\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Sphere.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Sphere = function ( center, radius ) {\r\n\r\n\tthis.center = ( center !== undefined ) ? center : new THREE.Vector3();\r\n\tthis.radius = ( radius !== undefined ) ? radius : 0;\r\n\r\n};\r\n\r\nTHREE.Sphere.prototype = {\r\n\r\n\tconstructor: THREE.Sphere,\r\n\r\n\tset: function ( center, radius ) {\r\n\r\n\t\tthis.center.copy( center );\r\n\t\tthis.radius = radius;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function () {\r\n\r\n\t\tvar box = new THREE.Box3();\r\n\r\n\t\treturn function ( points, optionalCenter ) {\r\n\r\n\t\t\tvar center = this.center;\r\n\r\n\t\t\tif ( optionalCenter !== undefined ) {\r\n\r\n\t\t\t\tcenter.copy( optionalCenter );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbox.setFromPoints( points ).center( center );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar maxRadiusSq = 0;\r\n\r\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( sphere ) {\r\n\r\n\t\tthis.center.copy( sphere.center );\r\n\t\tthis.radius = sphere.radius;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tempty: function () {\r\n\r\n\t\treturn ( this.radius <= 0 );\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function ( point ) {\r\n\r\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\r\n\r\n\t},\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\tvar radiusSum = this.radius + sphere.radius;\r\n\r\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\r\n\r\n\t},\r\n\r\n\tintersectsBox: function ( box ) {\r\n\r\n\t\treturn box.intersectsSphere( this );\r\n\r\n\t},\r\n\r\n\tintersectsPlane: function ( plane ) {\r\n\r\n\t\t// We use the following equation to compute the signed distance from\r\n\t\t// the center of the sphere to the plane.\r\n\t\t//\r\n\t\t// distance = q * n - d\r\n\t\t//\r\n\t\t// If this distance is greater than the radius of the sphere,\r\n\t\t// then there is no intersection.\r\n\r\n\t\treturn Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\tresult.copy( point );\r\n\r\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\r\n\r\n\t\t\tresult.sub( this.center ).normalize();\r\n\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\tgetBoundingBox: function ( optionalTarget ) {\r\n\r\n\t\tvar box = optionalTarget || new THREE.Box3();\r\n\r\n\t\tbox.set( this.center, this.center );\r\n\t\tbox.expandByScalar( this.radius );\r\n\r\n\t\treturn box;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( matrix ) {\r\n\r\n\t\tthis.center.applyMatrix4( matrix );\r\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.center.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( sphere ) {\r\n\r\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Frustum.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\r\n\r\n\tthis.planes = [\r\n\r\n\t\t( p0 !== undefined ) ? p0 : new THREE.Plane(),\r\n\t\t( p1 !== undefined ) ? p1 : new THREE.Plane(),\r\n\t\t( p2 !== undefined ) ? p2 : new THREE.Plane(),\r\n\t\t( p3 !== undefined ) ? p3 : new THREE.Plane(),\r\n\t\t( p4 !== undefined ) ? p4 : new THREE.Plane(),\r\n\t\t( p5 !== undefined ) ? p5 : new THREE.Plane()\r\n\r\n\t];\r\n\r\n};\r\n\r\nTHREE.Frustum.prototype = {\r\n\r\n\tconstructor: THREE.Frustum,\r\n\r\n\tset: function ( p0, p1, p2, p3, p4, p5 ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\r\n\t\tplanes[ 0 ].copy( p0 );\r\n\t\tplanes[ 1 ].copy( p1 );\r\n\t\tplanes[ 2 ].copy( p2 );\r\n\t\tplanes[ 3 ].copy( p3 );\r\n\t\tplanes[ 4 ].copy( p4 );\r\n\t\tplanes[ 5 ].copy( p5 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( frustum ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\r\n\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrix: function ( m ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\t\tvar me = m.elements;\r\n\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\r\n\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\r\n\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\r\n\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\r\n\r\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\r\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\r\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\r\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\r\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\r\n\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tintersectsObject: function () {\r\n\r\n\t\tvar sphere = new THREE.Sphere();\r\n\r\n\t\treturn function ( object ) {\r\n\r\n\t\t\tvar geometry = object.geometry;\r\n\r\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\tsphere.applyMatrix4( object.matrixWorld );\r\n\r\n\t\t\treturn this.intersectsSphere( sphere );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\t\tvar center = sphere.center;\r\n\t\tvar negRadius = - sphere.radius;\r\n\r\n\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tvar distance = planes[ i ].distanceToPoint( center );\r\n\r\n\t\t\tif ( distance < negRadius ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tintersectsBox: function () {\r\n\r\n\t\tvar p1 = new THREE.Vector3(),\r\n\t\t\tp2 = new THREE.Vector3();\r\n\r\n\t\treturn function ( box ) {\r\n\r\n\t\t\tvar planes = this.planes;\r\n\r\n\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\r\n\r\n\t\t\t\tvar plane = planes[ i ];\r\n\r\n\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\r\n\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\r\n\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\r\n\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\r\n\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\r\n\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\r\n\r\n\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\r\n\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\r\n\r\n\t\t\t\t// if both outside plane, no intersection\r\n\r\n\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\r\n\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Plane.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Plane = function ( normal, constant ) {\r\n\r\n\tthis.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\r\n\tthis.constant = ( constant !== undefined ) ? constant : 0;\r\n\r\n};\r\n\r\nTHREE.Plane.prototype = {\r\n\r\n\tconstructor: THREE.Plane,\r\n\r\n\tset: function ( normal, constant ) {\r\n\r\n\t\tthis.normal.copy( normal );\r\n\t\tthis.constant = constant;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponents: function ( x, y, z, w ) {\r\n\r\n\t\tthis.normal.set( x, y, z );\r\n\t\tthis.constant = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\r\n\r\n\t\tthis.normal.copy( normal );\r\n\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCoplanarPoints: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\r\n\t\treturn function ( a, b, c ) {\r\n\r\n\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\r\n\r\n\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\r\n\r\n\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( plane ) {\r\n\r\n\t\tthis.normal.copy( plane.normal );\r\n\t\tthis.constant = plane.constant;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\r\n\r\n\t\tvar inverseNormalLength = 1.0 / this.normal.length();\r\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\r\n\t\tthis.constant *= inverseNormalLength;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.constant *= - 1;\r\n\t\tthis.normal.negate();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function ( point ) {\r\n\r\n\t\treturn this.normal.dot( point ) + this.constant;\r\n\r\n\t},\r\n\r\n\tdistanceToSphere: function ( sphere ) {\r\n\r\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\r\n\r\n\t},\r\n\r\n\tprojectPoint: function ( point, optionalTarget ) {\r\n\r\n\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\r\n\r\n\t},\r\n\r\n\torthoPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\r\n\r\n\t},\r\n\r\n\tintersectLine: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( line, optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\t\tvar direction = line.delta( v1 );\r\n\r\n\t\t\tvar denominator = this.normal.dot( direction );\r\n\r\n\t\t\tif ( denominator === 0 ) {\r\n\r\n\t\t\t\t// line is coplanar, return origin\r\n\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\r\n\r\n\t\t\t\t\treturn result.copy( line.start );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Unsure if this is the correct method to handle this case.\r\n\t\t\t\treturn undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\r\n\r\n\t\t\tif ( t < 0 || t > 1 ) {\r\n\r\n\t\t\t\treturn undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectsLine: function ( line ) {\r\n\r\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\r\n\r\n\t\tvar startSign = this.distanceToPoint( line.start );\r\n\t\tvar endSign = this.distanceToPoint( line.end );\r\n\r\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\r\n\r\n\t},\r\n\r\n\tintersectsBox: function ( box ) {\r\n\r\n\t\treturn box.intersectsPlane( this );\r\n\r\n\t},\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\treturn sphere.intersectsPlane( this );\r\n\r\n\t},\r\n\r\n\tcoplanarPoint: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\t\tvar m1 = new THREE.Matrix3();\r\n\r\n\t\treturn function ( matrix, optionalNormalMatrix ) {\r\n\r\n\t\t\t// compute new normal based on theory here:\r\n\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\r\n\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\r\n\t\t\tvar newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );\r\n\r\n\t\t\tvar newCoplanarPoint = this.coplanarPoint( v2 );\r\n\t\t\tnewCoplanarPoint.applyMatrix4( matrix );\r\n\r\n\t\t\tthis.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.constant = this.constant - offset.dot( this.normal );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( plane ) {\r\n\r\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Spherical.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\r\n *\r\n * The poles (phi) are at the positive and negative y axis.\r\n * The equator starts at positive z.\r\n */\r\n\r\nTHREE.Spherical = function ( radius, phi, theta ) {\r\n\r\n\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\r\n\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\r\n\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nTHREE.Spherical.prototype = {\r\n\r\n\tconstructor: THREE.Spherical,\r\n\r\n\tset: function ( radius, phi, theta ) {\r\n\r\n\t\tthis.radius = radius;\r\n\t\tthis.phi = phi;\r\n\t\tthis.theta = theta;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( other ) {\r\n\r\n\t\tthis.radius.copy( other.radius );\r\n\t\tthis.phi.copy( other.phi );\r\n\t\tthis.theta.copy( other.theta );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// restrict phi to be betwee EPS and PI-EPS\r\n\tmakeSafe: function() {\r\n\r\n\t\tvar EPS = 0.000001;\r\n\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\r\n\r\n\t},\r\n\r\n\tsetFromVector3: function( vec3 ) {\r\n\r\n\t\tthis.radius = vec3.length();\r\n\r\n\t\tif ( this.radius === 0 ) {\r\n\r\n\t\t\tthis.theta = 0;\r\n\t\t\tthis.phi = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\r\n\t\t\tthis.phi = Math.acos( THREE.Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n};\r\n\r\n// File:src/math/Math.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Math = {\r\n\r\n\tgenerateUUID: function () {\r\n\r\n\t\t// http://www.broofa.com/Tools/Math.uuid.htm\r\n\r\n\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\r\n\t\tvar uuid = new Array( 36 );\r\n\t\tvar rnd = 0, r;\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tfor ( var i = 0; i < 36; i ++ ) {\r\n\r\n\t\t\t\tif ( i === 8 || i === 13 || i === 18 || i === 23 ) {\r\n\r\n\t\t\t\t\tuuid[ i ] = '-';\r\n\r\n\t\t\t\t} else if ( i === 14 ) {\r\n\r\n\t\t\t\t\tuuid[ i ] = '4';\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\r\n\t\t\t\t\tr = rnd & 0xf;\r\n\t\t\t\t\trnd = rnd >> 4;\r\n\t\t\t\t\tuuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn uuid.join( '' );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclamp: function ( value, min, max ) {\r\n\r\n\t\treturn Math.max( min, Math.min( max, value ) );\r\n\r\n\t},\r\n\r\n\t// compute euclidian modulo of m % n\r\n\t// https://en.wikipedia.org/wiki/Modulo_operation\r\n\r\n\teuclideanModulo: function ( n, m ) {\r\n\r\n\t\treturn ( ( n % m ) + m ) % m;\r\n\r\n\t},\r\n\r\n\t// Linear mapping from range <a1, a2> to range <b1, b2>\r\n\r\n\tmapLinear: function ( x, a1, a2, b1, b2 ) {\r\n\r\n\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\r\n\r\n\t},\r\n\r\n\t// http://en.wikipedia.org/wiki/Smoothstep\r\n\r\n\tsmoothstep: function ( x, min, max ) {\r\n\r\n\t\tif ( x <= min ) return 0;\r\n\t\tif ( x >= max ) return 1;\r\n\r\n\t\tx = ( x - min ) / ( max - min );\r\n\r\n\t\treturn x * x * ( 3 - 2 * x );\r\n\r\n\t},\r\n\r\n\tsmootherstep: function ( x, min, max ) {\r\n\r\n\t\tif ( x <= min ) return 0;\r\n\t\tif ( x >= max ) return 1;\r\n\r\n\t\tx = ( x - min ) / ( max - min );\r\n\r\n\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\r\n\r\n\t},\r\n\r\n\trandom16: function () {\r\n\r\n\t\tconsole.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );\r\n\t\treturn Math.random();\r\n\r\n\t},\r\n\r\n\t// Random integer from <low, high> interval\r\n\r\n\trandInt: function ( low, high ) {\r\n\r\n\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\r\n\r\n\t},\r\n\r\n\t// Random float from <low, high> interval\r\n\r\n\trandFloat: function ( low, high ) {\r\n\r\n\t\treturn low + Math.random() * ( high - low );\r\n\r\n\t},\r\n\r\n\t// Random float from <-range/2, range/2> interval\r\n\r\n\trandFloatSpread: function ( range ) {\r\n\r\n\t\treturn range * ( 0.5 - Math.random() );\r\n\r\n\t},\r\n\r\n\tdegToRad: function () {\r\n\r\n\t\tvar degreeToRadiansFactor = Math.PI / 180;\r\n\r\n\t\treturn function ( degrees ) {\r\n\r\n\t\t\treturn degrees * degreeToRadiansFactor;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tradToDeg: function () {\r\n\r\n\t\tvar radianToDegreesFactor = 180 / Math.PI;\r\n\r\n\t\treturn function ( radians ) {\r\n\r\n\t\t\treturn radians * radianToDegreesFactor;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tisPowerOfTwo: function ( value ) {\r\n\r\n\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\r\n\r\n\t},\r\n\r\n\tnearestPowerOfTwo: function ( value ) {\r\n\r\n\t\treturn Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );\r\n\r\n\t},\r\n\r\n\tnextPowerOfTwo: function ( value ) {\r\n\r\n\t\tvalue --;\r\n\t\tvalue |= value >> 1;\r\n\t\tvalue |= value >> 2;\r\n\t\tvalue |= value >> 4;\r\n\t\tvalue |= value >> 8;\r\n\t\tvalue |= value >> 16;\r\n\t\tvalue ++;\r\n\r\n\t\treturn value;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Spline.js\r\n\r\n/**\r\n * Spline from Tween.js, slightly optimized (and trashed)\r\n * http://sole.github.com/tween.js/examples/05_spline.html\r\n *\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Spline = function ( points ) {\r\n\r\n\tthis.points = points;\r\n\r\n\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\r\n\tpoint, intPoint, weight, w2, w3,\r\n\tpa, pb, pc, pd;\r\n\r\n\tthis.initFromArray = function ( a ) {\r\n\r\n\t\tthis.points = [];\r\n\r\n\t\tfor ( var i = 0; i < a.length; i ++ ) {\r\n\r\n\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.getPoint = function ( k ) {\r\n\r\n\t\tpoint = ( this.points.length - 1 ) * k;\r\n\t\tintPoint = Math.floor( point );\r\n\t\tweight = point - intPoint;\r\n\r\n\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\r\n\t\tc[ 1 ] = intPoint;\r\n\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\r\n\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\r\n\r\n\t\tpa = this.points[ c[ 0 ] ];\r\n\t\tpb = this.points[ c[ 1 ] ];\r\n\t\tpc = this.points[ c[ 2 ] ];\r\n\t\tpd = this.points[ c[ 3 ] ];\r\n\r\n\t\tw2 = weight * weight;\r\n\t\tw3 = weight * w2;\r\n\r\n\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\r\n\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\r\n\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\r\n\r\n\t\treturn v3;\r\n\r\n\t};\r\n\r\n\tthis.getControlPointsArray = function () {\r\n\r\n\t\tvar i, p, l = this.points.length,\r\n\t\t\tcoords = [];\r\n\r\n\t\tfor ( i = 0; i < l; i ++ ) {\r\n\r\n\t\t\tp = this.points[ i ];\r\n\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\r\n\r\n\t\t}\r\n\r\n\t\treturn coords;\r\n\r\n\t};\r\n\r\n\t// approximate length by summing linear segments\r\n\r\n\tthis.getLength = function ( nSubDivisions ) {\r\n\r\n\t\tvar i, index, nSamples, position,\r\n\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\r\n\t\t\toldPosition = new THREE.Vector3(),\r\n\t\t\ttmpVec = new THREE.Vector3(),\r\n\t\t\tchunkLengths = [],\r\n\t\t\ttotalLength = 0;\r\n\r\n\t\t// first point has 0 length\r\n\r\n\t\tchunkLengths[ 0 ] = 0;\r\n\r\n\t\tif ( ! nSubDivisions ) nSubDivisions = 100;\r\n\r\n\t\tnSamples = this.points.length * nSubDivisions;\r\n\r\n\t\toldPosition.copy( this.points[ 0 ] );\r\n\r\n\t\tfor ( i = 1; i < nSamples; i ++ ) {\r\n\r\n\t\t\tindex = i / nSamples;\r\n\r\n\t\t\tposition = this.getPoint( index );\r\n\t\t\ttmpVec.copy( position );\r\n\r\n\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\r\n\r\n\t\t\toldPosition.copy( position );\r\n\r\n\t\t\tpoint = ( this.points.length - 1 ) * index;\r\n\t\t\tintPoint = Math.floor( point );\r\n\r\n\t\t\tif ( intPoint !== oldIntPoint ) {\r\n\r\n\t\t\t\tchunkLengths[ intPoint ] = totalLength;\r\n\t\t\t\toldIntPoint = intPoint;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// last point ends with total length\r\n\r\n\t\tchunkLengths[ chunkLengths.length ] = totalLength;\r\n\r\n\t\treturn { chunks: chunkLengths, total: totalLength };\r\n\r\n\t};\r\n\r\n\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\r\n\r\n\t\tvar i, j,\r\n\t\t\tindex, indexCurrent, indexNext,\r\n\t\t\trealDistance,\r\n\t\t\tsampling, position,\r\n\t\t\tnewpoints = [],\r\n\t\t\ttmpVec = new THREE.Vector3(),\r\n\t\t\tsl = this.getLength();\r\n\r\n\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\r\n\r\n\t\tfor ( i = 1; i < this.points.length; i ++ ) {\r\n\r\n\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\r\n\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\r\n\r\n\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\r\n\r\n\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\r\n\r\n\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\r\n\t\t\tindexNext = i / ( this.points.length - 1 );\r\n\r\n\t\t\tfor ( j = 1; j < sampling - 1; j ++ ) {\r\n\r\n\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\r\n\r\n\t\t\t\tposition = this.getPoint( index );\r\n\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\r\n\r\n\t\t}\r\n\r\n\t\tthis.points = newpoints;\r\n\r\n\t};\r\n\r\n\t// Catmull-Rom\r\n\r\n\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\r\n\r\n\t\tvar v0 = ( p2 - p0 ) * 0.5,\r\n\t\t\tv1 = ( p3 - p1 ) * 0.5;\r\n\r\n\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Triangle.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Triangle = function ( a, b, c ) {\r\n\r\n\tthis.a = ( a !== undefined ) ? a : new THREE.Vector3();\r\n\tthis.b = ( b !== undefined ) ? b : new THREE.Vector3();\r\n\tthis.c = ( c !== undefined ) ? c : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Triangle.normal = function () {\r\n\r\n\tvar v0 = new THREE.Vector3();\r\n\r\n\treturn function ( a, b, c, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\tresult.subVectors( c, b );\r\n\t\tv0.subVectors( a, b );\r\n\t\tresult.cross( v0 );\r\n\r\n\t\tvar resultLengthSq = result.lengthSq();\r\n\t\tif ( resultLengthSq > 0 ) {\r\n\r\n\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn result.set( 0, 0, 0 );\r\n\r\n\t};\r\n\r\n}();\r\n\r\n// static/instance method to calculate barycentric coordinates\r\n// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\r\nTHREE.Triangle.barycoordFromPoint = function () {\r\n\r\n\tvar v0 = new THREE.Vector3();\r\n\tvar v1 = new THREE.Vector3();\r\n\tvar v2 = new THREE.Vector3();\r\n\r\n\treturn function ( point, a, b, c, optionalTarget ) {\r\n\r\n\t\tv0.subVectors( c, a );\r\n\t\tv1.subVectors( b, a );\r\n\t\tv2.subVectors( point, a );\r\n\r\n\t\tvar dot00 = v0.dot( v0 );\r\n\t\tvar dot01 = v0.dot( v1 );\r\n\t\tvar dot02 = v0.dot( v2 );\r\n\t\tvar dot11 = v1.dot( v1 );\r\n\t\tvar dot12 = v1.dot( v2 );\r\n\r\n\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\t// collinear or singular triangle\r\n\t\tif ( denom === 0 ) {\r\n\r\n\t\t\t// arbitrary location outside of triangle?\r\n\t\t\t// not sure if this is the best idea, maybe should be returning undefined\r\n\t\t\treturn result.set( - 2, - 1, - 1 );\r\n\r\n\t\t}\r\n\r\n\t\tvar invDenom = 1 / denom;\r\n\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\r\n\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\r\n\r\n\t\t// barycentric coordinates must always sum to 1\r\n\t\treturn result.set( 1 - u - v, v, u );\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.Triangle.containsPoint = function () {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\r\n\treturn function ( point, a, b, c ) {\r\n\r\n\t\tvar result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\r\n\r\n\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.Triangle.prototype = {\r\n\r\n\tconstructor: THREE.Triangle,\r\n\r\n\tset: function ( a, b, c ) {\r\n\r\n\t\tthis.a.copy( a );\r\n\t\tthis.b.copy( b );\r\n\t\tthis.c.copy( c );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\r\n\r\n\t\tthis.a.copy( points[ i0 ] );\r\n\t\tthis.b.copy( points[ i1 ] );\r\n\t\tthis.c.copy( points[ i2 ] );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( triangle ) {\r\n\r\n\t\tthis.a.copy( triangle.a );\r\n\t\tthis.b.copy( triangle.b );\r\n\t\tthis.c.copy( triangle.c );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tarea: function () {\r\n\r\n\t\tvar v0 = new THREE.Vector3();\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tv0.subVectors( this.c, this.b );\r\n\t\t\tv1.subVectors( this.a, this.b );\r\n\r\n\t\t\treturn v0.cross( v1 ).length() * 0.5;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmidpoint: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\r\n\r\n\t},\r\n\r\n\tnormal: function ( optionalTarget ) {\r\n\r\n\t\treturn THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\r\n\r\n\t},\r\n\r\n\tplane: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Plane();\r\n\r\n\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\r\n\r\n\t},\r\n\r\n\tbarycoordFromPoint: function ( point, optionalTarget ) {\r\n\r\n\t\treturn THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\treturn THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\r\n\r\n\t},\r\n\r\n\tequals: function ( triangle ) {\r\n\r\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Interpolant.js\r\n\r\n/**\r\n * Abstract base class of interpolants over parametric samples.\r\n *\r\n * The parameter domain is one dimensional, typically the time or a path\r\n * along a curve defined by the data.\r\n *\r\n * The sample values can have any dimensionality and derived classes may\r\n * apply special interpretations to the data.\r\n *\r\n * This class provides the interval seek in a Template Method, deferring\r\n * the actual interpolation to derived classes.\r\n *\r\n * Time complexity is O(1) for linear access crossing at most two points\r\n * and O(log N) for random access, where N is the number of positions.\r\n *\r\n * References:\r\n *\r\n * \t\thttp://www.oodesign.com/template-method-pattern.html\r\n *\r\n * @author tschw\r\n */\r\n\r\nTHREE.Interpolant = function(\r\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n\tthis.parameterPositions = parameterPositions;\r\n\tthis._cachedIndex = 0;\r\n\r\n\tthis.resultBuffer = resultBuffer !== undefined ?\r\n\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\r\n\tthis.sampleValues = sampleValues;\r\n\tthis.valueSize = sampleSize;\r\n\r\n};\r\n\r\nTHREE.Interpolant.prototype = {\r\n\r\n\tconstructor: THREE.Interpolant,\r\n\r\n\tevaluate: function( t ) {\r\n\r\n\t\tvar pp = this.parameterPositions,\r\n\t\t\ti1 = this._cachedIndex,\r\n\r\n\t\t\tt1 = pp[   i1   ],\r\n\t\t\tt0 = pp[ i1 - 1 ];\r\n\r\n\t\tvalidate_interval: {\r\n\r\n\t\t\tseek: {\r\n\r\n\t\t\t\tvar right;\r\n\r\n\t\t\t\tlinear_scan: {\r\n//- See http://jsperf.com/comparison-to-undefined/3\r\n//- slower code:\r\n//-\r\n//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\r\n\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\r\n\r\n\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ;) {\r\n\r\n\t\t\t\t\t\t\tif ( t1 === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\r\n\r\n\t\t\t\t\t\t\t\t// after end\r\n\r\n\t\t\t\t\t\t\t\ti1 = pp.length;\r\n\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\r\n\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\r\n\r\n\t\t\t\t\t\t\tt0 = t1;\r\n\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\r\n\r\n\t\t\t\t\t\t\tif ( t < t1 ) {\r\n\r\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\r\n\t\t\t\t\t\t\t\tbreak seek;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// prepare binary search on the right side of the index\r\n\t\t\t\t\t\tright = pp.length;\r\n\t\t\t\t\t\tbreak linear_scan;\r\n\r\n\t\t\t\t\t}\r\n\r\n//- slower code:\r\n//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\r\n\t\t\t\t\tif ( ! ( t >= t0 ) ) {\r\n\r\n\t\t\t\t\t\t// looping?\r\n\r\n\t\t\t\t\t\tvar t1global = pp[ 1 ];\r\n\r\n\t\t\t\t\t\tif ( t < t1global ) {\r\n\r\n\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\r\n\t\t\t\t\t\t\tt0 = t1global;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// linear reverse scan\r\n\r\n\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ;) {\r\n\r\n\t\t\t\t\t\t\tif ( t0 === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\t// before start\r\n\r\n\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\r\n\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\r\n\r\n\t\t\t\t\t\t\tt1 = t0;\r\n\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\r\n\r\n\t\t\t\t\t\t\tif ( t >= t0 ) {\r\n\r\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\r\n\t\t\t\t\t\t\t\tbreak seek;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// prepare binary search on the left side of the index\r\n\t\t\t\t\t\tright = i1;\r\n\t\t\t\t\t\ti1 = 0;\r\n\t\t\t\t\t\tbreak linear_scan;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// the interval is valid\r\n\r\n\t\t\t\t\tbreak validate_interval;\r\n\r\n\t\t\t\t} // linear scan\r\n\r\n\t\t\t\t// binary search\r\n\r\n\t\t\t\twhile ( i1 < right ) {\r\n\r\n\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\r\n\r\n\t\t\t\t\tif ( t < pp[ mid ] ) {\r\n\r\n\t\t\t\t\t\tright = mid;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\ti1 = mid + 1;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tt1 = pp[   i1   ];\r\n\t\t\t\tt0 = pp[ i1 - 1 ];\r\n\r\n\t\t\t\t// check boundary cases, again\r\n\r\n\t\t\t\tif ( t0 === undefined ) {\r\n\r\n\t\t\t\t\tthis._cachedIndex = 0;\r\n\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( t1 === undefined ) {\r\n\r\n\t\t\t\t\ti1 = pp.length;\r\n\t\t\t\t\tthis._cachedIndex = i1;\r\n\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} // seek\r\n\r\n\t\t\tthis._cachedIndex = i1;\r\n\r\n\t\t\tthis.intervalChanged_( i1, t0, t1 );\r\n\r\n\t\t} // validate_interval\r\n\r\n\t\treturn this.interpolate_( i1, t0, t, t1 );\r\n\r\n\t},\r\n\r\n\tsettings: null, // optional, subclass-specific settings structure\r\n\t// Note: The indirection allows central control of many interpolants.\r\n\r\n\t// --- Protected interface\r\n\r\n\tDefaultSettings_: {},\r\n\r\n\tgetSettings_: function() {\r\n\r\n\t\treturn this.settings || this.DefaultSettings_;\r\n\r\n\t},\r\n\r\n\tcopySampleValue_: function( index ) {\r\n\r\n\t\t// copies a sample value to the result buffer\r\n\r\n\t\tvar result = this.resultBuffer,\r\n\t\t\tvalues = this.sampleValues,\r\n\t\t\tstride = this.valueSize,\r\n\t\t\toffset = index * stride;\r\n\r\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\tresult[ i ] = values[ offset + i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\t// Template methods for derived classes:\r\n\r\n\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\r\n\t\tthrow new Error( \"call to abstract method\" );\r\n\t\t// implementations shall return this.resultBuffer\r\n\r\n\t},\r\n\r\n\tintervalChanged_: function( i1, t0, t1 ) {\r\n\r\n\t\t// empty\r\n\r\n\t}\r\n\r\n};\r\n\r\nObject.assign( THREE.Interpolant.prototype, {\r\n\r\n\tbeforeStart_: //( 0, t, t0 ), returns this.resultBuffer\r\n\t\tTHREE.Interpolant.prototype.copySampleValue_,\r\n\r\n\tafterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer\r\n\t\tTHREE.Interpolant.prototype.copySampleValue_\r\n\r\n} );\r\n\r\n// File:src/math/interpolants/CubicInterpolant.js\r\n\r\n/**\r\n * Fast and simple cubic spline interpolant.\r\n *\r\n * It was derived from a Hermitian construction setting the first derivative\r\n * at each sample position to the linear slope between neighboring positions\r\n * over their parameter interval.\r\n *\r\n * @author tschw\r\n */\r\n\r\nTHREE.CubicInterpolant = function(\r\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n\tTHREE.Interpolant.call(\r\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\r\n\tthis._weightPrev = -0;\r\n\tthis._offsetPrev = -0;\r\n\tthis._weightNext = -0;\r\n\tthis._offsetNext = -0;\r\n\r\n};\r\n\r\nTHREE.CubicInterpolant.prototype =\r\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\r\n\tconstructor: THREE.CubicInterpolant,\r\n\r\n\tDefaultSettings_: {\r\n\r\n\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\r\n\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\r\n\r\n\t},\r\n\r\n\tintervalChanged_: function( i1, t0, t1 ) {\r\n\r\n\t\tvar pp = this.parameterPositions,\r\n\t\t\tiPrev = i1 - 2,\r\n\t\t\tiNext = i1 + 1,\r\n\r\n\t\t\ttPrev = pp[ iPrev ],\r\n\t\t\ttNext = pp[ iNext ];\r\n\r\n\t\tif ( tPrev === undefined ) {\r\n\r\n\t\t\tswitch ( this.getSettings_().endingStart ) {\r\n\r\n\t\t\t\tcase THREE.ZeroSlopeEnding:\r\n\r\n\t\t\t\t\t// f'(t0) = 0\r\n\t\t\t\t\tiPrev = i1;\r\n\t\t\t\t\ttPrev = 2 * t0 - t1;\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.WrapAroundEnding:\r\n\r\n\t\t\t\t\t// use the other end of the curve\r\n\t\t\t\t\tiPrev = pp.length - 2;\r\n\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault: // ZeroCurvatureEnding\r\n\r\n\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\r\n\t\t\t\t\tiPrev = i1;\r\n\t\t\t\t\ttPrev = t1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( tNext === undefined ) {\r\n\r\n\t\t\tswitch ( this.getSettings_().endingEnd ) {\r\n\r\n\t\t\t\tcase THREE.ZeroSlopeEnding:\r\n\r\n\t\t\t\t\t// f'(tN) = 0\r\n\t\t\t\t\tiNext = i1;\r\n\t\t\t\t\ttNext = 2 * t1 - t0;\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.WrapAroundEnding:\r\n\r\n\t\t\t\t\t// use the other end of the curve\r\n\t\t\t\t\tiNext = 1;\r\n\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault: // ZeroCurvatureEnding\r\n\r\n\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\r\n\t\t\t\t\tiNext = i1 - 1;\r\n\t\t\t\t\ttNext = t0;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar halfDt = ( t1 - t0 ) * 0.5,\r\n\t\t\tstride = this.valueSize;\r\n\r\n\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\r\n\t\tthis._weightNext = halfDt / ( tNext - t1 );\r\n\t\tthis._offsetPrev = iPrev * stride;\r\n\t\tthis._offsetNext = iNext * stride;\r\n\r\n\t},\r\n\r\n\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\r\n\t\tvar result = this.resultBuffer,\r\n\t\t\tvalues = this.sampleValues,\r\n\t\t\tstride = this.valueSize,\r\n\r\n\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\r\n\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\r\n\t\t\twP = this._weightPrev,\twN = this._weightNext,\r\n\r\n\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\r\n\t\t\tpp = p * p,\r\n\t\t\tppp = pp * p;\r\n\r\n\t\t// evaluate polynomials\r\n\r\n\t\tvar sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;\r\n\t\tvar s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;\r\n\t\tvar s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;\r\n\t\tvar sN =       wN   * ppp   -           wN      * pp;\r\n\r\n\t\t// combine data linearly\r\n\r\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\tresult[ i ] =\r\n\t\t\t\t\tsP * values[ oP + i ] +\r\n\t\t\t\t\ts0 * values[ o0 + i ] +\r\n\t\t\t\t\ts1 * values[ o1 + i ] +\r\n\t\t\t\t\tsN * values[ oN + i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/math/interpolants/DiscreteInterpolant.js\r\n\r\n/**\r\n *\r\n * Interpolant that evaluates to the sample value at the position preceeding\r\n * the parameter.\r\n *\r\n * @author tschw\r\n */\r\n\r\nTHREE.DiscreteInterpolant = function(\r\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n\tTHREE.Interpolant.call(\r\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\r\n};\r\n\r\nTHREE.DiscreteInterpolant.prototype =\r\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\r\n\tconstructor: THREE.DiscreteInterpolant,\r\n\r\n\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\r\n\t\treturn this.copySampleValue_( i1 - 1 );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/math/interpolants/LinearInterpolant.js\r\n\r\n/**\r\n * @author tschw\r\n */\r\n\r\nTHREE.LinearInterpolant = function(\r\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n\tTHREE.Interpolant.call(\r\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\r\n};\r\n\r\nTHREE.LinearInterpolant.prototype =\r\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\r\n\tconstructor: THREE.LinearInterpolant,\r\n\r\n\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\r\n\t\tvar result = this.resultBuffer,\r\n\t\t\tvalues = this.sampleValues,\r\n\t\t\tstride = this.valueSize,\r\n\r\n\t\t\toffset1 = i1 * stride,\r\n\t\t\toffset0 = offset1 - stride,\r\n\r\n\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\r\n\t\t\tweight0 = 1 - weight1;\r\n\r\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\tresult[ i ] =\r\n\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\r\n\t\t\t\t\tvalues[ offset1 + i ] * weight1;\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/math/interpolants/QuaternionLinearInterpolant.js\r\n\r\n/**\r\n * Spherical linear unit quaternion interpolant.\r\n *\r\n * @author tschw\r\n */\r\n\r\nTHREE.QuaternionLinearInterpolant = function(\r\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n\tTHREE.Interpolant.call(\r\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\r\n};\r\n\r\nTHREE.QuaternionLinearInterpolant.prototype =\r\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\r\n\tconstructor: THREE.QuaternionLinearInterpolant,\r\n\r\n\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\r\n\t\tvar result = this.resultBuffer,\r\n\t\t\tvalues = this.sampleValues,\r\n\t\t\tstride = this.valueSize,\r\n\r\n\t\t\toffset = i1 * stride,\r\n\r\n\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\r\n\r\n\t\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\r\n\r\n\t\t\tTHREE.Quaternion.slerpFlat( result, 0,\r\n\t\t\t\t\tvalues, offset - stride, values, offset, alpha );\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/core/Clock.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Clock = function ( autoStart ) {\r\n\r\n\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\r\n\r\n\tthis.startTime = 0;\r\n\tthis.oldTime = 0;\r\n\tthis.elapsedTime = 0;\r\n\r\n\tthis.running = false;\r\n\r\n};\r\n\r\nTHREE.Clock.prototype = {\r\n\r\n\tconstructor: THREE.Clock,\r\n\r\n\tstart: function () {\r\n\r\n\t\tthis.startTime = performance.now();\r\n\r\n\t\tthis.oldTime = this.startTime;\r\n\t\tthis.running = true;\r\n\r\n\t},\r\n\r\n\tstop: function () {\r\n\r\n\t\tthis.getElapsedTime();\r\n\t\tthis.running = false;\r\n\r\n\t},\r\n\r\n\tgetElapsedTime: function () {\r\n\r\n\t\tthis.getDelta();\r\n\t\treturn this.elapsedTime;\r\n\r\n\t},\r\n\r\n\tgetDelta: function () {\r\n\r\n\t\tvar diff = 0;\r\n\r\n\t\tif ( this.autoStart && ! this.running ) {\r\n\r\n\t\t\tthis.start();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.running ) {\r\n\r\n\t\t\tvar newTime = performance.now();\r\n\r\n\t\t\tdiff = 0.001 * ( newTime - this.oldTime );\r\n\t\t\tthis.oldTime = newTime;\r\n\r\n\t\t\tthis.elapsedTime += diff;\r\n\r\n\t\t}\r\n\r\n\t\treturn diff;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/core/EventDispatcher.js\r\n\r\n/**\r\n * https://github.com/mrdoob/eventdispatcher.js/\r\n */\r\n\r\nTHREE.EventDispatcher = function () {};\r\n\r\nTHREE.EventDispatcher.prototype = {\r\n\r\n\tconstructor: THREE.EventDispatcher,\r\n\r\n\tapply: function ( object ) {\r\n\r\n\t\tobject.addEventListener = THREE.EventDispatcher.prototype.addEventListener;\r\n\t\tobject.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;\r\n\t\tobject.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;\r\n\t\tobject.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;\r\n\r\n\t},\r\n\r\n\taddEventListener: function ( type, listener ) {\r\n\r\n\t\tif ( this._listeners === undefined ) this._listeners = {};\r\n\r\n\t\tvar listeners = this._listeners;\r\n\r\n\t\tif ( listeners[ type ] === undefined ) {\r\n\r\n\t\t\tlisteners[ type ] = [];\r\n\r\n\t\t}\r\n\r\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\r\n\r\n\t\t\tlisteners[ type ].push( listener );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\thasEventListener: function ( type, listener ) {\r\n\r\n\t\tif ( this._listeners === undefined ) return false;\r\n\r\n\t\tvar listeners = this._listeners;\r\n\r\n\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tremoveEventListener: function ( type, listener ) {\r\n\r\n\t\tif ( this._listeners === undefined ) return;\r\n\r\n\t\tvar listeners = this._listeners;\r\n\t\tvar listenerArray = listeners[ type ];\r\n\r\n\t\tif ( listenerArray !== undefined ) {\r\n\r\n\t\t\tvar index = listenerArray.indexOf( listener );\r\n\r\n\t\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\t\tlistenerArray.splice( index, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tdispatchEvent: function ( event ) {\r\n\r\n\t\tif ( this._listeners === undefined ) return;\r\n\r\n\t\tvar listeners = this._listeners;\r\n\t\tvar listenerArray = listeners[ event.type ];\r\n\r\n\t\tif ( listenerArray !== undefined ) {\r\n\r\n\t\t\tevent.target = this;\r\n\r\n\t\t\tvar array = [];\r\n\t\t\tvar length = listenerArray.length;\r\n\r\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\t\t\tarray[ i ] = listenerArray[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\t\t\tarray[ i ].call( this, event );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/core/Layers.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Layers = function () {\r\n\r\n\tthis.mask = 1;\r\n\r\n};\r\n\r\nTHREE.Layers.prototype = {\r\n\r\n\tconstructor: THREE.Layers,\r\n\r\n\tset: function ( channel ) {\r\n\r\n\t\tthis.mask = 1 << channel;\r\n\r\n\t},\r\n\r\n\tenable: function ( channel ) {\r\n\r\n\t\tthis.mask |= 1 << channel;\r\n\r\n\t},\r\n\r\n\ttoggle: function ( channel ) {\r\n\r\n\t\tthis.mask ^= 1 << channel;\r\n\r\n\t},\r\n\r\n\tdisable: function ( channel ) {\r\n\r\n\t\tthis.mask &= ~ ( 1 << channel );\r\n\r\n\t},\r\n\r\n\ttest: function ( layers ) {\r\n\r\n\t\treturn ( this.mask & layers.mask ) !== 0;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/core/Raycaster.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author bhouston / http://clara.io/\r\n * @author stephomi / http://stephaneginier.com/\r\n */\r\n\r\n( function ( THREE ) {\r\n\r\n\tTHREE.Raycaster = function ( origin, direction, near, far ) {\r\n\r\n\t\tthis.ray = new THREE.Ray( origin, direction );\r\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\r\n\t\tthis.near = near || 0;\r\n\t\tthis.far = far || Infinity;\r\n\r\n\t\tthis.params = {\r\n\t\t\tMesh: {},\r\n\t\t\tLine: {},\r\n\t\t\tLOD: {},\r\n\t\t\tPoints: { threshold: 1 },\r\n\t\t\tSprite: {}\r\n\t\t};\r\n\r\n\t\tObject.defineProperties( this.params, {\r\n\t\t\tPointCloud: {\r\n\t\t\t\tget: function () {\r\n\t\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\r\n\t\t\t\t\treturn this.Points;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\tfunction ascSort( a, b ) {\r\n\r\n\t\treturn a.distance - b.distance;\r\n\r\n\t}\r\n\r\n\tfunction intersectObject( object, raycaster, intersects, recursive ) {\r\n\r\n\t\tif ( object.visible === false ) return;\r\n\r\n\t\tobject.raycast( raycaster, intersects );\r\n\r\n\t\tif ( recursive === true ) {\r\n\r\n\t\t\tvar children = object.children;\r\n\r\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tTHREE.Raycaster.prototype = {\r\n\r\n\t\tconstructor: THREE.Raycaster,\r\n\r\n\t\tlinePrecision: 1,\r\n\r\n\t\tset: function ( origin, direction ) {\r\n\r\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\r\n\t\t\tthis.ray.set( origin, direction );\r\n\r\n\t\t},\r\n\r\n\t\tsetFromCamera: function ( coords, camera ) {\r\n\r\n\t\t\tif ( camera instanceof THREE.PerspectiveCamera ) {\r\n\r\n\t\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\r\n\r\n\t\t\t} else if ( camera instanceof THREE.OrthographicCamera ) {\r\n\r\n\t\t\t\tthis.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );\r\n\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tintersectObject: function ( object, recursive ) {\r\n\r\n\t\t\tvar intersects = [];\r\n\r\n\t\t\tintersectObject( object, this, intersects, recursive );\r\n\r\n\t\t\tintersects.sort( ascSort );\r\n\r\n\t\t\treturn intersects;\r\n\r\n\t\t},\r\n\r\n\t\tintersectObjects: function ( objects, recursive ) {\r\n\r\n\t\t\tvar intersects = [];\r\n\r\n\t\t\tif ( Array.isArray( objects ) === false ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\r\n\t\t\t\treturn intersects;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tintersects.sort( ascSort );\r\n\r\n\t\t\treturn intersects;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}( THREE ) );\r\n\r\n// File:src/core/Object3D.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author elephantatwork / www.elephantatwork.ch\r\n */\r\n\r\nTHREE.Object3D = function () {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'Object3D';\r\n\r\n\tthis.parent = null;\r\n\tthis.children = [];\r\n\r\n\tthis.up = THREE.Object3D.DefaultUp.clone();\r\n\r\n\tvar position = new THREE.Vector3();\r\n\tvar rotation = new THREE.Euler();\r\n\tvar quaternion = new THREE.Quaternion();\r\n\tvar scale = new THREE.Vector3( 1, 1, 1 );\r\n\r\n\tfunction onRotationChange() {\r\n\r\n\t\tquaternion.setFromEuler( rotation, false );\r\n\r\n\t}\r\n\r\n\tfunction onQuaternionChange() {\r\n\r\n\t\trotation.setFromQuaternion( quaternion, undefined, false );\r\n\r\n\t}\r\n\r\n\trotation.onChange( onRotationChange );\r\n\tquaternion.onChange( onQuaternionChange );\r\n\r\n\tObject.defineProperties( this, {\r\n\t\tposition: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: position\r\n\t\t},\r\n\t\trotation: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: rotation\r\n\t\t},\r\n\t\tquaternion: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: quaternion\r\n\t\t},\r\n\t\tscale: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: scale\r\n\t\t},\r\n\t\tmodelViewMatrix: {\r\n\t\t\tvalue: new THREE.Matrix4()\r\n\t\t},\r\n\t\tnormalMatrix: {\r\n\t\t\tvalue: new THREE.Matrix3()\r\n\t\t}\r\n\t} );\r\n\r\n\tthis.rotationAutoUpdate = true;\r\n\r\n\tthis.matrix = new THREE.Matrix4();\r\n\tthis.matrixWorld = new THREE.Matrix4();\r\n\r\n\tthis.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;\r\n\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\tthis.layers = new THREE.Layers();\r\n\tthis.visible = true;\r\n\r\n\tthis.castShadow = false;\r\n\tthis.receiveShadow = false;\r\n\r\n\tthis.frustumCulled = true;\r\n\tthis.renderOrder = 0;\r\n\r\n\tthis.userData = {};\r\n\r\n};\r\n\r\nTHREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );\r\nTHREE.Object3D.DefaultMatrixAutoUpdate = true;\r\n\r\nTHREE.Object3D.prototype = {\r\n\r\n\tconstructor: THREE.Object3D,\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\r\n\r\n\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\r\n\r\n\t},\r\n\r\n\tsetRotationFromAxisAngle: function ( axis, angle ) {\r\n\r\n\t\t// assumes axis is normalized\r\n\r\n\t\tthis.quaternion.setFromAxisAngle( axis, angle );\r\n\r\n\t},\r\n\r\n\tsetRotationFromEuler: function ( euler ) {\r\n\r\n\t\tthis.quaternion.setFromEuler( euler, true );\r\n\r\n\t},\r\n\r\n\tsetRotationFromMatrix: function ( m ) {\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tthis.quaternion.setFromRotationMatrix( m );\r\n\r\n\t},\r\n\r\n\tsetRotationFromQuaternion: function ( q ) {\r\n\r\n\t\t// assumes q is normalized\r\n\r\n\t\tthis.quaternion.copy( q );\r\n\r\n\t},\r\n\r\n\trotateOnAxis: function () {\r\n\r\n\t\t// rotate object on axis in object space\r\n\t\t// axis is assumed to be normalized\r\n\r\n\t\tvar q1 = new THREE.Quaternion();\r\n\r\n\t\treturn function ( axis, angle ) {\r\n\r\n\t\t\tq1.setFromAxisAngle( axis, angle );\r\n\r\n\t\t\tthis.quaternion.multiply( q1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateX: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\r\n\r\n\t\treturn function ( angle ) {\r\n\r\n\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateY: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\r\n\r\n\t\treturn function ( angle ) {\r\n\r\n\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateZ: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\r\n\r\n\t\treturn function ( angle ) {\r\n\r\n\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateOnAxis: function () {\r\n\r\n\t\t// translate object by distance along axis in object space\r\n\t\t// axis is assumed to be normalized\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( axis, distance ) {\r\n\r\n\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\r\n\r\n\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateX: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\r\n\r\n\t\treturn function ( distance ) {\r\n\r\n\t\t\treturn this.translateOnAxis( v1, distance );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateY: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\r\n\r\n\t\treturn function ( distance ) {\r\n\r\n\t\t\treturn this.translateOnAxis( v1, distance );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateZ: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\r\n\r\n\t\treturn function ( distance ) {\r\n\r\n\t\t\treturn this.translateOnAxis( v1, distance );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlocalToWorld: function ( vector ) {\r\n\r\n\t\treturn vector.applyMatrix4( this.matrixWorld );\r\n\r\n\t},\r\n\r\n\tworldToLocal: function () {\r\n\r\n\t\tvar m1 = new THREE.Matrix4();\r\n\r\n\t\treturn function ( vector ) {\r\n\r\n\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlookAt: function () {\r\n\r\n\t\t// This routine does not support objects with rotated and/or translated parent(s)\r\n\r\n\t\tvar m1 = new THREE.Matrix4();\r\n\r\n\t\treturn function ( vector ) {\r\n\r\n\t\t\tm1.lookAt( vector, this.position, this.up );\r\n\r\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tadd: function ( object ) {\r\n\r\n\t\tif ( arguments.length > 1 ) {\r\n\r\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\r\n\t\t\t\tthis.add( arguments[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tif ( object === this ) {\r\n\r\n\t\t\tconsole.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tif ( object instanceof THREE.Object3D ) {\r\n\r\n\t\t\tif ( object.parent !== null ) {\r\n\r\n\t\t\t\tobject.parent.remove( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.parent = this;\r\n\t\t\tobject.dispatchEvent( { type: 'added' } );\r\n\r\n\t\t\tthis.children.push( object );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tremove: function ( object ) {\r\n\r\n\t\tif ( arguments.length > 1 ) {\r\n\r\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\r\n\t\t\t\tthis.remove( arguments[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar index = this.children.indexOf( object );\r\n\r\n\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\tobject.parent = null;\r\n\r\n\t\t\tobject.dispatchEvent( { type: 'removed' } );\r\n\r\n\t\t\tthis.children.splice( index, 1 );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetObjectById: function ( id ) {\r\n\r\n\t\treturn this.getObjectByProperty( 'id', id );\r\n\r\n\t},\r\n\r\n\tgetObjectByName: function ( name ) {\r\n\r\n\t\treturn this.getObjectByProperty( 'name', name );\r\n\r\n\t},\r\n\r\n\tgetObjectByProperty: function ( name, value ) {\r\n\r\n\t\tif ( this[ name ] === value ) return this;\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar child = this.children[ i ];\r\n\t\t\tvar object = child.getObjectByProperty( name, value );\r\n\r\n\t\t\tif ( object !== undefined ) {\r\n\r\n\t\t\t\treturn object;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn undefined;\r\n\r\n\t},\r\n\r\n\tgetWorldPosition: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\treturn result.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t},\r\n\r\n\tgetWorldQuaternion: function () {\r\n\r\n\t\tvar position = new THREE.Vector3();\r\n\t\tvar scale = new THREE.Vector3();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Quaternion();\r\n\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\t\tthis.matrixWorld.decompose( position, result, scale );\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetWorldRotation: function () {\r\n\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Euler();\r\n\r\n\t\t\tthis.getWorldQuaternion( quaternion );\r\n\r\n\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetWorldScale: function () {\r\n\r\n\t\tvar position = new THREE.Vector3();\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetWorldDirection: function () {\r\n\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\t\tthis.getWorldQuaternion( quaternion );\r\n\r\n\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\traycast: function () {},\r\n\r\n\ttraverse: function ( callback ) {\r\n\r\n\t\tcallback( this );\r\n\r\n\t\tvar children = this.children;\r\n\r\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tchildren[ i ].traverse( callback );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttraverseVisible: function ( callback ) {\r\n\r\n\t\tif ( this.visible === false ) return;\r\n\r\n\t\tcallback( this );\r\n\r\n\t\tvar children = this.children;\r\n\r\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tchildren[ i ].traverseVisible( callback );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttraverseAncestors: function ( callback ) {\r\n\r\n\t\tvar parent = this.parent;\r\n\r\n\t\tif ( parent !== null ) {\r\n\r\n\t\t\tcallback( parent );\r\n\r\n\t\t\tparent.traverseAncestors( callback );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tupdateMatrix: function () {\r\n\r\n\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\r\n\r\n\t\tthis.matrixWorldNeedsUpdate = true;\r\n\r\n\t},\r\n\r\n\tupdateMatrixWorld: function ( force ) {\r\n\r\n\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\r\n\r\n\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\r\n\r\n\t\t\tif ( this.parent === null ) {\r\n\r\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\t\t\tforce = true;\r\n\r\n\t\t}\r\n\r\n\t\t// update children\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis.children[ i ].updateMatrixWorld( force );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\tvar isRootObject = ( meta === undefined );\r\n\r\n\t\tvar output = {};\r\n\r\n\t\t// meta is a hash used to collect geometries, materials.\r\n\t\t// not providing it implies that this is the root object\r\n\t\t// being serialized.\r\n\t\tif ( isRootObject ) {\r\n\r\n\t\t\t// initialize meta obj\r\n\t\t\tmeta = {\r\n\t\t\t\tgeometries: {},\r\n\t\t\t\tmaterials: {},\r\n\t\t\t\ttextures: {},\r\n\t\t\t\timages: {}\r\n\t\t\t};\r\n\r\n\t\t\toutput.metadata = {\r\n\t\t\t\tversion: 4.4,\r\n\t\t\t\ttype: 'Object',\r\n\t\t\t\tgenerator: 'Object3D.toJSON'\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\t// standard Object3D serialization\r\n\r\n\t\tvar object = {};\r\n\r\n\t\tobject.uuid = this.uuid;\r\n\t\tobject.type = this.type;\r\n\r\n\t\tif ( this.name !== '' ) object.name = this.name;\r\n\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\r\n\t\tif ( this.castShadow === true ) object.castShadow = true;\r\n\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\r\n\t\tif ( this.visible === false ) object.visible = false;\r\n\r\n\t\tobject.matrix = this.matrix.toArray();\r\n\r\n\t\t//\r\n\r\n\t\tif ( this.geometry !== undefined ) {\r\n\r\n\t\t\tif ( meta.geometries[ this.geometry.uuid ] === undefined ) {\r\n\r\n\t\t\t\tmeta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.geometry = this.geometry.uuid;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.material !== undefined ) {\r\n\r\n\t\t\tif ( meta.materials[ this.material.uuid ] === undefined ) {\r\n\r\n\t\t\t\tmeta.materials[ this.material.uuid ] = this.material.toJSON( meta );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.material = this.material.uuid;\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( this.children.length > 0 ) {\r\n\r\n\t\t\tobject.children = [];\r\n\r\n\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\r\n\r\n\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( isRootObject ) {\r\n\r\n\t\t\tvar geometries = extractFromCache( meta.geometries );\r\n\t\t\tvar materials = extractFromCache( meta.materials );\r\n\t\t\tvar textures = extractFromCache( meta.textures );\r\n\t\t\tvar images = extractFromCache( meta.images );\r\n\r\n\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\r\n\t\t\tif ( materials.length > 0 ) output.materials = materials;\r\n\t\t\tif ( textures.length > 0 ) output.textures = textures;\r\n\t\t\tif ( images.length > 0 ) output.images = images;\r\n\r\n\t\t}\r\n\r\n\t\toutput.object = object;\r\n\r\n\t\treturn output;\r\n\r\n\t\t// extract data from the cache hash\r\n\t\t// remove metadata on each item\r\n\t\t// and return as array\r\n\t\tfunction extractFromCache ( cache ) {\r\n\r\n\t\t\tvar values = [];\r\n\t\t\tfor ( var key in cache ) {\r\n\r\n\t\t\t\tvar data = cache[ key ];\r\n\t\t\t\tdelete data.metadata;\r\n\t\t\t\tvalues.push( data );\r\n\r\n\t\t\t}\r\n\t\t\treturn values;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function ( recursive ) {\r\n\r\n\t\treturn new this.constructor().copy( this, recursive );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source, recursive ) {\r\n\r\n\t\tif ( recursive === undefined ) recursive = true;\r\n\r\n\t\tthis.name = source.name;\r\n\r\n\t\tthis.up.copy( source.up );\r\n\r\n\t\tthis.position.copy( source.position );\r\n\t\tthis.quaternion.copy( source.quaternion );\r\n\t\tthis.scale.copy( source.scale );\r\n\r\n\t\tthis.rotationAutoUpdate = source.rotationAutoUpdate;\r\n\r\n\t\tthis.matrix.copy( source.matrix );\r\n\t\tthis.matrixWorld.copy( source.matrixWorld );\r\n\r\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\r\n\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\r\n\r\n\t\tthis.visible = source.visible;\r\n\r\n\t\tthis.castShadow = source.castShadow;\r\n\t\tthis.receiveShadow = source.receiveShadow;\r\n\r\n\t\tthis.frustumCulled = source.frustumCulled;\r\n\t\tthis.renderOrder = source.renderOrder;\r\n\r\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\r\n\r\n\t\tif ( recursive === true ) {\r\n\r\n\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = source.children[ i ];\r\n\t\t\t\tthis.add( child.clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );\r\n\r\nTHREE.Object3DIdCount = 0;\r\n\r\n// File:src/core/Face3.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\r\n\r\n\tthis.a = a;\r\n\tthis.b = b;\r\n\tthis.c = c;\r\n\r\n\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\r\n\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\r\n\r\n\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\r\n\tthis.vertexColors = Array.isArray( color ) ? color : [];\r\n\r\n\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\r\n\r\n};\r\n\r\nTHREE.Face3.prototype = {\r\n\r\n\tconstructor: THREE.Face3,\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.a = source.a;\r\n\t\tthis.b = source.b;\r\n\t\tthis.c = source.c;\r\n\r\n\t\tthis.normal.copy( source.normal );\r\n\t\tthis.color.copy( source.color );\r\n\r\n\t\tthis.materialIndex = source.materialIndex;\r\n\r\n\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/core/BufferAttribute.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BufferAttribute = function ( array, itemSize ) {\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.array = array;\r\n\tthis.itemSize = itemSize;\r\n\r\n\tthis.dynamic = false;\r\n\tthis.updateRange = { offset: 0, count: - 1 };\r\n\r\n\tthis.version = 0;\r\n\r\n};\r\n\r\nTHREE.BufferAttribute.prototype = {\r\n\r\n\tconstructor: THREE.BufferAttribute,\r\n\r\n\tget count() {\r\n\r\n\t\treturn this.array.length / this.itemSize;\r\n\r\n\t},\r\n\r\n\tset needsUpdate( value ) {\r\n\r\n\t\tif ( value === true ) this.version ++;\r\n\r\n\t},\r\n\r\n\tsetDynamic: function ( value ) {\r\n\r\n\t\tthis.dynamic = value;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.array = new source.array.constructor( source.array );\r\n\t\tthis.itemSize = source.itemSize;\r\n\r\n\t\tthis.dynamic = source.dynamic;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyAt: function ( index1, attribute, index2 ) {\r\n\r\n\t\tindex1 *= this.itemSize;\r\n\t\tindex2 *= attribute.itemSize;\r\n\r\n\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\r\n\r\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyArray: function ( array ) {\r\n\r\n\t\tthis.array.set( array );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyColorsArray: function ( colors ) {\r\n\r\n\t\tvar array = this.array, offset = 0;\r\n\r\n\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar color = colors[ i ];\r\n\r\n\t\t\tif ( color === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\r\n\t\t\t\tcolor = new THREE.Color();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarray[ offset ++ ] = color.r;\r\n\t\t\tarray[ offset ++ ] = color.g;\r\n\t\t\tarray[ offset ++ ] = color.b;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyIndicesArray: function ( indices ) {\r\n\r\n\t\tvar array = this.array, offset = 0;\r\n\r\n\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar index = indices[ i ];\r\n\r\n\t\t\tarray[ offset ++ ] = index.a;\r\n\t\t\tarray[ offset ++ ] = index.b;\r\n\t\t\tarray[ offset ++ ] = index.c;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyVector2sArray: function ( vectors ) {\r\n\r\n\t\tvar array = this.array, offset = 0;\r\n\r\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar vector = vectors[ i ];\r\n\r\n\t\t\tif ( vector === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\r\n\t\t\t\tvector = new THREE.Vector2();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarray[ offset ++ ] = vector.x;\r\n\t\t\tarray[ offset ++ ] = vector.y;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyVector3sArray: function ( vectors ) {\r\n\r\n\t\tvar array = this.array, offset = 0;\r\n\r\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar vector = vectors[ i ];\r\n\r\n\t\t\tif ( vector === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\r\n\t\t\t\tvector = new THREE.Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarray[ offset ++ ] = vector.x;\r\n\t\t\tarray[ offset ++ ] = vector.y;\r\n\t\t\tarray[ offset ++ ] = vector.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyVector4sArray: function ( vectors ) {\r\n\r\n\t\tvar array = this.array, offset = 0;\r\n\r\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar vector = vectors[ i ];\r\n\r\n\t\t\tif ( vector === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\r\n\t\t\t\tvector = new THREE.Vector4();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarray[ offset ++ ] = vector.x;\r\n\t\t\tarray[ offset ++ ] = vector.y;\r\n\t\t\tarray[ offset ++ ] = vector.z;\r\n\t\t\tarray[ offset ++ ] = vector.w;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tset: function ( value, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.array.set( value, offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetX: function ( index ) {\r\n\r\n\t\treturn this.array[ index * this.itemSize ];\r\n\r\n\t},\r\n\r\n\tsetX: function ( index, x ) {\r\n\r\n\t\tthis.array[ index * this.itemSize ] = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetY: function ( index ) {\r\n\r\n\t\treturn this.array[ index * this.itemSize + 1 ];\r\n\r\n\t},\r\n\r\n\tsetY: function ( index, y ) {\r\n\r\n\t\tthis.array[ index * this.itemSize + 1 ] = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetZ: function ( index ) {\r\n\r\n\t\treturn this.array[ index * this.itemSize + 2 ];\r\n\r\n\t},\r\n\r\n\tsetZ: function ( index, z ) {\r\n\r\n\t\tthis.array[ index * this.itemSize + 2 ] = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetW: function ( index ) {\r\n\r\n\t\treturn this.array[ index * this.itemSize + 3 ];\r\n\r\n\t},\r\n\r\n\tsetW: function ( index, w ) {\r\n\r\n\t\tthis.array[ index * this.itemSize + 3 ] = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXY: function ( index, x, y ) {\r\n\r\n\t\tindex *= this.itemSize;\r\n\r\n\t\tthis.array[ index + 0 ] = x;\r\n\t\tthis.array[ index + 1 ] = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXYZ: function ( index, x, y, z ) {\r\n\r\n\t\tindex *= this.itemSize;\r\n\r\n\t\tthis.array[ index + 0 ] = x;\r\n\t\tthis.array[ index + 1 ] = y;\r\n\t\tthis.array[ index + 2 ] = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXYZW: function ( index, x, y, z, w ) {\r\n\r\n\t\tindex *= this.itemSize;\r\n\r\n\t\tthis.array[ index + 0 ] = x;\r\n\t\tthis.array[ index + 1 ] = y;\r\n\t\tthis.array[ index + 2 ] = z;\r\n\t\tthis.array[ index + 3 ] = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n//\r\n\r\nTHREE.Int8Attribute = function ( array, itemSize ) {\r\n\r\n\treturn new THREE.BufferAttribute( new Int8Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint8Attribute = function ( array, itemSize ) {\r\n\r\n\treturn new THREE.BufferAttribute( new Uint8Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint8ClampedAttribute = function ( array, itemSize ) {\r\n\r\n\treturn new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Int16Attribute = function ( array, itemSize ) {\r\n\r\n\treturn new THREE.BufferAttribute( new Int16Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint16Attribute = function ( array, itemSize ) {\r\n\r\n\treturn new THREE.BufferAttribute( new Uint16Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Int32Attribute = function ( array, itemSize ) {\r\n\r\n\treturn new THREE.BufferAttribute( new Int32Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint32Attribute = function ( array, itemSize ) {\r\n\r\n\treturn new THREE.BufferAttribute( new Uint32Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Float32Attribute = function ( array, itemSize ) {\r\n\r\n\treturn new THREE.BufferAttribute( new Float32Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Float64Attribute = function ( array, itemSize ) {\r\n\r\n\treturn new THREE.BufferAttribute( new Float64Array( array ), itemSize );\r\n\r\n};\r\n\r\n\r\n// Deprecated\r\n\r\nTHREE.DynamicBufferAttribute = function ( array, itemSize ) {\r\n\r\n\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\r\n\treturn new THREE.BufferAttribute( array, itemSize ).setDynamic( true );\r\n\r\n};\r\n\r\n// File:src/core/InstancedBufferAttribute.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {\r\n\r\n\tTHREE.BufferAttribute.call( this, array, itemSize );\r\n\r\n\tthis.meshPerAttribute = meshPerAttribute || 1;\r\n\r\n};\r\n\r\nTHREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );\r\nTHREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;\r\n\r\nTHREE.InstancedBufferAttribute.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.BufferAttribute.prototype.copy.call( this, source );\r\n\r\n\tthis.meshPerAttribute = source.meshPerAttribute;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/core/InterleavedBuffer.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.InterleavedBuffer = function ( array, stride ) {\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.array = array;\r\n\tthis.stride = stride;\r\n\r\n\tthis.dynamic = false;\r\n\tthis.updateRange = { offset: 0, count: - 1 };\r\n\r\n\tthis.version = 0;\r\n\r\n};\r\n\r\nTHREE.InterleavedBuffer.prototype = {\r\n\r\n\tconstructor: THREE.InterleavedBuffer,\r\n\r\n\tget length () {\r\n\r\n\t\treturn this.array.length;\r\n\r\n\t},\r\n\r\n\tget count () {\r\n\r\n\t\treturn this.array.length / this.stride;\r\n\r\n\t},\r\n\r\n\tset needsUpdate( value ) {\r\n\r\n\t\tif ( value === true ) this.version ++;\r\n\r\n\t},\r\n\r\n\tsetDynamic: function ( value ) {\r\n\r\n\t\tthis.dynamic = value;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.array = new source.array.constructor( source.array );\r\n\t\tthis.stride = source.stride;\r\n\t\tthis.dynamic = source.dynamic;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyAt: function ( index1, attribute, index2 ) {\r\n\r\n\t\tindex1 *= this.stride;\r\n\t\tindex2 *= attribute.stride;\r\n\r\n\t\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\r\n\r\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tset: function ( value, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.array.set( value, offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/core/InstancedInterleavedBuffer.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {\r\n\r\n\tTHREE.InterleavedBuffer.call( this, array, stride );\r\n\r\n\tthis.meshPerAttribute = meshPerAttribute || 1;\r\n\r\n};\r\n\r\nTHREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );\r\nTHREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;\r\n\r\nTHREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.InterleavedBuffer.prototype.copy.call( this, source );\r\n\r\n\tthis.meshPerAttribute = source.meshPerAttribute;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/core/InterleavedBufferAttribute.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.data = interleavedBuffer;\r\n\tthis.itemSize = itemSize;\r\n\tthis.offset = offset;\r\n\r\n};\r\n\r\n\r\nTHREE.InterleavedBufferAttribute.prototype = {\r\n\r\n\tconstructor: THREE.InterleavedBufferAttribute,\r\n\r\n\tget length() {\r\n\r\n\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\r\n\t\treturn this.array.length;\r\n\r\n\t},\r\n\r\n\tget count() {\r\n\r\n\t\treturn this.data.count;\r\n\r\n\t},\r\n\r\n\tsetX: function ( index, x ) {\r\n\r\n\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( index, y ) {\r\n\r\n\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( index, z ) {\r\n\r\n\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetW: function ( index, w ) {\r\n\r\n\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetX: function ( index ) {\r\n\r\n\t\treturn this.data.array[ index * this.data.stride + this.offset ];\r\n\r\n\t},\r\n\r\n\tgetY: function ( index ) {\r\n\r\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\r\n\r\n\t},\r\n\r\n\tgetZ: function ( index ) {\r\n\r\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\r\n\r\n\t},\r\n\r\n\tgetW: function ( index ) {\r\n\r\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\r\n\r\n\t},\r\n\r\n\tsetXY: function ( index, x, y ) {\r\n\r\n\t\tindex = index * this.data.stride + this.offset;\r\n\r\n\t\tthis.data.array[ index + 0 ] = x;\r\n\t\tthis.data.array[ index + 1 ] = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXYZ: function ( index, x, y, z ) {\r\n\r\n\t\tindex = index * this.data.stride + this.offset;\r\n\r\n\t\tthis.data.array[ index + 0 ] = x;\r\n\t\tthis.data.array[ index + 1 ] = y;\r\n\t\tthis.data.array[ index + 2 ] = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXYZW: function ( index, x, y, z, w ) {\r\n\r\n\t\tindex = index * this.data.stride + this.offset;\r\n\r\n\t\tthis.data.array[ index + 0 ] = x;\r\n\t\tthis.data.array[ index + 1 ] = y;\r\n\t\tthis.data.array[ index + 2 ] = z;\r\n\t\tthis.data.array[ index + 3 ] = w;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/core/Geometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author kile / http://kile.stravaganza.org/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Geometry = function () {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'Geometry';\r\n\r\n\tthis.vertices = [];\r\n\tthis.colors = [];\r\n\tthis.faces = [];\r\n\tthis.faceVertexUvs = [ [] ];\r\n\r\n\tthis.morphTargets = [];\r\n\tthis.morphNormals = [];\r\n\r\n\tthis.skinWeights = [];\r\n\tthis.skinIndices = [];\r\n\r\n\tthis.lineDistances = [];\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n\t// update flags\r\n\r\n\tthis.verticesNeedUpdate = false;\r\n\tthis.elementsNeedUpdate = false;\r\n\tthis.uvsNeedUpdate = false;\r\n\tthis.normalsNeedUpdate = false;\r\n\tthis.colorsNeedUpdate = false;\r\n\tthis.lineDistancesNeedUpdate = false;\r\n\tthis.groupsNeedUpdate = false;\r\n\r\n};\r\n\r\nTHREE.Geometry.prototype = {\r\n\r\n\tconstructor: THREE.Geometry,\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\tvertex.applyMatrix4( matrix );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar face = this.faces[ i ];\r\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingBox !== null ) {\r\n\r\n\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.computeBoundingSphere();\r\n\r\n\t\t}\r\n\r\n\t\tthis.verticesNeedUpdate = true;\r\n\t\tthis.normalsNeedUpdate = true;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotateX: function () {\r\n\r\n\t\t// rotate geometry around world x-axis\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function rotateX( angle ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeRotationX( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateY: function () {\r\n\r\n\t\t// rotate geometry around world y-axis\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function rotateY( angle ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeRotationY( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateZ: function () {\r\n\r\n\t\t// rotate geometry around world z-axis\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function rotateZ( angle ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeRotationZ( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function () {\r\n\r\n\t\t// translate geometry\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function translate( x, y, z ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeTranslation( x, y, z );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tscale: function () {\r\n\r\n\t\t// scale geometry\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function scale( x, y, z ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeScale( x, y, z );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlookAt: function () {\r\n\r\n\t\tvar obj;\r\n\r\n\t\treturn function lookAt( vector ) {\r\n\r\n\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\r\n\r\n\t\t\tobj.lookAt( vector );\r\n\r\n\t\t\tobj.updateMatrix();\r\n\r\n\t\t\tthis.applyMatrix( obj.matrix );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tfromBufferGeometry: function ( geometry ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\r\n\t\tvar attributes = geometry.attributes;\r\n\r\n\t\tvar positions = attributes.position.array;\r\n\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\r\n\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\r\n\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\r\n\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\r\n\r\n\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\r\n\r\n\t\tvar tempNormals = [];\r\n\t\tvar tempUVs = [];\r\n\t\tvar tempUVs2 = [];\r\n\r\n\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\r\n\r\n\t\t\tscope.vertices.push( new THREE.Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\r\n\r\n\t\t\tif ( normals !== undefined ) {\r\n\r\n\t\t\t\ttempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( colors !== undefined ) {\r\n\r\n\t\t\t\tscope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( uvs !== undefined ) {\r\n\r\n\t\t\t\ttempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( uvs2 !== undefined ) {\r\n\r\n\t\t\t\ttempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction addFace( a, b, c, materialIndex ) {\r\n\r\n\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\r\n\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\r\n\r\n\t\t\tvar face = new THREE.Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\r\n\r\n\t\t\tscope.faces.push( face );\r\n\r\n\t\t\tif ( uvs !== undefined ) {\r\n\r\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( uvs2 !== undefined ) {\r\n\r\n\t\t\t\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( indices !== undefined ) {\r\n\r\n\t\t\tvar groups = geometry.groups;\r\n\r\n\t\t\tif ( groups.length > 0 ) {\r\n\r\n\t\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\r\n\r\n\t\t\t\t\tvar group = groups[ i ];\r\n\r\n\t\t\t\t\tvar start = group.start;\r\n\t\t\t\t\tvar count = group.count;\r\n\r\n\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\r\n\r\n\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\r\n\r\n\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\r\n\r\n\t\t\t\taddFace( i, i + 1, i + 2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.computeFaceNormals();\r\n\r\n\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcenter: function () {\r\n\r\n\t\tthis.computeBoundingBox();\r\n\r\n\t\tvar offset = this.boundingBox.center().negate();\r\n\r\n\t\tthis.translate( offset.x, offset.y, offset.z );\r\n\r\n\t\treturn offset;\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\tthis.computeBoundingSphere();\r\n\r\n\t\tvar center = this.boundingSphere.center;\r\n\t\tvar radius = this.boundingSphere.radius;\r\n\r\n\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\r\n\r\n\t\tvar matrix = new THREE.Matrix4();\r\n\t\tmatrix.set(\r\n\t\t\ts, 0, 0, - s * center.x,\r\n\t\t\t0, s, 0, - s * center.y,\r\n\t\t\t0, 0, s, - s * center.z,\r\n\t\t\t0, 0, 0, 1\r\n\t\t);\r\n\r\n\t\tthis.applyMatrix( matrix );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcomputeFaceNormals: function () {\r\n\r\n\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\r\n\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tvar face = this.faces[ f ];\r\n\r\n\t\t\tvar vA = this.vertices[ face.a ];\r\n\t\t\tvar vB = this.vertices[ face.b ];\r\n\t\t\tvar vC = this.vertices[ face.c ];\r\n\r\n\t\t\tcb.subVectors( vC, vB );\r\n\t\t\tab.subVectors( vA, vB );\r\n\t\t\tcb.cross( ab );\r\n\r\n\t\t\tcb.normalize();\r\n\r\n\t\t\tface.normal.copy( cb );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeVertexNormals: function ( areaWeighted ) {\r\n\r\n\t\tif ( areaWeighted === undefined ) areaWeighted = true;\r\n\r\n\t\tvar v, vl, f, fl, face, vertices;\r\n\r\n\t\tvertices = new Array( this.vertices.length );\r\n\r\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\tvertices[ v ] = new THREE.Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tif ( areaWeighted ) {\r\n\r\n\t\t\t// vertex normals weighted by triangle areas\r\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\r\n\r\n\t\t\tvar vA, vB, vC;\r\n\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tvA = this.vertices[ face.a ];\r\n\t\t\t\tvB = this.vertices[ face.b ];\r\n\t\t\t\tvC = this.vertices[ face.c ];\r\n\r\n\t\t\t\tcb.subVectors( vC, vB );\r\n\t\t\t\tab.subVectors( vA, vB );\r\n\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\tvertices[ face.a ].add( cb );\r\n\t\t\t\tvertices[ face.b ].add( cb );\r\n\t\t\t\tvertices[ face.c ].add( cb );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tvertices[ face.a ].add( face.normal );\r\n\t\t\t\tvertices[ face.b ].add( face.normal );\r\n\t\t\t\tvertices[ face.c ].add( face.normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\tvertices[ v ].normalize();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tvar vertexNormals = face.vertexNormals;\r\n\r\n\t\t\tif ( vertexNormals.length === 3 ) {\r\n\r\n\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\r\n\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\r\n\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\r\n\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\r\n\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.faces.length > 0 ) {\r\n\r\n\t\t\tthis.normalsNeedUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeMorphNormals: function () {\r\n\r\n\t\tvar i, il, f, fl, face;\r\n\r\n\t\t// save original normals\r\n\t\t// - create temp variables on first access\r\n\t\t//   otherwise just copy (for faster repeated calls)\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tif ( ! face.__originalFaceNormal ) {\r\n\r\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\r\n\r\n\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\r\n\r\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// use temp geometry to compute face and vertex normals for each morph\r\n\r\n\t\tvar tmpGeo = new THREE.Geometry();\r\n\t\ttmpGeo.faces = this.faces;\r\n\r\n\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\t\t// create on first access\r\n\r\n\t\t\tif ( ! this.morphNormals[ i ] ) {\r\n\r\n\t\t\t\tthis.morphNormals[ i ] = {};\r\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\r\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\r\n\r\n\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\r\n\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\r\n\r\n\t\t\t\tvar faceNormal, vertexNormals;\r\n\r\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\tfaceNormal = new THREE.Vector3();\r\n\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\r\n\r\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\r\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar morphNormals = this.morphNormals[ i ];\r\n\r\n\t\t\t// set vertices to morph target\r\n\r\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\r\n\r\n\t\t\t// compute morph normals\r\n\r\n\t\t\ttmpGeo.computeFaceNormals();\r\n\t\t\ttmpGeo.computeVertexNormals();\r\n\r\n\t\t\t// store morph normals\r\n\r\n\t\t\tvar faceNormal, vertexNormals;\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\r\n\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\r\n\r\n\t\t\t\tfaceNormal.copy( face.normal );\r\n\r\n\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\r\n\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\r\n\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore original normals\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tface.normal = face.__originalFaceNormal;\r\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeTangents: function () {\r\n\r\n\t\tconsole.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\r\n\r\n\t},\r\n\r\n\tcomputeLineDistances: function () {\r\n\r\n\t\tvar d = 0;\r\n\t\tvar vertices = this.vertices;\r\n\r\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tif ( i > 0 ) {\r\n\r\n\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.lineDistances[ i ] = d;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeBoundingBox: function () {\r\n\r\n\t\tif ( this.boundingBox === null ) {\r\n\r\n\t\t\tthis.boundingBox = new THREE.Box3();\r\n\r\n\t\t}\r\n\r\n\t\tthis.boundingBox.setFromPoints( this.vertices );\r\n\r\n\t},\r\n\r\n\tcomputeBoundingSphere: function () {\r\n\r\n\t\tif ( this.boundingSphere === null ) {\r\n\r\n\t\t\tthis.boundingSphere = new THREE.Sphere();\r\n\r\n\t\t}\r\n\r\n\t\tthis.boundingSphere.setFromPoints( this.vertices );\r\n\r\n\t},\r\n\r\n\tmerge: function ( geometry, matrix, materialIndexOffset ) {\r\n\r\n\t\tif ( geometry instanceof THREE.Geometry === false ) {\r\n\r\n\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar normalMatrix,\r\n\t\tvertexOffset = this.vertices.length,\r\n\t\tvertices1 = this.vertices,\r\n\t\tvertices2 = geometry.vertices,\r\n\t\tfaces1 = this.faces,\r\n\t\tfaces2 = geometry.faces,\r\n\t\tuvs1 = this.faceVertexUvs[ 0 ],\r\n\t\tuvs2 = geometry.faceVertexUvs[ 0 ];\r\n\r\n\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\r\n\r\n\t\tif ( matrix !== undefined ) {\r\n\r\n\t\t\tnormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\t}\r\n\r\n\t\t// vertices\r\n\r\n\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar vertex = vertices2[ i ];\r\n\r\n\t\t\tvar vertexCopy = vertex.clone();\r\n\r\n\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\r\n\r\n\t\t\tvertices1.push( vertexCopy );\r\n\r\n\t\t}\r\n\r\n\t\t// faces\r\n\r\n\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\r\n\t\t\tfaceVertexNormals = face.vertexNormals,\r\n\t\t\tfaceVertexColors = face.vertexColors;\r\n\r\n\t\t\tfaceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\r\n\t\t\tfaceCopy.normal.copy( face.normal );\r\n\r\n\t\t\tif ( normalMatrix !== undefined ) {\r\n\r\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\r\n\r\n\t\t\t\tif ( normalMatrix !== undefined ) {\r\n\r\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfaceCopy.color.copy( face.color );\r\n\r\n\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tcolor = faceVertexColors[ j ];\r\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\r\n\r\n\t\t\tfaces1.push( faceCopy );\r\n\r\n\t\t}\r\n\r\n\t\t// uvs\r\n\r\n\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar uv = uvs2[ i ], uvCopy = [];\r\n\r\n\t\t\tif ( uv === undefined ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tuvCopy.push( uv[ j ].clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuvs1.push( uvCopy );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tmergeMesh: function ( mesh ) {\r\n\r\n\t\tif ( mesh instanceof THREE.Mesh === false ) {\r\n\r\n\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\r\n\r\n\t\tthis.merge( mesh.geometry, mesh.matrix );\r\n\r\n\t},\r\n\r\n\t/*\r\n\t * Checks for duplicate vertices with hashmap.\r\n\t * Duplicated vertices are removed\r\n\t * and faces' vertices are updated.\r\n\t */\r\n\r\n\tmergeVertices: function () {\r\n\r\n\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\r\n\t\tvar unique = [], changes = [];\r\n\r\n\t\tvar v, key;\r\n\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\r\n\t\tvar precision = Math.pow( 10, precisionPoints );\r\n\t\tvar i, il, face;\r\n\t\tvar indices, j, jl;\r\n\r\n\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tv = this.vertices[ i ];\r\n\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\r\n\r\n\t\t\tif ( verticesMap[ key ] === undefined ) {\r\n\r\n\t\t\t\tverticesMap[ key ] = i;\r\n\t\t\t\tunique.push( this.vertices[ i ] );\r\n\t\t\t\tchanges[ i ] = unique.length - 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\r\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// if faces are completely degenerate after merging vertices, we\r\n\t\t// have to remove them from the geometry.\r\n\t\tvar faceIndicesToRemove = [];\r\n\r\n\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tface = this.faces[ i ];\r\n\r\n\t\t\tface.a = changes[ face.a ];\r\n\t\t\tface.b = changes[ face.b ];\r\n\t\t\tface.c = changes[ face.c ];\r\n\r\n\t\t\tindices = [ face.a, face.b, face.c ];\r\n\r\n\t\t\tvar dupIndex = - 1;\r\n\r\n\t\t\t// if any duplicate vertices are found in a Face3\r\n\t\t\t// we have to remove the face as nothing can be saved\r\n\t\t\tfor ( var n = 0; n < 3; n ++ ) {\r\n\r\n\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\r\n\r\n\t\t\t\t\tdupIndex = n;\r\n\t\t\t\t\tfaceIndicesToRemove.push( i );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\r\n\r\n\t\t\tvar idx = faceIndicesToRemove[ i ];\r\n\r\n\t\t\tthis.faces.splice( idx, 1 );\r\n\r\n\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Use unique set of vertices\r\n\r\n\t\tvar diff = this.vertices.length - unique.length;\r\n\t\tthis.vertices = unique;\r\n\t\treturn diff;\r\n\r\n\t},\r\n\r\n\tsortFacesByMaterialIndex: function () {\r\n\r\n\t\tvar faces = this.faces;\r\n\t\tvar length = faces.length;\r\n\r\n\t\t// tag faces\r\n\r\n\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\t\tfaces[ i ]._id = i;\r\n\r\n\t\t}\r\n\r\n\t\t// sort faces\r\n\r\n\t\tfunction materialIndexSort( a, b ) {\r\n\r\n\t\t\treturn a.materialIndex - b.materialIndex;\r\n\r\n\t\t}\r\n\r\n\t\tfaces.sort( materialIndexSort );\r\n\r\n\t\t// sort uvs\r\n\r\n\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\r\n\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\r\n\r\n\t\tvar newUvs1, newUvs2;\r\n\r\n\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\r\n\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\r\n\r\n\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\t\tvar id = faces[ i ]._id;\r\n\r\n\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\r\n\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\r\n\r\n\t\t}\r\n\r\n\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\r\n\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar data = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.4,\r\n\t\t\t\ttype: 'Geometry',\r\n\t\t\t\tgenerator: 'Geometry.toJSON'\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// standard Geometry serialization\r\n\r\n\t\tdata.uuid = this.uuid;\r\n\t\tdata.type = this.type;\r\n\t\tif ( this.name !== '' ) data.name = this.name;\r\n\r\n\t\tif ( this.parameters !== undefined ) {\r\n\r\n\t\t\tvar parameters = this.parameters;\r\n\r\n\t\t\tfor ( var key in parameters ) {\r\n\r\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tvar vertices = [];\r\n\r\n\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\r\n\r\n\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t}\r\n\r\n\t\tvar faces = [];\r\n\t\tvar normals = [];\r\n\t\tvar normalsHash = {};\r\n\t\tvar colors = [];\r\n\t\tvar colorsHash = {};\r\n\t\tvar uvs = [];\r\n\t\tvar uvsHash = {};\r\n\r\n\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\r\n\r\n\t\t\tvar face = this.faces[ i ];\r\n\r\n\t\t\tvar hasMaterial = true;\r\n\t\t\tvar hasFaceUv = false; // deprecated\r\n\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\r\n\t\t\tvar hasFaceNormal = face.normal.length() > 0;\r\n\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\r\n\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\r\n\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\r\n\r\n\t\t\tvar faceType = 0;\r\n\r\n\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\r\n\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\r\n\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\r\n\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\r\n\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\r\n\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\r\n\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\r\n\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\r\n\r\n\t\t\tfaces.push( faceType );\r\n\t\t\tfaces.push( face.a, face.b, face.c );\r\n\t\t\tfaces.push( face.materialIndex );\r\n\r\n\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\r\n\r\n\t\t\t\tfaces.push(\r\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\r\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\r\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\tvar vertexNormals = face.vertexNormals;\r\n\r\n\t\t\t\tfaces.push(\r\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\r\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\r\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\tfaces.push( getColorIndex( face.color ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\tvar vertexColors = face.vertexColors;\r\n\r\n\t\t\t\tfaces.push(\r\n\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\r\n\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\r\n\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction setBit( value, position, enabled ) {\r\n\r\n\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\r\n\r\n\t\t}\r\n\r\n\t\tfunction getNormalIndex( normal ) {\r\n\r\n\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\r\n\r\n\t\t\tif ( normalsHash[ hash ] !== undefined ) {\r\n\r\n\t\t\t\treturn normalsHash[ hash ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnormalsHash[ hash ] = normals.length / 3;\r\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\r\n\t\t\treturn normalsHash[ hash ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction getColorIndex( color ) {\r\n\r\n\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\r\n\r\n\t\t\tif ( colorsHash[ hash ] !== undefined ) {\r\n\r\n\t\t\t\treturn colorsHash[ hash ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcolorsHash[ hash ] = colors.length;\r\n\t\t\tcolors.push( color.getHex() );\r\n\r\n\t\t\treturn colorsHash[ hash ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction getUvIndex( uv ) {\r\n\r\n\t\t\tvar hash = uv.x.toString() + uv.y.toString();\r\n\r\n\t\t\tif ( uvsHash[ hash ] !== undefined ) {\r\n\r\n\t\t\t\treturn uvsHash[ hash ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuvsHash[ hash ] = uvs.length / 2;\r\n\t\t\tuvs.push( uv.x, uv.y );\r\n\r\n\t\t\treturn uvsHash[ hash ];\r\n\r\n\t\t}\r\n\r\n\t\tdata.data = {};\r\n\r\n\t\tdata.data.vertices = vertices;\r\n\t\tdata.data.normals = normals;\r\n\t\tif ( colors.length > 0 ) data.data.colors = colors;\r\n\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\r\n\t\tdata.data.faces = faces;\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\t/*\r\n\t\t// Handle primitives\r\n\r\n\t\tvar parameters = this.parameters;\r\n\r\n\t\tif ( parameters !== undefined ) {\r\n\r\n\t\t\tvar values = [];\r\n\r\n\t\t\tfor ( var key in parameters ) {\r\n\r\n\t\t\t\tvalues.push( parameters[ key ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar geometry = Object.create( this.constructor.prototype );\r\n\t\t\tthis.constructor.apply( geometry, values );\r\n\t\t\treturn geometry;\r\n\r\n\t\t}\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\t\t*/\r\n\r\n\t\treturn new THREE.Geometry().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.vertices = [];\r\n\t\tthis.faces = [];\r\n\t\tthis.faceVertexUvs = [ [] ];\r\n\r\n\t\tvar vertices = source.vertices;\r\n\r\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.vertices.push( vertices[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\tvar faces = source.faces;\r\n\r\n\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.faces.push( faces[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\r\n\r\n\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\r\n\r\n\t\t\t\tthis.faceVertexUvs[ i ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\r\n\r\n\t\t\t\tfor ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\r\n\r\n\t\t\t\t\tvar uv = uvs[ k ];\r\n\r\n\t\t\t\t\tuvsCopy.push( uv.clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );\r\n\r\nTHREE.GeometryIdCount = 0;\r\n\r\n// File:src/core/DirectGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.DirectGeometry = function () {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'DirectGeometry';\r\n\r\n\tthis.indices = [];\r\n\tthis.vertices = [];\r\n\tthis.normals = [];\r\n\tthis.colors = [];\r\n\tthis.uvs = [];\r\n\tthis.uvs2 = [];\r\n\r\n\tthis.groups = [];\r\n\r\n\tthis.morphTargets = {};\r\n\r\n\tthis.skinWeights = [];\r\n\tthis.skinIndices = [];\r\n\r\n\t// this.lineDistances = [];\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n\t// update flags\r\n\r\n\tthis.verticesNeedUpdate = false;\r\n\tthis.normalsNeedUpdate = false;\r\n\tthis.colorsNeedUpdate = false;\r\n\tthis.uvsNeedUpdate = false;\r\n\tthis.groupsNeedUpdate = false;\r\n\r\n};\r\n\r\nTHREE.DirectGeometry.prototype = {\r\n\r\n\tconstructor: THREE.DirectGeometry,\r\n\r\n\tcomputeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,\r\n\tcomputeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,\r\n\r\n\tcomputeFaceNormals: function () {\r\n\r\n\t\tconsole.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );\r\n\r\n\t},\r\n\r\n\tcomputeVertexNormals: function () {\r\n\r\n\t\tconsole.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );\r\n\r\n\t},\r\n\r\n\tcomputeGroups: function ( geometry ) {\r\n\r\n\t\tvar group;\r\n\t\tvar groups = [];\r\n\t\tvar materialIndex;\r\n\r\n\t\tvar faces = geometry.faces;\r\n\r\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\t// materials\r\n\r\n\t\t\tif ( face.materialIndex !== materialIndex ) {\r\n\r\n\t\t\t\tmaterialIndex = face.materialIndex;\r\n\r\n\t\t\t\tif ( group !== undefined ) {\r\n\r\n\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\r\n\t\t\t\t\tgroups.push( group );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgroup = {\r\n\t\t\t\t\tstart: i * 3,\r\n\t\t\t\t\tmaterialIndex: materialIndex\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( group !== undefined ) {\r\n\r\n\t\t\tgroup.count = ( i * 3 ) - group.start;\r\n\t\t\tgroups.push( group );\r\n\r\n\t\t}\r\n\r\n\t\tthis.groups = groups;\r\n\r\n\t},\r\n\r\n\tfromGeometry: function ( geometry ) {\r\n\r\n\t\tvar faces = geometry.faces;\r\n\t\tvar vertices = geometry.vertices;\r\n\t\tvar faceVertexUvs = geometry.faceVertexUvs;\r\n\r\n\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\r\n\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\r\n\r\n\t\t// morphs\r\n\r\n\t\tvar morphTargets = geometry.morphTargets;\r\n\t\tvar morphTargetsLength = morphTargets.length;\r\n\r\n\t\tvar morphTargetsPosition;\r\n\r\n\t\tif ( morphTargetsLength > 0 ) {\r\n\r\n\t\t\tmorphTargetsPosition = [];\r\n\r\n\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\r\n\r\n\t\t\t\tmorphTargetsPosition[ i ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.morphTargets.position = morphTargetsPosition;\r\n\r\n\t\t}\r\n\r\n\t\tvar morphNormals = geometry.morphNormals;\r\n\t\tvar morphNormalsLength = morphNormals.length;\r\n\r\n\t\tvar morphTargetsNormal;\r\n\r\n\t\tif ( morphNormalsLength > 0 ) {\r\n\r\n\t\t\tmorphTargetsNormal = [];\r\n\r\n\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\r\n\r\n\t\t\t\tmorphTargetsNormal[ i ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.morphTargets.normal = morphTargetsNormal;\r\n\r\n\t\t}\r\n\r\n\t\t// skins\r\n\r\n\t\tvar skinIndices = geometry.skinIndices;\r\n\t\tvar skinWeights = geometry.skinWeights;\r\n\r\n\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\r\n\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\r\n\r\n\t\t//\r\n\r\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\r\n\r\n\t\t\tvar vertexNormals = face.vertexNormals;\r\n\r\n\t\t\tif ( vertexNormals.length === 3 ) {\r\n\r\n\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar normal = face.normal;\r\n\r\n\t\t\t\tthis.normals.push( normal, normal, normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar vertexColors = face.vertexColors;\r\n\r\n\t\t\tif ( vertexColors.length === 3 ) {\r\n\r\n\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar color = face.color;\r\n\r\n\t\t\t\tthis.colors.push( color, color, color );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexUv === true ) {\r\n\r\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\r\n\r\n\t\t\t\tif ( vertexUvs !== undefined ) {\r\n\r\n\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\r\n\r\n\t\t\t\t\tthis.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexUv2 === true ) {\r\n\r\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\r\n\r\n\t\t\t\tif ( vertexUvs !== undefined ) {\r\n\r\n\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\r\n\r\n\t\t\t\t\tthis.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// morphs\r\n\r\n\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\r\n\r\n\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\r\n\r\n\t\t\t\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\r\n\r\n\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\r\n\r\n\t\t\t\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// skins\r\n\r\n\t\t\tif ( hasSkinIndices ) {\r\n\r\n\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasSkinWeights ) {\r\n\r\n\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.computeGroups( geometry );\r\n\r\n\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\r\n\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\r\n\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\r\n\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\r\n\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.DirectGeometry.prototype );\r\n\r\n// File:src/core/BufferGeometry.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BufferGeometry = function () {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'BufferGeometry';\r\n\r\n\tthis.index = null;\r\n\tthis.attributes = {};\r\n\r\n\tthis.morphAttributes = {};\r\n\r\n\tthis.groups = [];\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n\tthis.drawRange = { start: 0, count: Infinity };\r\n\r\n};\r\n\r\nTHREE.BufferGeometry.prototype = {\r\n\r\n\tconstructor: THREE.BufferGeometry,\r\n\r\n\tgetIndex: function () {\r\n\r\n\t\treturn this.index;\r\n\r\n\t},\r\n\r\n\tsetIndex: function ( index ) {\r\n\r\n\t\tthis.index = index;\r\n\r\n\t},\r\n\r\n\taddAttribute: function ( name, attribute ) {\r\n\r\n\t\tif ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\r\n\r\n\t\t\tthis.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( name === 'index' ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\r\n\t\t\tthis.setIndex( attribute );\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tthis.attributes[ name ] = attribute;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetAttribute: function ( name ) {\r\n\r\n\t\treturn this.attributes[ name ];\r\n\r\n\t},\r\n\r\n\tremoveAttribute: function ( name ) {\r\n\r\n\t\tdelete this.attributes[ name ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddGroup: function ( start, count, materialIndex ) {\r\n\r\n\t\tthis.groups.push( {\r\n\r\n\t\t\tstart: start,\r\n\t\t\tcount: count,\r\n\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\r\n\r\n\t\t} );\r\n\r\n\t},\r\n\r\n\tclearGroups: function () {\r\n\r\n\t\tthis.groups = [];\r\n\r\n\t},\r\n\r\n\tsetDrawRange: function ( start, count ) {\r\n\r\n\t\tthis.drawRange.start = start;\r\n\t\tthis.drawRange.count = count;\r\n\r\n\t},\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tvar position = this.attributes.position;\r\n\r\n\t\tif ( position !== undefined ) {\r\n\r\n\t\t\tmatrix.applyToVector3Array( position.array );\r\n\t\t\tposition.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tvar normal = this.attributes.normal;\r\n\r\n\t\tif ( normal !== undefined ) {\r\n\r\n\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\t\tnormalMatrix.applyToVector3Array( normal.array );\r\n\t\t\tnormal.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingBox !== null ) {\r\n\r\n\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.computeBoundingSphere();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotateX: function () {\r\n\r\n\t\t// rotate geometry around world x-axis\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function rotateX( angle ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeRotationX( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateY: function () {\r\n\r\n\t\t// rotate geometry around world y-axis\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function rotateY( angle ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeRotationY( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateZ: function () {\r\n\r\n\t\t// rotate geometry around world z-axis\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function rotateZ( angle ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeRotationZ( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function () {\r\n\r\n\t\t// translate geometry\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function translate( x, y, z ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeTranslation( x, y, z );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tscale: function () {\r\n\r\n\t\t// scale geometry\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function scale( x, y, z ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeScale( x, y, z );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlookAt: function () {\r\n\r\n\t\tvar obj;\r\n\r\n\t\treturn function lookAt( vector ) {\r\n\r\n\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\r\n\r\n\t\t\tobj.lookAt( vector );\r\n\r\n\t\t\tobj.updateMatrix();\r\n\r\n\t\t\tthis.applyMatrix( obj.matrix );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcenter: function () {\r\n\r\n\t\tthis.computeBoundingBox();\r\n\r\n\t\tvar offset = this.boundingBox.center().negate();\r\n\r\n\t\tthis.translate( offset.x, offset.y, offset.z );\r\n\r\n\t\treturn offset;\r\n\r\n\t},\r\n\r\n\tsetFromObject: function ( object ) {\r\n\r\n\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\r\n\r\n\t\tvar geometry = object.geometry;\r\n\r\n\t\tif ( object instanceof THREE.Points || object instanceof THREE.Line ) {\r\n\r\n\t\t\tvar positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );\r\n\t\t\tvar colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );\r\n\r\n\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\r\n\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\r\n\r\n\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\r\n\r\n\t\t\t\tvar lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );\r\n\r\n\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( geometry.boundingSphere !== null ) {\r\n\r\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\tif ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\t\tthis.fromGeometry( geometry );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tupdateFromObject: function ( object ) {\r\n\r\n\t\tvar geometry = object.geometry;\r\n\r\n\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\tvar direct = geometry.__directGeometry;\r\n\r\n\t\t\tif ( direct === undefined ) {\r\n\r\n\t\t\t\treturn this.fromGeometry( geometry );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\r\n\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\r\n\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\r\n\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\r\n\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\r\n\r\n\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\tgeometry.normalsNeedUpdate = false;\r\n\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\t\tgeometry.uvsNeedUpdate = false;\r\n\t\t\tgeometry.groupsNeedUpdate = false;\r\n\r\n\t\t\tgeometry = direct;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.verticesNeedUpdate === true ) {\r\n\r\n\t\t\tvar attribute = this.attributes.position;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.verticesNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.normalsNeedUpdate === true ) {\r\n\r\n\t\t\tvar attribute = this.attributes.normal;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyVector3sArray( geometry.normals );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.normalsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.colorsNeedUpdate === true ) {\r\n\r\n\t\t\tvar attribute = this.attributes.color;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyColorsArray( geometry.colors );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.colorsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.uvsNeedUpdate ) {\r\n\r\n\t\t\tvar attribute = this.attributes.uv;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.uvsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.lineDistancesNeedUpdate ) {\r\n\r\n\t\t\tvar attribute = this.attributes.lineDistance;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyArray( geometry.lineDistances );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.lineDistancesNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.groupsNeedUpdate ) {\r\n\r\n\t\t\tgeometry.computeGroups( object.geometry );\r\n\t\t\tthis.groups = geometry.groups;\r\n\r\n\t\t\tgeometry.groupsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tfromGeometry: function ( geometry ) {\r\n\r\n\t\tgeometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );\r\n\r\n\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\r\n\r\n\t},\r\n\r\n\tfromDirectGeometry: function ( geometry ) {\r\n\r\n\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\r\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\r\n\r\n\t\tif ( geometry.normals.length > 0 ) {\r\n\r\n\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\r\n\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.colors.length > 0 ) {\r\n\r\n\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\r\n\t\t\tthis.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.uvs.length > 0 ) {\r\n\r\n\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\r\n\t\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.uvs2.length > 0 ) {\r\n\r\n\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\r\n\t\t\tthis.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.indices.length > 0 ) {\r\n\r\n\t\t\tvar TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;\r\n\t\t\tvar indices = new TypeArray( geometry.indices.length * 3 );\r\n\t\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\r\n\r\n\t\t}\r\n\r\n\t\t// groups\r\n\r\n\t\tthis.groups = geometry.groups;\r\n\r\n\t\t// morphs\r\n\r\n\t\tfor ( var name in geometry.morphTargets ) {\r\n\r\n\t\t\tvar array = [];\r\n\t\t\tvar morphTargets = geometry.morphTargets[ name ];\r\n\r\n\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar morphTarget = morphTargets[ i ];\r\n\r\n\t\t\t\tvar attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );\r\n\r\n\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.morphAttributes[ name ] = array;\r\n\r\n\t\t}\r\n\r\n\t\t// skinning\r\n\r\n\t\tif ( geometry.skinIndices.length > 0 ) {\r\n\r\n\t\t\tvar skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );\r\n\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.skinWeights.length > 0 ) {\r\n\r\n\t\t\tvar skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );\r\n\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( geometry.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcomputeBoundingBox: function () {\r\n\r\n\t\tvar vector = new THREE.Vector3();\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tif ( this.boundingBox === null ) {\r\n\r\n\t\t\t\tthis.boundingBox = new THREE.Box3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar positions = this.attributes.position.array;\r\n\r\n\t\t\tif ( positions ) {\r\n\r\n\t\t\t\tthis.boundingBox.setFromArray( positions );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( positions === undefined || positions.length === 0 ) {\r\n\r\n\t\t\t\tthis.boundingBox.min.set( 0, 0, 0 );\r\n\t\t\t\tthis.boundingBox.max.set( 0, 0, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcomputeBoundingSphere: function () {\r\n\r\n\t\tvar box = new THREE.Box3();\r\n\t\tvar vector = new THREE.Vector3();\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tif ( this.boundingSphere === null ) {\r\n\r\n\t\t\t\tthis.boundingSphere = new THREE.Sphere();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar positions = this.attributes.position.array;\r\n\r\n\t\t\tif ( positions ) {\r\n\r\n\t\t\t\tvar center = this.boundingSphere.center;\r\n\r\n\t\t\t\tbox.setFromArray( positions );\r\n\t\t\t\tbox.center( center );\r\n\r\n\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\r\n\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\r\n\r\n\t\t\t\tvar maxRadiusSq = 0;\r\n\r\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\tvector.fromArray( positions, i );\r\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\r\n\r\n\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\r\n\r\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcomputeFaceNormals: function () {\r\n\r\n\t\t// backwards compatibility\r\n\r\n\t},\r\n\r\n\tcomputeVertexNormals: function () {\r\n\r\n\t\tvar index = this.index;\r\n\t\tvar attributes = this.attributes;\r\n\t\tvar groups = this.groups;\r\n\r\n\t\tif ( attributes.position ) {\r\n\r\n\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\tif ( attributes.normal === undefined ) {\r\n\r\n\t\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// reset existing normals to zero\r\n\r\n\t\t\t\tvar array = attributes.normal.array;\r\n\r\n\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tarray[ i ] = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar normals = attributes.normal.array;\r\n\r\n\t\t\tvar vA, vB, vC,\r\n\r\n\t\t\tpA = new THREE.Vector3(),\r\n\t\t\tpB = new THREE.Vector3(),\r\n\t\t\tpC = new THREE.Vector3(),\r\n\r\n\t\t\tcb = new THREE.Vector3(),\r\n\t\t\tab = new THREE.Vector3();\r\n\r\n\t\t\t// indexed elements\r\n\r\n\t\t\tif ( index ) {\r\n\r\n\t\t\t\tvar indices = index.array;\r\n\r\n\t\t\t\tif ( groups.length === 0 ) {\r\n\r\n\t\t\t\t\tthis.addGroup( 0, indices.length );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\r\n\r\n\t\t\t\t\tvar group = groups[ j ];\r\n\r\n\t\t\t\t\tvar start = group.start;\r\n\t\t\t\t\tvar count = group.count;\r\n\r\n\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\t\tvA = indices[ i + 0 ] * 3;\r\n\t\t\t\t\t\tvB = indices[ i + 1 ] * 3;\r\n\t\t\t\t\t\tvC = indices[ i + 2 ] * 3;\r\n\r\n\t\t\t\t\t\tpA.fromArray( positions, vA );\r\n\t\t\t\t\t\tpB.fromArray( positions, vB );\r\n\t\t\t\t\t\tpC.fromArray( positions, vC );\r\n\r\n\t\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\t\t\tnormals[ vA ] += cb.x;\r\n\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\r\n\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\r\n\r\n\t\t\t\t\t\tnormals[ vB ] += cb.x;\r\n\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\r\n\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\r\n\r\n\t\t\t\t\t\tnormals[ vC ] += cb.x;\r\n\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\r\n\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\r\n\r\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\r\n\r\n\t\t\t\t\tpA.fromArray( positions, i );\r\n\t\t\t\t\tpB.fromArray( positions, i + 3 );\r\n\t\t\t\t\tpC.fromArray( positions, i + 6 );\r\n\r\n\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\t\tnormals[ i ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 1 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 2 ] = cb.z;\r\n\r\n\t\t\t\t\tnormals[ i + 3 ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 4 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 5 ] = cb.z;\r\n\r\n\t\t\t\t\tnormals[ i + 6 ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 7 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 8 ] = cb.z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.normalizeNormals();\r\n\r\n\t\t\tattributes.normal.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tmerge: function ( geometry, offset ) {\r\n\r\n\t\tif ( geometry instanceof THREE.BufferGeometry === false ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tvar attributes = this.attributes;\r\n\r\n\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\r\n\r\n\t\t\tvar attribute1 = attributes[ key ];\r\n\t\t\tvar attributeArray1 = attribute1.array;\r\n\r\n\t\t\tvar attribute2 = geometry.attributes[ key ];\r\n\t\t\tvar attributeArray2 = attribute2.array;\r\n\r\n\t\t\tvar attributeSize = attribute2.itemSize;\r\n\r\n\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\r\n\r\n\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnormalizeNormals: function () {\r\n\r\n\t\tvar normals = this.attributes.normal.array;\r\n\r\n\t\tvar x, y, z, n;\r\n\r\n\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\r\n\r\n\t\t\tx = normals[ i ];\r\n\t\t\ty = normals[ i + 1 ];\r\n\t\t\tz = normals[ i + 2 ];\r\n\r\n\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\r\n\r\n\t\t\tnormals[ i ] *= n;\r\n\t\t\tnormals[ i + 1 ] *= n;\r\n\t\t\tnormals[ i + 2 ] *= n;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttoNonIndexed: function () {\r\n\r\n\t\tif ( this.index === null ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar geometry2 = new THREE.BufferGeometry();\r\n\r\n\t\tvar indices = this.index.array;\r\n\t\tvar attributes = this.attributes;\r\n\r\n\t\tfor ( var name in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ name ];\r\n\r\n\t\t\tvar array = attribute.array;\r\n\t\t\tvar itemSize = attribute.itemSize;\r\n\r\n\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\r\n\r\n\t\t\tvar index = 0, index2 = 0;\r\n\r\n\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tindex = indices[ i ] * itemSize;\r\n\r\n\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\r\n\r\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry2.addAttribute( name, new THREE.BufferAttribute( array2, itemSize ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry2;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar data = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.4,\r\n\t\t\t\ttype: 'BufferGeometry',\r\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// standard BufferGeometry serialization\r\n\r\n\t\tdata.uuid = this.uuid;\r\n\t\tdata.type = this.type;\r\n\t\tif ( this.name !== '' ) data.name = this.name;\r\n\r\n\t\tif ( this.parameters !== undefined ) {\r\n\r\n\t\t\tvar parameters = this.parameters;\r\n\r\n\t\t\tfor ( var key in parameters ) {\r\n\r\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tdata.data = { attributes: {} };\r\n\r\n\t\tvar index = this.index;\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tvar array = Array.prototype.slice.call( index.array );\r\n\r\n\t\t\tdata.data.index = {\r\n\t\t\t\ttype: index.array.constructor.name,\r\n\t\t\t\tarray: array\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tvar attributes = this.attributes;\r\n\r\n\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ key ];\r\n\r\n\t\t\tvar array = Array.prototype.slice.call( attribute.array );\r\n\r\n\t\t\tdata.data.attributes[ key ] = {\r\n\t\t\t\titemSize: attribute.itemSize,\r\n\t\t\t\ttype: attribute.array.constructor.name,\r\n\t\t\t\tarray: array\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tvar groups = this.groups;\r\n\r\n\t\tif ( groups.length > 0 ) {\r\n\r\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar boundingSphere = this.boundingSphere;\r\n\r\n\t\tif ( boundingSphere !== null ) {\r\n\r\n\t\t\tdata.data.boundingSphere = {\r\n\t\t\t\tcenter: boundingSphere.center.toArray(),\r\n\t\t\t\tradius: boundingSphere.radius\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\t/*\r\n\t\t// Handle primitives\r\n\r\n\t\tvar parameters = this.parameters;\r\n\r\n\t\tif ( parameters !== undefined ) {\r\n\r\n\t\t\tvar values = [];\r\n\r\n\t\t\tfor ( var key in parameters ) {\r\n\r\n\t\t\t\tvalues.push( parameters[ key ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar geometry = Object.create( this.constructor.prototype );\r\n\t\t\tthis.constructor.apply( geometry, values );\r\n\t\t\treturn geometry;\r\n\r\n\t\t}\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\t\t*/\r\n\r\n\t\treturn new THREE.BufferGeometry().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tvar index = source.index;\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tthis.setIndex( index.clone() );\r\n\r\n\t\t}\r\n\r\n\t\tvar attributes = source.attributes;\r\n\r\n\t\tfor ( var name in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ name ];\r\n\t\t\tthis.addAttribute( name, attribute.clone() );\r\n\r\n\t\t}\r\n\r\n\t\tvar groups = source.groups;\r\n\r\n\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar group = groups[ i ];\r\n\t\t\tthis.addGroup( group.start, group.count );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );\r\n\r\nTHREE.BufferGeometry.MaxIndex = 65535;\r\n\r\n// File:src/core/InstancedBufferGeometry.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.InstancedBufferGeometry = function () {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'InstancedBufferGeometry';\r\n\tthis.maxInstancedCount = undefined;\r\n\r\n};\r\n\r\nTHREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;\r\n\r\nTHREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {\r\n\r\n\tthis.groups.push( {\r\n\r\n\t\tstart: start,\r\n\t\tcount: count,\r\n\t\tinstances: instances\r\n\r\n\t} );\r\n\r\n};\r\n\r\nTHREE.InstancedBufferGeometry.prototype.copy = function ( source ) {\r\n\r\n\tvar index = source.index;\r\n\r\n\tif ( index !== null ) {\r\n\r\n\t\tthis.setIndex( index.clone() );\r\n\r\n\t}\r\n\r\n\tvar attributes = source.attributes;\r\n\r\n\tfor ( var name in attributes ) {\r\n\r\n\t\tvar attribute = attributes[ name ];\r\n\t\tthis.addAttribute( name, attribute.clone() );\r\n\r\n\t}\r\n\r\n\tvar groups = source.groups;\r\n\r\n\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n\t\tvar group = groups[ i ];\r\n\t\tthis.addGroup( group.start, group.count, group.instances );\r\n\r\n\t}\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.InstancedBufferGeometry.prototype );\r\n\r\n// File:src/core/Uniform.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Uniform = function ( type, value ) {\r\n\r\n\tthis.type = type;\r\n\tthis.value = value;\r\n\r\n\tthis.dynamic = false;\r\n\r\n};\r\n\r\nTHREE.Uniform.prototype = {\r\n\r\n\tconstructor: THREE.Uniform,\r\n\r\n\tonUpdate: function ( callback ) {\r\n\r\n\t\tthis.dynamic = true;\r\n\t\tthis.onUpdateCallback = callback;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/animation/AnimationClip.js\r\n\r\n/**\r\n *\r\n * Reusable set of Tracks that represent an animation.\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n */\r\n\r\nTHREE.AnimationClip = function ( name, duration, tracks ) {\r\n\r\n\tthis.name = name || THREE.Math.generateUUID();\r\n\tthis.tracks = tracks;\r\n\tthis.duration = ( duration !== undefined ) ? duration : -1;\r\n\r\n\t// this means it should figure out its duration by scanning the tracks\r\n\tif ( this.duration < 0 ) {\r\n\r\n\t\tthis.resetDuration();\r\n\r\n\t}\r\n\r\n\t// maybe only do these on demand, as doing them here could potentially slow down loading\r\n\t// but leaving these here during development as this ensures a lot of testing of these functions\r\n\tthis.trim();\r\n\tthis.optimize();\r\n\r\n};\r\n\r\nTHREE.AnimationClip.prototype = {\r\n\r\n\tconstructor: THREE.AnimationClip,\r\n\r\n\tresetDuration: function() {\r\n\r\n\t\tvar tracks = this.tracks,\r\n\t\t\tduration = 0;\r\n\r\n\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar track = this.tracks[ i ];\r\n\r\n\t\t\tduration = Math.max(\r\n\t\t\t\t\tduration, track.times[ track.times.length - 1 ] );\r\n\r\n\t\t}\r\n\r\n\t\tthis.duration = duration;\r\n\r\n\t},\r\n\r\n\ttrim: function() {\r\n\r\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\r\n\r\n\t\t\tthis.tracks[ i ].trim( 0, this.duration );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\toptimize: function() {\r\n\r\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\r\n\r\n\t\t\tthis.tracks[ i ].optimize();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// Static methods:\r\n\r\nObject.assign( THREE.AnimationClip, {\r\n\r\n\tparse: function( json ) {\r\n\r\n\t\tvar tracks = [],\r\n\t\t\tjsonTracks = json.tracks,\r\n\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\r\n\r\n\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\r\n\r\n\t\t\ttracks.push( THREE.KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn new THREE.AnimationClip( json.name, json.duration, tracks );\r\n\r\n\t},\r\n\r\n\r\n\ttoJSON: function( clip ) {\r\n\r\n\t\tvar tracks = [],\r\n\t\t\tclipTracks = clip.tracks;\r\n\r\n\t\tvar json = {\r\n\r\n\t\t\t'name': clip.name,\r\n\t\t\t'duration': clip.duration,\r\n\t\t\t'tracks': tracks\r\n\r\n\t\t};\r\n\r\n\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\r\n\r\n\t\t\ttracks.push( THREE.KeyframeTrack.toJSON( clipTracks[ i ] ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn json;\r\n\r\n\t},\r\n\r\n\r\n\tCreateFromMorphTargetSequence: function( name, morphTargetSequence, fps ) {\r\n\r\n\t\tvar numMorphTargets = morphTargetSequence.length;\r\n\t\tvar tracks = [];\r\n\r\n\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\r\n\r\n\t\t\tvar times = [];\r\n\t\t\tvar values = [];\r\n\r\n\t\t\ttimes.push(\r\n\t\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\r\n\t\t\t\t\ti,\r\n\t\t\t\t\t( i + 1 ) % numMorphTargets );\r\n\r\n\t\t\tvalues.push( 0, 1, 0 );\r\n\r\n\t\t\tvar order = THREE.AnimationUtils.getKeyframeOrder( times );\r\n\t\t\ttimes = THREE.AnimationUtils.sortedArray( times, 1, order );\r\n\t\t\tvalues = THREE.AnimationUtils.sortedArray( values, 1, order );\r\n\r\n\t\t\t// if there is a key at the first frame, duplicate it as the\r\n\t\t\t// last frame as well for perfect loop.\r\n\t\t\tif ( times[ 0 ] === 0 ) {\r\n\r\n\t\t\t\ttimes.push( numMorphTargets );\r\n\t\t\t\tvalues.push( values[ 0 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttracks.push(\r\n\t\t\t\t\tnew THREE.NumberKeyframeTrack(\r\n\t\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\r\n\t\t\t\t\t\ttimes, values\r\n\t\t\t\t\t).scale( 1.0 / fps ) );\r\n\t\t}\r\n\r\n\t\treturn new THREE.AnimationClip( name, -1, tracks );\r\n\r\n\t},\r\n\r\n\tfindByName: function( clipArray, name ) {\r\n\r\n\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\r\n\r\n\t\t\tif ( clipArray[ i ].name === name ) {\r\n\r\n\t\t\t\treturn clipArray[ i ];\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t},\r\n\r\n\tCreateClipsFromMorphTargetSequences: function( morphTargets, fps ) {\r\n\r\n\t\tvar animationToMorphTargets = {};\r\n\r\n\t\t// tested with https://regex101.com/ on trick sequences\r\n\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\r\n\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\r\n\r\n\t\t// sort morph target names into animation groups based\r\n\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\r\n\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar morphTarget = morphTargets[ i ];\r\n\t\t\tvar parts = morphTarget.name.match( pattern );\r\n\r\n\t\t\tif ( parts && parts.length > 1 ) {\r\n\r\n\t\t\t\tvar name = parts[ 1 ];\r\n\r\n\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\r\n\t\t\t\tif ( ! animationMorphTargets ) {\r\n\r\n\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tanimationMorphTargets.push( morphTarget );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar clips = [];\r\n\r\n\t\tfor ( var name in animationToMorphTargets ) {\r\n\r\n\t\t\tclips.push( THREE.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn clips;\r\n\r\n\t},\r\n\r\n\t// parse the animation.hierarchy format\r\n\tparseAnimation: function( animation, bones, nodeName ) {\r\n\r\n\t\tif ( ! animation ) {\r\n\r\n\t\t\tconsole.error( \"  no animation in JSONLoader data\" );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tvar addNonemptyTrack = function(\r\n\t\t\t\ttrackType, trackName, animationKeys, propertyName, destTracks ) {\r\n\r\n\t\t\t// only return track if there are actually keys.\r\n\t\t\tif ( animationKeys.length !== 0 ) {\r\n\r\n\t\t\t\tvar times = [];\r\n\t\t\t\tvar values = [];\r\n\r\n\t\t\t\tTHREE.AnimationUtils.flattenJSON(\r\n\t\t\t\t\t\tanimationKeys, times, values, propertyName );\r\n\r\n\t\t\t\t// empty keys are filtered out, so check again\r\n\t\t\t\tif ( times.length !== 0 ) {\r\n\r\n\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tvar tracks = [];\r\n\r\n\t\tvar clipName = animation.name || 'default';\r\n\t\t// automatic length determination in AnimationClip.\r\n\t\tvar duration = animation.length || -1;\r\n\t\tvar fps = animation.fps || 30;\r\n\r\n\t\tvar hierarchyTracks = animation.hierarchy || [];\r\n\r\n\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\r\n\r\n\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\r\n\r\n\t\t\t// skip empty tracks\r\n\t\t\tif ( ! animationKeys || animationKeys.length == 0 ) continue;\r\n\r\n\t\t\t// process morph targets in a way exactly compatible\r\n\t\t\t// with AnimationHandler.init( animation )\r\n\t\t\tif ( animationKeys[0].morphTargets ) {\r\n\r\n\t\t\t\t// figure out all morph targets used in this track\r\n\t\t\t\tvar morphTargetNames = {};\r\n\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\r\n\r\n\t\t\t\t\tif ( animationKeys[k].morphTargets ) {\r\n\r\n\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {\r\n\r\n\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// create a track for each morph target with all zero\r\n\t\t\t\t// morphTargetInfluences except for the keys in which\r\n\t\t\t\t// the morphTarget is named.\r\n\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\r\n\r\n\t\t\t\t\tvar times = [];\r\n\t\t\t\t\tvar values = [];\r\n\r\n\t\t\t\t\tfor ( var m = 0;\r\n\t\t\t\t\t\t\tm !== animationKeys[k].morphTargets.length; ++ m ) {\r\n\r\n\t\t\t\t\t\tvar animationKey = animationKeys[k];\r\n\r\n\t\t\t\t\t\ttimes.push( animationKey.time );\r\n\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 )\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttracks.push( new THREE.NumberKeyframeTrack(\r\n\t\t\t\t\t\t\t'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\r\n\r\n\t\t\t} else {\r\n\t\t\t\t// ...assume skeletal animation\r\n\r\n\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\r\n\r\n\t\t\t\taddNonemptyTrack(\r\n\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.position',\r\n\t\t\t\t\t\tanimationKeys, 'pos', tracks );\r\n\r\n\t\t\t\taddNonemptyTrack(\r\n\t\t\t\t\t\tTHREE.QuaternionKeyframeTrack, boneName + '.quaternion',\r\n\t\t\t\t\t\tanimationKeys, 'rot', tracks );\r\n\r\n\t\t\t\taddNonemptyTrack(\r\n\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.scale',\r\n\t\t\t\t\t\tanimationKeys, 'scl', tracks );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( tracks.length === 0 ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tvar clip = new THREE.AnimationClip( clipName, duration, tracks );\r\n\r\n\t\treturn clip;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n\r\n// File:src/animation/AnimationMixer.js\r\n\r\n/**\r\n *\r\n * Player for AnimationClips.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.AnimationMixer = function( root ) {\r\n\r\n\tthis._root = root;\r\n\tthis._initMemoryManager();\r\n\tthis._accuIndex = 0;\r\n\r\n\tthis.time = 0;\r\n\r\n\tthis.timeScale = 1.0;\r\n\r\n};\r\n\r\nTHREE.AnimationMixer.prototype = {\r\n\r\n\tconstructor: THREE.AnimationMixer,\r\n\r\n\t// return an action for a clip optionally using a custom root target\r\n\t// object (this method allocates a lot of dynamic memory in case a\r\n\t// previously unknown clip/root combination is specified)\r\n\tclipAction: function( clip, optionalRoot ) {\r\n\r\n\t\tvar root = optionalRoot || this._root,\r\n\t\t\trootUuid = root.uuid,\r\n\t\t\tclipName = ( typeof clip === 'string' ) ? clip : clip.name,\r\n\t\t\tclipObject = ( clip !== clipName ) ? clip : null,\r\n\r\n\t\t\tactionsForClip = this._actionsByClip[ clipName ],\r\n\t\t\tprototypeAction;\r\n\r\n\t\tif ( actionsForClip !== undefined ) {\r\n\r\n\t\t\tvar existingAction =\r\n\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\r\n\r\n\t\t\tif ( existingAction !== undefined ) {\r\n\r\n\t\t\t\treturn existingAction;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// we know the clip, so we don't have to parse all\r\n\t\t\t// the bindings again but can just copy\r\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\r\n\r\n\t\t\t// also, take the clip from the prototype action\r\n\t\t\tclipObject = prototypeAction._clip;\r\n\r\n\t\t\tif ( clip !== clipName && clip !== clipObject ) {\r\n\r\n\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t\"Different clips with the same name detected!\" );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// clip must be known when specified via string\r\n\t\tif ( clipObject === null ) return null;\r\n\r\n\t\t// allocate all resources required to run it\r\n\t\tvar newAction = new THREE.\r\n\t\t\t\tAnimationMixer._Action( this, clipObject, optionalRoot );\r\n\r\n\t\tthis._bindAction( newAction, prototypeAction );\r\n\r\n\t\t// and make the action known to the memory manager\r\n\t\tthis._addInactiveAction( newAction, clipName, rootUuid );\r\n\r\n\t\treturn newAction;\r\n\r\n\t},\r\n\r\n\t// get an existing action\r\n\texistingAction: function( clip, optionalRoot ) {\r\n\r\n\t\tvar root = optionalRoot || this._root,\r\n\t\t\trootUuid = root.uuid,\r\n\t\t\tclipName = ( typeof clip === 'string' ) ? clip : clip.name,\r\n\t\t\tactionsForClip = this._actionsByClip[ clipName ];\r\n\r\n\t\tif ( actionsForClip !== undefined ) {\r\n\r\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t},\r\n\r\n\t// deactivates all previously scheduled actions\r\n\tstopAllAction: function() {\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tnActions = this._nActiveActions,\r\n\t\t\tbindings = this._bindings,\r\n\t\t\tnBindings = this._nActiveBindings;\r\n\r\n\t\tthis._nActiveActions = 0;\r\n\t\tthis._nActiveBindings = 0;\r\n\r\n\t\tfor ( var i = 0; i !== nActions; ++ i ) {\r\n\r\n\t\t\tactions[ i ].reset();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\r\n\r\n\t\t\tbindings[ i ].useCount = 0;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// advance the time and update apply the animation\r\n\tupdate: function( deltaTime ) {\r\n\r\n\t\tdeltaTime *= this.timeScale;\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tnActions = this._nActiveActions,\r\n\r\n\t\t\ttime = this.time += deltaTime,\r\n\t\t\ttimeDirection = Math.sign( deltaTime ),\r\n\r\n\t\t\taccuIndex = this._accuIndex ^= 1;\r\n\r\n\t\t// run active actions\r\n\r\n\t\tfor ( var i = 0; i !== nActions; ++ i ) {\r\n\r\n\t\t\tvar action = actions[ i ];\r\n\r\n\t\t\tif ( action.enabled ) {\r\n\r\n\t\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// update scene graph\r\n\r\n\t\tvar bindings = this._bindings,\r\n\t\t\tnBindings = this._nActiveBindings;\r\n\r\n\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\r\n\r\n\t\t\tbindings[ i ].apply( accuIndex );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// return this mixer's root target object\r\n\tgetRoot: function() {\r\n\r\n\t\treturn this._root;\r\n\r\n\t},\r\n\r\n\t// free all resources specific to a particular clip\r\n\tuncacheClip: function( clip ) {\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tclipName = clip.name,\r\n\t\t\tactionsByClip = this._actionsByClip,\r\n\t\t\tactionsForClip = actionsByClip[ clipName ];\r\n\r\n\t\tif ( actionsForClip !== undefined ) {\r\n\r\n\t\t\t// note: just calling _removeInactiveAction would mess up the\r\n\t\t\t// iteration state and also require updating the state we can\r\n\t\t\t// just throw away\r\n\r\n\t\t\tvar actionsToRemove = actionsForClip.knownActions;\r\n\r\n\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\tvar action = actionsToRemove[ i ];\r\n\r\n\t\t\t\tthis._deactivateAction( action );\r\n\r\n\t\t\t\tvar cacheIndex = action._cacheIndex,\r\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\r\n\r\n\t\t\t\taction._cacheIndex = null;\r\n\t\t\t\taction._byClipCacheIndex = null;\r\n\r\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\r\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\r\n\t\t\t\tactions.pop();\r\n\r\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdelete actionsByClip[ clipName ];\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// free all resources specific to a particular root target object\r\n\tuncacheRoot: function( root ) {\r\n\r\n\t\tvar rootUuid = root.uuid,\r\n\t\t\tactionsByClip = this._actionsByClip;\r\n\r\n\t\tfor ( var clipName in actionsByClip ) {\r\n\r\n\t\t\tvar actionByRoot = actionsByClip[ clipName ].actionByRoot,\r\n\t\t\t\taction = actionByRoot[ rootUuid ];\r\n\r\n\t\t\tif ( action !== undefined ) {\r\n\r\n\t\t\t\tthis._deactivateAction( action );\r\n\t\t\t\tthis._removeInactiveAction( action );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar bindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\r\n\r\n\t\tif ( bindingByName !== undefined ) {\r\n\r\n\t\t\tfor ( var trackName in bindingByName ) {\r\n\r\n\t\t\t\tvar binding = bindingByName[ trackName ];\r\n\t\t\t\tbinding.restoreOriginalState();\r\n\t\t\t\tthis._removeInactiveBinding( binding );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// remove a targeted clip from the cache\r\n\tuncacheAction: function( clip, optionalRoot ) {\r\n\r\n\t\tvar action = this.existingAction( clip, optionalRoot );\r\n\r\n\t\tif ( action !== null ) {\r\n\r\n\t\t\tthis._deactivateAction( action );\r\n\t\t\tthis._removeInactiveAction( action );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.AnimationMixer.prototype );\r\n\r\nTHREE.AnimationMixer._Action =\r\n\t\tfunction( mixer, clip, localRoot ) {\r\n\r\n\tthis._mixer = mixer;\r\n\tthis._clip = clip;\r\n\tthis._localRoot = localRoot || null;\r\n\r\n\tvar tracks = clip.tracks,\r\n\t\tnTracks = tracks.length,\r\n\t\tinterpolants = new Array( nTracks );\r\n\r\n\tvar interpolantSettings = {\r\n\t\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\r\n\t\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\r\n\t};\r\n\r\n\tfor ( var i = 0; i !== nTracks; ++ i ) {\r\n\r\n\t\tvar interpolant = tracks[ i ].createInterpolant( null );\r\n\t\tinterpolants[ i ] = interpolant;\r\n\t\tinterpolant.settings = interpolantSettings\r\n\r\n\t}\r\n\r\n\tthis._interpolantSettings = interpolantSettings;\r\n\r\n\tthis._interpolants = interpolants;\t// bound by the mixer\r\n\r\n\t// inside: PropertyMixer (managed by the mixer)\r\n\tthis._propertyBindings = new Array( nTracks );\r\n\r\n\tthis._cacheIndex = null;\t\t\t// for the memory manager\r\n\tthis._byClipCacheIndex = null;\t\t// for the memory manager\r\n\r\n\tthis._timeScaleInterpolant = null;\r\n\tthis._weightInterpolant = null;\r\n\r\n\tthis.loop = THREE.LoopRepeat;\r\n\tthis._loopCount = -1;\r\n\r\n\t// global mixer time when the action is to be started\r\n\t// it's set back to 'null' upon start of the action\r\n\tthis._startTime = null;\r\n\r\n\t// scaled local time of the action\r\n\t// gets clamped or wrapped to 0..clip.duration according to loop\r\n\tthis.time = 0;\r\n\r\n\tthis.timeScale = 1;\r\n\tthis._effectiveTimeScale = 1;\r\n\r\n\tthis.weight = 1;\r\n\tthis._effectiveWeight = 1;\r\n\r\n\tthis.repetitions = Infinity; \t\t// no. of repetitions when looping\r\n\r\n\tthis.paused = false;\t\t\t\t// false -> zero effective time scale\r\n\tthis.enabled = true;\t\t\t\t// true -> zero effective weight\r\n\r\n\tthis.clampWhenFinished \t= false;\t// keep feeding the last frame?\r\n\r\n\tthis.zeroSlopeAtStart \t= true;\t\t// for smooth interpolation w/o separate\r\n\tthis.zeroSlopeAtEnd\t\t= true;\t\t// clips for start, loop and end\r\n\r\n};\r\n\r\nTHREE.AnimationMixer._Action.prototype = {\r\n\r\n\tconstructor: THREE.AnimationMixer._Action,\r\n\r\n\t// State & Scheduling\r\n\r\n\tplay: function() {\r\n\r\n\t\tthis._mixer._activateAction( this );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tstop: function() {\r\n\r\n\t\tthis._mixer._deactivateAction( this );\r\n\r\n\t\treturn this.reset();\r\n\r\n\t},\r\n\r\n\treset: function() {\r\n\r\n\t\tthis.paused = false;\r\n\t\tthis.enabled = true;\r\n\r\n\t\tthis.time = 0;\t\t\t// restart clip\r\n\t\tthis._loopCount = -1;\t// forget previous loops\r\n\t\tthis._startTime = null;\t// forget scheduling\r\n\r\n\t\treturn this.stopFading().stopWarping();\r\n\r\n\t},\r\n\r\n\tisRunning: function() {\r\n\r\n\t\tvar start = this._startTime;\r\n\r\n\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\r\n\t\t\t\tthis._startTime === null && this._mixer._isActiveAction( this )\r\n\r\n\t},\r\n\r\n\t// return true when play has been called\r\n\tisScheduled: function() {\r\n\r\n\t\treturn this._mixer._isActiveAction( this );\r\n\r\n\t},\r\n\r\n\tstartAt: function( time ) {\r\n\r\n\t\tthis._startTime = time;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetLoop: function( mode, repetitions ) {\r\n\r\n\t\tthis.loop = mode;\r\n\t\tthis.repetitions = repetitions;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// Weight\r\n\r\n\t// set the weight stopping any scheduled fading\r\n\t// although .enabled = false yields an effective weight of zero, this\r\n\t// method does *not* change .enabled, because it would be confusing\r\n\tsetEffectiveWeight: function( weight ) {\r\n\r\n\t\tthis.weight = weight;\r\n\r\n\t\t// note: same logic as when updated at runtime\r\n\t\tthis._effectiveWeight = this.enabled ? weight : 0;\r\n\r\n\t\treturn this.stopFading();\r\n\r\n\t},\r\n\r\n\t// return the weight considering fading and .enabled\r\n\tgetEffectiveWeight: function() {\r\n\r\n\t\treturn this._effectiveWeight;\r\n\r\n\t},\r\n\r\n\tfadeIn: function( duration ) {\r\n\r\n\t\treturn this._scheduleFading( duration, 0, 1 );\r\n\r\n\t},\r\n\r\n\tfadeOut: function( duration ) {\r\n\r\n\t\treturn this._scheduleFading( duration, 1, 0 );\r\n\r\n\t},\r\n\r\n\tcrossFadeFrom: function( fadeOutAction, duration, warp ) {\r\n\r\n\t\tvar mixer = this._mixer;\r\n\r\n\t\tfadeOutAction.fadeOut( duration );\r\n\t\tthis.fadeIn( duration );\r\n\r\n\t\tif( warp ) {\r\n\r\n\t\t\tvar fadeInDuration = this._clip.duration,\r\n\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\r\n\r\n\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\r\n\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\r\n\r\n\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\r\n\t\t\tthis.warp( endStartRatio, 1.0, duration );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcrossFadeTo: function( fadeInAction, duration, warp ) {\r\n\r\n\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\r\n\r\n\t},\r\n\r\n\tstopFading: function() {\r\n\r\n\t\tvar weightInterpolant = this._weightInterpolant;\r\n\r\n\t\tif ( weightInterpolant !== null ) {\r\n\r\n\t\t\tthis._weightInterpolant = null;\r\n\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// Time Scale Control\r\n\r\n\t// set the weight stopping any scheduled warping\r\n\t// although .paused = true yields an effective time scale of zero, this\r\n\t// method does *not* change .paused, because it would be confusing\r\n\tsetEffectiveTimeScale: function( timeScale ) {\r\n\r\n\t\tthis.timeScale = timeScale;\r\n\t\tthis._effectiveTimeScale = this.paused ? 0 :timeScale;\r\n\r\n\t\treturn this.stopWarping();\r\n\r\n\t},\r\n\r\n\t// return the time scale considering warping and .paused\r\n\tgetEffectiveTimeScale: function() {\r\n\r\n\t\treturn this._effectiveTimeScale;\r\n\r\n\t},\r\n\r\n\tsetDuration: function( duration ) {\r\n\r\n\t\tthis.timeScale = this._clip.duration / duration;\r\n\r\n\t\treturn this.stopWarping();\r\n\r\n\t},\r\n\r\n\tsyncWith: function( action ) {\r\n\r\n\t\tthis.time = action.time;\r\n\t\tthis.timeScale = action.timeScale;\r\n\r\n\t\treturn this.stopWarping();\r\n\r\n\t},\r\n\r\n\thalt: function( duration ) {\r\n\r\n\t\treturn this.warp( this._currentTimeScale, 0, duration );\r\n\r\n\t},\r\n\r\n\twarp: function( startTimeScale, endTimeScale, duration ) {\r\n\r\n\t\tvar mixer = this._mixer, now = mixer.time,\r\n\t\t\tinterpolant = this._timeScaleInterpolant,\r\n\r\n\t\t\ttimeScale = this.timeScale;\r\n\r\n\t\tif ( interpolant === null ) {\r\n\r\n\t\t\tinterpolant = mixer._lendControlInterpolant(),\r\n\t\t\tthis._timeScaleInterpolant = interpolant;\r\n\r\n\t\t}\r\n\r\n\t\tvar times = interpolant.parameterPositions,\r\n\t\t\tvalues = interpolant.sampleValues;\r\n\r\n\t\ttimes[ 0 ] = now;\r\n\t\ttimes[ 1 ] = now + duration;\r\n\r\n\t\tvalues[ 0 ] = startTimeScale / timeScale;\r\n\t\tvalues[ 1 ] = endTimeScale / timeScale;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tstopWarping: function() {\r\n\r\n\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\r\n\r\n\t\tif ( timeScaleInterpolant !== null ) {\r\n\r\n\t\t\tthis._timeScaleInterpolant = null;\r\n\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// Object Accessors\r\n\r\n\tgetMixer: function() {\r\n\r\n\t\treturn this._mixer;\r\n\r\n\t},\r\n\r\n\tgetClip: function() {\r\n\r\n\t\treturn this._clip;\r\n\r\n\t},\r\n\r\n\tgetRoot: function() {\r\n\r\n\t\treturn this._localRoot || this._mixer._root;\r\n\r\n\t},\r\n\r\n\t// Interna\r\n\r\n\t_update: function( time, deltaTime, timeDirection, accuIndex ) {\r\n\t\t// called by the mixer\r\n\r\n\t\tvar startTime = this._startTime;\r\n\r\n\t\tif ( startTime !== null ) {\r\n\r\n\t\t\t// check for scheduled start of action\r\n\r\n\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\r\n\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\r\n\r\n\t\t\t\treturn; // yet to come / don't decide when delta = 0\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// start\r\n\r\n\t\t\tthis._startTime = null; // unschedule\r\n\t\t\tdeltaTime = timeDirection * timeRunning;\r\n\r\n\t\t}\r\n\r\n\t\t// apply time scale and advance time\r\n\r\n\t\tdeltaTime *= this._updateTimeScale( time );\r\n\t\tvar clipTime = this._updateTime( deltaTime );\r\n\r\n\t\t// note: _updateTime may disable the action resulting in\r\n\t\t// an effective weight of 0\r\n\r\n\t\tvar weight = this._updateWeight( time );\r\n\r\n\t\tif ( weight > 0 ) {\r\n\r\n\t\t\tvar interpolants = this._interpolants;\r\n\t\t\tvar propertyMixers = this._propertyBindings;\r\n\r\n\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\r\n\r\n\t\t\t\tinterpolants[ j ].evaluate( clipTime );\r\n\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_updateWeight: function( time ) {\r\n\r\n\t\tvar weight = 0;\r\n\r\n\t\tif ( this.enabled ) {\r\n\r\n\t\t\tweight = this.weight;\r\n\t\t\tvar interpolant = this._weightInterpolant;\r\n\r\n\t\t\tif ( interpolant !== null ) {\r\n\r\n\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\r\n\r\n\t\t\t\tweight *= interpolantValue;\r\n\r\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\r\n\r\n\t\t\t\t\tthis.stopFading();\r\n\r\n\t\t\t\t\tif ( interpolantValue === 0 ) {\r\n\r\n\t\t\t\t\t\t// faded out, disable\r\n\t\t\t\t\t\tthis.enabled = false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis._effectiveWeight = weight;\r\n\t\treturn weight;\r\n\r\n\t},\r\n\r\n\t_updateTimeScale: function( time ) {\r\n\r\n\t\tvar timeScale = 0;\r\n\r\n\t\tif ( ! this.paused ) {\r\n\r\n\t\t\ttimeScale = this.timeScale;\r\n\r\n\t\t\tvar interpolant = this._timeScaleInterpolant;\r\n\r\n\t\t\tif ( interpolant !== null ) {\r\n\r\n\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\r\n\r\n\t\t\t\ttimeScale *= interpolantValue;\r\n\r\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\r\n\r\n\t\t\t\t\tthis.stopWarping();\r\n\r\n\t\t\t\t\tif ( timeScale === 0 ) {\r\n\r\n\t\t\t\t\t\t// motion has halted, pause\r\n\t\t\t\t\t\tthis.pause = true;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// warp done - apply final time scale\r\n\t\t\t\t\t\tthis.timeScale = timeScale;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis._effectiveTimeScale = timeScale;\r\n\t\treturn timeScale;\r\n\r\n\t},\r\n\r\n\t_updateTime: function( deltaTime ) {\r\n\r\n\t\tvar time = this.time + deltaTime;\r\n\r\n\t\tif ( deltaTime === 0 ) return time;\r\n\r\n\t\tvar duration = this._clip.duration,\r\n\r\n\t\t\tloop = this.loop,\r\n\t\t\tloopCount = this._loopCount,\r\n\r\n\t\t\tpingPong = false;\r\n\r\n\t\tswitch ( loop ) {\r\n\r\n\t\t\tcase THREE.LoopOnce:\r\n\r\n\t\t\t\tif ( loopCount === -1 ) {\r\n\r\n\t\t\t\t\t// just started\r\n\r\n\t\t\t\t\tthis.loopCount = 0;\r\n\t\t\t\t\tthis._setEndings( true, true, false );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( time >= duration ) {\r\n\r\n\t\t\t\t\ttime = duration;\r\n\r\n\t\t\t\t} else if ( time < 0 ) {\r\n\r\n\t\t\t\t\ttime = 0;\r\n\r\n\t\t\t\t} else break;\r\n\r\n\t\t\t\t// reached the end\r\n\r\n\t\t\t\tif ( this.clampWhenFinished ) this.pause = true;\r\n\t\t\t\telse this.enabled = false;\r\n\r\n\t\t\t\tthis._mixer.dispatchEvent( {\r\n\t\t\t\t\ttype: 'finished', action: this,\r\n\t\t\t\t\tdirection: deltaTime < 0 ? -1 : 1\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase THREE.LoopPingPong:\r\n\r\n\t\t\t\tpingPong = true;\r\n\r\n\t\t\tcase THREE.LoopRepeat:\r\n\r\n\t\t\t\tif ( loopCount === -1 ) {\r\n\r\n\t\t\t\t\t// just started\r\n\r\n\t\t\t\t\tif ( deltaTime > 0 ) {\r\n\r\n\t\t\t\t\t\tloopCount = 0;\r\n\r\n\t\t\t\t\t\tthis._setEndings(\r\n\t\t\t\t\t\t\t\ttrue, this.repetitions === 0, pingPong );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// when looping in reverse direction, the initial\r\n\t\t\t\t\t\t// transition through zero counts as a repetition,\r\n\t\t\t\t\t\t// so leave loopCount at -1\r\n\r\n\t\t\t\t\t\tthis._setEndings(\r\n\t\t\t\t\t\t\t\tthis.repetitions === 0, true, pingPong );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( time >= duration || time < 0 ) {\r\n\r\n\t\t\t\t\t// wrap around\r\n\r\n\t\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\r\n\t\t\t\t\ttime -= duration * loopDelta;\r\n\r\n\t\t\t\t\tloopCount += Math.abs( loopDelta );\r\n\r\n\t\t\t\t\tvar pending = this.repetitions - loopCount;\r\n\r\n\t\t\t\t\tif ( pending < 0 ) {\r\n\r\n\t\t\t\t\t\t// stop (switch state, clamp time, fire event)\r\n\r\n\t\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\r\n\t\t\t\t\t\telse this.enabled = false;\r\n\r\n\t\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\r\n\r\n\t\t\t\t\t\tthis._mixer.dispatchEvent( {\r\n\t\t\t\t\t\t\ttype: 'finished', action: this,\r\n\t\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : -1\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t} else if ( pending === 0 ) {\r\n\r\n\t\t\t\t\t\t// transition to last round\r\n\r\n\t\t\t\t\t\tvar atStart = deltaTime < 0;\r\n\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis._loopCount = loopCount;\r\n\r\n\t\t\t\t\tthis._mixer.dispatchEvent( {\r\n\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( loop === THREE.LoopPingPong && ( loopCount & 1 ) === 1 ) {\r\n\r\n\t\t\t\t\t// invert time for the \"pong round\"\r\n\r\n\t\t\t\t\tthis.time = time;\r\n\r\n\t\t\t\t\treturn duration - time;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\tthis.time = time;\r\n\r\n\t\treturn time;\r\n\r\n\t},\r\n\r\n\t_setEndings: function( atStart, atEnd, pingPong ) {\r\n\r\n\t\tvar settings = this._interpolantSettings;\r\n\r\n\t\tif ( pingPong ) {\r\n\r\n\t\t\tsettings.endingStart \t= THREE.ZeroSlopeEnding;\r\n\t\t\tsettings.endingEnd\t\t= THREE.ZeroSlopeEnding;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// assuming for LoopOnce atStart == atEnd == true\r\n\r\n\t\t\tif ( atStart ) {\r\n\r\n\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ?\r\n\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tsettings.endingStart = THREE.WrapAroundEnding;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( atEnd ) {\r\n\r\n\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ?\r\n\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tsettings.endingEnd \t = THREE.WrapAroundEnding;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_scheduleFading: function( duration, weightNow, weightThen ) {\r\n\r\n\t\tvar mixer = this._mixer, now = mixer.time,\r\n\t\t\tinterpolant = this._weightInterpolant;\r\n\r\n\t\tif ( interpolant === null ) {\r\n\r\n\t\t\tinterpolant = mixer._lendControlInterpolant(),\r\n\t\t\tthis._weightInterpolant = interpolant;\r\n\r\n\t\t}\r\n\r\n\t\tvar times = interpolant.parameterPositions,\r\n\t\t\tvalues = interpolant.sampleValues;\r\n\r\n\t\ttimes[ 0 ] = now; \t\t\t\tvalues[ 0 ] = weightNow;\r\n\t\ttimes[ 1 ] = now + duration;\tvalues[ 1 ] = weightThen;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// Implementation details:\r\n\r\nObject.assign( THREE.AnimationMixer.prototype, {\r\n\r\n\t_bindAction: function( action, prototypeAction ) {\r\n\r\n\t\tvar root = action._localRoot || this._root,\r\n\t\t\ttracks = action._clip.tracks,\r\n\t\t\tnTracks = tracks.length,\r\n\t\t\tbindings = action._propertyBindings,\r\n\t\t\tinterpolants = action._interpolants,\r\n\t\t\trootUuid = root.uuid,\r\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\r\n\r\n\t\tif ( bindingsByName === undefined ) {\r\n\r\n\t\t\tbindingsByName = {};\r\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\r\n\r\n\t\t\tvar track = tracks[ i ],\r\n\t\t\t\ttrackName = track.name,\r\n\t\t\t\tbinding = bindingsByName[ trackName ];\r\n\r\n\t\t\tif ( binding !== undefined ) {\r\n\r\n\t\t\t\tbindings[ i ] = binding;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbinding = bindings[ i ];\r\n\r\n\t\t\t\tif ( binding !== undefined ) {\r\n\r\n\t\t\t\t\t// existing binding, make sure the cache knows\r\n\r\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\r\n\r\n\t\t\t\t\t\t++ binding.referenceCount;\r\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar path = prototypeAction && prototypeAction.\r\n\t\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\r\n\r\n\t\t\t\tbinding = new THREE.PropertyMixer(\r\n\t\t\t\t\t\tTHREE.PropertyBinding.create( root, trackName, path ),\r\n\t\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\r\n\r\n\t\t\t\t++ binding.referenceCount;\r\n\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\r\n\r\n\t\t\t\tbindings[ i ] = binding;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_activateAction: function( action ) {\r\n\r\n\t\tif ( ! this._isActiveAction( action ) ) {\r\n\r\n\t\t\tif ( action._cacheIndex === null ) {\r\n\r\n\t\t\t\t// this action has been forgotten by the cache, but the user\r\n\t\t\t\t// appears to be still using it -> rebind\r\n\r\n\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\r\n\t\t\t\t\tclipName = action._clip.name,\r\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipName ];\r\n\r\n\t\t\t\tthis._bindAction( action,\r\n\t\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\r\n\r\n\t\t\t\tthis._addInactiveAction( action, clipName, rootUuid );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar bindings = action._propertyBindings;\r\n\r\n\t\t\t// increment reference counts / sort out state\r\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\tvar binding = bindings[ i ];\r\n\r\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\r\n\r\n\t\t\t\t\tthis._lendBinding( binding );\r\n\t\t\t\t\tbinding.saveOriginalState();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis._lendAction( action );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_deactivateAction: function( action ) {\r\n\r\n\t\tif ( this._isActiveAction( action ) ) {\r\n\r\n\t\t\tvar bindings = action._propertyBindings;\r\n\r\n\t\t\t// decrement reference counts / sort out state\r\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\tvar binding = bindings[ i ];\r\n\r\n\t\t\t\tif ( -- binding.useCount === 0 ) {\r\n\r\n\t\t\t\t\tbinding.restoreOriginalState();\r\n\t\t\t\t\tthis._takeBackBinding( binding );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis._takeBackAction( action );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// Memory manager\r\n\r\n\t_initMemoryManager: function() {\r\n\r\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\r\n\t\tthis._nActiveActions = 0;\r\n\r\n\t\tthis._actionsByClip = {};\r\n\t\t// inside:\r\n\t\t// {\r\n\t\t// \t\tknownActions: Array< _Action >\t- used as prototypes\r\n\t\t// \t\tactionByRoot: _Action\t\t\t- lookup\r\n\t\t// }\r\n\r\n\r\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\r\n\t\tthis._nActiveBindings = 0;\r\n\r\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\r\n\r\n\r\n\t\tthis._controlInterpolants = []; // same game as above\r\n\t\tthis._nActiveControlInterpolants = 0;\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tthis.stats = {\r\n\r\n\t\t\tactions: {\r\n\t\t\t\tget total() { return scope._actions.length; },\r\n\t\t\t\tget inUse() { return scope._nActiveActions; }\r\n\t\t\t},\r\n\t\t\tbindings: {\r\n\t\t\t\tget total() { return scope._bindings.length; },\r\n\t\t\t\tget inUse() { return scope._nActiveBindings; }\r\n\t\t\t},\r\n\t\t\tcontrolInterpolants: {\r\n\t\t\t\tget total() { return scope._controlInterpolants.length; },\r\n\t\t\t\tget inUse() { return scope._nActiveControlInterpolants; }\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t},\r\n\r\n\t// Memory management for _Action objects\r\n\r\n\t_isActiveAction: function( action ) {\r\n\r\n\t\tvar index = action._cacheIndex;\r\n\t\treturn index !== null && index < this._nActiveActions;\r\n\r\n\t},\r\n\r\n\t_addInactiveAction: function( action, clipName, rootUuid ) {\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tactionsByClip = this._actionsByClip,\r\n\t\t\tactionsForClip = actionsByClip[ clipName ];\r\n\r\n\t\tif ( actionsForClip === undefined ) {\r\n\r\n\t\t\tactionsForClip = {\r\n\r\n\t\t\t\tknownActions: [ action ],\r\n\t\t\t\tactionByRoot: {}\r\n\r\n\t\t\t};\r\n\r\n\t\t\taction._byClipCacheIndex = 0;\r\n\r\n\t\t\tactionsByClip[ clipName ] = actionsForClip;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar knownActions = actionsForClip.knownActions;\r\n\r\n\t\t\taction._byClipCacheIndex = knownActions.length;\r\n\t\t\tknownActions.push( action );\r\n\r\n\t\t}\r\n\r\n\t\taction._cacheIndex = actions.length;\r\n\t\tactions.push( action );\r\n\r\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\r\n\r\n\t},\r\n\r\n\t_removeInactiveAction: function( action ) {\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\r\n\t\t\tcacheIndex = action._cacheIndex;\r\n\r\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\r\n\t\tactions[ cacheIndex ] = lastInactiveAction;\r\n\t\tactions.pop();\r\n\r\n\t\taction._cacheIndex = null;\r\n\r\n\r\n\t\tvar clipName = action._clip.name,\r\n\t\t\tactionsByClip = this._actionsByClip,\r\n\t\t\tactionsForClip = actionsByClip[ clipName ],\r\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\r\n\r\n\t\t\tlastKnownAction =\r\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\r\n\r\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\r\n\r\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\r\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\r\n\t\tknownActionsForClip.pop();\r\n\r\n\t\taction._byClipCacheIndex = null;\r\n\r\n\r\n\t\tvar actionByRoot = actionsForClip.actionByRoot,\r\n\t\t\trootUuid = ( actions._localRoot || this._root ).uuid;\r\n\r\n\t\tdelete actionByRoot[ rootUuid ];\r\n\r\n\t\tif ( knownActionsForClip.length === 0 ) {\r\n\r\n\t\t\tdelete actionsByClip[ clipName ];\r\n\r\n\t\t}\r\n\r\n\t\tthis._removeInactiveBindingsForAction( action );\r\n\r\n\t},\r\n\r\n\t_removeInactiveBindingsForAction: function( action ) {\r\n\r\n\t\tvar bindings = action._propertyBindings;\r\n\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar binding = bindings[ i ];\r\n\r\n\t\t\tif ( -- binding.referenceCount === 0 ) {\r\n\r\n\t\t\t\tthis._removeInactiveBinding( binding );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_lendAction: function( action ) {\r\n\r\n\t\t// [ active actions |  inactive actions  ]\r\n\t\t// [  active actions >| inactive actions ]\r\n\t\t//                 s        a\r\n\t\t//                  <-swap->\r\n\t\t//                 a        s\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tprevIndex = action._cacheIndex,\r\n\r\n\t\t\tlastActiveIndex = this._nActiveActions ++,\r\n\r\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\r\n\r\n\t\taction._cacheIndex = lastActiveIndex;\r\n\t\tactions[ lastActiveIndex ] = action;\r\n\r\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\r\n\t\tactions[ prevIndex ] = firstInactiveAction;\r\n\r\n\t},\r\n\r\n\t_takeBackAction: function( action ) {\r\n\r\n\t\t// [  active actions  | inactive actions ]\r\n\t\t// [ active actions |< inactive actions  ]\r\n\t\t//        a        s\r\n\t\t//         <-swap->\r\n\t\t//        s        a\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tprevIndex = action._cacheIndex,\r\n\r\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\r\n\r\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\r\n\r\n\t\taction._cacheIndex = firstInactiveIndex;\r\n\t\tactions[ firstInactiveIndex ] = action;\r\n\r\n\t\tlastActiveAction._cacheIndex = prevIndex;\r\n\t\tactions[ prevIndex ] = lastActiveAction;\r\n\r\n\t},\r\n\r\n\t// Memory management for PropertyMixer objects\r\n\r\n\t_addInactiveBinding: function( binding, rootUuid, trackName ) {\r\n\r\n\t\tvar bindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\r\n\r\n\t\t\tbindings = this._bindings;\r\n\r\n\t\tif ( bindingByName === undefined ) {\r\n\r\n\t\t\tbindingByName = {};\r\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\r\n\r\n\t\t}\r\n\r\n\t\tbindingByName[ trackName ] = binding;\r\n\r\n\t\tbinding._cacheIndex = bindings.length;\r\n\t\tbindings.push( binding );\r\n\r\n\t},\r\n\r\n\t_removeInactiveBinding: function( binding ) {\r\n\r\n\t\tvar bindings = this._bindings,\r\n\t\t\tpropBinding = binding.binding,\r\n\t\t\trootUuid = propBinding.rootNode.uuid,\r\n\t\t\ttrackName = propBinding.path,\r\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\r\n\r\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\r\n\t\t\tcacheIndex = binding._cacheIndex;\r\n\r\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\r\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\r\n\t\tbindings.pop();\r\n\r\n\t\tdelete bindingByName[ trackName ];\r\n\r\n\t\tremove_empty_map: {\r\n\r\n\t\t\tfor ( var _ in bindingByName ) break remove_empty_map;\r\n\r\n\t\t\tdelete bindingsByRoot[ rootUuid ];\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_lendBinding: function( binding ) {\r\n\r\n\t\tvar bindings = this._bindings,\r\n\t\t\tprevIndex = binding._cacheIndex,\r\n\r\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\r\n\r\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\r\n\r\n\t\tbinding._cacheIndex = lastActiveIndex;\r\n\t\tbindings[ lastActiveIndex ] = binding;\r\n\r\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\r\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\r\n\r\n\t},\r\n\r\n\t_takeBackBinding: function( binding ) {\r\n\r\n\t\tvar bindings = this._bindings,\r\n\t\t\tprevIndex = binding._cacheIndex,\r\n\r\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\r\n\r\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\r\n\r\n\t\tbinding._cacheIndex = firstInactiveIndex;\r\n\t\tbindings[ firstInactiveIndex ] = binding;\r\n\r\n\t\tlastActiveBinding._cacheIndex = prevIndex;\r\n\t\tbindings[ prevIndex ] = lastActiveBinding;\r\n\r\n\t},\r\n\r\n\r\n\t// Memory management of Interpolants for weight and time scale\r\n\r\n\t_lendControlInterpolant: function() {\r\n\r\n\t\tvar interpolants = this._controlInterpolants,\r\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\r\n\t\t\tinterpolant = interpolants[ lastActiveIndex ];\r\n\r\n\t\tif ( interpolant === undefined ) {\r\n\r\n\t\t\tinterpolant = new THREE.LinearInterpolant(\r\n\t\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\r\n\t\t\t\t\t\t1, this._controlInterpolantsResultBuffer );\r\n\r\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\r\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\r\n\r\n\t\t}\r\n\r\n\t\treturn interpolant;\r\n\r\n\t},\r\n\r\n\t_takeBackControlInterpolant: function( interpolant ) {\r\n\r\n\t\tvar interpolants = this._controlInterpolants,\r\n\t\t\tprevIndex = interpolant.__cacheIndex,\r\n\r\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\r\n\r\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\r\n\r\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\r\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\r\n\r\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\r\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\r\n\r\n\t},\r\n\r\n\t_controlInterpolantsResultBuffer: new Float32Array( 1 )\r\n\r\n} );\r\n\r\n\r\n// File:src/animation/AnimationObjectGroup.js\r\n\r\n/**\r\n *\r\n * A group of objects that receives a shared animation state.\r\n *\r\n * Usage:\r\n *\r\n * \t-\tAdd objects you would otherwise pass as 'root' to the\r\n * \t\tconstructor or the .clipAction method of AnimationMixer.\r\n *\r\n * \t-\tInstead pass this object as 'root'.\r\n *\r\n * \t-\tYou can also add and remove objects later when the mixer\r\n * \t\tis running.\r\n *\r\n * Note:\r\n *\r\n *  \tObjects of this class appear as one object to the mixer,\r\n *  \tso cache control of the individual objects must be done\r\n *  \ton the group.\r\n *\r\n * Limitation:\r\n *\r\n * \t- \tThe animated properties must be compatible among the\r\n * \t\tall objects in the group.\r\n *\r\n *  -\tA single property can either be controlled through a\r\n *  \ttarget group or directly, but not both.\r\n *\r\n * @author tschw\r\n */\r\n\r\nTHREE.AnimationObjectGroup = function( var_args ) {\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\t// cached objects followed by the active ones\r\n\tthis._objects = Array.prototype.slice.call( arguments );\r\n\r\n\tthis.nCachedObjects_ = 0;\t\t\t// threshold\r\n\t// note: read by PropertyBinding.Composite\r\n\r\n\tvar indices = {};\r\n\tthis._indicesByUUID = indices;\t\t// for bookkeeping\r\n\r\n\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\r\n\t\tindices[ arguments[ i ].uuid ] = i;\r\n\r\n\t}\r\n\r\n\tthis._paths = [];\t\t\t\t\t// inside: string\r\n\tthis._parsedPaths = [];\t\t\t\t// inside: { we don't care, here }\r\n\tthis._bindings = []; \t\t\t\t// inside: Array< PropertyBinding >\r\n\tthis._bindingsIndicesByPath = {}; \t// inside: indices in these arrays\r\n\r\n\tvar scope = this;\r\n\r\n\tthis.stats = {\r\n\r\n\t\tobjects: {\r\n\t\t\tget total() { return scope._objects.length; },\r\n\t\t\tget inUse() { return this.total - scope.nCachedObjects_;  }\r\n\t\t},\r\n\r\n\t\tget bindingsPerObject() { return scope._bindings.length; }\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.AnimationObjectGroup.prototype = {\r\n\r\n\tconstructor: THREE.AnimationObjectGroup,\r\n\r\n\tadd: function( var_args ) {\r\n\r\n\t\tvar objects = this._objects,\r\n\t\t\tnObjects = objects.length,\r\n\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\tindicesByUUID = this._indicesByUUID,\r\n\t\t\tpaths = this._paths,\r\n\t\t\tparsedPaths = this._parsedPaths,\r\n\t\t\tbindings = this._bindings,\r\n\t\t\tnBindings = bindings.length;\r\n\r\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar object = arguments[ i ],\r\n\t\t\t\tuuid = object.uuid,\r\n\t\t\t\tindex = indicesByUUID[ uuid ];\r\n\r\n\t\t\tif ( index === undefined ) {\r\n\r\n\t\t\t\t// unknown object -> add it to the ACTIVE region\r\n\r\n\t\t\t\tindex = nObjects ++;\r\n\t\t\t\tindicesByUUID[ uuid ] = index;\r\n\t\t\t\tobjects.push( object );\r\n\r\n\t\t\t\t// accounting is done, now do the same for all bindings\r\n\r\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n\t\t\t\t\tbindings[ j ].push(\r\n\t\t\t\t\t\t\tnew THREE.PropertyBinding(\r\n\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( index < nCachedObjects ) {\r\n\r\n\t\t\t\tvar knownObject = objects[ index ];\r\n\r\n\t\t\t\t// move existing object to the ACTIVE region\r\n\r\n\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\r\n\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\r\n\r\n\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\r\n\t\t\t\tobjects[ index ] = lastCachedObject;\r\n\r\n\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\r\n\t\t\t\tobjects[ firstActiveIndex ] = object;\r\n\r\n\t\t\t\t// accounting is done, now do the same for all bindings\r\n\r\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n\t\t\t\t\tvar bindingsForPath = bindings[ j ],\r\n\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\r\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\r\n\r\n\t\t\t\t\tbindingsForPath[ index ] = lastCached;\r\n\r\n\t\t\t\t\tif ( binding === undefined ) {\r\n\r\n\t\t\t\t\t\t// since we do not bother to create new bindings\r\n\t\t\t\t\t\t// for objects that are cached, the binding may\r\n\t\t\t\t\t\t// or may not exist\r\n\r\n\t\t\t\t\t\tbinding = new THREE.PropertyBinding(\r\n\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( objects[ index ] !== knownObject) {\r\n\r\n\t\t\t\tconsole.error( \"Different objects with the same UUID \" +\r\n\t\t\t\t\t\t\"detected. Clean the caches or recreate your \" +\r\n\t\t\t\t\t\t\"infrastructure when reloading scenes...\" );\r\n\r\n\t\t\t} // else the object is already where we want it to be\r\n\r\n\t\t} // for arguments\r\n\r\n\t\tthis.nCachedObjects_ = nCachedObjects;\r\n\r\n\t},\r\n\r\n\tremove: function( var_args ) {\r\n\r\n\t\tvar objects = this._objects,\r\n\t\t\tnObjects = objects.length,\r\n\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\tindicesByUUID = this._indicesByUUID,\r\n\t\t\tbindings = this._bindings,\r\n\t\t\tnBindings = bindings.length;\r\n\r\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar object = arguments[ i ],\r\n\t\t\t\tuuid = object.uuid,\r\n\t\t\t\tindex = indicesByUUID[ uuid ];\r\n\r\n\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\r\n\r\n\t\t\t\t// move existing object into the CACHED region\r\n\r\n\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\r\n\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\r\n\r\n\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\r\n\t\t\t\tobjects[ index ] = firstActiveObject;\r\n\r\n\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\r\n\t\t\t\tobjects[ lastCachedIndex ] = object;\r\n\r\n\t\t\t\t// accounting is done, now do the same for all bindings\r\n\r\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n\t\t\t\t\tvar bindingsForPath = bindings[ j ],\r\n\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\r\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\r\n\r\n\t\t\t\t\tbindingsForPath[ index ] = firstActive;\r\n\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} // for arguments\r\n\r\n\t\tthis.nCachedObjects_ = nCachedObjects;\r\n\r\n\t},\r\n\r\n\t// remove & forget\r\n\tuncache: function( var_args ) {\r\n\r\n\t\tvar objects = this._objects,\r\n\t\t\tnObjects = objects.length,\r\n\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\tindicesByUUID = this._indicesByUUID,\r\n\t\t\tbindings = this._bindings,\r\n\t\t\tnBindings = bindings.length;\r\n\r\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar object = arguments[ i ],\r\n\t\t\t\tuuid = object.uuid,\r\n\t\t\t\tindex = indicesByUUID[ uuid ];\r\n\r\n\t\t\tif ( index !== undefined ) {\r\n\r\n\t\t\t\tdelete indicesByUUID[ uuid ];\r\n\r\n\t\t\t\tif ( index < nCachedObjects ) {\r\n\r\n\t\t\t\t\t// object is cached, shrink the CACHED region\r\n\r\n\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\r\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\r\n\t\t\t\t\t\tlastIndex = -- nObjects,\r\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\r\n\r\n\t\t\t\t\t// last cached object takes this object's place\r\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\r\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\r\n\r\n\t\t\t\t\t// last object goes to the activated slot and pop\r\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\r\n\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\r\n\t\t\t\t\tobjects.pop();\r\n\r\n\t\t\t\t\t// accounting is done, now do the same for all bindings\r\n\r\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\r\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\r\n\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\r\n\r\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\r\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\r\n\t\t\t\t\t\tbindingsForPath.pop();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// object is active, just swap with the last and pop\r\n\r\n\t\t\t\t\tvar lastIndex = -- nObjects,\r\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\r\n\r\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\r\n\t\t\t\t\tobjects[ index ] = lastObject;\r\n\t\t\t\t\tobjects.pop();\r\n\r\n\t\t\t\t\t// accounting is done, now do the same for all bindings\r\n\r\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\r\n\r\n\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\r\n\t\t\t\t\t\tbindingsForPath.pop();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} // cached or active\r\n\r\n\t\t\t} // if object is known\r\n\r\n\t\t} // for arguments\r\n\r\n\t\tthis.nCachedObjects_ = nCachedObjects;\r\n\r\n\t},\r\n\r\n\t// Internal interface used by befriended PropertyBinding.Composite:\r\n\r\n\tsubscribe_: function( path, parsedPath ) {\r\n\t\t// returns an array of bindings for the given path that is changed\r\n\t\t// according to the contained objects in the group\r\n\r\n\t\tvar indicesByPath = this._bindingsIndicesByPath,\r\n\t\t\tindex = indicesByPath[ path ],\r\n\t\t\tbindings = this._bindings;\r\n\r\n\t\tif ( index !== undefined ) return bindings[ index ];\r\n\r\n\t\tvar paths = this._paths,\r\n\t\t\tparsedPaths = this._parsedPaths,\r\n\t\t\tobjects = this._objects,\r\n\t\t\tnObjects = objects.length,\r\n\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\tbindingsForPath = new Array( nObjects );\r\n\r\n\t\tindex = bindings.length;\r\n\r\n\t\tindicesByPath[ path ] = index;\r\n\r\n\t\tpaths.push( path );\r\n\t\tparsedPaths.push( parsedPath );\r\n\t\tbindings.push( bindingsForPath );\r\n\r\n\t\tfor ( var i = nCachedObjects,\r\n\t\t\t\tn = objects.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar object = objects[ i ];\r\n\r\n\t\t\tbindingsForPath[ i ] =\r\n\t\t\t\t\tnew THREE.PropertyBinding( object, path, parsedPath );\r\n\r\n\t\t}\r\n\r\n\t\treturn bindingsForPath;\r\n\r\n\t},\r\n\r\n\tunsubscribe_: function( path ) {\r\n\t\t// tells the group to forget about a property path and no longer\r\n\t\t// update the array previously obtained with 'subscribe_'\r\n\r\n\t\tvar indicesByPath = this._bindingsIndicesByPath,\r\n\t\t\tindex = indicesByPath[ path ];\r\n\r\n\t\tif ( index !== undefined ) {\r\n\r\n\t\t\tvar paths = this._paths,\r\n\t\t\t\tparsedPaths = this._parsedPaths,\r\n\t\t\t\tbindings = this._bindings,\r\n\t\t\t\tlastBindingsIndex = bindings.length - 1,\r\n\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\r\n\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\r\n\r\n\t\t\tindicesByPath[ lastBindingsPath ] = index;\r\n\r\n\t\t\tbindings[ index ] = lastBindings;\r\n\t\t\tbindings.pop();\r\n\r\n\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\r\n\t\t\tparsedPaths.pop();\r\n\r\n\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\r\n\t\t\tpaths.pop();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n// File:src/animation/AnimationUtils.js\r\n\r\n/**\r\n * @author tschw\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n */\r\n\r\nTHREE.AnimationUtils = {\r\n\r\n\t// same as Array.prototype.slice, but also works on typed arrays\r\n\tarraySlice: function( array, from, to ) {\r\n\r\n\t\tif ( THREE.AnimationUtils.isTypedArray( array ) ) {\r\n\r\n\t\t\treturn new array.constructor( array.subarray( from, to ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn array.slice( from, to );\r\n\r\n\t},\r\n\r\n\t// converts an array to a specific type\r\n\tconvertArray: function( array, type, forceClone ) {\r\n\r\n\t\tif ( ! array || // let 'undefined' and 'null' pass\r\n\t\t\t\t! forceClone && array.constructor === type ) return array;\r\n\r\n\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\r\n\r\n\t\t\treturn new type( array ); // create typed array\r\n\r\n\t\t}\r\n\r\n\t\treturn Array.prototype.slice.call( array ); // create Array\r\n\r\n\t},\r\n\r\n\tisTypedArray: function( object ) {\r\n\r\n\t\treturn ArrayBuffer.isView( object ) &&\r\n\t\t\t\t! ( object instanceof DataView );\r\n\r\n\t},\r\n\r\n\t// returns an array by which times and values can be sorted\r\n\tgetKeyframeOrder: function( times ) {\r\n\r\n\t\tfunction compareTime( i, j ) {\r\n\r\n\t\t\treturn times[ i ] - times[ j ];\r\n\r\n\t\t}\r\n\r\n\t\tvar n = times.length;\r\n\t\tvar result = new Array( n );\r\n\t\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\r\n\r\n\t\tresult.sort( compareTime );\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\t// uses the array previously returned by 'getKeyframeOrder' to sort data\r\n\tsortedArray: function( values, stride, order ) {\r\n\r\n\t\tvar nValues = values.length;\r\n\t\tvar result = new values.constructor( nValues );\r\n\r\n\t\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\r\n\r\n\t\t\tvar srcOffset = order[ i ] * stride;\r\n\r\n\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\r\n\r\n\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\t// function for parsing AOS keyframe formats\r\n\tflattenJSON: function( jsonKeys, times, values, valuePropertyName ) {\r\n\r\n\t\tvar i = 1, key = jsonKeys[ 0 ];\r\n\r\n\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\r\n\r\n\t\t\tkey = jsonKeys[ i ++ ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( key === undefined ) return; // no data\r\n\r\n\t\tvar value = key[ valuePropertyName ];\r\n\t\tif ( value === undefined ) return; // no data\r\n\r\n\t\tif ( Array.isArray( value ) ) {\r\n\r\n\t\t\tdo {\r\n\r\n\t\t\t\tvalue = key[ valuePropertyName ];\r\n\r\n\t\t\t\tif ( value !== undefined ) {\r\n\r\n\t\t\t\t\ttimes.push( key.time );\r\n\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tkey = jsonKeys[ i ++ ];\r\n\r\n\t\t\t} while ( key !== undefined );\r\n\r\n\t\t} else if ( value.toArray !== undefined ) {\r\n\t\t\t// ...assume THREE.Math-ish\r\n\r\n\t\t\tdo {\r\n\r\n\t\t\t\tvalue = key[ valuePropertyName ];\r\n\r\n\t\t\t\tif ( value !== undefined ) {\r\n\r\n\t\t\t\t\ttimes.push( key.time );\r\n\t\t\t\t\tvalue.toArray( values, values.length );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tkey = jsonKeys[ i ++ ];\r\n\r\n\t\t\t} while ( key !== undefined );\r\n\r\n\t\t} else {\r\n\t\t\t// otherwise push as-is\r\n\r\n\t\t\tdo {\r\n\r\n\t\t\t\tvalue = key[ valuePropertyName ];\r\n\r\n\t\t\t\tif ( value !== undefined ) {\r\n\r\n\t\t\t\t\ttimes.push( key.time );\r\n\t\t\t\t\tvalues.push( value );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tkey = jsonKeys[ i ++ ];\r\n\r\n\t\t\t} while ( key !== undefined );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/animation/KeyframeTrack.js\r\n\r\n/**\r\n *\r\n * A timed sequence of keyframes for a specific property.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.KeyframeTrack = function ( name, times, values, interpolation ) {\r\n\r\n\tif( name === undefined ) throw new Error( \"track name is undefined\" );\r\n\r\n\tif( times === undefined || times.length === 0 ) {\r\n\r\n\t\tthrow new Error( \"no keyframes in track named \" + name );\r\n\r\n\t}\r\n\r\n\tthis.name = name;\r\n\r\n\tthis.times = THREE.AnimationUtils.convertArray( times, this.TimeBufferType );\r\n\tthis.values = THREE.AnimationUtils.convertArray( values, this.ValueBufferType );\r\n\r\n\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\r\n\r\n\tthis.validate();\r\n\tthis.optimize();\r\n\r\n};\r\n\r\nTHREE.KeyframeTrack.prototype = {\r\n\r\n\tconstructor: THREE.KeyframeTrack,\r\n\r\n\tTimeBufferType: Float32Array,\r\n\tValueBufferType: Float32Array,\r\n\r\n\tDefaultInterpolation: THREE.InterpolateLinear,\r\n\r\n\tInterpolantFactoryMethodDiscrete: function( result ) {\r\n\r\n\t\treturn new THREE.DiscreteInterpolant(\r\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\r\n\r\n\t},\r\n\r\n\tInterpolantFactoryMethodLinear: function( result ) {\r\n\r\n\t\treturn new THREE.LinearInterpolant(\r\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\r\n\r\n\t},\r\n\r\n\tInterpolantFactoryMethodSmooth: function( result ) {\r\n\r\n\t\treturn new THREE.CubicInterpolant(\r\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\r\n\r\n\t},\r\n\r\n\tsetInterpolation: function( interpolation ) {\r\n\r\n\t\tvar factoryMethod = undefined;\r\n\r\n\t\tswitch ( interpolation ) {\r\n\r\n\t\t\tcase THREE.InterpolateDiscrete:\r\n\r\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase THREE.InterpolateLinear:\r\n\r\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase THREE.InterpolateSmooth:\r\n\r\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\tif ( factoryMethod === undefined ) {\r\n\r\n\t\t\tvar message = \"unsupported interpolation for \" +\r\n\t\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\r\n\r\n\t\t\tif ( this.createInterpolant === undefined ) {\r\n\r\n\t\t\t\t// fall back to default, unless the default itself is messed up\r\n\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\r\n\r\n\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthrow new Error( message ); // fatal, in this case\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconsole.warn( message );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tthis.createInterpolant = factoryMethod;\r\n\r\n\t},\r\n\r\n\tgetInterpolation: function() {\r\n\r\n\t\tswitch ( this.createInterpolant ) {\r\n\r\n\t\t\tcase this.InterpolantFactoryMethodDiscrete:\r\n\r\n\t\t\t\treturn THREE.InterpolateDiscrete;\r\n\r\n\t\t\tcase this.InterpolantFactoryMethodLinear:\r\n\r\n\t\t\t\treturn THREE.InterpolateLinear;\r\n\r\n\t\t\tcase this.InterpolantFactoryMethodSmooth:\r\n\r\n\t\t\t\treturn THREE.InterpolateSmooth;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetValueSize: function() {\r\n\r\n\t\treturn this.values.length / this.times.length;\r\n\r\n\t},\r\n\r\n\t// move all keyframes either forwards or backwards in time\r\n\tshift: function( timeOffset ) {\r\n\r\n\t\tif( timeOffset !== 0.0 ) {\r\n\r\n\t\t\tvar times = this.times;\r\n\r\n\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\ttimes[ i ] += timeOffset;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\r\n\tscale: function( timeScale ) {\r\n\r\n\t\tif( timeScale !== 1.0 ) {\r\n\r\n\t\t\tvar times = this.times;\r\n\r\n\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\ttimes[ i ] *= timeScale;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\r\n\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\r\n\ttrim: function( startTime, endTime ) {\r\n\r\n\t\tvar times = this.times,\r\n\t\t\tnKeys = times.length,\r\n\t\t\tfrom = 0,\r\n\t\t\tto = nKeys - 1;\r\n\r\n\t\twhile ( from !== nKeys && times[ from ] < startTime ) ++ from;\r\n\t\twhile ( to !== -1 && times[ to ] > endTime ) -- to;\r\n\r\n\t\t++ to; // inclusive -> exclusive bound\r\n\r\n\t\tif( from !== 0 || to !== nKeys ) {\r\n\r\n\t\t\t// empty tracks are forbidden, so keep at least one keyframe\r\n\t\t\tif ( from >= to ) to = Math.max( to , 1 ), from = to - 1;\r\n\r\n\t\t\tvar stride = this.getValueSize();\r\n\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, from, to );\r\n\t\t\tthis.values = THREE.AnimationUtils.\r\n\t\t\t\t\tarraySlice( this.values, from * stride, to * stride );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\r\n\tvalidate: function() {\r\n\r\n\t\tvar valid = true;\r\n\r\n\t\tvar valueSize = this.getValueSize();\r\n\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\r\n\r\n\t\t\tconsole.error( \"invalid value size in track\", this );\r\n\t\t\tvalid = false;\r\n\r\n\t\t}\r\n\r\n\t\tvar times = this.times,\r\n\t\t\tvalues = this.values,\r\n\r\n\t\t\tnKeys = times.length;\r\n\r\n\t\tif( nKeys === 0 ) {\r\n\r\n\t\t\tconsole.error( \"track is empty\", this );\r\n\t\t\tvalid = false;\r\n\r\n\t\t}\r\n\r\n\t\tvar prevTime = null;\r\n\r\n\t\tfor( var i = 0; i !== nKeys; i ++ ) {\r\n\r\n\t\t\tvar currTime = times[ i ];\r\n\r\n\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\r\n\r\n\t\t\t\tconsole.error( \"time is not a valid number\", this, i, currTime );\r\n\t\t\t\tvalid = false;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif( prevTime !== null && prevTime > currTime ) {\r\n\r\n\t\t\t\tconsole.error( \"out of order keys\", this, i, currTime, prevTime );\r\n\t\t\t\tvalid = false;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tprevTime = currTime;\r\n\r\n\t\t}\r\n\r\n\t\tif ( values !== undefined ) {\r\n\r\n\t\t\tif ( THREE.AnimationUtils.isTypedArray( values ) ) {\r\n\r\n\t\t\t\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\t\tvar value = values[ i ];\r\n\r\n\t\t\t\t\tif ( isNaN( value ) ) {\r\n\r\n\t\t\t\t\t\tconsole.error( \"value is not a valid number\", this, i, value );\r\n\t\t\t\t\t\tvalid = false;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn valid;\r\n\r\n\t},\r\n\r\n\t// removes equivalent sequential keys as common in morph target sequences\r\n\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\r\n\toptimize: function() {\r\n\r\n\t\tvar times = this.times,\r\n\t\t\tvalues = this.values,\r\n\t\t\tstride = this.getValueSize(),\r\n\r\n\t\t\twriteIndex = 1;\r\n\r\n\t\tfor( var i = 1, n = times.length - 1; i <= n; ++ i ) {\r\n\r\n\t\t\tvar keep = false;\r\n\r\n\t\t\tvar time = times[ i ];\r\n\t\t\tvar timeNext = times[ i + 1 ];\r\n\r\n\t\t\t// remove adjacent keyframes scheduled at the same time\r\n\r\n\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\r\n\r\n\t\t\t\t// remove unnecessary keyframes same as their neighbors\r\n\t\t\t\tvar offset = i * stride,\r\n\t\t\t\t\toffsetP = offset - stride,\r\n\t\t\t\t\toffsetN = offset + stride;\r\n\r\n\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\r\n\r\n\t\t\t\t\tvar value = values[ offset + j ];\r\n\r\n\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\r\n\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\r\n\r\n\t\t\t\t\t\tkeep = true;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// in-place compaction\r\n\r\n\t\t\tif ( keep ) {\r\n\r\n\t\t\t\tif ( i !== writeIndex ) {\r\n\r\n\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\r\n\r\n\t\t\t\t\tvar readOffset = i * stride,\r\n\t\t\t\t\t\twriteOffset = writeIndex * stride;\r\n\r\n\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\r\n\r\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t++ writeIndex;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( writeIndex !== times.length ) {\r\n\r\n\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, 0, writeIndex );\r\n\t\t\tthis.values = THREE.AnimationUtils.arraySlice( values, 0, writeIndex * stride );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// Static methods:\r\n\r\nObject.assign( THREE.KeyframeTrack, {\r\n\r\n\t// Serialization (in static context, because of constructor invocation\r\n\t// and automatic invocation of .toJSON):\r\n\r\n\tparse: function( json ) {\r\n\r\n\t\tif( json.type === undefined ) {\r\n\r\n\t\t\tthrow new Error( \"track type undefined, can not parse\" );\r\n\r\n\t\t}\r\n\r\n\t\tvar trackType = THREE.KeyframeTrack._getTrackTypeForValueTypeName( json.type );\r\n\r\n\t\tif ( json.times === undefined ) {\r\n\r\n\t\t\tconsole.warn( \"legacy JSON format detected, converting\" );\r\n\r\n\t\t\tvar times = [], values = [];\r\n\r\n\t\t\tTHREE.AnimationUtils.flattenJSON( json.keys, times, values, 'value' );\r\n\r\n\t\t\tjson.times = times;\r\n\t\t\tjson.values = values;\r\n\r\n\t\t}\r\n\r\n\t\t// derived classes can define a static parse method\r\n\t\tif ( trackType.parse !== undefined ) {\r\n\r\n\t\t\treturn trackType.parse( json );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// by default, we asssume a constructor compatible with the base\r\n\t\t\treturn new trackType(\r\n\t\t\t\t\tjson.name, json.times, json.values, json.interpolation );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttoJSON: function( track ) {\r\n\r\n\t\tvar trackType = track.constructor;\r\n\r\n\t\tvar json;\r\n\r\n\t\t// derived classes can define a static toJSON method\r\n\t\tif ( trackType.toJSON !== undefined ) {\r\n\r\n\t\t\tjson = trackType.toJSON( track );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// by default, we assume the data can be serialized as-is\r\n\t\t\tjson = {\r\n\r\n\t\t\t\t'name': track.name,\r\n\t\t\t\t'times': THREE.AnimationUtils.convertArray( track.times, Array ),\r\n\t\t\t\t'values': THREE.AnimationUtils.convertArray( track.values, Array )\r\n\r\n\t\t\t};\r\n\r\n\t\t\tvar interpolation = track.getInterpolation();\r\n\r\n\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\r\n\r\n\t\t\t\tjson.interpolation = interpolation;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tjson.type = track.ValueTypeName; // mandatory\r\n\r\n\t\treturn json;\r\n\r\n\t},\r\n\r\n\t_getTrackTypeForValueTypeName: function( typeName ) {\r\n\r\n\t\tswitch( typeName.toLowerCase() ) {\r\n\r\n\t\t\tcase \"scalar\":\r\n\t\t\tcase \"double\":\r\n\t\t\tcase \"float\":\r\n\t\t\tcase \"number\":\r\n\t\t\tcase \"integer\":\r\n\r\n\t\t\t\treturn THREE.NumberKeyframeTrack;\r\n\r\n\t\t\tcase \"vector\":\r\n\t\t\tcase \"vector2\":\r\n\t\t\tcase \"vector3\":\r\n\t\t\tcase \"vector4\":\r\n\r\n\t\t\t\treturn THREE.VectorKeyframeTrack;\r\n\r\n\t\t\tcase \"color\":\r\n\r\n\t\t\t\treturn THREE.ColorKeyframeTrack;\r\n\r\n\t\t\tcase \"quaternion\":\r\n\r\n\t\t\t\treturn THREE.QuaternionKeyframeTrack;\r\n\r\n\t\t\tcase \"bool\":\r\n\t\t\tcase \"boolean\":\r\n\r\n\t\t\t\treturn THREE.BooleanKeyframeTrack;\r\n\r\n\t\t\tcase \"string\":\r\n\r\n\t\t\t\treturn THREE.StringKeyframeTrack;\r\n\r\n\t\t};\r\n\r\n\t\tthrow new Error( \"Unsupported typeName: \" + typeName );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/animation/PropertyBinding.js\r\n\r\n/**\r\n *\r\n * A reference to a real property in the scene graph.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.PropertyBinding = function ( rootNode, path, parsedPath ) {\r\n\r\n\tthis.path = path;\r\n\tthis.parsedPath = parsedPath ||\r\n\t\t\tTHREE.PropertyBinding.parseTrackName( path );\r\n\r\n\tthis.node = THREE.PropertyBinding.findNode(\r\n\t\t\trootNode, this.parsedPath.nodeName ) || rootNode;\r\n\r\n\tthis.rootNode = rootNode;\r\n\r\n};\r\n\r\nTHREE.PropertyBinding.prototype = {\r\n\r\n\tconstructor: THREE.PropertyBinding,\r\n\r\n\tgetValue: function getValue_unbound( targetArray, offset ) {\r\n\r\n\t\tthis.bind();\r\n\t\tthis.getValue( targetArray, offset );\r\n\r\n\t\t// Note: This class uses a State pattern on a per-method basis:\r\n\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\r\n\t\t// prototype version of these methods with one that represents\r\n\t\t// the bound state. When the property is not found, the methods\r\n\t\t// become no-ops.\r\n\r\n\t},\r\n\r\n\tsetValue: function getValue_unbound( sourceArray, offset ) {\r\n\r\n\t\tthis.bind();\r\n\t\tthis.setValue( sourceArray, offset );\r\n\r\n\t},\r\n\r\n\t// create getter / setter pair for a property in the scene graph\r\n\tbind: function() {\r\n\r\n\t\tvar targetObject = this.node,\r\n\t\t\tparsedPath = this.parsedPath,\r\n\r\n\t\t\tobjectName = parsedPath.objectName,\r\n\t\t\tpropertyName = parsedPath.propertyName,\r\n\t\t\tpropertyIndex = parsedPath.propertyIndex;\r\n\r\n\t\tif ( ! targetObject ) {\r\n\r\n\t\t\ttargetObject = THREE.PropertyBinding.findNode(\r\n\t\t\t\t\tthis.rootNode, parsedPath.nodeName ) || this.rootNode;\r\n\r\n\t\t\tthis.node = targetObject;\r\n\r\n\t\t}\r\n\r\n\t\t// set fail state so we can just 'return' on error\r\n\t\tthis.getValue = this._getValue_unavailable;\r\n\t\tthis.setValue = this._setValue_unavailable;\r\n\r\n \t\t// ensure there is a value node\r\n\t\tif ( ! targetObject ) {\r\n\r\n\t\t\tconsole.error( \"  trying to update node for track: \" + this.path + \" but it wasn't found.\" );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif( objectName ) {\r\n\r\n\t\t\tvar objectIndex = parsedPath.objectIndex;\r\n\r\n\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\r\n\t\t\tswitch ( objectName ) {\r\n\r\n\t\t\t\tcase 'materials':\r\n\r\n\t\t\t\t\tif( ! targetObject.material ) {\r\n\r\n\t\t\t\t\t\tconsole.error( '  can not bind to material as node does not have a material', this );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif( ! targetObject.material.materials ) {\r\n\r\n\t\t\t\t\t\tconsole.error( '  can not bind to material.materials as node.material does not have a materials array', this );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttargetObject = targetObject.material.materials;\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'bones':\r\n\r\n\t\t\t\t\tif( ! targetObject.skeleton ) {\r\n\r\n\t\t\t\t\t\tconsole.error( '  can not bind to bones as node does not have a skeleton', this );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\r\n\t\t\t\t\t// and convert the integer string to a true integer.\r\n\r\n\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\r\n\r\n\t\t\t\t\t// support resolving morphTarget names into indices.\r\n\t\t\t\t\tfor ( var i = 0; i < targetObject.length; i ++ ) {\r\n\r\n\t\t\t\t\t\tif ( targetObject[i].name === objectIndex ) {\r\n\r\n\t\t\t\t\t\t\tobjectIndex = i;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\r\n\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\r\n\r\n\t\t\t\t\t\tconsole.error( '  can not bind to objectName of node, undefined', this );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttargetObject = targetObject[ objectName ];\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif ( objectIndex !== undefined ) {\r\n\r\n\t\t\t\tif( targetObject[ objectIndex ] === undefined ) {\r\n\r\n\t\t\t\t\tconsole.error( \"  trying to bind to objectIndex of objectName, but is undefined:\", this, targetObject );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttargetObject = targetObject[ objectIndex ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// resolve property\r\n\t\tvar nodeProperty = targetObject[ propertyName ];\r\n\r\n\t\tif ( ! nodeProperty ) {\r\n\r\n\t\t\tvar nodeName = parsedPath.nodeName;\r\n\r\n\t\t\tconsole.error( \"  trying to update property for track: \" + nodeName +\r\n\t\t\t\t\t'.' + propertyName + \" but it wasn't found.\", targetObject );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\t// determine versioning scheme\r\n\t\tvar versioning = this.Versioning.None;\r\n\r\n\t\tif ( targetObject.needsUpdate !== undefined ) { // material\r\n\r\n\t\t\tversioning = this.Versioning.NeedsUpdate;\r\n\t\t\tthis.targetObject = targetObject;\r\n\r\n\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\r\n\r\n\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\r\n\t\t\tthis.targetObject = targetObject;\r\n\r\n\t\t}\r\n\r\n\t\t// determine how the property gets bound\r\n\t\tvar bindingType = this.BindingType.Direct;\r\n\r\n\t\tif ( propertyIndex !== undefined ) {\r\n\t\t\t// access a sub element of the property array (only primitives are supported right now)\r\n\r\n\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\r\n\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\r\n\r\n\t\t\t\t// support resolving morphTarget names into indices.\r\n\t\t\t\tif ( ! targetObject.geometry ) {\r\n\r\n\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ! targetObject.geometry.morphTargets ) {\r\n\r\n\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\r\n\r\n\t\t\t\t\tif ( targetObject.geometry.morphTargets[i].name === propertyIndex ) {\r\n\r\n\t\t\t\t\t\tpropertyIndex = i;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbindingType = this.BindingType.ArrayElement;\r\n\r\n\t\t\tthis.resolvedProperty = nodeProperty;\r\n\t\t\tthis.propertyIndex = propertyIndex;\r\n\r\n\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\r\n\t\t\t// must use copy for Object3D.Euler/Quaternion\r\n\r\n\t\t\tbindingType = this.BindingType.HasFromToArray;\r\n\r\n\t\t\tthis.resolvedProperty = nodeProperty;\r\n\r\n\t\t} else if ( nodeProperty.length !== undefined ) {\r\n\r\n\t\t\tbindingType = this.BindingType.EntireArray;\r\n\r\n\t\t\tthis.resolvedProperty = nodeProperty;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.propertyName = propertyName;\r\n\r\n\t\t}\r\n\r\n\t\t// select getter / setter\r\n\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\r\n\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\r\n\r\n\t},\r\n\r\n\tunbind: function() {\r\n\r\n\t\tthis.node = null;\r\n\r\n\t\t// back to the prototype version of getValue / setValue\r\n\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\r\n\t\tthis.getValue = this._getValue_unbound;\r\n\t\tthis.setValue = this._setValue_unbound;\r\n\r\n\t}\r\n\r\n};\r\n\r\nObject.assign( THREE.PropertyBinding.prototype, { // prototype, continued\r\n\r\n\t// these are used to \"bind\" a nonexistent property\r\n\t_getValue_unavailable: function() {},\r\n\t_setValue_unavailable: function() {},\r\n\r\n\t// initial state of these methods that calls 'bind'\r\n\t_getValue_unbound: THREE.PropertyBinding.prototype.getValue,\r\n\t_setValue_unbound: THREE.PropertyBinding.prototype.setValue,\r\n\r\n\tBindingType: {\r\n\t\tDirect: 0,\r\n\t\tEntireArray: 1,\r\n\t\tArrayElement: 2,\r\n\t\tHasFromToArray: 3\r\n\t},\r\n\r\n\tVersioning: {\r\n\t\tNone: 0,\r\n\t\tNeedsUpdate: 1,\r\n\t\tMatrixWorldNeedsUpdate: 2\r\n\t},\r\n\r\n\tGetterByBindingType: [\r\n\r\n\t\tfunction getValue_direct( buffer, offset ) {\r\n\r\n\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\r\n\r\n\t\t},\r\n\r\n\t\tfunction getValue_array( buffer, offset ) {\r\n\r\n\t\t\tvar source = this.resolvedProperty;\r\n\r\n\t\t\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\tbuffer[ offset ++ ] = source[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tfunction getValue_arrayElement( buffer, offset ) {\r\n\r\n\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\r\n\r\n\t\t},\r\n\r\n\t\tfunction getValue_toArray( buffer, offset ) {\r\n\r\n\t\t\tthis.resolvedProperty.toArray( buffer, offset );\r\n\r\n\t\t}\r\n\r\n\t],\r\n\r\n\tSetterByBindingTypeAndVersioning: [\r\n\r\n\t\t[\r\n\t\t\t// Direct\r\n\r\n\t\t\tfunction setValue_direct( buffer, offset ) {\r\n\r\n\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\r\n\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\r\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t], [\r\n\r\n\t\t\t// EntireArray\r\n\r\n\t\t\tfunction setValue_array( buffer, offset ) {\r\n\r\n\t\t\t\tvar dest = this.resolvedProperty;\r\n\r\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tvar dest = this.resolvedProperty;\r\n\r\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tvar dest = this.resolvedProperty;\r\n\r\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t], [\r\n\r\n\t\t\t// ArrayElement\r\n\r\n\t\t\tfunction setValue_arrayElement( buffer, offset ) {\r\n\r\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\r\n\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\r\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t], [\r\n\r\n\t\t\t// HasToFromArray\r\n\r\n\t\t\tfunction setValue_fromArray( buffer, offset ) {\r\n\r\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\r\n\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\r\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t]\r\n\r\n\t]\r\n\r\n} );\r\n\r\nTHREE.PropertyBinding.Composite =\r\n\t\tfunction( targetGroup, path, optionalParsedPath ) {\r\n\r\n\tvar parsedPath = optionalParsedPath ||\r\n\t\t\tTHREE.PropertyBinding.parseTrackName( path );\r\n\r\n\tthis._targetGroup = targetGroup;\r\n\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\r\n\r\n};\r\n\r\nTHREE.PropertyBinding.Composite.prototype = {\r\n\r\n\tconstructor: THREE.PropertyBinding.Composite,\r\n\r\n\tgetValue: function( array, offset ) {\r\n\r\n\t\tthis.bind(); // bind all binding\r\n\r\n\t\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\r\n\t\t\tbinding = this._bindings[ firstValidIndex ];\r\n\r\n\t\t// and only call .getValue on the first\r\n\t\tif ( binding !== undefined ) binding.getValue( array, offset );\r\n\r\n\t},\r\n\r\n\tsetValue: function( array, offset ) {\r\n\r\n\t\tvar bindings = this._bindings;\r\n\r\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\r\n\t\t\t\tn = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\tbindings[ i ].setValue( array, offset );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tbind: function() {\r\n\r\n\t\tvar bindings = this._bindings;\r\n\r\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\r\n\t\t\t\tn = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\tbindings[ i ].bind();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tunbind: function() {\r\n\r\n\t\tvar bindings = this._bindings;\r\n\r\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\r\n\t\t\t\tn = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\tbindings[ i ].unbind();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.PropertyBinding.create = function( root, path, parsedPath ) {\r\n\r\n\tif ( ! ( root instanceof THREE.AnimationObjectGroup ) ) {\r\n\r\n\t\treturn new THREE.PropertyBinding( root, path, parsedPath );\r\n\r\n\t} else {\r\n\r\n\t\treturn new THREE.PropertyBinding.Composite( root, path, parsedPath );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.PropertyBinding.parseTrackName = function( trackName ) {\r\n\r\n\t// matches strings in the form of:\r\n\t//    nodeName.property\r\n\t//    nodeName.property[accessor]\r\n\t//    nodeName.material.property[accessor]\r\n\t//    uuid.property[accessor]\r\n\t//    uuid.objectName[objectIndex].propertyName[propertyIndex]\r\n\t//    parentName/nodeName.property\r\n\t//    parentName/parentName/nodeName.property[index]\r\n\t//\t  .bone[Armature.DEF_cog].position\r\n\t// created and tested via https://regex101.com/#javascript\r\n\r\n\tvar re = /^(([\\w]+\\/)*)([\\w-\\d]+)?(\\.([\\w]+)(\\[([\\w\\d\\[\\]\\_.:\\- ]+)\\])?)?(\\.([\\w.]+)(\\[([\\w\\d\\[\\]\\_. ]+)\\])?)$/;\r\n\tvar matches = re.exec(trackName);\r\n\r\n\tif( ! matches ) {\r\n\t\tthrow new Error( \"cannot parse trackName at all: \" + trackName );\r\n\t}\r\n\r\n    if (matches.index === re.lastIndex) {\r\n        re.lastIndex++;\r\n    }\r\n\r\n\tvar results = {\r\n\t\t// directoryName: matches[1], // (tschw) currently unused\r\n\t\tnodeName: matches[3], \t// allowed to be null, specified root node.\r\n\t\tobjectName: matches[5],\r\n\t\tobjectIndex: matches[7],\r\n\t\tpropertyName: matches[9],\r\n\t\tpropertyIndex: matches[11]\t// allowed to be null, specifies that the whole property is set.\r\n\t};\r\n\r\n\tif( results.propertyName === null || results.propertyName.length === 0 ) {\r\n\t\tthrow new Error( \"can not parse propertyName from trackName: \" + trackName );\r\n\t}\r\n\r\n\treturn results;\r\n\r\n};\r\n\r\nTHREE.PropertyBinding.findNode = function( root, nodeName ) {\r\n\r\n\tif( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {\r\n\r\n\t\treturn root;\r\n\r\n\t}\r\n\r\n\t// search into skeleton bones.\r\n\tif( root.skeleton ) {\r\n\r\n\t\tvar searchSkeleton = function( skeleton ) {\r\n\r\n\t\t\tfor( var i = 0; i < skeleton.bones.length; i ++ ) {\r\n\r\n\t\t\t\tvar bone = skeleton.bones[i];\r\n\r\n\t\t\t\tif( bone.name === nodeName ) {\r\n\r\n\t\t\t\t\treturn bone;\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t};\r\n\r\n\t\tvar bone = searchSkeleton( root.skeleton );\r\n\r\n\t\tif( bone ) {\r\n\r\n\t\t\treturn bone;\r\n\r\n\t\t}\r\n\t}\r\n\r\n\t// search into node subtree.\r\n\tif( root.children ) {\r\n\r\n\t\tvar searchNodeSubtree = function( children ) {\r\n\r\n\t\t\tfor( var i = 0; i < children.length; i ++ ) {\r\n\r\n\t\t\t\tvar childNode = children[i];\r\n\r\n\t\t\t\tif( childNode.name === nodeName || childNode.uuid === nodeName ) {\r\n\r\n\t\t\t\t\treturn childNode;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar result = searchNodeSubtree( childNode.children );\r\n\r\n\t\t\t\tif( result ) return result;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t};\r\n\r\n\t\tvar subTreeNode = searchNodeSubtree( root.children );\r\n\r\n\t\tif( subTreeNode ) {\r\n\r\n\t\t\treturn subTreeNode;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn null;\r\n\r\n}\r\n\r\n// File:src/animation/PropertyMixer.js\r\n\r\n/**\r\n *\r\n * Buffered scene graph property that allows weighted accumulation.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.PropertyMixer = function ( binding, typeName, valueSize ) {\r\n\r\n\tthis.binding = binding;\r\n\tthis.valueSize = valueSize;\r\n\r\n\tvar bufferType = Float64Array,\r\n\t\tmixFunction;\r\n\r\n\tswitch ( typeName ) {\r\n\r\n\t\tcase 'quaternion':\t\t\tmixFunction = this._slerp;\t\tbreak;\r\n\r\n\t\tcase 'string':\r\n\t\tcase 'bool':\r\n\r\n\t\t\tbufferType = Array,\t\tmixFunction = this._select;\t\tbreak;\r\n\r\n\t\tdefault:\t\t\t\t\tmixFunction = this._lerp;\r\n\r\n\t}\r\n\r\n\tthis.buffer = new bufferType( valueSize * 4 );\r\n\t// layout: [ incoming | accu0 | accu1 | orig ]\r\n\t//\r\n\t// interpolators can use .buffer as their .result\r\n\t// the data then goes to 'incoming'\r\n\t//\r\n\t// 'accu0' and 'accu1' are used frame-interleaved for\r\n\t// the cumulative result and are compared to detect\r\n\t// changes\r\n\t//\r\n\t// 'orig' stores the original state of the property\r\n\r\n\tthis._mixBufferRegion = mixFunction;\r\n\r\n\tthis.cumulativeWeight = 0;\r\n\r\n\tthis.useCount = 0;\r\n\tthis.referenceCount = 0;\r\n\r\n};\r\n\r\nTHREE.PropertyMixer.prototype = {\r\n\r\n\tconstructor: THREE.PropertyMixer,\r\n\r\n\t// accumulate data in the 'incoming' region into 'accu<i>'\r\n\taccumulate: function( accuIndex, weight ) {\r\n\r\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\r\n\t\t// the weight and shouldn't have made the call in the first place\r\n\r\n\t\tvar buffer = this.buffer,\r\n\t\t\tstride = this.valueSize,\r\n\t\t\toffset = accuIndex * stride + stride,\r\n\r\n\t\t\tcurrentWeight = this.cumulativeWeight;\r\n\r\n\t\tif ( currentWeight === 0 ) {\r\n\r\n\t\t\t// accuN := incoming * weight\r\n\r\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentWeight = weight;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// accuN := accuN + incoming * weight\r\n\r\n\t\t\tcurrentWeight += weight;\r\n\t\t\tvar mix = weight / currentWeight;\r\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\r\n\r\n\t\t}\r\n\r\n\t\tthis.cumulativeWeight = currentWeight;\r\n\r\n\t},\r\n\r\n\t// apply the state of 'accu<i>' to the binding when accus differ\r\n\tapply: function( accuIndex ) {\r\n\r\n\t\tvar stride = this.valueSize,\r\n\t\t\tbuffer = this.buffer,\r\n\t\t\toffset = accuIndex * stride + stride,\r\n\r\n\t\t\tweight = this.cumulativeWeight,\r\n\r\n\t\t\tbinding = this.binding;\r\n\r\n\t\tthis.cumulativeWeight = 0;\r\n\r\n\t\tif ( weight < 1 ) {\r\n\r\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\r\n\r\n\t\t\tvar originalValueOffset = stride * 3;\r\n\r\n\t\t\tthis._mixBufferRegion(\r\n\t\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\r\n\r\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\r\n\r\n\t\t\t\t// value has changed -> update scene graph\r\n\r\n\t\t\t\tbinding.setValue( buffer, offset );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// remember the state of the bound property and copy it to both accus\r\n\tsaveOriginalState: function() {\r\n\r\n\t\tvar binding = this.binding;\r\n\r\n\t\tvar buffer = this.buffer,\r\n\t\t\tstride = this.valueSize,\r\n\r\n\t\t\toriginalValueOffset = stride * 3;\r\n\r\n\t\tbinding.getValue( buffer, originalValueOffset );\r\n\r\n\t\t// accu[0..1] := orig -- initially detect changes against the original\r\n\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\r\n\r\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\r\n\r\n\t\t}\r\n\r\n\t\tthis.cumulativeWeight = 0;\r\n\r\n\t},\r\n\r\n\t// apply the state previously taken via 'saveOriginalState' to the binding\r\n\trestoreOriginalState: function() {\r\n\r\n\t\tvar originalValueOffset = this.valueSize * 3;\r\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\r\n\r\n\t},\r\n\r\n\r\n\t// mix functions\r\n\r\n\t_select: function( buffer, dstOffset, srcOffset, t, stride ) {\r\n\r\n\t\tif ( t >= 0.5 ) {\r\n\r\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {\r\n\r\n\t\tTHREE.Quaternion.slerpFlat( buffer, dstOffset,\r\n\t\t\t\tbuffer, dstOffset, buffer, srcOffset, t );\r\n\r\n\t},\r\n\r\n\t_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {\r\n\r\n\t\tvar s = 1 - t;\r\n\r\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\tvar j = dstOffset + i;\r\n\r\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/animation/tracks/BooleanKeyframeTrack.js\r\n\r\n/**\r\n *\r\n * A Track of Boolean keyframe values.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.BooleanKeyframeTrack = function ( name, times, values ) {\r\n\r\n\tTHREE.KeyframeTrack.call( this, name, times, values );\r\n\r\n};\r\n\r\nTHREE.BooleanKeyframeTrack.prototype =\r\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\r\n\tconstructor: THREE.BooleanKeyframeTrack,\r\n\r\n\tValueTypeName: 'bool',\r\n\tValueBufferType: Array,\r\n\r\n\tDefaultInterpolation: THREE.IntepolateDiscrete,\r\n\r\n\tInterpolantFactoryMethodLinear: undefined,\r\n\tInterpolantFactoryMethodSmooth: undefined\r\n\r\n\t// Note: Actually this track could have a optimized / compressed\r\n\t// representation of a single value and a custom interpolant that\r\n\t// computes \"firstValue ^ isOdd( index )\".\r\n\r\n} );\r\n\r\n// File:src/animation/tracks/NumberKeyframeTrack.js\r\n\r\n/**\r\n *\r\n * A Track of numeric keyframe values.\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.NumberKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\r\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\r\n};\r\n\r\nTHREE.NumberKeyframeTrack.prototype =\r\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\r\n\tconstructor: THREE.NumberKeyframeTrack,\r\n\r\n\tValueTypeName: 'number',\r\n\r\n\t// ValueBufferType is inherited\r\n\r\n\t// DefaultInterpolation is inherited\r\n\r\n} );\r\n\r\n// File:src/animation/tracks/QuaternionKeyframeTrack.js\r\n\r\n/**\r\n *\r\n * A Track of quaternion keyframe values.\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.QuaternionKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\r\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\r\n};\r\n\r\nTHREE.QuaternionKeyframeTrack.prototype =\r\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\r\n\tconstructor: THREE.QuaternionKeyframeTrack,\r\n\r\n\tValueTypeName: 'quaternion',\r\n\r\n\t// ValueBufferType is inherited\r\n\r\n\tDefaultInterpolation: THREE.InterpolateLinear,\r\n\r\n\tInterpolantFactoryMethodLinear: function( result ) {\r\n\r\n\t\treturn new THREE.QuaternionLinearInterpolant(\r\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\r\n\r\n\t},\r\n\r\n\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\r\n\r\n} );\r\n\r\n// File:src/animation/tracks/StringKeyframeTrack.js\r\n\r\n/**\r\n *\r\n * A Track that interpolates Strings\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.StringKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\r\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\r\n};\r\n\r\nTHREE.StringKeyframeTrack.prototype =\r\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\r\n\tconstructor: THREE.StringKeyframeTrack,\r\n\r\n\tValueTypeName: 'string',\r\n\tValueBufferType: Array,\r\n\r\n\tDefaultInterpolation: THREE.IntepolateDiscrete,\r\n\r\n\tInterpolantFactoryMethodLinear: undefined,\r\n\r\n\tInterpolantFactoryMethodSmooth: undefined\r\n\r\n} );\r\n\r\n// File:src/animation/tracks/VectorKeyframeTrack.js\r\n\r\n/**\r\n *\r\n * A Track of vectored keyframe values.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.VectorKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\r\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\r\n};\r\n\r\nTHREE.VectorKeyframeTrack.prototype =\r\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\r\n\tconstructor: THREE.VectorKeyframeTrack,\r\n\r\n\tValueTypeName: 'vector'\r\n\r\n\t// ValueBufferType is inherited\r\n\r\n\t// DefaultInterpolation is inherited\r\n\r\n} );\r\n\r\n// File:src/audio/Audio.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Audio = function ( listener ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Audio';\r\n\r\n\tthis.context = listener.context;\r\n\tthis.source = this.context.createBufferSource();\r\n\tthis.source.onended = this.onEnded.bind( this );\r\n\r\n\tthis.gain = this.context.createGain();\r\n\tthis.gain.connect( listener.getInput() );\r\n\r\n\tthis.autoplay = false;\r\n\r\n\tthis.startTime = 0;\r\n\tthis.playbackRate = 1;\r\n\tthis.isPlaying = false;\r\n\tthis.hasPlaybackControl = true;\r\n\tthis.sourceType = 'empty';\r\n\r\n\tthis.filter = null;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Audio.prototype.constructor = THREE.Audio;\r\n\r\nTHREE.Audio.prototype.getOutput = function () {\r\n\r\n\treturn this.gain;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.load = function ( file ) {\r\n\r\n\tvar buffer = new THREE.AudioBuffer( this.context );\r\n\tbuffer.load( file );\r\n\r\n\tthis.setBuffer( buffer );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setNodeSource = function ( audioNode ) {\r\n\r\n\tthis.hasPlaybackControl = false;\r\n\tthis.sourceType = 'audioNode';\r\n\tthis.source = audioNode;\r\n\tthis.connect();\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setBuffer = function ( audioBuffer ) {\r\n\r\n\tvar scope = this;\r\n\r\n\taudioBuffer.onReady( function( buffer ) {\r\n\r\n\t\tscope.source.buffer = buffer;\r\n\t\tscope.sourceType = 'buffer';\r\n\t\tif ( scope.autoplay ) scope.play();\r\n\r\n\t} );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.play = function () {\r\n\r\n\tif ( this.isPlaying === true ) {\r\n\r\n\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tif ( this.hasPlaybackControl === false ) {\r\n\r\n\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tvar source = this.context.createBufferSource();\r\n\r\n\tsource.buffer = this.source.buffer;\r\n\tsource.loop = this.source.loop;\r\n\tsource.onended = this.source.onended;\r\n\tsource.start( 0, this.startTime );\r\n\tsource.playbackRate.value = this.playbackRate;\r\n\r\n\tthis.isPlaying = true;\r\n\r\n\tthis.source = source;\r\n\r\n\tthis.connect();\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.pause = function () {\r\n\r\n\tif ( this.hasPlaybackControl === false ) {\r\n\r\n\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tthis.source.stop();\r\n\tthis.startTime = this.context.currentTime;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.stop = function () {\r\n\r\n\tif ( this.hasPlaybackControl === false ) {\r\n\r\n\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tthis.source.stop();\r\n\tthis.startTime = 0;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.connect = function () {\r\n\r\n\tif ( this.filter !== null ) {\r\n\r\n\t\tthis.source.connect( this.filter );\r\n\t\tthis.filter.connect( this.getOutput() );\r\n\r\n\t} else {\r\n\r\n\t\tthis.source.connect( this.getOutput() );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.disconnect = function () {\r\n\r\n\tif ( this.filter !== null ) {\r\n\r\n\t\tthis.source.disconnect( this.filter );\r\n\t\tthis.filter.disconnect( this.getOutput() );\r\n\r\n\t} else {\r\n\r\n\t\tthis.source.disconnect( this.getOutput() );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.getFilter = function () {\r\n\r\n\treturn this.filter;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setFilter = function ( value ) {\r\n\r\n\tif ( value === undefined ) value = null;\r\n\r\n\tif ( this.isPlaying === true ) {\r\n\r\n\t\tthis.disconnect();\r\n\t\tthis.filter = value;\r\n\t\tthis.connect();\r\n\r\n\t} else {\r\n\r\n\t\tthis.filter = value;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setPlaybackRate = function ( value ) {\r\n\r\n\tif ( this.hasPlaybackControl === false ) {\r\n\r\n\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tthis.playbackRate = value;\r\n\r\n\tif ( this.isPlaying === true ) {\r\n\r\n\t\tthis.source.playbackRate.value = this.playbackRate;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.getPlaybackRate = function () {\r\n\r\n\treturn this.playbackRate;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.onEnded = function() {\r\n\r\n\tthis.isPlaying = false;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setLoop = function ( value ) {\r\n\r\n\tif ( this.hasPlaybackControl === false ) {\r\n\r\n\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tthis.source.loop = value;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.getLoop = function () {\r\n\r\n\tif ( this.hasPlaybackControl === false ) {\r\n\r\n\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\treturn this.source.loop;\r\n\r\n};\r\n\r\n\r\nTHREE.Audio.prototype.setVolume = function ( value ) {\r\n\r\n\tthis.gain.gain.value = value;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.getVolume = function () {\r\n\r\n\treturn this.gain.gain.value;\r\n\r\n};\r\n\r\n// File:src/audio/AudioAnalyser.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AudioAnalyser = function ( audio, fftSize ) {\r\n\r\n\tthis.analyser = audio.context.createAnalyser();\r\n\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\r\n\r\n\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\r\n\r\n\taudio.getOutput().connect( this.analyser );\r\n\r\n};\r\n\r\nTHREE.AudioAnalyser.prototype = {\r\n\r\n\tconstructor: THREE.AudioAnalyser,\r\n\r\n\tgetData: function () {\r\n\r\n\t\tthis.analyser.getByteFrequencyData( this.data );\r\n\t\treturn this.data;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/audio/AudioBuffer.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AudioBuffer = function ( context ) {\r\n\r\n\tthis.context = context;\r\n\tthis.ready = false;\r\n\tthis.readyCallbacks = [];\r\n\r\n};\r\n\r\nTHREE.AudioBuffer.prototype.load = function ( file ) {\r\n\r\n\tvar scope = this;\r\n\r\n\tvar request = new XMLHttpRequest();\r\n\trequest.open( 'GET', file, true );\r\n\trequest.responseType = 'arraybuffer';\r\n\trequest.onload = function ( e ) {\r\n\r\n\t\tscope.context.decodeAudioData( this.response, function ( buffer ) {\r\n\r\n\t\t\tscope.buffer = buffer;\r\n\t\t\tscope.ready = true;\r\n\r\n\t\t\tfor ( var i = 0; i < scope.readyCallbacks.length; i ++ ) {\r\n\r\n\t\t\t\tscope.readyCallbacks[ i ]( scope.buffer );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tscope.readyCallbacks = [];\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\trequest.send();\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nTHREE.AudioBuffer.prototype.onReady = function ( callback ) {\r\n\r\n\tif ( this.ready ) {\r\n\r\n\t\tcallback( this.buffer );\r\n\r\n\t} else {\r\n\r\n\t\tthis.readyCallbacks.push( callback );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/audio/PositionalAudio.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.PositionalAudio = function ( listener ) {\r\n\r\n\tTHREE.Audio.call( this, listener );\r\n\r\n\tthis.panner = this.context.createPanner();\r\n\tthis.panner.connect( this.gain );\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype = Object.create( THREE.Audio.prototype );\r\nTHREE.PositionalAudio.prototype.constructor = THREE.PositionalAudio;\r\n\r\nTHREE.PositionalAudio.prototype.getOutput = function () {\r\n\r\n\treturn this.panner;\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype.setRefDistance = function ( value ) {\r\n\r\n\tthis.panner.refDistance = value;\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype.getRefDistance = function () {\r\n\r\n\treturn this.panner.refDistance;\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype.setRolloffFactor = function ( value ) {\r\n\r\n\tthis.panner.rolloffFactor = value;\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype.getRolloffFactor = function () {\r\n\r\n\treturn this.panner.rolloffFactor;\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype.setDistanceModel = function ( value ) {\r\n\r\n\tthis.panner.distanceModel = value;\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype.getDistanceModel = function () {\r\n\r\n\treturn this.panner.distanceModel;\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype.setMaxDistance = function ( value ) {\r\n\r\n\tthis.panner.maxDistance = value;\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype.getMaxDistance = function () {\r\n\r\n\treturn this.panner.maxDistance;\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype.updateMatrixWorld = ( function () {\r\n\r\n\tvar position = new THREE.Vector3();\r\n\r\n\treturn function updateMatrixWorld( force ) {\r\n\r\n\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\r\n\r\n\t\tposition.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\tthis.panner.setPosition( position.x, position.y, position.z );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n// File:src/audio/AudioListener.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AudioListener = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'AudioListener';\r\n\r\n\tthis.context = new ( window.AudioContext || window.webkitAudioContext )();\r\n\r\n\tthis.gain = this.context.createGain();\r\n\tthis.gain.connect( this.context.destination );\r\n\r\n\tthis.filter = null;\r\n\r\n};\r\n\r\nTHREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.AudioListener.prototype.constructor = THREE.AudioListener;\r\n\r\nTHREE.AudioListener.prototype.getInput = function () {\r\n\r\n\treturn this.gain;\r\n\r\n};\r\n\r\nTHREE.AudioListener.prototype.removeFilter = function ( ) {\r\n\r\n\tif ( this.filter !== null ) {\r\n\r\n\t\tthis.gain.disconnect( this.filter );\r\n\t\tthis.filter.disconnect( this.context.destination );\r\n\t\tthis.gain.connect( this.context.destination );\r\n\t\tthis.filter = null;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.AudioListener.prototype.setFilter = function ( value ) {\r\n\r\n\tif ( this.filter !== null ) {\r\n\r\n\t\tthis.gain.disconnect( this.filter );\r\n\t\tthis.filter.disconnect( this.context.destination );\r\n\r\n\t} else {\r\n\r\n\t\tthis.gain.disconnect( this.context.destination );\r\n\r\n\t}\r\n\r\n\tthis.filter = value;\r\n\tthis.gain.connect( this.filter );\r\n\tthis.filter.connect( this.context.destination );\r\n\r\n};\r\n\r\nTHREE.AudioListener.prototype.getFilter = function () {\r\n\r\n\treturn this.filter;\r\n\r\n};\r\n\r\nTHREE.AudioListener.prototype.setMasterVolume = function ( value ) {\r\n\r\n\tthis.gain.gain.value = value;\r\n\r\n};\r\n\r\nTHREE.AudioListener.prototype.getMasterVolume = function () {\r\n\r\n\treturn this.gain.gain.value;\r\n\r\n};\r\n\r\n\r\nTHREE.AudioListener.prototype.updateMatrixWorld = ( function () {\r\n\r\n\tvar position = new THREE.Vector3();\r\n\tvar quaternion = new THREE.Quaternion();\r\n\tvar scale = new THREE.Vector3();\r\n\r\n\tvar orientation = new THREE.Vector3();\r\n\r\n\treturn function updateMatrixWorld( force ) {\r\n\r\n\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\r\n\r\n\t\tvar listener = this.context.listener;\r\n\t\tvar up = this.up;\r\n\r\n\t\tthis.matrixWorld.decompose( position, quaternion, scale );\r\n\r\n\t\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\r\n\r\n\t\tlistener.setPosition( position.x, position.y, position.z );\r\n\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n// File:src/cameras/Camera.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.Camera = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Camera';\r\n\r\n\tthis.matrixWorldInverse = new THREE.Matrix4();\r\n\tthis.projectionMatrix = new THREE.Matrix4();\r\n\r\n};\r\n\r\nTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Camera.prototype.constructor = THREE.Camera;\r\n\r\nTHREE.Camera.prototype.getWorldDirection = function () {\r\n\r\n\tvar quaternion = new THREE.Quaternion();\r\n\r\n\treturn function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\tthis.getWorldQuaternion( quaternion );\r\n\r\n\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.Camera.prototype.lookAt = function () {\r\n\r\n\t// This routine does not support cameras with rotated and/or translated parent(s)\r\n\r\n\tvar m1 = new THREE.Matrix4();\r\n\r\n\treturn function ( vector ) {\r\n\r\n\t\tm1.lookAt( this.position, vector, this.up );\r\n\r\n\t\tthis.quaternion.setFromRotationMatrix( m1 );\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.Camera.prototype.clone = function () {\r\n\r\n\treturn new this.constructor().copy( this );\r\n\r\n};\r\n\r\nTHREE.Camera.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Object3D.prototype.copy.call( this, source );\r\n\r\n\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\r\n\tthis.projectionMatrix.copy( source.projectionMatrix );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/cameras/CubeCamera.js\r\n\r\n/**\r\n * Camera for rendering cube maps\r\n *\t- renders scene into axis-aligned cube\r\n *\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.CubeCamera = function ( near, far, cubeResolution ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'CubeCamera';\r\n\r\n\tvar fov = 90, aspect = 1;\r\n\r\n\tvar cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraPX.up.set( 0, - 1, 0 );\r\n\tcameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\r\n\tthis.add( cameraPX );\r\n\r\n\tvar cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraNX.up.set( 0, - 1, 0 );\r\n\tcameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );\r\n\tthis.add( cameraNX );\r\n\r\n\tvar cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraPY.up.set( 0, 0, 1 );\r\n\tcameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\r\n\tthis.add( cameraPY );\r\n\r\n\tvar cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraNY.up.set( 0, 0, - 1 );\r\n\tcameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );\r\n\tthis.add( cameraNY );\r\n\r\n\tvar cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraPZ.up.set( 0, - 1, 0 );\r\n\tcameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\r\n\tthis.add( cameraPZ );\r\n\r\n\tvar cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraNZ.up.set( 0, - 1, 0 );\r\n\tcameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );\r\n\tthis.add( cameraNZ );\r\n\r\n\tvar options = { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };\r\n\r\n\tthis.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\r\n\r\n\tthis.updateCubeMap = function ( renderer, scene ) {\r\n\r\n\t\tif ( this.parent === null ) this.updateMatrixWorld();\r\n\r\n\t\tvar renderTarget = this.renderTarget;\r\n\t\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\r\n\r\n\t\trenderTarget.texture.generateMipmaps = false;\r\n\r\n\t\trenderTarget.activeCubeFace = 0;\r\n\t\trenderer.render( scene, cameraPX, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 1;\r\n\t\trenderer.render( scene, cameraNX, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 2;\r\n\t\trenderer.render( scene, cameraPY, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 3;\r\n\t\trenderer.render( scene, cameraNY, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 4;\r\n\t\trenderer.render( scene, cameraPZ, renderTarget );\r\n\r\n\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\r\n\r\n\t\trenderTarget.activeCubeFace = 5;\r\n\t\trenderer.render( scene, cameraNZ, renderTarget );\r\n\r\n\t\trenderer.setRenderTarget( null );\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.CubeCamera.prototype.constructor = THREE.CubeCamera;\r\n\r\n// File:src/cameras/OrthographicCamera.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\r\n\r\n\tTHREE.Camera.call( this );\r\n\r\n\tthis.type = 'OrthographicCamera';\r\n\r\n\tthis.zoom = 1;\r\n\r\n\tthis.left = left;\r\n\tthis.right = right;\r\n\tthis.top = top;\r\n\tthis.bottom = bottom;\r\n\r\n\tthis.near = ( near !== undefined ) ? near : 0.1;\r\n\tthis.far = ( far !== undefined ) ? far : 2000;\r\n\r\n\tthis.updateProjectionMatrix();\r\n\r\n};\r\n\r\nTHREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );\r\nTHREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;\r\n\r\nTHREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {\r\n\r\n\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\r\n\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\r\n\tvar cx = ( this.right + this.left ) / 2;\r\n\tvar cy = ( this.top + this.bottom ) / 2;\r\n\r\n\tthis.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );\r\n\r\n};\r\n\r\nTHREE.OrthographicCamera.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Camera.prototype.copy.call( this, source );\r\n\r\n\tthis.left = source.left;\r\n\tthis.right = source.right;\r\n\tthis.top = source.top;\r\n\tthis.bottom = source.bottom;\r\n\tthis.near = source.near;\r\n\tthis.far = source.far;\r\n\r\n\tthis.zoom = source.zoom;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nTHREE.OrthographicCamera.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n\tdata.object.zoom = this.zoom;\r\n\tdata.object.left = this.left;\r\n\tdata.object.right = this.right;\r\n\tdata.object.top = this.top;\r\n\tdata.object.bottom = this.bottom;\r\n\tdata.object.near = this.near;\r\n\tdata.object.far = this.far;\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\n// File:src/cameras/PerspectiveCamera.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author greggman / http://games.greggman.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.PerspectiveCamera = function ( fov, aspect, near, far ) {\r\n\r\n\tTHREE.Camera.call( this );\r\n\r\n\tthis.type = 'PerspectiveCamera';\r\n\r\n\tthis.focalLength = 10;\r\n\tthis.zoom = 1;\r\n\r\n\tthis.fov = fov !== undefined ? fov : 50;\r\n\tthis.aspect = aspect !== undefined ? aspect : 1;\r\n\tthis.near = near !== undefined ? near : 0.1;\r\n\tthis.far = far !== undefined ? far : 2000;\r\n\r\n\tthis.updateProjectionMatrix();\r\n\r\n};\r\n\r\nTHREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );\r\nTHREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;\r\n\r\n\r\n/**\r\n * Uses Focal Length (in mm) to estimate and set FOV\r\n * 35mm (full-frame) camera is used if frame size is not specified;\r\n * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\r\n */\r\n\r\nTHREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {\r\n\r\n\tif ( frameHeight === undefined ) frameHeight = 24;\r\n\r\n\tthis.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );\r\n\tthis.updateProjectionMatrix();\r\n\r\n};\r\n\r\n\r\n/**\r\n * Sets an offset in a larger frustum. This is useful for multi-window or\r\n * multi-monitor/multi-machine setups.\r\n *\r\n * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\r\n * the monitors are in grid like this\r\n *\r\n *   +---+---+---+\r\n *   | A | B | C |\r\n *   +---+---+---+\r\n *   | D | E | F |\r\n *   +---+---+---+\r\n *\r\n * then for each monitor you would call it like this\r\n *\r\n *   var w = 1920;\r\n *   var h = 1080;\r\n *   var fullWidth = w * 3;\r\n *   var fullHeight = h * 2;\r\n *\r\n *   --A--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\r\n *   --B--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\r\n *   --C--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\r\n *   --D--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\r\n *   --E--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\r\n *   --F--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\r\n *\r\n *   Note there is no reason monitors have to be the same size or in a grid.\r\n */\r\n\r\nTHREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {\r\n\r\n\tthis.fullWidth = fullWidth;\r\n\tthis.fullHeight = fullHeight;\r\n\tthis.x = x;\r\n\tthis.y = y;\r\n\tthis.width = width;\r\n\tthis.height = height;\r\n\r\n\tthis.updateProjectionMatrix();\r\n\r\n};\r\n\r\n\r\nTHREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {\r\n\r\n\tvar fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );\r\n\r\n\tif ( this.fullWidth ) {\r\n\r\n\t\tvar aspect = this.fullWidth / this.fullHeight;\r\n\t\tvar top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;\r\n\t\tvar bottom = - top;\r\n\t\tvar left = aspect * bottom;\r\n\t\tvar right = aspect * top;\r\n\t\tvar width = Math.abs( right - left );\r\n\t\tvar height = Math.abs( top - bottom );\r\n\r\n\t\tthis.projectionMatrix.makeFrustum(\r\n\t\t\tleft + this.x * width / this.fullWidth,\r\n\t\t\tleft + ( this.x + this.width ) * width / this.fullWidth,\r\n\t\t\ttop - ( this.y + this.height ) * height / this.fullHeight,\r\n\t\t\ttop - this.y * height / this.fullHeight,\r\n\t\t\tthis.near,\r\n\t\t\tthis.far\r\n\t\t);\r\n\r\n\t} else {\r\n\r\n\t\tthis.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.PerspectiveCamera.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Camera.prototype.copy.call( this, source );\r\n\r\n\tthis.focalLength = source.focalLength;\r\n\tthis.zoom = source.zoom;\r\n\r\n\tthis.fov = source.fov;\r\n\tthis.aspect = source.aspect;\r\n\tthis.near = source.near;\r\n\tthis.far = source.far;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nTHREE.PerspectiveCamera.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n\tdata.object.focalLength = this.focalLength;\r\n\tdata.object.zoom = this.zoom;\r\n\r\n\tdata.object.fov = this.fov;\r\n\tdata.object.aspect = this.aspect;\r\n\tdata.object.near = this.near;\r\n\tdata.object.far = this.far;\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\n// File:src/cameras/StereoCamera.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.StereoCamera = function () {\r\n\r\n\tthis.type = 'StereoCamera';\r\n\r\n\tthis.aspect = 1;\r\n\r\n\tthis.cameraL = new THREE.PerspectiveCamera();\r\n\tthis.cameraL.layers.enable( 1 );\r\n\tthis.cameraL.matrixAutoUpdate = false;\r\n\r\n\tthis.cameraR = new THREE.PerspectiveCamera();\r\n\tthis.cameraR.layers.enable( 2 );\r\n\tthis.cameraR.matrixAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.StereoCamera.prototype = {\r\n\r\n\tconstructor: THREE.StereoCamera,\r\n\r\n\tupdate: ( function () {\r\n\r\n\t\tvar focalLength, fov, aspect, near, far;\r\n\r\n\t\tvar eyeRight = new THREE.Matrix4();\r\n\t\tvar eyeLeft = new THREE.Matrix4();\r\n\r\n\t\treturn function update ( camera ) {\r\n\r\n\t\t\tvar needsUpdate = focalLength !== camera.focalLength || fov !== camera.fov ||\r\n\t\t\t\t\t\t\t\t\t\t\t\taspect !== camera.aspect * this.aspect || near !== camera.near ||\r\n\t\t\t\t\t\t\t\t\t\t\t\tfar !== camera.far;\r\n\r\n\t\t\tif ( needsUpdate ) {\r\n\r\n\t\t\t\tfocalLength = camera.focalLength;\r\n\t\t\t\tfov = camera.fov;\r\n\t\t\t\taspect = camera.aspect * this.aspect;\r\n\t\t\t\tnear = camera.near;\r\n\t\t\t\tfar = camera.far;\r\n\r\n\t\t\t\t// Off-axis stereoscopic effect based on\r\n\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\r\n\r\n\t\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\r\n\t\t\t\tvar eyeSep = 0.064 / 2;\r\n\t\t\t\tvar eyeSepOnProjection = eyeSep * near / focalLength;\r\n\t\t\t\tvar ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );\r\n\t\t\t\tvar xmin, xmax;\r\n\r\n\t\t\t\t// translate xOffset\r\n\r\n\t\t\t\teyeLeft.elements[ 12 ] = - eyeSep;\r\n\t\t\t\teyeRight.elements[ 12 ] = eyeSep;\r\n\r\n\t\t\t\t// for left eye\r\n\r\n\t\t\t\txmin = - ymax * aspect + eyeSepOnProjection;\r\n\t\t\t\txmax = ymax * aspect + eyeSepOnProjection;\r\n\r\n\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\r\n\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\r\n\r\n\t\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\r\n\r\n\t\t\t\t// for right eye\r\n\r\n\t\t\t\txmin = - ymax * aspect - eyeSepOnProjection;\r\n\t\t\t\txmax = ymax * aspect - eyeSepOnProjection;\r\n\r\n\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\r\n\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\r\n\r\n\t\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\r\n\t\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\r\n\r\n\t\t};\r\n\r\n\t} )()\r\n\r\n};\r\n\r\n// File:src/lights/Light.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Light = function ( color, intensity ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Light';\r\n\r\n\tthis.color = new THREE.Color( color );\r\n\tthis.intensity = intensity !== undefined ? intensity : 1;\r\n\r\n\tthis.receiveShadow = undefined;\r\n\r\n};\r\n\r\nTHREE.Light.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Light.prototype.constructor = THREE.Light;\r\n\r\nTHREE.Light.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Object3D.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\tthis.intensity = source.intensity;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nTHREE.Light.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n\tdata.object.color = this.color.getHex();\r\n\tdata.object.intensity = this.intensity;\r\n\r\n\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\r\n\r\n\tif ( this.distance !== undefined ) data.object.distance = this.distance;\r\n\tif ( this.angle !== undefined ) data.object.angle = this.angle;\r\n\tif ( this.decay !== undefined ) data.object.decay = this.decay;\r\n\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\n// File:src/lights/LightShadow.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LightShadow = function ( camera ) {\r\n\r\n\tthis.camera = camera;\r\n\r\n\tthis.bias = 0;\r\n\tthis.radius = 1;\r\n\r\n\tthis.mapSize = new THREE.Vector2( 512, 512 );\r\n\r\n\tthis.map = null;\r\n\tthis.matrix = new THREE.Matrix4();\r\n\r\n};\r\n\r\nTHREE.LightShadow.prototype = {\r\n\r\n\tconstructor: THREE.LightShadow,\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.camera = source.camera.clone();\r\n\r\n\t\tthis.bias = source.bias;\r\n\t\tthis.radius = source.radius;\r\n\r\n\t\tthis.mapSize.copy( source.mapSize );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/lights/AmbientLight.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AmbientLight = function ( color, intensity ) {\r\n\r\n\tTHREE.Light.call( this, color, intensity );\r\n\r\n\tthis.type = 'AmbientLight';\r\n\r\n\tthis.castShadow = undefined;\r\n\r\n};\r\n\r\nTHREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.AmbientLight.prototype.constructor = THREE.AmbientLight;\r\n\r\n// File:src/lights/DirectionalLight.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.DirectionalLight = function ( color, intensity ) {\r\n\r\n\tTHREE.Light.call( this, color, intensity );\r\n\r\n\tthis.type = 'DirectionalLight';\r\n\r\n\tthis.position.set( 0, 1, 0 );\r\n\tthis.updateMatrix();\r\n\r\n\tthis.target = new THREE.Object3D();\r\n\r\n\tthis.shadow = new THREE.LightShadow( new THREE.OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\r\n\r\n};\r\n\r\nTHREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;\r\n\r\nTHREE.DirectionalLight.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Light.prototype.copy.call( this, source );\r\n\r\n\tthis.target = source.target.clone();\r\n\r\n\tthis.shadow = source.shadow.clone();\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/lights/HemisphereLight.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {\r\n\r\n\tTHREE.Light.call( this, skyColor, intensity );\r\n\r\n\tthis.type = 'HemisphereLight';\r\n\r\n\tthis.castShadow = undefined;\r\n\r\n\tthis.position.set( 0, 1, 0 );\r\n\tthis.updateMatrix();\r\n\r\n\tthis.groundColor = new THREE.Color( groundColor );\r\n\r\n};\r\n\r\nTHREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;\r\n\r\nTHREE.HemisphereLight.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Light.prototype.copy.call( this, source );\r\n\r\n\tthis.groundColor.copy( source.groundColor );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/lights/PointLight.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\n\r\nTHREE.PointLight = function ( color, intensity, distance, decay ) {\r\n\r\n\tTHREE.Light.call( this, color, intensity );\r\n\r\n\tthis.type = 'PointLight';\r\n\r\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\r\n\r\n\tthis.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );\r\n\r\n};\r\n\r\nTHREE.PointLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.PointLight.prototype.constructor = THREE.PointLight;\r\n\r\nObject.defineProperty( THREE.PointLight.prototype, \"power\", {\r\n\r\n\tget: function () {\r\n\r\n\t\t// intensity = power per solid angle.\r\n\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\r\n\t\treturn this.intensity * 4 * Math.PI;\r\n\r\n\t},\r\n\r\n\tset: function ( power ) {\r\n\r\n\t\t// intensity = power per solid angle.\r\n\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\r\n\t\tthis.intensity = power / ( 4 * Math.PI );\r\n\r\n\t}\r\n\r\n} );\r\n\r\nTHREE.PointLight.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Light.prototype.copy.call( this, source );\r\n\r\n\tthis.distance = source.distance;\r\n\tthis.decay = source.decay;\r\n\r\n\tthis.shadow = source.shadow.clone();\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/lights/SpotLight.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SpotLight = function ( color, intensity, distance, angle, penumbra, decay ) {\r\n\r\n\tTHREE.Light.call( this, color, intensity );\r\n\r\n\tthis.type = 'SpotLight';\r\n\r\n\tthis.position.set( 0, 1, 0 );\r\n\tthis.updateMatrix();\r\n\r\n\tthis.target = new THREE.Object3D();\r\n\r\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\r\n\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\r\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\r\n\r\n\tthis.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 50, 1, 0.5, 500 ) );\r\n\r\n};\r\n\r\nTHREE.SpotLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.SpotLight.prototype.constructor = THREE.SpotLight;\r\n\r\nObject.defineProperty( THREE.SpotLight.prototype, \"power\", {\r\n\r\n\tget: function () {\r\n\r\n\t\t// intensity = power per solid angle.\r\n\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\r\n\t\treturn this.intensity * Math.PI;\r\n\r\n\t},\r\n\r\n\tset: function ( power ) {\r\n\r\n\t\t// intensity = power per solid angle.\r\n\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\r\n\t\tthis.intensity = power / Math.PI;\r\n\r\n\t}\r\n\r\n} );\r\n\r\nTHREE.SpotLight.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Light.prototype.copy.call( this, source );\r\n\r\n\tthis.distance = source.distance;\r\n\tthis.angle = source.angle;\r\n\tthis.penumbra = source.penumbra;\r\n\tthis.decay = source.decay;\r\n\r\n\tthis.target = source.target.clone();\r\n\r\n\tthis.shadow = source.shadow.clone();\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/loaders/Cache.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Cache = {\r\n\r\n\tenabled: false,\r\n\r\n\tfiles: {},\r\n\r\n\tadd: function ( key, file ) {\r\n\r\n\t\tif ( this.enabled === false ) return;\r\n\r\n\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\r\n\r\n\t\tthis.files[ key ] = file;\r\n\r\n\t},\r\n\r\n\tget: function ( key ) {\r\n\r\n\t\tif ( this.enabled === false ) return;\r\n\r\n\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\r\n\r\n\t\treturn this.files[ key ];\r\n\r\n\t},\r\n\r\n\tremove: function ( key ) {\r\n\r\n\t\tdelete this.files[ key ];\r\n\r\n\t},\r\n\r\n\tclear: function () {\r\n\r\n\t\tthis.files = {};\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/Loader.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Loader = function () {\r\n\r\n\tthis.onLoadStart = function () {};\r\n\tthis.onLoadProgress = function () {};\r\n\tthis.onLoadComplete = function () {};\r\n\r\n};\r\n\r\nTHREE.Loader.prototype = {\r\n\r\n\tconstructor: THREE.Loader,\r\n\r\n\tcrossOrigin: undefined,\r\n\r\n\textractUrlBase: function ( url ) {\r\n\r\n\t\tvar parts = url.split( '/' );\r\n\r\n\t\tif ( parts.length === 1 ) return './';\r\n\r\n\t\tparts.pop();\r\n\r\n\t\treturn parts.join( '/' ) + '/';\r\n\r\n\t},\r\n\r\n\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\r\n\r\n\t\tvar array = [];\r\n\r\n\t\tfor ( var i = 0; i < materials.length; ++ i ) {\r\n\r\n\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\r\n\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tcreateMaterial: ( function () {\r\n\r\n\t\tvar color, textureLoader, materialLoader;\r\n\r\n\t\treturn function ( m, texturePath, crossOrigin ) {\r\n\r\n\t\t\tif ( color === undefined ) color = new THREE.Color();\r\n\t\t\tif ( textureLoader === undefined ) textureLoader = new THREE.TextureLoader();\r\n\t\t\tif ( materialLoader === undefined ) materialLoader = new THREE.MaterialLoader();\r\n\r\n\t\t\t// convert from old material format\r\n\r\n\t\t\tvar textures = {};\r\n\r\n\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\r\n\r\n\t\t\t\tvar fullPath = texturePath + path;\r\n\t\t\t\tvar loader = THREE.Loader.Handlers.get( fullPath );\r\n\r\n\t\t\t\tvar texture;\r\n\r\n\t\t\t\tif ( loader !== null ) {\r\n\r\n\t\t\t\t\ttexture = loader.load( fullPath );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttextureLoader.setCrossOrigin( crossOrigin );\r\n\t\t\t\t\ttexture = textureLoader.load( fullPath );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( repeat !== undefined ) {\r\n\r\n\t\t\t\t\ttexture.repeat.fromArray( repeat );\r\n\r\n\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\r\n\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( offset !== undefined ) {\r\n\r\n\t\t\t\t\ttexture.offset.fromArray( offset );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( wrap !== undefined ) {\r\n\r\n\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;\r\n\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;\r\n\r\n\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;\r\n\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( anisotropy !== undefined ) {\r\n\r\n\t\t\t\t\ttexture.anisotropy = anisotropy;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar uuid = THREE.Math.generateUUID();\r\n\r\n\t\t\t\ttextures[ uuid ] = texture;\r\n\r\n\t\t\t\treturn uuid;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//\r\n\r\n\t\t\tvar json = {\r\n\t\t\t\tuuid: THREE.Math.generateUUID(),\r\n\t\t\t\ttype: 'MeshLambertMaterial'\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var name in m ) {\r\n\r\n\t\t\t\tvar value = m[ name ];\r\n\r\n\t\t\t\tswitch ( name ) {\r\n\t\t\t\t\tcase 'DbgColor':\r\n\t\t\t\t\tcase 'DbgIndex':\r\n\t\t\t\t\tcase 'opticalDensity':\r\n\t\t\t\t\tcase 'illumination':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'DbgName':\r\n\t\t\t\t\t\tjson.name = value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'blending':\r\n\t\t\t\t\t\tjson.blending = THREE[ value ];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'colorAmbient':\r\n\t\t\t\t\tcase 'mapAmbient':\r\n\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'colorDiffuse':\r\n\t\t\t\t\t\tjson.color = color.fromArray( value ).getHex();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'colorSpecular':\r\n\t\t\t\t\t\tjson.specular = color.fromArray( value ).getHex();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'colorEmissive':\r\n\t\t\t\t\t\tjson.emissive = color.fromArray( value ).getHex();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'specularCoef':\r\n\t\t\t\t\t\tjson.shininess = value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'shading':\r\n\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\r\n\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapDiffuse':\r\n\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapDiffuseRepeat':\r\n\t\t\t\t\tcase 'mapDiffuseOffset':\r\n\t\t\t\t\tcase 'mapDiffuseWrap':\r\n\t\t\t\t\tcase 'mapDiffuseAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapLight':\r\n\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapLightRepeat':\r\n\t\t\t\t\tcase 'mapLightOffset':\r\n\t\t\t\t\tcase 'mapLightWrap':\r\n\t\t\t\t\tcase 'mapLightAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapAO':\r\n\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapAORepeat':\r\n\t\t\t\t\tcase 'mapAOOffset':\r\n\t\t\t\t\tcase 'mapAOWrap':\r\n\t\t\t\t\tcase 'mapAOAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapBump':\r\n\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapBumpScale':\r\n\t\t\t\t\t\tjson.bumpScale = value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapBumpRepeat':\r\n\t\t\t\t\tcase 'mapBumpOffset':\r\n\t\t\t\t\tcase 'mapBumpWrap':\r\n\t\t\t\t\tcase 'mapBumpAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapNormal':\r\n\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapNormalFactor':\r\n\t\t\t\t\t\tjson.normalScale = [ value, value ];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapNormalRepeat':\r\n\t\t\t\t\tcase 'mapNormalOffset':\r\n\t\t\t\t\tcase 'mapNormalWrap':\r\n\t\t\t\t\tcase 'mapNormalAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapSpecular':\r\n\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapSpecularRepeat':\r\n\t\t\t\t\tcase 'mapSpecularOffset':\r\n\t\t\t\t\tcase 'mapSpecularWrap':\r\n\t\t\t\t\tcase 'mapSpecularAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapAlpha':\r\n\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapAlphaRepeat':\r\n\t\t\t\t\tcase 'mapAlphaOffset':\r\n\t\t\t\t\tcase 'mapAlphaWrap':\r\n\t\t\t\t\tcase 'mapAlphaAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'flipSided':\r\n\t\t\t\t\t\tjson.side = THREE.BackSide;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'doubleSided':\r\n\t\t\t\t\t\tjson.side = THREE.DoubleSide;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'transparency':\r\n\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\r\n\t\t\t\t\t\tjson.opacity = value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'depthTest':\r\n\t\t\t\t\tcase 'depthWrite':\r\n\t\t\t\t\tcase 'colorWrite':\r\n\t\t\t\t\tcase 'opacity':\r\n\t\t\t\t\tcase 'reflectivity':\r\n\t\t\t\t\tcase 'transparent':\r\n\t\t\t\t\tcase 'visible':\r\n\t\t\t\t\tcase 'wireframe':\r\n\t\t\t\t\t\tjson[ name ] = value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'vertexColors':\r\n\t\t\t\t\t\tif ( value === true ) json.vertexColors = THREE.VertexColors;\r\n\t\t\t\t\t\tif ( value === 'face' ) json.vertexColors = THREE.FaceColors;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\r\n\t\t\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\r\n\r\n\t\t\tif ( json.opacity < 1 ) json.transparent = true;\r\n\r\n\t\t\tmaterialLoader.setTextures( textures );\r\n\r\n\t\t\treturn materialLoader.parse( json );\r\n\r\n\t\t};\r\n\r\n\t} )()\r\n\r\n};\r\n\r\nTHREE.Loader.Handlers = {\r\n\r\n\thandlers: [],\r\n\r\n\tadd: function ( regex, loader ) {\r\n\r\n\t\tthis.handlers.push( regex, loader );\r\n\r\n\t},\r\n\r\n\tget: function ( file ) {\r\n\r\n\t\tvar handlers = this.handlers;\r\n\r\n\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\r\n\r\n\t\t\tvar regex = handlers[ i ];\r\n\t\t\tvar loader  = handlers[ i + 1 ];\r\n\r\n\t\t\tif ( regex.test( file ) ) {\r\n\r\n\t\t\t\treturn loader;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/XHRLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.XHRLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.XHRLoader.prototype = {\r\n\r\n\tconstructor: THREE.XHRLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tif ( this.path !== undefined ) url = this.path + url;\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar cached = THREE.Cache.get( url );\r\n\r\n\t\tif ( cached !== undefined ) {\r\n\r\n\t\t\tif ( onLoad ) {\r\n\r\n\t\t\t\tsetTimeout( function () {\r\n\r\n\t\t\t\t\tonLoad( cached );\r\n\r\n\t\t\t\t}, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn cached;\r\n\r\n\t\t}\r\n\r\n\t\tvar request = new XMLHttpRequest();\r\n\t\trequest.overrideMimeType( 'text/plain' );\r\n\t\trequest.open( 'GET', url, true );\r\n\r\n\t\trequest.addEventListener( 'load', function ( event ) {\r\n\r\n\t\t\tvar response = event.target.response;\r\n\r\n\t\t\tTHREE.Cache.add( url, response );\r\n\r\n\t\t\tif ( this.status === 200 ) {\r\n\r\n\t\t\t\tif ( onLoad ) onLoad( response );\r\n\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t} else if ( this.status === 0 ) {\r\n\r\n\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\r\n\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\r\n\r\n\t\t\t\tconsole.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );\r\n\r\n\t\t\t\tif ( onLoad ) onLoad( response );\r\n\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( onError ) onError( event );\r\n\r\n\t\t\t\tscope.manager.itemError( url );\r\n\r\n\t\t\t}\r\n\r\n\t\t}, false );\r\n\r\n\t\tif ( onProgress !== undefined ) {\r\n\r\n\t\t\trequest.addEventListener( 'progress', function ( event ) {\r\n\r\n\t\t\t\tonProgress( event );\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t}\r\n\r\n\t\trequest.addEventListener( 'error', function ( event ) {\r\n\r\n\t\t\tif ( onError ) onError( event );\r\n\r\n\t\t\tscope.manager.itemError( url );\r\n\r\n\t\t}, false );\r\n\r\n\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\r\n\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\r\n\r\n\t\trequest.send( null );\r\n\r\n\t\tscope.manager.itemStart( url );\r\n\r\n\t\treturn request;\r\n\r\n\t},\r\n\r\n\tsetPath: function ( value ) {\r\n\r\n\t\tthis.path = value;\r\n\r\n\t},\r\n\r\n\tsetResponseType: function ( value ) {\r\n\r\n\t\tthis.responseType = value;\r\n\r\n\t},\r\n\r\n\tsetWithCredentials: function ( value ) {\r\n\r\n\t\tthis.withCredentials = value;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/FontLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.FontLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.FontLoader.prototype = {\r\n\r\n\tconstructor: THREE.FontLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( new THREE.Font( JSON.parse( text.substring( 65, text.length - 2 ) ) ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/ImageLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.ImageLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.ImageLoader.prototype = {\r\n\r\n\tconstructor: THREE.ImageLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tif ( this.path !== undefined ) url = this.path + url;\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar cached = THREE.Cache.get( url );\r\n\r\n\t\tif ( cached !== undefined ) {\r\n\r\n\t\t\tscope.manager.itemStart( url );\r\n\r\n\t\t\tif ( onLoad ) {\r\n\r\n\t\t\t\tsetTimeout( function () {\r\n\r\n\t\t\t\t\tonLoad( cached );\r\n\r\n\t\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t\t}, 0 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn cached;\r\n\r\n\t\t}\r\n\r\n\t\tvar image = document.createElement( 'img' );\r\n\r\n\t\timage.addEventListener( 'load', function ( event ) {\r\n\r\n\t\t\tTHREE.Cache.add( url, this );\r\n\r\n\t\t\tif ( onLoad ) onLoad( this );\r\n\r\n\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t}, false );\r\n\r\n\t\tif ( onProgress !== undefined ) {\r\n\r\n\t\t\timage.addEventListener( 'progress', function ( event ) {\r\n\r\n\t\t\t\tonProgress( event );\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t}\r\n\r\n\t\timage.addEventListener( 'error', function ( event ) {\r\n\r\n\t\t\tif ( onError ) onError( event );\r\n\r\n\t\t\tscope.manager.itemError( url );\r\n\r\n\t\t}, false );\r\n\r\n\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\r\n\r\n\t\tscope.manager.itemStart( url );\r\n\r\n\t\timage.src = url;\r\n\r\n\t\treturn image;\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tsetPath: function ( value ) {\r\n\r\n\t\tthis.path = value;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/JSONLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.JSONLoader = function ( manager ) {\r\n\r\n\tif ( typeof manager === 'boolean' ) {\r\n\r\n\t\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\r\n\t\tmanager = undefined;\r\n\r\n\t}\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n\tthis.withCredentials = false;\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype = {\r\n\r\n\tconstructor: THREE.JSONLoader,\r\n\r\n\t// Deprecated\r\n\r\n\tget statusDomElement () {\r\n\r\n\t\tif ( this._statusDomElement === undefined ) {\r\n\r\n\t\t\tthis._statusDomElement = document.createElement( 'div' );\r\n\r\n\t\t}\r\n\r\n\t\tconsole.warn( 'THREE.JSONLoader: .statusDomElement has been removed.' );\r\n\t\treturn this._statusDomElement;\r\n\r\n\t},\r\n\r\n\tload: function( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar texturePath = this.texturePath && ( typeof this.texturePath === \"string\" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );\r\n\r\n\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\tloader.setWithCredentials( this.withCredentials );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tvar json = JSON.parse( text );\r\n\t\t\tvar metadata = json.metadata;\r\n\r\n\t\t\tif ( metadata !== undefined ) {\r\n\r\n\t\t\t\tvar type = metadata.type;\r\n\r\n\t\t\t\tif ( type !== undefined ) {\r\n\r\n\t\t\t\t\tif ( type.toLowerCase() === 'object' ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( type.toLowerCase() === 'scene' ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar object = scope.parse( json, texturePath );\r\n\t\t\tonLoad( object.geometry, object.materials );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tsetTexturePath: function ( value ) {\r\n\r\n\t\tthis.texturePath = value;\r\n\r\n\t},\r\n\r\n\tparse: function ( json, texturePath ) {\r\n\r\n\t\tvar geometry = new THREE.Geometry(),\r\n\t\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\r\n\r\n\t\tparseModel( scale );\r\n\r\n\t\tparseSkin();\r\n\t\tparseMorphing( scale );\r\n\t\tparseAnimations();\r\n\r\n\t\tgeometry.computeFaceNormals();\r\n\t\tgeometry.computeBoundingSphere();\r\n\r\n\t\tfunction parseModel( scale ) {\r\n\r\n\t\t\tfunction isBitSet( value, position ) {\r\n\r\n\t\t\t\treturn value & ( 1 << position );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar i, j, fi,\r\n\r\n\t\t\toffset, zLength,\r\n\r\n\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\r\n\r\n\t\t\ttype,\r\n\t\t\tisQuad,\r\n\t\t\thasMaterial,\r\n\t\t\thasFaceVertexUv,\r\n\t\t\thasFaceNormal, hasFaceVertexNormal,\r\n\t\t\thasFaceColor, hasFaceVertexColor,\r\n\r\n\t\tvertex, face, faceA, faceB, hex, normal,\r\n\r\n\t\t\tuvLayer, uv, u, v,\r\n\r\n\t\t\tfaces = json.faces,\r\n\t\t\tvertices = json.vertices,\r\n\t\t\tnormals = json.normals,\r\n\t\t\tcolors = json.colors,\r\n\r\n\t\t\tnUvLayers = 0;\r\n\r\n\t\t\tif ( json.uvs !== undefined ) {\r\n\r\n\t\t\t\t// disregard empty arrays\r\n\r\n\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\r\n\r\n\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\r\n\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\toffset = 0;\r\n\t\t\tzLength = vertices.length;\r\n\r\n\t\t\twhile ( offset < zLength ) {\r\n\r\n\t\t\t\tvertex = new THREE.Vector3();\r\n\r\n\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\r\n\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\r\n\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\r\n\r\n\t\t\t\tgeometry.vertices.push( vertex );\r\n\r\n\t\t\t}\r\n\r\n\t\t\toffset = 0;\r\n\t\t\tzLength = faces.length;\r\n\r\n\t\t\twhile ( offset < zLength ) {\r\n\r\n\t\t\t\ttype = faces[ offset ++ ];\r\n\r\n\r\n\t\t\t\tisQuad              = isBitSet( type, 0 );\r\n\t\t\t\thasMaterial         = isBitSet( type, 1 );\r\n\t\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\r\n\t\t\t\thasFaceNormal       = isBitSet( type, 4 );\r\n\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\r\n\t\t\t\thasFaceColor\t     = isBitSet( type, 6 );\r\n\t\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\r\n\r\n\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\r\n\r\n\t\t\t\tif ( isQuad ) {\r\n\r\n\t\t\t\t\tfaceA = new THREE.Face3();\r\n\t\t\t\t\tfaceA.a = faces[ offset ];\r\n\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\r\n\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\r\n\r\n\t\t\t\t\tfaceB = new THREE.Face3();\r\n\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\r\n\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\r\n\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\r\n\r\n\t\t\t\t\toffset += 4;\r\n\r\n\t\t\t\t\tif ( hasMaterial ) {\r\n\r\n\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\r\n\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// to get face <=> uv index correspondence\r\n\r\n\t\t\t\t\tfi = geometry.faces.length;\r\n\r\n\t\t\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\r\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\r\n\r\n\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\r\n\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\r\n\r\n\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\t\tfaceA.normal.set(\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\t\t\tnormal = new THREE.Vector3(\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t\t);\r\n\r\n\r\n\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\r\n\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\thex = colors[ colorIndex ];\r\n\r\n\t\t\t\t\t\tfaceA.color.setHex( hex );\r\n\t\t\t\t\t\tfaceB.color.setHex( hex );\r\n\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\thex = colors[ colorIndex ];\r\n\r\n\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );\r\n\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgeometry.faces.push( faceA );\r\n\t\t\t\t\tgeometry.faces.push( faceB );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tface = new THREE.Face3();\r\n\t\t\t\t\tface.a = faces[ offset ++ ];\r\n\t\t\t\t\tface.b = faces[ offset ++ ];\r\n\t\t\t\t\tface.c = faces[ offset ++ ];\r\n\r\n\t\t\t\t\tif ( hasMaterial ) {\r\n\r\n\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\tface.materialIndex = materialIndex;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// to get face <=> uv index correspondence\r\n\r\n\t\t\t\t\tfi = geometry.faces.length;\r\n\r\n\t\t\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\r\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\r\n\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\r\n\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\r\n\r\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\t\tface.normal.set(\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\t\t\tnormal = new THREE.Vector3(\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\tface.vertexNormals.push( normal );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\tface.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgeometry.faces.push( face );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tfunction parseSkin() {\r\n\r\n\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\r\n\r\n\t\t\tif ( json.skinWeights ) {\r\n\r\n\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\r\n\r\n\t\t\t\t\tvar x =                               json.skinWeights[ i ];\r\n\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\r\n\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\r\n\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\r\n\r\n\t\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( json.skinIndices ) {\r\n\r\n\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\r\n\r\n\t\t\t\t\tvar a =                               json.skinIndices[ i ];\r\n\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\r\n\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\r\n\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\r\n\r\n\t\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.bones = json.bones;\r\n\r\n\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\r\n\r\n\t\t\t\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\r\n\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tfunction parseMorphing( scale ) {\r\n\r\n\t\t\tif ( json.morphTargets !== undefined ) {\r\n\r\n\t\t\t\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tgeometry.morphTargets[ i ] = {};\r\n\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\r\n\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\r\n\r\n\t\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\r\n\t\t\t\t\tvar srcVertices = json.morphTargets[ i ].vertices;\r\n\r\n\t\t\t\t\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\r\n\r\n\t\t\t\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\r\n\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\r\n\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\r\n\r\n\t\t\t\t\t\tdstVertices.push( vertex );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\r\n\r\n\t\t\t\tvar faces = geometry.faces;\r\n\t\t\t\tvar morphColors = json.morphColors[ 0 ].colors;\r\n\r\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tfaces[ i ].color.fromArray( morphColors, i * 3 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseAnimations() {\r\n\r\n\t\t\tvar outputAnimations = [];\r\n\r\n\t\t\t// parse old style Bone/Hierarchy animations\r\n\t\t\tvar animations = [];\r\n\r\n\t\t\tif ( json.animation !== undefined ) {\r\n\r\n\t\t\t\tanimations.push( json.animation );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( json.animations !== undefined ) {\r\n\r\n\t\t\t\tif ( json.animations.length ) {\r\n\r\n\t\t\t\t\tanimations = animations.concat( json.animations );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tanimations.push( json.animations );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0; i < animations.length; i ++ ) {\r\n\r\n\t\t\t\tvar clip = THREE.AnimationClip.parseAnimation( animations[ i ], geometry.bones );\r\n\t\t\t\tif ( clip ) outputAnimations.push( clip );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// parse implicit morph animations\r\n\t\t\tif ( geometry.morphTargets ) {\r\n\r\n\t\t\t\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\r\n\t\t\t\tvar morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\r\n\t\t\t\toutputAnimations = outputAnimations.concat( morphAnimationClips );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\r\n\r\n\t\t};\r\n\r\n\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\r\n\r\n\t\t\treturn { geometry: geometry };\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\r\n\r\n\t\t\treturn { geometry: geometry, materials: materials };\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/LoadingManager.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LoadingManager = function ( onLoad, onProgress, onError ) {\r\n\r\n\tvar scope = this;\r\n\r\n\tvar isLoading = false, itemsLoaded = 0, itemsTotal = 0;\r\n\r\n\tthis.onStart = undefined;\r\n\tthis.onLoad = onLoad;\r\n\tthis.onProgress = onProgress;\r\n\tthis.onError = onError;\r\n\r\n\tthis.itemStart = function ( url ) {\r\n\r\n\t\titemsTotal ++;\r\n\r\n\t\tif ( isLoading === false ) {\r\n\r\n\t\t\tif ( scope.onStart !== undefined ) {\r\n\r\n\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tisLoading = true;\r\n\r\n\t};\r\n\r\n\tthis.itemEnd = function ( url ) {\r\n\r\n\t\titemsLoaded ++;\r\n\r\n\t\tif ( scope.onProgress !== undefined ) {\r\n\r\n\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\r\n\r\n\t\t}\r\n\r\n\t\tif ( itemsLoaded === itemsTotal ) {\r\n\r\n\t\t\tisLoading = false;\r\n\r\n\t\t\tif ( scope.onLoad !== undefined ) {\r\n\r\n\t\t\t\tscope.onLoad();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.itemError = function ( url ) {\r\n\r\n\t\tif ( scope.onError !== undefined ) {\r\n\r\n\t\t\tscope.onError( url );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.DefaultLoadingManager = new THREE.LoadingManager();\r\n\r\n// File:src/loaders/BufferGeometryLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BufferGeometryLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.BufferGeometryLoader.prototype = {\r\n\r\n\tconstructor: THREE.BufferGeometryLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tparse: function ( json ) {\r\n\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\r\n\t\tvar index = json.data.index;\r\n\r\n\t\tvar TYPED_ARRAYS = {\r\n\t\t\t'Int8Array': Int8Array,\r\n\t\t\t'Uint8Array': Uint8Array,\r\n\t\t\t'Uint8ClampedArray': Uint8ClampedArray,\r\n\t\t\t'Int16Array': Int16Array,\r\n\t\t\t'Uint16Array': Uint16Array,\r\n\t\t\t'Int32Array': Int32Array,\r\n\t\t\t'Uint32Array': Uint32Array,\r\n\t\t\t'Float32Array': Float32Array,\r\n\t\t\t'Float64Array': Float64Array\r\n\t\t};\r\n\r\n\t\tif ( index !== undefined ) {\r\n\r\n\t\t\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\r\n\t\t\tgeometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar attributes = json.data.attributes;\r\n\r\n\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ key ];\r\n\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\r\n\r\n\t\t\tgeometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\r\n\r\n\t\tif ( groups !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\tvar group = groups[ i ];\r\n\r\n\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar boundingSphere = json.data.boundingSphere;\r\n\r\n\t\tif ( boundingSphere !== undefined ) {\r\n\r\n\t\t\tvar center = new THREE.Vector3();\r\n\r\n\t\t\tif ( boundingSphere.center !== undefined ) {\r\n\r\n\t\t\t\tcenter.fromArray( boundingSphere.center );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/MaterialLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.MaterialLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\tthis.textures = {};\r\n\r\n};\r\n\r\nTHREE.MaterialLoader.prototype = {\r\n\r\n\tconstructor: THREE.MaterialLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tsetTextures: function ( value ) {\r\n\r\n\t\tthis.textures = value;\r\n\r\n\t},\r\n\r\n\tgetTexture: function ( name ) {\r\n\r\n\t\tvar textures = this.textures;\r\n\r\n\t\tif ( textures[ name ] === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\r\n\r\n\t\t}\r\n\r\n\t\treturn textures[ name ];\r\n\r\n\t},\r\n\r\n\tparse: function ( json ) {\r\n\r\n\t\tvar material = new THREE[ json.type ];\r\n\r\n\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\r\n\t\tif ( json.name !== undefined ) material.name = json.name;\r\n\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\r\n\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\r\n\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\r\n\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\r\n\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\r\n\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\r\n\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\r\n\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\r\n\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\r\n\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\r\n\t\tif ( json.shading !== undefined ) material.shading = json.shading;\r\n\t\tif ( json.blending !== undefined ) material.blending = json.blending;\r\n\t\tif ( json.side !== undefined ) material.side = json.side;\r\n\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\r\n\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\r\n\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\r\n\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\r\n\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\r\n\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\r\n\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\r\n\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\r\n\r\n\t\t// for PointsMaterial\r\n\t\tif ( json.size !== undefined ) material.size = json.size;\r\n\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\r\n\r\n\t\t// maps\r\n\r\n\t\tif ( json.map !== undefined ) material.map = this.getTexture( json.map );\r\n\r\n\t\tif ( json.alphaMap !== undefined ) {\r\n\r\n\t\t\tmaterial.alphaMap = this.getTexture( json.alphaMap );\r\n\t\t\tmaterial.transparent = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );\r\n\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\r\n\r\n\t\tif ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );\r\n\t\tif ( json.normalScale !== undefined ) {\r\n\r\n\t\t\tvar normalScale = json.normalScale;\r\n\r\n\t\t\tif ( Array.isArray( normalScale ) === false ) {\r\n\r\n\t\t\t\t// Blender exporter used to export a scalar. See #7459\r\n\r\n\t\t\t\tnormalScale = [ normalScale, normalScale ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterial.normalScale = new THREE.Vector2().fromArray( normalScale );\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );\r\n\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\r\n\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\r\n\r\n\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = this.getTexture( json.roughnessMap );\r\n\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = this.getTexture( json.metalnessMap );\r\n\r\n\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = this.getTexture( json.emissiveMap );\r\n\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\r\n\r\n\t\tif ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );\r\n\r\n\t\tif ( json.envMap !== undefined ) {\r\n\r\n\t\t\tmaterial.envMap = this.getTexture( json.envMap );\r\n\t\t\tmaterial.combine = THREE.MultiplyOperation;\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.reflectivity ) material.reflectivity = json.reflectivity;\r\n\r\n\t\tif ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );\r\n\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\r\n\r\n\t\tif ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );\r\n\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\r\n\r\n\t\t// MultiMaterial\r\n\r\n\t\tif ( json.materials !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/ObjectLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.ObjectLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\tthis.texturePath = '';\r\n\r\n};\r\n\r\nTHREE.ObjectLoader.prototype = {\r\n\r\n\tconstructor: THREE.ObjectLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tif ( this.texturePath === '' ) {\r\n\r\n\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\r\n\r\n\t\t}\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tscope.parse( JSON.parse( text ), onLoad );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tsetTexturePath: function ( value ) {\r\n\r\n\t\tthis.texturePath = value;\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tparse: function ( json, onLoad ) {\r\n\r\n\t\tvar geometries = this.parseGeometries( json.geometries );\r\n\r\n\t\tvar images = this.parseImages( json.images, function () {\r\n\r\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\r\n\r\n\t\t} );\r\n\r\n\t\tvar textures  = this.parseTextures( json.textures, images );\r\n\t\tvar materials = this.parseMaterials( json.materials, textures );\r\n\r\n\t\tvar object = this.parseObject( json.object, geometries, materials );\r\n\r\n\t\tif ( json.animations ) {\r\n\r\n\t\t\tobject.animations = this.parseAnimations( json.animations );\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.images === undefined || json.images.length === 0 ) {\r\n\r\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\r\n\r\n\t\t}\r\n\r\n\t\treturn object;\r\n\r\n\t},\r\n\r\n\tparseGeometries: function ( json ) {\r\n\r\n\t\tvar geometries = {};\r\n\r\n\t\tif ( json !== undefined ) {\r\n\r\n\t\t\tvar geometryLoader = new THREE.JSONLoader();\r\n\t\t\tvar bufferGeometryLoader = new THREE.BufferGeometryLoader();\r\n\r\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar geometry;\r\n\t\t\t\tvar data = json[ i ];\r\n\r\n\t\t\t\tswitch ( data.type ) {\r\n\r\n\t\t\t\t\tcase 'PlaneGeometry':\r\n\t\t\t\t\tcase 'PlaneBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.width,\r\n\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'BoxGeometry':\r\n\t\t\t\t\tcase 'BoxBufferGeometry':\r\n\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.width,\r\n\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\tdata.depth,\r\n\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\tdata.depthSegments\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'CircleGeometry':\r\n\t\t\t\t\tcase 'CircleBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.segments,\r\n\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'CylinderGeometry':\r\n\t\t\t\t\tcase 'CylinderBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.radiusTop,\r\n\t\t\t\t\t\t\tdata.radiusBottom,\r\n\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\tdata.openEnded,\r\n\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'SphereGeometry':\r\n\t\t\t\t\tcase 'SphereBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\tdata.phiStart,\r\n\t\t\t\t\t\t\tdata.phiLength,\r\n\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'DodecahedronGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.DodecahedronGeometry(\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.detail\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'IcosahedronGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.IcosahedronGeometry(\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.detail\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'OctahedronGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.OctahedronGeometry(\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.detail\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'TetrahedronGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.TetrahedronGeometry(\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.detail\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'RingGeometry':\r\n\t\t\t\t\tcase 'RingBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.innerRadius,\r\n\t\t\t\t\t\t\tdata.outerRadius,\r\n\t\t\t\t\t\t\tdata.thetaSegments,\r\n\t\t\t\t\t\t\tdata.phiSegments,\r\n\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'TorusGeometry':\r\n\t\t\t\t\tcase 'TorusBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.tube,\r\n\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\tdata.tubularSegments,\r\n\t\t\t\t\t\t\tdata.arc\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'TorusKnotGeometry':\r\n\t\t\t\t\tcase 'TorusKnotBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.tube,\r\n\t\t\t\t\t\t\tdata.tubularSegments,\r\n\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\tdata.p,\r\n\t\t\t\t\t\t\tdata.q\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'LatheGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE.LatheGeometry(\r\n\t\t\t\t\t\t\tdata.points,\r\n\t\t\t\t\t\t\tdata.segments,\r\n\t\t\t\t\t\t\tdata.phiStart,\r\n\t\t\t\t\t\t\tdata.phiLength\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'BufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'Geometry':\r\n\r\n\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data, this.texturePath ).geometry;\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\r\n\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.uuid = data.uuid;\r\n\r\n\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\r\n\r\n\t\t\t\tgeometries[ data.uuid ] = geometry;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn geometries;\r\n\r\n\t},\r\n\r\n\tparseMaterials: function ( json, textures ) {\r\n\r\n\t\tvar materials = {};\r\n\r\n\t\tif ( json !== undefined ) {\r\n\r\n\t\t\tvar loader = new THREE.MaterialLoader();\r\n\t\t\tloader.setTextures( textures );\r\n\r\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar material = loader.parse( json[ i ] );\r\n\t\t\t\tmaterials[ material.uuid ] = material;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn materials;\r\n\r\n\t},\r\n\r\n\tparseAnimations: function ( json ) {\r\n\r\n\t\tvar animations = [];\r\n\r\n\t\tfor ( var i = 0; i < json.length; i ++ ) {\r\n\r\n\t\t\tvar clip = THREE.AnimationClip.parse( json[ i ] );\r\n\r\n\t\t\tanimations.push( clip );\r\n\r\n\t\t}\r\n\r\n\t\treturn animations;\r\n\r\n\t},\r\n\r\n\tparseImages: function ( json, onLoad ) {\r\n\r\n\t\tvar scope = this;\r\n\t\tvar images = {};\r\n\r\n\t\tfunction loadImage( url ) {\r\n\r\n\t\t\tscope.manager.itemStart( url );\r\n\r\n\t\t\treturn loader.load( url, function () {\r\n\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\tif ( json !== undefined && json.length > 0 ) {\r\n\r\n\t\t\tvar manager = new THREE.LoadingManager( onLoad );\r\n\r\n\t\t\tvar loader = new THREE.ImageLoader( manager );\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\r\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar image = json[ i ];\r\n\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\r\n\r\n\t\t\t\timages[ image.uuid ] = loadImage( path );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn images;\r\n\r\n\t},\r\n\r\n\tparseTextures: function ( json, images ) {\r\n\r\n\t\tfunction parseConstant( value ) {\r\n\r\n\t\t\tif ( typeof( value ) === 'number' ) return value;\r\n\r\n\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\r\n\r\n\t\t\treturn THREE[ value ];\r\n\r\n\t\t}\r\n\r\n\t\tvar textures = {};\r\n\r\n\t\tif ( json !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar data = json[ i ];\r\n\r\n\t\t\t\tif ( data.image === undefined ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( images[ data.image ] === undefined ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar texture = new THREE.Texture( images[ data.image ] );\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\ttexture.uuid = data.uuid;\r\n\r\n\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\r\n\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );\r\n\t\t\t\tif ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );\r\n\t\t\t\tif ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );\r\n\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );\r\n\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );\r\n\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\r\n\t\t\t\tif ( Array.isArray( data.wrap ) ) {\r\n\r\n\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ] );\r\n\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttextures[ data.uuid ] = texture;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn textures;\r\n\r\n\t},\r\n\r\n\tparseObject: function () {\r\n\r\n\t\tvar matrix = new THREE.Matrix4();\r\n\r\n\t\treturn function ( data, geometries, materials ) {\r\n\r\n\t\t\tvar object;\r\n\r\n\t\t\tfunction getGeometry( name ) {\r\n\r\n\t\t\t\tif ( geometries[ name ] === undefined ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn geometries[ name ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction getMaterial( name ) {\r\n\r\n\t\t\t\tif ( name === undefined ) return undefined;\r\n\r\n\t\t\t\tif ( materials[ name ] === undefined ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn materials[ name ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tswitch ( data.type ) {\r\n\r\n\t\t\t\tcase 'Scene':\r\n\r\n\t\t\t\t\tobject = new THREE.Scene();\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'PerspectiveCamera':\r\n\r\n\t\t\t\t\tobject = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'OrthographicCamera':\r\n\r\n\t\t\t\t\tobject = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'AmbientLight':\r\n\r\n\t\t\t\t\tobject = new THREE.AmbientLight( data.color, data.intensity );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'DirectionalLight':\r\n\r\n\t\t\t\t\tobject = new THREE.DirectionalLight( data.color, data.intensity );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'PointLight':\r\n\r\n\t\t\t\t\tobject = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'SpotLight':\r\n\r\n\t\t\t\t\tobject = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'HemisphereLight':\r\n\r\n\t\t\t\t\tobject = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Mesh':\r\n\r\n\t\t\t\t\tvar geometry = getGeometry( data.geometry );\r\n\t\t\t\t\tvar material = getMaterial( data.material );\r\n\r\n\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 ) {\r\n\r\n\t\t\t\t\t\tobject = new THREE.SkinnedMesh( geometry, material );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tobject = new THREE.Mesh( geometry, material );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'LOD':\r\n\r\n\t\t\t\t\tobject = new THREE.LOD();\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Line':\r\n\r\n\t\t\t\t\tobject = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'PointCloud':\r\n\t\t\t\tcase 'Points':\r\n\r\n\t\t\t\t\tobject = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Sprite':\r\n\r\n\t\t\t\t\tobject = new THREE.Sprite( getMaterial( data.material ) );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Group':\r\n\r\n\t\t\t\t\tobject = new THREE.Group();\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\r\n\t\t\t\t\tobject = new THREE.Object3D();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.uuid = data.uuid;\r\n\r\n\t\t\tif ( data.name !== undefined ) object.name = data.name;\r\n\t\t\tif ( data.matrix !== undefined ) {\r\n\r\n\t\t\t\tmatrix.fromArray( data.matrix );\r\n\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\r\n\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\r\n\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\r\n\t\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\r\n\r\n\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\r\n\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\r\n\r\n\t\t\tif ( data.children !== undefined ) {\r\n\r\n\t\t\t\tfor ( var child in data.children ) {\r\n\r\n\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( data.type === 'LOD' ) {\r\n\r\n\t\t\t\tvar levels = data.levels;\r\n\r\n\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\r\n\r\n\t\t\t\t\tvar level = levels[ l ];\r\n\t\t\t\t\tvar child = object.getObjectByProperty( 'uuid', level.object );\r\n\r\n\t\t\t\t\tif ( child !== undefined ) {\r\n\r\n\t\t\t\t\t\tobject.addLevel( child, level.distance );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn object;\r\n\r\n\t\t};\r\n\r\n\t}()\r\n\r\n};\r\n\r\n// File:src/loaders/TextureLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.TextureLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.TextureLoader.prototype = {\r\n\r\n\tconstructor: THREE.TextureLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar texture = new THREE.Texture();\r\n\r\n\t\tvar loader = new THREE.ImageLoader( this.manager );\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.setPath( this.path );\r\n\t\tloader.load( url, function ( image ) {\r\n\r\n\t\t\ttexture.image = image;\r\n\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\tif ( onLoad !== undefined ) {\r\n\r\n\t\t\t\tonLoad( texture );\r\n\r\n\t\t\t}\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tsetPath: function ( value ) {\r\n\r\n\t\tthis.path = value;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/CubeTextureLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CubeTextureLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.CubeTextureLoader.prototype = {\r\n\r\n\tconstructor: THREE.CubeTextureLoader,\r\n\r\n\tload: function ( urls, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar texture = new THREE.CubeTexture();\r\n\r\n\t\tvar loader = new THREE.ImageLoader( this.manager );\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.setPath( this.path );\r\n\r\n\t\tvar loaded = 0;\r\n\r\n\t\tfunction loadTexture( i ) {\r\n\r\n\t\t\tloader.load( urls[ i ], function ( image ) {\r\n\r\n\t\t\t\ttexture.images[ i ] = image;\r\n\r\n\t\t\t\tloaded ++;\r\n\r\n\t\t\t\tif ( loaded === 6 ) {\r\n\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, undefined, onError );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < urls.length; ++ i ) {\r\n\r\n\t\t\tloadTexture( i );\r\n\r\n\t\t}\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tsetPath: function ( value ) {\r\n\r\n\t\tthis.path = value;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/BinaryTextureLoader.js\r\n\r\n/**\r\n * @author Nikos M. / https://github.com/foo123/\r\n *\r\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\r\n */\r\n\r\nTHREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n\t// override in sub classes\r\n\tthis._parser = null;\r\n\r\n};\r\n\r\nTHREE.BinaryTextureLoader.prototype = {\r\n\r\n\tconstructor: THREE.BinaryTextureLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar texture = new THREE.DataTexture();\r\n\r\n\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\r\n\t\tloader.load( url, function ( buffer ) {\r\n\r\n\t\t\tvar texData = scope._parser( buffer );\r\n\r\n\t\t\tif ( ! texData ) return;\r\n\r\n\t\t\tif ( undefined !== texData.image ) {\r\n\r\n\t\t\t\ttexture.image = texData.image;\r\n\r\n\t\t\t} else if ( undefined !== texData.data ) {\r\n\r\n\t\t\t\ttexture.image.width = texData.width;\r\n\t\t\t\ttexture.image.height = texData.height;\r\n\t\t\t\ttexture.image.data = texData.data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;\r\n\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;\r\n\r\n\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;\r\n\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;\r\n\r\n\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\r\n\r\n\t\t\tif ( undefined !== texData.format ) {\r\n\r\n\t\t\t\ttexture.format = texData.format;\r\n\r\n\t\t\t}\r\n\t\t\tif ( undefined !== texData.type ) {\r\n\r\n\t\t\t\ttexture.type = texData.type;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( undefined !== texData.mipmaps ) {\r\n\r\n\t\t\t\ttexture.mipmaps = texData.mipmaps;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( 1 === texData.mipmapCount ) {\r\n\r\n\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\tif ( onLoad ) onLoad( texture, texData );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/CompressedTextureLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n *\r\n * Abstract Base class to block based textures loader (dds, pvr, ...)\r\n */\r\n\r\nTHREE.CompressedTextureLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n\t// override in sub classes\r\n\tthis._parser = null;\r\n\r\n};\r\n\r\n\r\nTHREE.CompressedTextureLoader.prototype = {\r\n\r\n\tconstructor: THREE.CompressedTextureLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar images = [];\r\n\r\n\t\tvar texture = new THREE.CompressedTexture();\r\n\t\ttexture.image = images;\r\n\r\n\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\tloader.setPath( this.path );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\r\n\t\tfunction loadTexture( i ) {\r\n\r\n\t\t\tloader.load( url[ i ], function ( buffer ) {\r\n\r\n\t\t\t\tvar texDatas = scope._parser( buffer, true );\r\n\r\n\t\t\t\timages[ i ] = {\r\n\t\t\t\t\twidth: texDatas.width,\r\n\t\t\t\t\theight: texDatas.height,\r\n\t\t\t\t\tformat: texDatas.format,\r\n\t\t\t\t\tmipmaps: texDatas.mipmaps\r\n\t\t\t\t};\r\n\r\n\t\t\t\tloaded += 1;\r\n\r\n\t\t\t\tif ( loaded === 6 ) {\r\n\r\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\r\n\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\r\n\t\t\t\t\ttexture.format = texDatas.format;\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, onProgress, onError );\r\n\r\n\t\t}\r\n\r\n\t\tif ( Array.isArray( url ) ) {\r\n\r\n\t\t\tvar loaded = 0;\r\n\r\n\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\r\n\r\n\t\t\t\tloadTexture( i );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// compressed cubemap texture stored in a single DDS file\r\n\r\n\t\t\tloader.load( url, function ( buffer ) {\r\n\r\n\t\t\t\tvar texDatas = scope._parser( buffer, true );\r\n\r\n\t\t\t\tif ( texDatas.isCubemap ) {\r\n\r\n\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\r\n\r\n\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\r\n\r\n\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\r\n\r\n\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\r\n\r\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\r\n\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\r\n\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\r\n\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttexture.image.width = texDatas.width;\r\n\t\t\t\t\ttexture.image.height = texDatas.height;\r\n\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\r\n\r\n\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.format = texDatas.format;\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t\t}, onProgress, onError );\r\n\r\n\t\t}\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tsetPath: function ( value ) {\r\n\r\n\t\tthis.path = value;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/materials/Material.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Material = function () {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'Material';\r\n\r\n\tthis.side = THREE.FrontSide;\r\n\r\n\tthis.opacity = 1;\r\n\tthis.transparent = false;\r\n\r\n\tthis.blending = THREE.NormalBlending;\r\n\r\n\tthis.blendSrc = THREE.SrcAlphaFactor;\r\n\tthis.blendDst = THREE.OneMinusSrcAlphaFactor;\r\n\tthis.blendEquation = THREE.AddEquation;\r\n\tthis.blendSrcAlpha = null;\r\n\tthis.blendDstAlpha = null;\r\n\tthis.blendEquationAlpha = null;\r\n\r\n\tthis.depthFunc = THREE.LessEqualDepth;\r\n\tthis.depthTest = true;\r\n\tthis.depthWrite = true;\r\n\r\n\tthis.colorWrite = true;\r\n\r\n\tthis.precision = null; // override the renderer's default precision for this material\r\n\r\n\tthis.polygonOffset = false;\r\n\tthis.polygonOffsetFactor = 0;\r\n\tthis.polygonOffsetUnits = 0;\r\n\r\n\tthis.alphaTest = 0;\r\n\tthis.premultipliedAlpha = false;\r\n\r\n\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\r\n\r\n\tthis.visible = true;\r\n\r\n\tthis._needsUpdate = true;\r\n\r\n};\r\n\r\nTHREE.Material.prototype = {\r\n\r\n\tconstructor: THREE.Material,\r\n\r\n\tget needsUpdate () {\r\n\r\n\t\treturn this._needsUpdate;\r\n\r\n\t},\r\n\r\n\tset needsUpdate ( value ) {\r\n\r\n\t\tif ( value === true ) this.update();\r\n\r\n\t\tthis._needsUpdate = value;\r\n\r\n\t},\r\n\r\n\tsetValues: function ( values ) {\r\n\r\n\t\tif ( values === undefined ) return;\r\n\r\n\t\tfor ( var key in values ) {\r\n\r\n\t\t\tvar newValue = values[ key ];\r\n\r\n\t\t\tif ( newValue === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar currentValue = this[ key ];\r\n\r\n\t\t\tif ( currentValue === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( currentValue instanceof THREE.Color ) {\r\n\r\n\t\t\t\tcurrentValue.set( newValue );\r\n\r\n\t\t\t} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\r\n\r\n\t\t\t\tcurrentValue.copy( newValue );\r\n\r\n\t\t\t} else if ( key === 'overdraw' ) {\r\n\r\n\t\t\t\t// ensure overdraw is backwards-compatible with legacy boolean type\r\n\t\t\t\tthis[ key ] = Number( newValue );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis[ key ] = newValue;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\tvar isRoot = meta === undefined;\r\n\r\n\t\tif ( isRoot ) {\r\n\r\n\t\t\tmeta = {\r\n\t\t\t\ttextures: {},\r\n\t\t\t\timages: {}\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tvar data = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.4,\r\n\t\t\t\ttype: 'Material',\r\n\t\t\t\tgenerator: 'Material.toJSON'\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// standard Material serialization\r\n\t\tdata.uuid = this.uuid;\r\n\t\tdata.type = this.type;\r\n\t\tif ( this.name !== '' ) data.name = this.name;\r\n\r\n\t\tif ( this.color instanceof THREE.Color ) data.color = this.color.getHex();\r\n\r\n\t\tif ( this.roughness !== 0.5 ) data.roughness = this.roughness;\r\n\t\tif ( this.metalness !== 0.5 ) data.metalness = this.metalness;\r\n\r\n\t\tif ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();\r\n\t\tif ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();\r\n\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\r\n\r\n\t\tif ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;\r\n\t\tif ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\r\n\t\tif ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\r\n\t\tif ( this.bumpMap instanceof THREE.Texture ) {\r\n\r\n\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\r\n\t\t\tdata.bumpScale = this.bumpScale;\r\n\r\n\t\t}\r\n\t\tif ( this.normalMap instanceof THREE.Texture ) {\r\n\r\n\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\r\n\t\t\tdata.normalScale = this.normalScale.toArray();\r\n\r\n\t\t}\r\n\t\tif ( this.displacementMap instanceof THREE.Texture ) {\r\n\r\n\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\r\n\t\t\tdata.displacementScale = this.displacementScale;\r\n\t\t\tdata.displacementBias = this.displacementBias;\r\n\r\n\t\t}\r\n\t\tif ( this.roughnessMap instanceof THREE.Texture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\r\n\t\tif ( this.metalnessMap instanceof THREE.Texture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\r\n\r\n\t\tif ( this.emissiveMap instanceof THREE.Texture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\r\n\t\tif ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\r\n\r\n\t\tif ( this.envMap instanceof THREE.Texture ) {\r\n\r\n\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\r\n\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.size !== undefined ) data.size = this.size;\r\n\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\r\n\r\n\t\tif ( this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;\r\n\t\tif ( this.shading !== undefined && this.shading !== THREE.SmoothShading ) data.shading = this.shading;\r\n\t\tif ( this.blending !== undefined && this.blending !== THREE.NormalBlending ) data.blending = this.blending;\r\n\t\tif ( this.side !== undefined && this.side !== THREE.FrontSide ) data.side = this.side;\r\n\r\n\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\r\n\t\tif ( this.transparent === true ) data.transparent = this.transparent;\r\n\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\r\n\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\r\n\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\r\n\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\r\n\r\n\t\t// TODO: Copied from Object3D.toJSON\r\n\r\n\t\tfunction extractFromCache ( cache ) {\r\n\r\n\t\t\tvar values = [];\r\n\r\n\t\t\tfor ( var key in cache ) {\r\n\r\n\t\t\t\tvar data = cache[ key ];\r\n\t\t\t\tdelete data.metadata;\r\n\t\t\t\tvalues.push( data );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn values;\r\n\r\n\t\t}\r\n\r\n\t\tif ( isRoot ) {\r\n\r\n\t\t\tvar textures = extractFromCache( meta.textures );\r\n\t\t\tvar images = extractFromCache( meta.images );\r\n\r\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\r\n\t\t\tif ( images.length > 0 ) data.images = images;\r\n\r\n\t\t}\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.name = source.name;\r\n\r\n\t\tthis.side = source.side;\r\n\r\n\t\tthis.opacity = source.opacity;\r\n\t\tthis.transparent = source.transparent;\r\n\r\n\t\tthis.blending = source.blending;\r\n\r\n\t\tthis.blendSrc = source.blendSrc;\r\n\t\tthis.blendDst = source.blendDst;\r\n\t\tthis.blendEquation = source.blendEquation;\r\n\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\r\n\t\tthis.blendDstAlpha = source.blendDstAlpha;\r\n\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\r\n\r\n\t\tthis.depthFunc = source.depthFunc;\r\n\t\tthis.depthTest = source.depthTest;\r\n\t\tthis.depthWrite = source.depthWrite;\r\n\r\n\t\tthis.colorWrite = source.colorWrite;\r\n\r\n\t\tthis.precision = source.precision;\r\n\r\n\t\tthis.polygonOffset = source.polygonOffset;\r\n\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\r\n\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\r\n\r\n\t\tthis.alphaTest = source.alphaTest;\r\n\r\n\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\r\n\r\n\t\tthis.overdraw = source.overdraw;\r\n\r\n\t\tthis.visible = source.visible;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tupdate: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'update' } );\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Material.prototype );\r\n\r\nTHREE.MaterialIdCount = 0;\r\n\r\n// File:src/materials/LineBasicMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  linewidth: <float>,\r\n *  linecap: \"round\",\r\n *  linejoin: \"round\",\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  vertexColors: <bool>\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.LineBasicMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'LineBasicMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\r\n\tthis.linewidth = 1;\r\n\tthis.linecap = 'round';\r\n\tthis.linejoin = 'round';\r\n\r\n\tthis.blending = THREE.NormalBlending;\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;\r\n\r\nTHREE.LineBasicMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\r\n\tthis.linewidth = source.linewidth;\r\n\tthis.linecap = source.linecap;\r\n\tthis.linejoin = source.linejoin;\r\n\r\n\tthis.vertexColors = source.vertexColors;\r\n\r\n\tthis.fog = source.fog;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/LineDashedMaterial.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  linewidth: <float>,\r\n *\r\n *  scale: <float>,\r\n *  dashSize: <float>,\r\n *  gapSize: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.FaceColors / THREE.VertexColors\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.LineDashedMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'LineDashedMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\r\n\tthis.linewidth = 1;\r\n\r\n\tthis.scale = 1;\r\n\tthis.dashSize = 3;\r\n\tthis.gapSize = 1;\r\n\r\n\tthis.blending = THREE.NormalBlending;\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;\r\n\r\nTHREE.LineDashedMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\r\n\tthis.linewidth = source.linewidth;\r\n\r\n\tthis.scale = source.scale;\r\n\tthis.dashSize = source.dashSize;\r\n\tthis.gapSize = source.gapSize;\r\n\r\n\tthis.vertexColors = source.vertexColors;\r\n\r\n\tthis.fog = source.fog;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshBasicMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  aoMap: new THREE.Texture( <Image> ),\r\n *  aoMapIntensity: <float>\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshBasicMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'MeshBasicMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // emissive\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.aoMap = null;\r\n\tthis.aoMapIntensity = 1.0;\r\n\r\n\tthis.specularMap = null;\r\n\r\n\tthis.alphaMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.combine = THREE.MultiplyOperation;\r\n\tthis.reflectivity = 1;\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\tthis.blending = THREE.NormalBlending;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;\r\n\r\nTHREE.MeshBasicMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\r\n\tthis.map = source.map;\r\n\r\n\tthis.aoMap = source.aoMap;\r\n\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\r\n\tthis.specularMap = source.specularMap;\r\n\r\n\tthis.alphaMap = source.alphaMap;\r\n\r\n\tthis.envMap = source.envMap;\r\n\tthis.combine = source.combine;\r\n\tthis.reflectivity = source.reflectivity;\r\n\tthis.refractionRatio = source.refractionRatio;\r\n\r\n\tthis.fog = source.fog;\r\n\r\n\tthis.shading = source.shading;\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\r\n\tthis.vertexColors = source.vertexColors;\r\n\r\n\tthis.skinning = source.skinning;\r\n\tthis.morphTargets = source.morphTargets;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshLambertMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *  lightMapIntensity: <float>\r\n *\r\n *  aoMap: new THREE.Texture( <Image> ),\r\n *  aoMapIntensity: <float>\r\n *\r\n *  emissive: <hex>,\r\n *  emissiveIntensity: <float>\r\n *  emissiveMap: new THREE.Texture( <Image> ),\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *\tfog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshLambertMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'MeshLambertMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.lightMap = null;\r\n\tthis.lightMapIntensity = 1.0;\r\n\r\n\tthis.aoMap = null;\r\n\tthis.aoMapIntensity = 1.0;\r\n\r\n\tthis.emissive = new THREE.Color( 0x000000 );\r\n\tthis.emissiveIntensity = 1.0;\r\n\tthis.emissiveMap = null;\r\n\r\n\tthis.specularMap = null;\r\n\r\n\tthis.alphaMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.combine = THREE.MultiplyOperation;\r\n\tthis.reflectivity = 1;\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.blending = THREE.NormalBlending;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\tthis.morphNormals = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;\r\n\r\nTHREE.MeshLambertMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\r\n\tthis.map = source.map;\r\n\r\n\tthis.lightMap = source.lightMap;\r\n\tthis.lightMapIntensity = source.lightMapIntensity;\r\n\r\n\tthis.aoMap = source.aoMap;\r\n\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\r\n\tthis.emissive.copy( source.emissive );\r\n\tthis.emissiveMap = source.emissiveMap;\r\n\tthis.emissiveIntensity = source.emissiveIntensity;\r\n\r\n\tthis.specularMap = source.specularMap;\r\n\r\n\tthis.alphaMap = source.alphaMap;\r\n\r\n\tthis.envMap = source.envMap;\r\n\tthis.combine = source.combine;\r\n\tthis.reflectivity = source.reflectivity;\r\n\tthis.refractionRatio = source.refractionRatio;\r\n\r\n\tthis.fog = source.fog;\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\r\n\tthis.vertexColors = source.vertexColors;\r\n\r\n\tthis.skinning = source.skinning;\r\n\tthis.morphTargets = source.morphTargets;\r\n\tthis.morphNormals = source.morphNormals;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshPhongMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  specular: <hex>,\r\n *  shininess: <float>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *  lightMapIntensity: <float>\r\n *\r\n *  aoMap: new THREE.Texture( <Image> ),\r\n *  aoMapIntensity: <float>\r\n *\r\n *  emissive: <hex>,\r\n *  emissiveIntensity: <float>\r\n *  emissiveMap: new THREE.Texture( <Image> ),\r\n *\r\n *  bumpMap: new THREE.Texture( <Image> ),\r\n *  bumpScale: <float>,\r\n *\r\n *  normalMap: new THREE.Texture( <Image> ),\r\n *  normalScale: <Vector2>,\r\n *\r\n *  displacementMap: new THREE.Texture( <Image> ),\r\n *  displacementScale: <float>,\r\n *  displacementBias: <float>,\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *\tfog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshPhongMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'MeshPhongMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\tthis.specular = new THREE.Color( 0x111111 );\r\n\tthis.shininess = 30;\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.lightMap = null;\r\n\tthis.lightMapIntensity = 1.0;\r\n\r\n\tthis.aoMap = null;\r\n\tthis.aoMapIntensity = 1.0;\r\n\r\n\tthis.emissive = new THREE.Color( 0x000000 );\r\n\tthis.emissiveIntensity = 1.0;\r\n\tthis.emissiveMap = null;\r\n\r\n\tthis.bumpMap = null;\r\n\tthis.bumpScale = 1;\r\n\r\n\tthis.normalMap = null;\r\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\r\n\r\n\tthis.displacementMap = null;\r\n\tthis.displacementScale = 1;\r\n\tthis.displacementBias = 0;\r\n\r\n\tthis.specularMap = null;\r\n\r\n\tthis.alphaMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.combine = THREE.MultiplyOperation;\r\n\tthis.reflectivity = 1;\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\tthis.blending = THREE.NormalBlending;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\tthis.morphNormals = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;\r\n\r\nTHREE.MeshPhongMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\tthis.specular.copy( source.specular );\r\n\tthis.shininess = source.shininess;\r\n\r\n\tthis.map = source.map;\r\n\r\n\tthis.lightMap = source.lightMap;\r\n\tthis.lightMapIntensity = source.lightMapIntensity;\r\n\r\n\tthis.aoMap = source.aoMap;\r\n\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\r\n\tthis.emissive.copy( source.emissive );\r\n\tthis.emissiveMap = source.emissiveMap;\r\n\tthis.emissiveIntensity = source.emissiveIntensity;\r\n\r\n\tthis.bumpMap = source.bumpMap;\r\n\tthis.bumpScale = source.bumpScale;\r\n\r\n\tthis.normalMap = source.normalMap;\r\n\tthis.normalScale.copy( source.normalScale );\r\n\r\n\tthis.displacementMap = source.displacementMap;\r\n\tthis.displacementScale = source.displacementScale;\r\n\tthis.displacementBias = source.displacementBias;\r\n\r\n\tthis.specularMap = source.specularMap;\r\n\r\n\tthis.alphaMap = source.alphaMap;\r\n\r\n\tthis.envMap = source.envMap;\r\n\tthis.combine = source.combine;\r\n\tthis.reflectivity = source.reflectivity;\r\n\tthis.refractionRatio = source.refractionRatio;\r\n\r\n\tthis.fog = source.fog;\r\n\r\n\tthis.shading = source.shading;\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\r\n\tthis.vertexColors = source.vertexColors;\r\n\r\n\tthis.skinning = source.skinning;\r\n\tthis.morphTargets = source.morphTargets;\r\n\tthis.morphNormals = source.morphNormals;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshStandardMaterial.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  roughness: <float>,\r\n *  metalness: <float>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *  lightMapIntensity: <float>\r\n *\r\n *  aoMap: new THREE.Texture( <Image> ),\r\n *  aoMapIntensity: <float>\r\n *\r\n *  emissive: <hex>,\r\n *  emissiveIntensity: <float>\r\n *  emissiveMap: new THREE.Texture( <Image> ),\r\n *\r\n *  bumpMap: new THREE.Texture( <Image> ),\r\n *  bumpScale: <float>,\r\n *\r\n *  normalMap: new THREE.Texture( <Image> ),\r\n *  normalScale: <Vector2>,\r\n *\r\n *  displacementMap: new THREE.Texture( <Image> ),\r\n *  displacementScale: <float>,\r\n *  displacementBias: <float>,\r\n *\r\n *  roughnessMap: new THREE.Texture( <Image> ),\r\n *\r\n *  metalnessMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\r\n *  envMapIntensity: <float>\r\n *\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *\tfog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshStandardMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'MeshStandardMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\tthis.roughness = 0.5;\r\n\tthis.metalness = 0.5;\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.lightMap = null;\r\n\tthis.lightMapIntensity = 1.0;\r\n\r\n\tthis.aoMap = null;\r\n\tthis.aoMapIntensity = 1.0;\r\n\r\n\tthis.emissive = new THREE.Color( 0x000000 );\r\n\tthis.emissiveIntensity = 1.0;\r\n\tthis.emissiveMap = null;\r\n\r\n\tthis.bumpMap = null;\r\n\tthis.bumpScale = 1;\r\n\r\n\tthis.normalMap = null;\r\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\r\n\r\n\tthis.displacementMap = null;\r\n\tthis.displacementScale = 1;\r\n\tthis.displacementBias = 0;\r\n\r\n\tthis.roughnessMap = null;\r\n\r\n\tthis.metalnessMap = null;\r\n\r\n\tthis.alphaMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.envMapIntensity = 1.0;\r\n\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\tthis.blending = THREE.NormalBlending;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\tthis.morphNormals = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshStandardMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial;\r\n\r\nTHREE.MeshStandardMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\tthis.roughness = source.roughness;\r\n\tthis.metalness = source.metalness;\r\n\r\n\tthis.map = source.map;\r\n\r\n\tthis.lightMap = source.lightMap;\r\n\tthis.lightMapIntensity = source.lightMapIntensity;\r\n\r\n\tthis.aoMap = source.aoMap;\r\n\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\r\n\tthis.emissive.copy( source.emissive );\r\n\tthis.emissiveMap = source.emissiveMap;\r\n\tthis.emissiveIntensity = source.emissiveIntensity;\r\n\r\n\tthis.bumpMap = source.bumpMap;\r\n\tthis.bumpScale = source.bumpScale;\r\n\r\n\tthis.normalMap = source.normalMap;\r\n\tthis.normalScale.copy( source.normalScale );\r\n\r\n\tthis.displacementMap = source.displacementMap;\r\n\tthis.displacementScale = source.displacementScale;\r\n\tthis.displacementBias = source.displacementBias;\r\n\r\n\tthis.roughnessMap = source.roughnessMap;\r\n\r\n\tthis.metalnessMap = source.metalnessMap;\r\n\r\n\tthis.alphaMap = source.alphaMap;\r\n\r\n\tthis.envMap = source.envMap;\r\n\tthis.envMapIntensity = source.envMapIntensity;\r\n\r\n\tthis.refractionRatio = source.refractionRatio;\r\n\r\n\tthis.fog = source.fog;\r\n\r\n\tthis.shading = source.shading;\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\r\n\tthis.vertexColors = source.vertexColors;\r\n\r\n\tthis.skinning = source.skinning;\r\n\tthis.morphTargets = source.morphTargets;\r\n\tthis.morphNormals = source.morphNormals;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshDepthMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  opacity: <float>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>\r\n * }\r\n */\r\n\r\nTHREE.MeshDepthMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'MeshDepthMaterial';\r\n\r\n\tthis.morphTargets = false;\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;\r\n\r\nTHREE.MeshDepthMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshNormalMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n *\r\n * parameters = {\r\n *  opacity: <float>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>\r\n * }\r\n */\r\n\r\nTHREE.MeshNormalMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this, parameters );\r\n\r\n\tthis.type = 'MeshNormalMaterial';\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\r\n\tthis.morphTargets = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;\r\n\r\nTHREE.MeshNormalMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/MultiMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.MultiMaterial = function ( materials ) {\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.type = 'MultiMaterial';\r\n\r\n\tthis.materials = materials instanceof Array ? materials : [];\r\n\r\n\tthis.visible = true;\r\n\r\n};\r\n\r\nTHREE.MultiMaterial.prototype = {\r\n\r\n\tconstructor: THREE.MultiMaterial,\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\tvar output = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.2,\r\n\t\t\t\ttype: 'material',\r\n\t\t\t\tgenerator: 'MaterialExporter'\r\n\t\t\t},\r\n\t\t\tuuid: this.uuid,\r\n\t\t\ttype: this.type,\r\n\t\t\tmaterials: []\r\n\t\t};\r\n\r\n\t\tvar materials = this.materials;\r\n\r\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar material = materials[ i ].toJSON( meta );\r\n\t\t\tdelete material.metadata;\r\n\r\n\t\t\toutput.materials.push( material );\r\n\r\n\t\t}\r\n\r\n\t\toutput.visible = this.visible;\r\n\r\n\t\treturn output;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar material = new this.constructor();\r\n\r\n\t\tfor ( var i = 0; i < this.materials.length; i ++ ) {\r\n\r\n\t\t\tmaterial.materials.push( this.materials[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\tmaterial.visible = this.visible;\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/materials/PointsMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  size: <float>,\r\n *  sizeAttenuation: <bool>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  vertexColors: <bool>,\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.PointsMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'PointsMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.size = 1;\r\n\tthis.sizeAttenuation = true;\r\n\r\n\tthis.blending = THREE.NormalBlending;\r\n\r\n\tthis.vertexColors = THREE.NoColors;\r\n\r\n\tthis.fog = true;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;\r\n\r\nTHREE.PointsMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\r\n\tthis.map = source.map;\r\n\r\n\tthis.size = source.size;\r\n\tthis.sizeAttenuation = source.sizeAttenuation;\r\n\r\n\tthis.vertexColors = source.vertexColors;\r\n\r\n\tthis.fog = source.fog;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/ShaderMaterial.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  defines: { \"label\" : \"value\" },\r\n *  uniforms: { \"parameter1\": { type: \"f\", value: 1.0 }, \"parameter2\": { type: \"i\" value2: 2 } },\r\n *\r\n *  fragmentShader: <string>,\r\n *  vertexShader: <string>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  lights: <bool>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *\tfog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.ShaderMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'ShaderMaterial';\r\n\r\n\tthis.defines = {};\r\n\tthis.uniforms = {};\r\n\r\n\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\r\n\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\r\n\r\n\tthis.shading = THREE.SmoothShading;\r\n\r\n\tthis.linewidth = 1;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\r\n\tthis.fog = false; // set to use scene fog\r\n\r\n\tthis.lights = false; // set to use scene lights\r\n\r\n\tthis.vertexColors = THREE.NoColors; // set to use \"color\" attribute stream\r\n\r\n\tthis.skinning = false; // set to use skinning attribute streams\r\n\r\n\tthis.morphTargets = false; // set to use morph targets\r\n\tthis.morphNormals = false; // set to use morph normals\r\n\r\n\tthis.extensions = {\r\n\t\tderivatives: false, // set to use derivatives\r\n\t\tfragDepth: false, // set to use fragment depth values\r\n\t\tdrawBuffers: false, // set to use draw buffers\r\n\t\tshaderTextureLOD: false // set to use shader texture LOD\r\n\t};\r\n\r\n\t// When rendered geometry doesn't include these attributes but the material does,\r\n\t// use these default values in WebGL. This avoids errors when buffer data is missing.\r\n\tthis.defaultAttributeValues = {\r\n\t\t'color': [ 1, 1, 1 ],\r\n\t\t'uv': [ 0, 0 ],\r\n\t\t'uv2': [ 0, 0 ]\r\n\t};\r\n\r\n\tthis.index0AttributeName = undefined;\r\n\r\n\tif ( parameters !== undefined ) {\r\n\r\n\t\tif ( parameters.attributes !== undefined ) {\r\n\r\n\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\r\n\r\n\t\t}\r\n\r\n\t\tthis.setValues( parameters );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;\r\n\r\nTHREE.ShaderMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.fragmentShader = source.fragmentShader;\r\n\tthis.vertexShader = source.vertexShader;\r\n\r\n\tthis.uniforms = THREE.UniformsUtils.clone( source.uniforms );\r\n\r\n\tthis.defines = source.defines;\r\n\r\n\tthis.shading = source.shading;\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\r\n\tthis.fog = source.fog;\r\n\r\n\tthis.lights = source.lights;\r\n\r\n\tthis.vertexColors = source.vertexColors;\r\n\r\n\tthis.skinning = source.skinning;\r\n\r\n\tthis.morphTargets = source.morphTargets;\r\n\tthis.morphNormals = source.morphNormals;\r\n\r\n\tthis.extensions = source.extensions;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nTHREE.ShaderMaterial.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = THREE.Material.prototype.toJSON.call( this, meta );\r\n\r\n\tdata.uniforms = this.uniforms;\r\n\tdata.vertexShader = this.vertexShader;\r\n\tdata.fragmentShader = this.fragmentShader;\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\n// File:src/materials/RawShaderMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.RawShaderMaterial = function ( parameters ) {\r\n\r\n\tTHREE.ShaderMaterial.call( this, parameters );\r\n\r\n\tthis.type = 'RawShaderMaterial';\r\n\r\n};\r\n\r\nTHREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\r\nTHREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;\r\n\r\n// File:src/materials/SpriteMaterial.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *\tuvOffset: new THREE.Vector2(),\r\n *\tuvScale: new THREE.Vector2(),\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.SpriteMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'SpriteMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\tthis.map = null;\r\n\r\n\tthis.rotation = 0;\r\n\r\n\tthis.fog = false;\r\n\r\n\t// set parameters\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;\r\n\r\nTHREE.SpriteMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\tthis.map = source.map;\r\n\r\n\tthis.rotation = source.rotation;\r\n\r\n\tthis.fog = source.fog;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/textures/Texture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author szimek / https://github.com/szimek/\r\n */\r\n\r\nTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.sourceFile = '';\r\n\r\n\tthis.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;\r\n\tthis.mipmaps = [];\r\n\r\n\tthis.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;\r\n\r\n\tthis.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\r\n\tthis.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\r\n\r\n\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\r\n\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\r\n\r\n\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\r\n\r\n\tthis.format = format !== undefined ? format : THREE.RGBAFormat;\r\n\tthis.type = type !== undefined ? type : THREE.UnsignedByteType;\r\n\r\n\tthis.offset = new THREE.Vector2( 0, 0 );\r\n\tthis.repeat = new THREE.Vector2( 1, 1 );\r\n\r\n\tthis.generateMipmaps = true;\r\n\tthis.premultiplyAlpha = false;\r\n\tthis.flipY = true;\r\n\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\r\n\r\n\r\n\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\r\n\t//\r\n\t// Also changing the encoding after already used by a Material will not automatically make the Material\r\n\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\r\n\tthis.encoding = THREE.LinearEncoding;\r\n\r\n\tthis.version = 0;\r\n\tthis.onUpdate = null;\r\n\r\n};\r\n\r\nTHREE.Texture.DEFAULT_IMAGE = undefined;\r\nTHREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;\r\n\r\nTHREE.Texture.prototype = {\r\n\r\n\tconstructor: THREE.Texture,\r\n\r\n\tset needsUpdate ( value ) {\r\n\r\n\t\tif ( value === true ) this.version ++;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.image = source.image;\r\n\t\tthis.mipmaps = source.mipmaps.slice( 0 );\r\n\r\n\t\tthis.mapping = source.mapping;\r\n\r\n\t\tthis.wrapS = source.wrapS;\r\n\t\tthis.wrapT = source.wrapT;\r\n\r\n\t\tthis.magFilter = source.magFilter;\r\n\t\tthis.minFilter = source.minFilter;\r\n\r\n\t\tthis.anisotropy = source.anisotropy;\r\n\r\n\t\tthis.format = source.format;\r\n\t\tthis.type = source.type;\r\n\r\n\t\tthis.offset.copy( source.offset );\r\n\t\tthis.repeat.copy( source.repeat );\r\n\r\n\t\tthis.generateMipmaps = source.generateMipmaps;\r\n\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\r\n\t\tthis.flipY = source.flipY;\r\n\t\tthis.unpackAlignment = source.unpackAlignment;\r\n\t\tthis.encoding = source.encoding;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\tif ( meta.textures[ this.uuid ] !== undefined ) {\r\n\r\n\t\t\treturn meta.textures[ this.uuid ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction getDataURL( image ) {\r\n\r\n\t\t\tvar canvas;\r\n\r\n\t\t\tif ( image.toDataURL !== undefined ) {\r\n\r\n\t\t\t\tcanvas = image;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tcanvas = document.createElement( 'canvas' );\r\n\t\t\t\tcanvas.width = image.width;\r\n\t\t\t\tcanvas.height = image.height;\r\n\r\n\t\t\t\tcanvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\r\n\r\n\t\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn canvas.toDataURL( 'image/png' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar output = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.4,\r\n\t\t\t\ttype: 'Texture',\r\n\t\t\t\tgenerator: 'Texture.toJSON'\r\n\t\t\t},\r\n\r\n\t\t\tuuid: this.uuid,\r\n\t\t\tname: this.name,\r\n\r\n\t\t\tmapping: this.mapping,\r\n\r\n\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\r\n\t\t\toffset: [ this.offset.x, this.offset.y ],\r\n\t\t\twrap: [ this.wrapS, this.wrapT ],\r\n\r\n\t\t\tminFilter: this.minFilter,\r\n\t\t\tmagFilter: this.magFilter,\r\n\t\t\tanisotropy: this.anisotropy\r\n\t\t};\r\n\r\n\t\tif ( this.image !== undefined ) {\r\n\r\n\t\t\t// TODO: Move to THREE.Image\r\n\r\n\t\t\tvar image = this.image;\r\n\r\n\t\t\tif ( image.uuid === undefined ) {\r\n\r\n\t\t\t\timage.uuid = THREE.Math.generateUUID(); // UGH\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( meta.images[ image.uuid ] === undefined ) {\r\n\r\n\t\t\t\tmeta.images[ image.uuid ] = {\r\n\t\t\t\t\tuuid: image.uuid,\r\n\t\t\t\t\turl: getDataURL( image )\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t\toutput.image = image.uuid;\r\n\r\n\t\t}\r\n\r\n\t\tmeta.textures[ this.uuid ] = output;\r\n\r\n\t\treturn output;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t},\r\n\r\n\ttransformUv: function ( uv ) {\r\n\r\n\t\tif ( this.mapping !== THREE.UVMapping )  return;\r\n\r\n\t\tuv.multiply( this.repeat );\r\n\t\tuv.add( this.offset );\r\n\r\n\t\tif ( uv.x < 0 || uv.x > 1 ) {\r\n\r\n\t\t\tswitch ( this.wrapS ) {\r\n\r\n\t\t\t\tcase THREE.RepeatWrapping:\r\n\r\n\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.ClampToEdgeWrapping:\r\n\r\n\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.MirroredRepeatWrapping:\r\n\r\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\r\n\r\n\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( uv.y < 0 || uv.y > 1 ) {\r\n\r\n\t\t\tswitch ( this.wrapT ) {\r\n\r\n\t\t\t\tcase THREE.RepeatWrapping:\r\n\r\n\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.ClampToEdgeWrapping:\r\n\r\n\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.MirroredRepeatWrapping:\r\n\r\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\r\n\r\n\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.flipY ) {\r\n\r\n\t\t\tuv.y = 1 - uv.y;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );\r\n\r\nTHREE.TextureIdCount = 0;\r\n\r\n// File:src/textures/CanvasTexture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n\tTHREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n\tthis.needsUpdate = true;\r\n\r\n};\r\n\r\nTHREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;\r\n\r\n// File:src/textures/CubeTexture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n\timages = images !== undefined ? images : [];\r\n\tmapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;\r\n\r\n\tTHREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n\tthis.flipY = false;\r\n\r\n};\r\n\r\nTHREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.CubeTexture.prototype.constructor = THREE.CubeTexture;\r\n\r\nObject.defineProperty( THREE.CubeTexture.prototype, 'images', {\r\n\r\n\tget: function () {\r\n\r\n\t\treturn this.image;\r\n\r\n\t},\r\n\r\n\tset: function ( value ) {\r\n\r\n\t\tthis.image = value;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/textures/CompressedTexture.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\r\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n\tthis.image = { width: width, height: height };\r\n\tthis.mipmaps = mipmaps;\r\n\r\n\t// no flipping for cube textures\r\n\t// (also flipping doesn't work for compressed textures )\r\n\r\n\tthis.flipY = false;\r\n\r\n\t// can't generate mipmaps for compressed textures\r\n\t// mips must be embedded in DDS files\r\n\r\n\tthis.generateMipmaps = false;\r\n\r\n};\r\n\r\nTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;\r\n\r\n// File:src/textures/DataTexture.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\r\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n\tthis.image = { data: data, width: width, height: height };\r\n\r\n\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\r\n\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\r\n\r\n\tthis.flipY = false;\r\n\tthis.generateMipmaps  = false;\r\n\r\n};\r\n\r\nTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.DataTexture.prototype.constructor = THREE.DataTexture;\r\n\r\n// File:src/textures/VideoTexture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n\tTHREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n\tthis.generateMipmaps = false;\r\n\r\n\tvar scope = this;\r\n\r\n\tfunction update() {\r\n\r\n\t\trequestAnimationFrame( update );\r\n\r\n\t\tif ( video.readyState === video.HAVE_ENOUGH_DATA ) {\r\n\r\n\t\t\tscope.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdate();\r\n\r\n};\r\n\r\nTHREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.VideoTexture.prototype.constructor = THREE.VideoTexture;\r\n\r\n// File:src/objects/Group.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Group = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Group';\r\n\r\n};\r\n\r\nTHREE.Group.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Group.prototype.constructor = THREE.Group;\r\n\r\n// File:src/objects/Points.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Points = function ( geometry, material ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Points';\r\n\r\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n\tthis.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n};\r\n\r\nTHREE.Points.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Points.prototype.constructor = THREE.Points;\r\n\r\nTHREE.Points.prototype.raycast = ( function () {\r\n\r\n\tvar inverseMatrix = new THREE.Matrix4();\r\n\tvar ray = new THREE.Ray();\r\n\tvar sphere = new THREE.Sphere();\r\n\r\n\treturn function raycast( raycaster, intersects ) {\r\n\r\n\t\tvar object = this;\r\n\t\tvar geometry = this.geometry;\r\n\t\tvar matrixWorld = this.matrixWorld;\r\n\t\tvar threshold = raycaster.params.Points.threshold;\r\n\r\n\t\t// Checking boundingSphere distance to ray\r\n\r\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n\t\tsphere.copy( geometry.boundingSphere );\r\n\t\tsphere.applyMatrix4( matrixWorld );\r\n\r\n\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\r\n\r\n\t\t//\r\n\r\n\t\tinverseMatrix.getInverse( matrixWorld );\r\n\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\r\n\t\tvar localThresholdSq = localThreshold * localThreshold;\r\n\t\tvar position = new THREE.Vector3();\r\n\r\n\t\tfunction testPoint( point, index ) {\r\n\r\n\t\t\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\r\n\r\n\t\t\tif ( rayPointDistanceSq < localThresholdSq ) {\r\n\r\n\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\r\n\t\t\t\tintersectPoint.applyMatrix4( matrixWorld );\r\n\r\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\r\n\r\n\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\r\n\r\n\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\r\n\t\t\t\t\tpoint: intersectPoint.clone(),\r\n\t\t\t\t\tindex: index,\r\n\t\t\t\t\tface: null,\r\n\t\t\t\t\tobject: object\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\tvar index = geometry.index;\r\n\t\t\tvar attributes = geometry.attributes;\r\n\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\tif ( index !== null ) {\r\n\r\n\t\t\t\tvar indices = index.array;\r\n\r\n\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tvar a = indices[ i ];\r\n\r\n\t\t\t\t\tposition.fromArray( positions, a * 3 );\r\n\r\n\t\t\t\t\ttestPoint( position, a );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tposition.fromArray( positions, i * 3 );\r\n\r\n\t\t\t\t\ttestPoint( position, i );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar vertices = geometry.vertices;\r\n\r\n\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\ttestPoint( vertices[ i ], i );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}() );\r\n\r\nTHREE.Points.prototype.clone = function () {\r\n\r\n\treturn new this.constructor( this.geometry, this.material ).copy( this );\r\n\r\n};\r\n\r\n// File:src/objects/Line.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Line = function ( geometry, material, mode ) {\r\n\r\n\tif ( mode === 1 ) {\r\n\r\n\t\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\r\n\t\treturn new THREE.LineSegments( geometry, material );\r\n\r\n\t}\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Line';\r\n\r\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n\tthis.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n};\r\n\r\nTHREE.Line.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Line.prototype.constructor = THREE.Line;\r\n\r\nTHREE.Line.prototype.raycast = ( function () {\r\n\r\n\tvar inverseMatrix = new THREE.Matrix4();\r\n\tvar ray = new THREE.Ray();\r\n\tvar sphere = new THREE.Sphere();\r\n\r\n\treturn function raycast( raycaster, intersects ) {\r\n\r\n\t\tvar precision = raycaster.linePrecision;\r\n\t\tvar precisionSq = precision * precision;\r\n\r\n\t\tvar geometry = this.geometry;\r\n\t\tvar matrixWorld = this.matrixWorld;\r\n\r\n\t\t// Checking boundingSphere distance to ray\r\n\r\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n\t\tsphere.copy( geometry.boundingSphere );\r\n\t\tsphere.applyMatrix4( matrixWorld );\r\n\r\n\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\r\n\r\n\t\t//\r\n\r\n\t\tinverseMatrix.getInverse( matrixWorld );\r\n\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n\t\tvar vStart = new THREE.Vector3();\r\n\t\tvar vEnd = new THREE.Vector3();\r\n\t\tvar interSegment = new THREE.Vector3();\r\n\t\tvar interRay = new THREE.Vector3();\r\n\t\tvar step = this instanceof THREE.LineSegments ? 2 : 1;\r\n\r\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\tvar index = geometry.index;\r\n\t\t\tvar attributes = geometry.attributes;\r\n\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\tif ( index !== null ) {\r\n\r\n\t\t\t\tvar indices = index.array;\r\n\r\n\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\r\n\r\n\t\t\t\t\tvar a = indices[ i ];\r\n\t\t\t\t\tvar b = indices[ i + 1 ];\r\n\r\n\t\t\t\t\tvStart.fromArray( positions, a * 3 );\r\n\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\r\n\r\n\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\r\n\t\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\r\n\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\r\n\r\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\r\n\r\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n\t\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\tobject: this\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\r\n\r\n\t\t\t\t\tvStart.fromArray( positions, 3 * i );\r\n\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\r\n\r\n\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\r\n\t\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\r\n\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\r\n\r\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\r\n\r\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n\t\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\tobject: this\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\tvar vertices = geometry.vertices;\r\n\t\t\tvar nbVertices = vertices.length;\r\n\r\n\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\r\n\r\n\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\r\n\r\n\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\r\n\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\r\n\r\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\r\n\r\n\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\tindex: i,\r\n\t\t\t\t\tface: null,\r\n\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\tobject: this\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}() );\r\n\r\nTHREE.Line.prototype.clone = function () {\r\n\r\n\treturn new this.constructor( this.geometry, this.material ).copy( this );\r\n\r\n};\r\n\r\n// DEPRECATED\r\n\r\nTHREE.LineStrip = 0;\r\nTHREE.LinePieces = 1;\r\n\r\n// File:src/objects/LineSegments.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LineSegments = function ( geometry, material ) {\r\n\r\n\tTHREE.Line.call( this, geometry, material );\r\n\r\n\tthis.type = 'LineSegments';\r\n\r\n};\r\n\r\nTHREE.LineSegments.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.LineSegments.prototype.constructor = THREE.LineSegments;\r\n\r\n// File:src/objects/Mesh.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author jonobr1 / http://jonobr1.com/\r\n */\r\n\r\nTHREE.Mesh = function ( geometry, material ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Mesh';\r\n\r\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n\tthis.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n\tthis.drawMode = THREE.TrianglesDrawMode;\r\n\r\n\tthis.updateMorphTargets();\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Mesh.prototype.constructor = THREE.Mesh;\r\n\r\nTHREE.Mesh.prototype.setDrawMode = function ( value ) {\r\n\r\n\tthis.drawMode = value;\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype.updateMorphTargets = function () {\r\n\r\n\tif ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {\r\n\r\n\t\tthis.morphTargetBase = - 1;\r\n\t\tthis.morphTargetInfluences = [];\r\n\t\tthis.morphTargetDictionary = {};\r\n\r\n\t\tfor ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\r\n\r\n\t\t\tthis.morphTargetInfluences.push( 0 );\r\n\t\t\tthis.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {\r\n\r\n\tif ( this.morphTargetDictionary[ name ] !== undefined ) {\r\n\r\n\t\treturn this.morphTargetDictionary[ name ];\r\n\r\n\t}\r\n\r\n\tconsole.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );\r\n\r\n\treturn 0;\r\n\r\n};\r\n\r\n\r\nTHREE.Mesh.prototype.raycast = ( function () {\r\n\r\n\tvar inverseMatrix = new THREE.Matrix4();\r\n\tvar ray = new THREE.Ray();\r\n\tvar sphere = new THREE.Sphere();\r\n\r\n\tvar vA = new THREE.Vector3();\r\n\tvar vB = new THREE.Vector3();\r\n\tvar vC = new THREE.Vector3();\r\n\r\n\tvar tempA = new THREE.Vector3();\r\n\tvar tempB = new THREE.Vector3();\r\n\tvar tempC = new THREE.Vector3();\r\n\r\n\tvar uvA = new THREE.Vector2();\r\n\tvar uvB = new THREE.Vector2();\r\n\tvar uvC = new THREE.Vector2();\r\n\r\n\tvar barycoord = new THREE.Vector3();\r\n\r\n\tvar intersectionPoint = new THREE.Vector3();\r\n\tvar intersectionPointWorld = new THREE.Vector3();\r\n\r\n\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\r\n\r\n\t\tTHREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\r\n\r\n\t\tuv1.multiplyScalar( barycoord.x );\r\n\t\tuv2.multiplyScalar( barycoord.y );\r\n\t\tuv3.multiplyScalar( barycoord.z );\r\n\r\n\t\tuv1.add( uv2 ).add( uv3 );\r\n\r\n\t\treturn uv1.clone();\r\n\r\n\t}\r\n\r\n\tfunction checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {\r\n\r\n\t\tvar intersect;\r\n\t\tvar material = object.material;\r\n\r\n\t\tif ( material.side === THREE.BackSide ) {\r\n\r\n\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );\r\n\r\n\t\t}\r\n\r\n\t\tif ( intersect === null ) return null;\r\n\r\n\t\tintersectionPointWorld.copy( point );\r\n\t\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\r\n\r\n\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\r\n\r\n\t\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\r\n\r\n\t\treturn {\r\n\t\t\tdistance: distance,\r\n\t\t\tpoint: intersectionPointWorld.clone(),\r\n\t\t\tobject: object\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tfunction checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {\r\n\r\n\t\tvA.fromArray( positions, a * 3 );\r\n\t\tvB.fromArray( positions, b * 3 );\r\n\t\tvC.fromArray( positions, c * 3 );\r\n\r\n\t\tvar intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );\r\n\r\n\t\tif ( intersection ) {\r\n\r\n\t\t\tif ( uvs ) {\r\n\r\n\t\t\t\tuvA.fromArray( uvs, a * 2 );\r\n\t\t\t\tuvB.fromArray( uvs, b * 2 );\r\n\t\t\t\tuvC.fromArray( uvs, c * 2 );\r\n\r\n\t\t\t\tintersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tintersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );\r\n\t\t\tintersection.faceIndex = a;\r\n\r\n\t\t}\r\n\r\n\t\treturn intersection;\r\n\r\n\t}\r\n\r\n\treturn function raycast( raycaster, intersects ) {\r\n\r\n\t\tvar geometry = this.geometry;\r\n\t\tvar material = this.material;\r\n\t\tvar matrixWorld = this.matrixWorld;\r\n\r\n\t\tif ( material === undefined ) return;\r\n\r\n\t\t// Checking boundingSphere distance to ray\r\n\r\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n\t\tsphere.copy( geometry.boundingSphere );\r\n\t\tsphere.applyMatrix4( matrixWorld );\r\n\r\n\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\r\n\r\n\t\t//\r\n\r\n\t\tinverseMatrix.getInverse( matrixWorld );\r\n\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n\t\t// Check boundingBox before continuing\r\n\r\n\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\r\n\r\n\t\t}\r\n\r\n\t\tvar uvs, intersection;\r\n\r\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\tvar a, b, c;\r\n\t\t\tvar index = geometry.index;\r\n\t\t\tvar attributes = geometry.attributes;\r\n\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\tif ( attributes.uv !== undefined ) {\r\n\r\n\t\t\t\tuvs = attributes.uv.array;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( index !== null ) {\r\n\r\n\t\t\t\tvar indices = index.array;\r\n\r\n\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\ta = indices[ i ];\r\n\t\t\t\t\tb = indices[ i + 1 ];\r\n\t\t\t\t\tc = indices[ i + 2 ];\r\n\r\n\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\r\n\r\n\t\t\t\t\tif ( intersection ) {\r\n\r\n\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\r\n\t\t\t\t\t\tintersects.push( intersection );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\r\n\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 9 ) {\r\n\r\n\t\t\t\t\ta = i / 3;\r\n\t\t\t\t\tb = a + 1;\r\n\t\t\t\t\tc = a + 2;\r\n\r\n\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\r\n\r\n\t\t\t\t\tif ( intersection ) {\r\n\r\n\t\t\t\t\t\tintersection.index = a; // triangle number in positions buffer semantics\r\n\t\t\t\t\t\tintersects.push( intersection );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\tvar fvA, fvB, fvC;\r\n\t\t\tvar isFaceMaterial = material instanceof THREE.MultiMaterial;\r\n\t\t\tvar materials = isFaceMaterial === true ? material.materials : null;\r\n\r\n\t\t\tvar vertices = geometry.vertices;\r\n\t\t\tvar faces = geometry.faces;\r\n\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\r\n\t\t\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\r\n\r\n\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tvar face = faces[ f ];\r\n\t\t\t\tvar faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;\r\n\r\n\t\t\t\tif ( faceMaterial === undefined ) continue;\r\n\r\n\t\t\t\tfvA = vertices[ face.a ];\r\n\t\t\t\tfvB = vertices[ face.b ];\r\n\t\t\t\tfvC = vertices[ face.c ];\r\n\r\n\t\t\t\tif ( faceMaterial.morphTargets === true ) {\r\n\r\n\t\t\t\t\tvar morphTargets = geometry.morphTargets;\r\n\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\r\n\r\n\t\t\t\t\tvA.set( 0, 0, 0 );\r\n\t\t\t\t\tvB.set( 0, 0, 0 );\r\n\t\t\t\t\tvC.set( 0, 0, 0 );\r\n\r\n\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\r\n\r\n\t\t\t\t\t\tvar influence = morphInfluences[ t ];\r\n\r\n\t\t\t\t\t\tif ( influence === 0 ) continue;\r\n\r\n\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\r\n\r\n\t\t\t\t\t\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\r\n\t\t\t\t\t\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\r\n\t\t\t\t\t\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvA.add( fvA );\r\n\t\t\t\t\tvB.add( fvB );\r\n\t\t\t\t\tvC.add( fvC );\r\n\r\n\t\t\t\t\tfvA = vA;\r\n\t\t\t\t\tfvB = vB;\r\n\t\t\t\t\tfvC = vC;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tintersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\r\n\r\n\t\t\t\tif ( intersection ) {\r\n\r\n\t\t\t\t\tif ( uvs ) {\r\n\r\n\t\t\t\t\t\tvar uvs_f = uvs[ f ];\r\n\t\t\t\t\t\tuvA.copy( uvs_f[ 0 ] );\r\n\t\t\t\t\t\tuvB.copy( uvs_f[ 1 ] );\r\n\t\t\t\t\t\tuvC.copy( uvs_f[ 2 ] );\r\n\r\n\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tintersection.face = face;\r\n\t\t\t\t\tintersection.faceIndex = f;\r\n\t\t\t\t\tintersects.push( intersection );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}() );\r\n\r\nTHREE.Mesh.prototype.clone = function () {\r\n\r\n\treturn new this.constructor( this.geometry, this.material ).copy( this );\r\n\r\n};\r\n\r\n// File:src/objects/Bone.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.Bone = function ( skin ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Bone';\r\n\r\n\tthis.skin = skin;\r\n\r\n};\r\n\r\nTHREE.Bone.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Bone.prototype.constructor = THREE.Bone;\r\n\r\nTHREE.Bone.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Object3D.prototype.copy.call( this, source );\r\n\r\n\tthis.skin = source.skin;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/objects/Skeleton.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author michael guerrero / http://realitymeltdown.com\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {\r\n\r\n\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\r\n\r\n\tthis.identityMatrix = new THREE.Matrix4();\r\n\r\n\t// copy the bone array\r\n\r\n\tbones = bones || [];\r\n\r\n\tthis.bones = bones.slice( 0 );\r\n\r\n\t// create a bone texture or an array of floats\r\n\r\n\tif ( this.useVertexTexture ) {\r\n\r\n\t\t// layout (1 matrix = 4 pixels)\r\n\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\r\n\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\r\n\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\r\n\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\r\n\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\r\n\r\n\t\t\r\n\t\tvar size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\r\n\t\tsize = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );\r\n\t\tsize = Math.max( size, 4 );\r\n\r\n\t\tthis.boneTextureWidth = size;\r\n\t\tthis.boneTextureHeight = size;\r\n\r\n\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\r\n\t\tthis.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\r\n\r\n\t} else {\r\n\r\n\t\tthis.boneMatrices = new Float32Array( 16 * this.bones.length );\r\n\r\n\t}\r\n\r\n\t// use the supplied bone inverses or calculate the inverses\r\n\r\n\tif ( boneInverses === undefined ) {\r\n\r\n\t\tthis.calculateInverses();\r\n\r\n\t} else {\r\n\r\n\t\tif ( this.bones.length === boneInverses.length ) {\r\n\r\n\t\t\tthis.boneInverses = boneInverses.slice( 0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\r\n\r\n\t\t\tthis.boneInverses = [];\r\n\r\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\t\t\tthis.boneInverses.push( new THREE.Matrix4() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Skeleton.prototype.calculateInverses = function () {\r\n\r\n\tthis.boneInverses = [];\r\n\r\n\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\tvar inverse = new THREE.Matrix4();\r\n\r\n\t\tif ( this.bones[ b ] ) {\r\n\r\n\t\t\tinverse.getInverse( this.bones[ b ].matrixWorld );\r\n\r\n\t\t}\r\n\r\n\t\tthis.boneInverses.push( inverse );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Skeleton.prototype.pose = function () {\r\n\r\n\tvar bone;\r\n\r\n\t// recover the bind-time world matrices\r\n\r\n\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\tbone = this.bones[ b ];\r\n\r\n\t\tif ( bone ) {\r\n\r\n\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ b ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// compute the local matrices, positions, rotations and scales\r\n\r\n\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\tbone = this.bones[ b ];\r\n\r\n\t\tif ( bone ) {\r\n\r\n\t\t\tif ( bone.parent ) {\r\n\r\n\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\r\n\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbone.matrix.copy( bone.matrixWorld );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Skeleton.prototype.update = ( function () {\r\n\r\n\tvar offsetMatrix = new THREE.Matrix4();\r\n\r\n\treturn function update() {\r\n\r\n\t\t// flatten bone matrices to array\r\n\r\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\t\t// compute the offset between the current and the original transform\r\n\r\n\t\t\tvar matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\r\n\r\n\t\t\toffsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\r\n\t\t\toffsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.useVertexTexture ) {\r\n\r\n\t\t\tthis.boneTexture.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nTHREE.Skeleton.prototype.clone = function () {\r\n\r\n\treturn new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );\r\n\r\n};\r\n\r\n// File:src/objects/SkinnedMesh.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\tthis.type = 'SkinnedMesh';\r\n\r\n\tthis.bindMode = \"attached\";\r\n\tthis.bindMatrix = new THREE.Matrix4();\r\n\tthis.bindMatrixInverse = new THREE.Matrix4();\r\n\r\n\t// init bones\r\n\r\n\t// TODO: remove bone creation as there is no reason (other than\r\n\t// convenience) for THREE.SkinnedMesh to do this.\r\n\r\n\tvar bones = [];\r\n\r\n\tif ( this.geometry && this.geometry.bones !== undefined ) {\r\n\r\n\t\tvar bone, gbone;\r\n\r\n\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\r\n\r\n\t\t\tgbone = this.geometry.bones[ b ];\r\n\r\n\t\t\tbone = new THREE.Bone( this );\r\n\t\t\tbones.push( bone );\r\n\r\n\t\t\tbone.name = gbone.name;\r\n\t\t\tbone.position.fromArray( gbone.pos );\r\n\t\t\tbone.quaternion.fromArray( gbone.rotq );\r\n\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\r\n\r\n\t\t\tgbone = this.geometry.bones[ b ];\r\n\r\n\t\t\tif ( gbone.parent !== - 1 && gbone.parent !== null ) {\r\n\r\n\t\t\t\tbones[ gbone.parent ].add( bones[ b ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.add( bones[ b ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.normalizeSkinWeights();\r\n\r\n\tthis.updateMatrixWorld( true );\r\n\tthis.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );\r\n\r\n};\r\n\r\n\r\nTHREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;\r\n\r\nTHREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {\r\n\r\n\tthis.skeleton = skeleton;\r\n\r\n\tif ( bindMatrix === undefined ) {\r\n\r\n\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\tthis.skeleton.calculateInverses();\r\n\r\n\t\tbindMatrix = this.matrixWorld;\r\n\r\n\t}\r\n\r\n\tthis.bindMatrix.copy( bindMatrix );\r\n\tthis.bindMatrixInverse.getInverse( bindMatrix );\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.pose = function () {\r\n\r\n\tthis.skeleton.pose();\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {\r\n\r\n\tif ( this.geometry instanceof THREE.Geometry ) {\r\n\r\n\t\tfor ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {\r\n\r\n\t\t\tvar sw = this.geometry.skinWeights[ i ];\r\n\r\n\t\t\tvar scale = 1.0 / sw.lengthManhattan();\r\n\r\n\t\t\tif ( scale !== Infinity ) {\r\n\r\n\t\t\t\tsw.multiplyScalar( scale );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tsw.set( 1, 0, 0, 0 ); // do something reasonable\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else if ( this.geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\tvar vec = new THREE.Vector4();\r\n\r\n\t\tvar skinWeight = this.geometry.attributes.skinWeight;\r\n\r\n\t\tfor ( var i = 0; i < skinWeight.count; i ++ ) {\r\n\r\n\t\t\tvec.x = skinWeight.getX( i );\r\n\t\t\tvec.y = skinWeight.getY( i );\r\n\t\t\tvec.z = skinWeight.getZ( i );\r\n\t\t\tvec.w = skinWeight.getW( i );\r\n\r\n\t\t\tvar scale = 1.0 / vec.lengthManhattan();\r\n\r\n\t\t\tif ( scale !== Infinity ) {\r\n\r\n\t\t\t\tvec.multiplyScalar( scale );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvec.set( 1, 0, 0, 0 ); // do something reasonable\r\n\r\n\t\t\t}\r\n\r\n\t\t\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {\r\n\r\n\tTHREE.Mesh.prototype.updateMatrixWorld.call( this, true );\r\n\r\n\tif ( this.bindMode === \"attached\" ) {\r\n\r\n\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\r\n\r\n\t} else if ( this.bindMode === \"detached\" ) {\r\n\r\n\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.clone = function() {\r\n\r\n\treturn new this.constructor( this.geometry, this.material, this.useVertexTexture ).copy( this );\r\n\r\n};\r\n\r\n// File:src/objects/LOD.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LOD = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'LOD';\r\n\r\n\tObject.defineProperties( this, {\r\n\t\tlevels: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: []\r\n\t\t},\r\n\t\tobjects: {\r\n\t\t\tget: function () {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\r\n\t\t\t\treturn this.levels;\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\r\n};\r\n\r\n\r\nTHREE.LOD.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.LOD.prototype.constructor = THREE.LOD;\r\n\r\nTHREE.LOD.prototype.addLevel = function ( object, distance ) {\r\n\r\n\tif ( distance === undefined ) distance = 0;\r\n\r\n\tdistance = Math.abs( distance );\r\n\r\n\tvar levels = this.levels;\r\n\r\n\tfor ( var l = 0; l < levels.length; l ++ ) {\r\n\r\n\t\tif ( distance < levels[ l ].distance ) {\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tlevels.splice( l, 0, { distance: distance, object: object } );\r\n\r\n\tthis.add( object );\r\n\r\n};\r\n\r\nTHREE.LOD.prototype.getObjectForDistance = function ( distance ) {\r\n\r\n\tvar levels = this.levels;\r\n\r\n\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\r\n\r\n\t\tif ( distance < levels[ i ].distance ) {\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn levels[ i - 1 ].object;\r\n\r\n};\r\n\r\nTHREE.LOD.prototype.raycast = ( function () {\r\n\r\n\tvar matrixPosition = new THREE.Vector3();\r\n\r\n\treturn function raycast( raycaster, intersects ) {\r\n\r\n\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\r\n\r\n\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\r\n\r\n\t};\r\n\r\n}() );\r\n\r\nTHREE.LOD.prototype.update = function () {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\tvar v2 = new THREE.Vector3();\r\n\r\n\treturn function update( camera ) {\r\n\r\n\t\tvar levels = this.levels;\r\n\r\n\t\tif ( levels.length > 1 ) {\r\n\r\n\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\t\tvar distance = v1.distanceTo( v2 );\r\n\r\n\t\t\tlevels[ 0 ].object.visible = true;\r\n\r\n\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tif ( distance >= levels[ i ].distance ) {\r\n\r\n\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\r\n\t\t\t\t\tlevels[ i ].object.visible = true;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( ; i < l; i ++ ) {\r\n\r\n\t\t\t\tlevels[ i ].object.visible = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.LOD.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Object3D.prototype.copy.call( this, source, false );\r\n\r\n\tvar levels = source.levels;\r\n\r\n\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\r\n\r\n\t\tvar level = levels[ i ];\r\n\r\n\t\tthis.addLevel( level.object.clone(), level.distance );\r\n\r\n\t}\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nTHREE.LOD.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n\tdata.object.levels = [];\r\n\r\n\tvar levels = this.levels;\r\n\r\n\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\r\n\r\n\t\tvar level = levels[ i ];\r\n\r\n\t\tdata.object.levels.push( {\r\n\t\t\tobject: level.object.uuid,\r\n\t\t\tdistance: level.distance\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\n// File:src/objects/Sprite.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Sprite = ( function () {\r\n\r\n\tvar indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );\r\n\tvar vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );\r\n\tvar uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );\r\n\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\tgeometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n\treturn function Sprite( material ) {\r\n\r\n\t\tTHREE.Object3D.call( this );\r\n\r\n\t\tthis.type = 'Sprite';\r\n\r\n\t\tthis.geometry = geometry;\r\n\t\tthis.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nTHREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Sprite.prototype.constructor = THREE.Sprite;\r\n\r\nTHREE.Sprite.prototype.raycast = ( function () {\r\n\r\n\tvar matrixPosition = new THREE.Vector3();\r\n\r\n\treturn function raycast( raycaster, intersects ) {\r\n\r\n\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\tvar distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );\r\n\t\tvar guessSizeSq = this.scale.x * this.scale.y;\r\n\r\n\t\tif ( distanceSq > guessSizeSq ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tintersects.push( {\r\n\r\n\t\t\tdistance: Math.sqrt( distanceSq ),\r\n\t\t\tpoint: this.position,\r\n\t\t\tface: null,\r\n\t\t\tobject: this\r\n\r\n\t\t} );\r\n\r\n\t};\r\n\r\n}() );\r\n\r\nTHREE.Sprite.prototype.clone = function () {\r\n\r\n\treturn new this.constructor( this.material ).copy( this );\r\n\r\n};\r\n\r\n// Backwards compatibility\r\n\r\nTHREE.Particle = THREE.Sprite;\r\n\r\n// File:src/objects/LensFlare.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.lensFlares = [];\r\n\r\n\tthis.positionScreen = new THREE.Vector3();\r\n\tthis.customUpdateCallback = undefined;\r\n\r\n\tif ( texture !== undefined ) {\r\n\r\n\t\tthis.add( texture, size, distance, blending, color );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.LensFlare.prototype.constructor = THREE.LensFlare;\r\n\r\n\r\n/*\r\n * Add: adds another flare\r\n */\r\n\r\nTHREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {\r\n\r\n\tif ( size === undefined ) size = - 1;\r\n\tif ( distance === undefined ) distance = 0;\r\n\tif ( opacity === undefined ) opacity = 1;\r\n\tif ( color === undefined ) color = new THREE.Color( 0xffffff );\r\n\tif ( blending === undefined ) blending = THREE.NormalBlending;\r\n\r\n\tdistance = Math.min( distance, Math.max( 0, distance ) );\r\n\r\n\tthis.lensFlares.push( {\r\n\t\ttexture: texture,\t// THREE.Texture\r\n\t\tsize: size, \t\t// size in pixels (-1 = use texture.width)\r\n\t\tdistance: distance, \t// distance (0-1) from light source (0=at light source)\r\n\t\tx: 0, y: 0, z: 0,\t// screen position (-1 => 1) z = 0 is in front z = 1 is back\r\n\t\tscale: 1, \t\t// scale\r\n\t\trotation: 0, \t\t// rotation\r\n\t\topacity: opacity,\t// opacity\r\n\t\tcolor: color,\t\t// color\r\n\t\tblending: blending\t// blending\r\n\t} );\r\n\r\n};\r\n\r\n/*\r\n * Update lens flares update positions on all flares based on the screen position\r\n * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\r\n */\r\n\r\nTHREE.LensFlare.prototype.updateLensFlares = function () {\r\n\r\n\tvar f, fl = this.lensFlares.length;\r\n\tvar flare;\r\n\tvar vecX = - this.positionScreen.x * 2;\r\n\tvar vecY = - this.positionScreen.y * 2;\r\n\r\n\tfor ( f = 0; f < fl; f ++ ) {\r\n\r\n\t\tflare = this.lensFlares[ f ];\r\n\r\n\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\r\n\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\r\n\r\n\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\r\n\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.LensFlare.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Object3D.prototype.copy.call( this, source );\r\n\r\n\tthis.positionScreen.copy( source.positionScreen );\r\n\tthis.customUpdateCallback = source.customUpdateCallback;\r\n\r\n\tfor ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\r\n\r\n\t\tthis.lensFlares.push( source.lensFlares[ i ] );\r\n\r\n\t}\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/scenes/Scene.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Scene = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Scene';\r\n\r\n\tthis.fog = null;\r\n\tthis.overrideMaterial = null;\r\n\r\n\tthis.autoUpdate = true; // checked by the renderer\r\n\r\n};\r\n\r\nTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Scene.prototype.constructor = THREE.Scene;\r\n\r\nTHREE.Scene.prototype.copy = function ( source, recursive ) {\r\n\r\n\tTHREE.Object3D.prototype.copy.call( this, source, recursive );\r\n\r\n\tif ( source.fog !== null ) this.fog = source.fog.clone();\r\n\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\r\n\r\n\tthis.autoUpdate = source.autoUpdate;\r\n\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/scenes/Fog.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Fog = function ( color, near, far ) {\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.color = new THREE.Color( color );\r\n\r\n\tthis.near = ( near !== undefined ) ? near : 1;\r\n\tthis.far = ( far !== undefined ) ? far : 1000;\r\n\r\n};\r\n\r\nTHREE.Fog.prototype.clone = function () {\r\n\r\n\treturn new THREE.Fog( this.color.getHex(), this.near, this.far );\r\n\r\n};\r\n\r\n// File:src/scenes/FogExp2.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.FogExp2 = function ( color, density ) {\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.color = new THREE.Color( color );\r\n\tthis.density = ( density !== undefined ) ? density : 0.00025;\r\n\r\n};\r\n\r\nTHREE.FogExp2.prototype.clone = function () {\r\n\r\n\treturn new THREE.FogExp2( this.color.getHex(), this.density );\r\n\r\n};\r\n\r\n// File:src/renderers/shaders/ShaderChunk.js\r\n\r\nTHREE.ShaderChunk = {};\r\n\r\n// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'alphamap_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'alphamap_pars_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tuniform sampler2D alphaMap;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'alphatest_fragment' ] = \"#ifdef ALPHATEST\\n\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'aomap_fragment' ] = \"#ifdef USE_AOMAP\\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'aomap_pars_fragment' ] = \"#ifdef USE_AOMAP\\n\tuniform sampler2D aoMap;\\n\tuniform float aoMapIntensity;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'begin_vertex' ] = \"\\nvec3 transformed = vec3( position );\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'beginnormal_vertex' ] = \"\\nvec3 objectNormal = vec3( normal );\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/bsdfs.glsl\r\n\r\nTHREE.ShaderChunk[ 'bsdfs' ] = \"bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\t\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\t\t}\\n\t\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\treturn 1.0 / ( gl * gv );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat alpha = pow2( roughness );\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_GGX_Smith( alpha, dotNL, dotNV );\\n\tfloat D = D_GGX( alpha, dotNH );\\n\treturn F * ( G * D );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\tvec4 r = roughness * c0 + c1;\\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_BlinnPhong_Implicit( );\\n\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'bumpmap_pars_fragment' ] = \"#ifdef USE_BUMPMAP\\n\tuniform sampler2D bumpMap;\\n\tuniform float bumpScale;\\n\tvec2 dHdxy_fwd() {\\n\t\tvec2 dSTdx = dFdx( vUv );\\n\t\tvec2 dSTdy = dFdy( vUv );\\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\t\treturn vec2( dBx, dBy );\\n\t}\\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\t\tvec3 vSigmaX = dFdx( surf_pos );\\n\t\tvec3 vSigmaY = dFdy( surf_pos );\\n\t\tvec3 vN = surf_norm;\\n\t\tvec3 R1 = cross( vSigmaY, vN );\\n\t\tvec3 R2 = cross( vN, vSigmaX );\\n\t\tfloat fDet = dot( vSigmaX, R1 );\\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\t}\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_fragment' ] = \"#ifdef USE_COLOR\\n\tdiffuseColor.rgb *= vColor;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_pars_fragment' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_pars_vertex' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_vertex' ] = \"#ifdef USE_COLOR\\n\tvColor.xyz = color.xyz;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/common.glsl\r\n\r\nTHREE.ShaderChunk[ 'common' ] = \"#define PI 3.14159\\n#define PI2 6.28318\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nstruct IncidentLight {\\n\tvec3 color;\\n\tvec3 direction;\\n\tbool visible;\\n};\\nstruct ReflectedLight {\\n\tvec3 directDiffuse;\\n\tvec3 directSpecular;\\n\tvec3 indirectDiffuse;\\n\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\tvec3 position;\\n\tvec3 normal;\\n\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/cube_uv_reflection_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'cube_uv_reflection_fragment' ] = \"#ifdef ENVMAP_TYPE_CUBE_UV\\nconst float cubeUV_textureSize = 1024.0;\\nint getFaceFromDirection(vec3 direction) {\\n    vec3 absDirection = abs(direction);\\n    int face = -1;\\n    if( absDirection.x > absDirection.z ) {\\n        if(absDirection.x > absDirection.y )\\n            face = direction.x > 0.0 ? 0 : 3;\\n        else\\n            face = direction.y > 0.0 ? 1 : 4;\\n    }\\n    else {\\n        if(absDirection.z > absDirection.y )\\n            face = direction.z > 0.0 ? 2 : 5;\\n        else\\n            face = direction.y > 0.0 ? 1 : 4;\\n    }\\n    return face;\\n}\\nconst float cubeUV_maxLods1 = log2(cubeUV_textureSize*0.25) - 1.0;\\nconst float cubeUV_rangeClamp = exp2((6.0 - 1.0) * 2.0);\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n    float scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n    float dxRoughness = dFdx(roughness);\\n    float dyRoughness = dFdy(roughness);\\n    vec3 dx = dFdx( vec * scale * dxRoughness );\\n    vec3 dy = dFdy( vec * scale * dyRoughness );\\n    float d = max( dot( dx, dx ), dot( dy, dy ) );\\n    d = clamp(d, 1.0, cubeUV_rangeClamp);\\n    float mipLevel = 0.5 * log2(d);\\n    return vec2(floor(mipLevel), fract(mipLevel));\\n}\\nconst float cubeUV_maxLods2 = log2(cubeUV_textureSize*0.25) - 2.0;\\nconst float cubeUV_rcpTextureSize = 1.0 / cubeUV_textureSize;\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n    mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n    float a = 16.0 * cubeUV_rcpTextureSize;\\n    vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n    vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n    float powScale = exp2_packed.x * exp2_packed.y;\\n    float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n    float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n    bool bRes = mipLevel == 0.0;\\n    scale =  bRes && (scale < a) ? a : scale;\\n    vec3 r;\\n    vec2 offset;\\n    int face = getFaceFromDirection(direction);\\n    float rcpPowScale = 1.0 / powScale;\\n    if( face == 0) {\\n        r = vec3(direction.x, -direction.z, direction.y);\\n        offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n        offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n    }\\n    else if( face == 1) {\\n        r = vec3(direction.y, direction.x, direction.z);\\n        offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n        offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n    }\\n    else if( face == 2) {\\n        r = vec3(direction.z, direction.x, direction.y);\\n        offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n        offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n    }\\n    else if( face == 3) {\\n        r = vec3(direction.x, direction.z, direction.y);\\n        offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n        offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n    }\\n    else if( face == 4) {\\n        r = vec3(direction.y, direction.x, -direction.z);\\n        offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n        offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n    }\\n    else {\\n        r = vec3(direction.z, -direction.x, direction.y);\\n        offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n        offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n    }\\n    r = normalize(r);\\n    float texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n    vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n    vec2 base = offset + vec2( texelOffset );\\n    return base + s * ( scale - 2.0 * texelOffset );\\n}\\nconst float cubeUV_maxLods3 = log2(cubeUV_textureSize*0.25) - 3.0;\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\n    float roughnessVal = roughness* cubeUV_maxLods3;\\n    float r1 = floor(roughnessVal);\\n    float r2 = r1 + 1.0;\\n    float t = fract(roughnessVal);\\n    vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n    float s = mipInfo.y;\\n    float level0 = mipInfo.x;\\n    float level1 = level0 + 1.0;\\n    level1 = level1 > 5.0 ? 5.0 : level1;\\n    level0 += min( floor( s + 0.5 ), 5.0 );\\n    vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n    vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n    vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n    vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n    vec4 result = mix(color10, color20, t);\\n    return vec4(result.rgb, 1.0);\\n}\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'defaultnormal_vertex' ] = \"#ifdef FLIP_SIDED\\n\tobjectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'displacementmap_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'displacementmap_pars_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\tuniform sampler2D displacementMap;\\n\tuniform float displacementScale;\\n\tuniform float displacementBias;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'emissivemap_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'emissivemap_pars_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tuniform sampler2D emissiveMap;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/encodings_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'encodings_pars_fragment' ] = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n  return value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n  float maxComponent = max( max( value.r, value.g ), value.b );\\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n  float maxRGB = max( value.x, max( value.g, value.b ) );\\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n  M            = ceil( M * 255.0 ) / 255.0;\\n  return vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n    float maxRGB = max( value.x, max( value.g, value.b ) );\\n    float D      = max( maxRange / maxRGB, 1.0 );\\n    D            = min( floor( D ) / 255.0, 1.0 );\\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n  vec4 vResult;\\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n  vResult.w = fract(Le);\\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n  return vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n  float Le = value.z * 255.0 + value.w;\\n  vec3 Xp_Y_XYZp;\\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n  return vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/encodings_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'encodings_fragment' ] = \"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_fragment' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#else\\n\t\tvec3 reflectVec = vReflect;\\n\t#endif\\n\t#ifdef DOUBLE_SIDED\\n\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\t#else\\n\t\tfloat flipNormal = 1.0;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\tvec2 sampleUV;\\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\\n\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\t#endif\\n\tenvColor = envMapTexelToLinear( envColor );\\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_MIX )\\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_ADD )\\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_pars_fragment' ] = \"#if defined( USE_ENVMAP ) || defined( STANDARD )\\n\tuniform float reflectivity;\\n\tuniform float envMapIntenstiy;\\n#endif\\n#ifdef USE_ENVMAP\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tuniform samplerCube envMap;\\n\t#else\\n\t\tuniform sampler2D envMap;\\n\t#endif\\n\tuniform float flipEnvMap;\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( STANDARD )\\n\t\tuniform float refractionRatio;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_pars_vertex' ] = \"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG ) && ! defined( STANDARD )\\n\tvarying vec3 vReflect;\\n\tuniform float refractionRatio;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_vertex' ] = \"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG ) && ! defined( STANDARD )\\n\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\tvReflect = reflect( cameraToVertex, worldNormal );\\n\t#else\\n\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'fog_fragment' ] = \"#ifdef USE_FOG\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\t#else\\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\t#endif\\n\t#ifdef FOG_EXP2\\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\\n\t#else\\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\t#endif\\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'fog_pars_fragment' ] = \"#ifdef USE_FOG\\n\tuniform vec3 fogColor;\\n\t#ifdef FOG_EXP2\\n\t\tuniform float fogDensity;\\n\t#else\\n\t\tuniform float fogNear;\\n\t\tuniform float fogFar;\\n\t#endif\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lightmap_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lightmap_pars_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\tuniform sampler2D lightMap;\\n\tuniform float lightMapIntensity;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_lambert_vertex' ] = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tdirectLight = getPointDirectLightIrradiance( pointLights[ i ], geometry );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tdirectLight = getSpotDirectLightIrradiance( spotLights[ i ], geometry );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectLight = getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\t\t#endif\\n\t}\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_pars.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_pars' ] = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\tvec3 irradiance = ambientLightColor;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\tstruct DirectionalLight {\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\tIncidentLight getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry ) {\\n\t\tIncidentLight directLight;\\n\t\tdirectLight.color = directionalLight.color;\\n\t\tdirectLight.direction = directionalLight.direction;\\n\t\tdirectLight.visible = true;\\n\t\treturn directLight;\\n\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\tstruct PointLight {\\n\t\tvec3 position;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\tIncidentLight getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry ) {\\n\t\tIncidentLight directLight;\\n\t\tvec3 lVector = pointLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\\n\t\t\tdirectLight.color = pointLight.color;\\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t\treturn directLight;\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tstruct SpotLight {\\n\t\tvec3 position;\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tfloat coneCos;\\n\t\tfloat penumbraCos;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\tIncidentLight getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry ) {\\n\t\tIncidentLight directLight;\\n\t\tvec3 lVector = spotLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\t\t\tdirectLight.color = spotLight.color;\\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t\treturn directLight;\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tstruct HemisphereLight {\\n\t\tvec3 direction;\\n\t\tvec3 skyColor;\\n\t\tvec3 groundColor;\\n\t};\\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tirradiance *= PI;\\n\t\t#endif\\n\t\treturn irradiance;\\n\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( STANDARD )\\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\t\t#else\\n\t\t\tfloat flipNormal = 1.0;\\n\t\t#endif\\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#endif\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\n\t\t#else\\n\t\t\tvec4 envMapColor = vec4( 0.0 );\\n\t\t#endif\\n\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\\n\t}\\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\t}\\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\t\t#endif\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\t\t#else\\n\t\t\tfloat flipNormal = 1.0;\\n\t\t#endif\\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#endif\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\t\tvec2 sampleUV;\\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#endif\\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#endif\\n\t\t#endif\\n\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\treturn envMapColor.rgb * envMapIntensity;\\n\t}\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_fragment' ] = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_pars_fragment' ] = \"#ifdef USE_ENVMAP\\n\tvarying vec3 vWorldPosition;\\n#endif\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\tvec3\tdiffuseColor;\\n\tvec3\tspecularColor;\\n\tfloat\tspecularShininess;\\n\tfloat\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\t(0)\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_pars_vertex' ] = \"#ifdef USE_ENVMAP\\n\tvarying vec3 vWorldPosition;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_vertex' ] = \"#ifdef USE_ENVMAP\\n\tvWorldPosition = worldPosition.xyz;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_standard_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_standard_fragment' ] = \"StandardMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\nmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_standard_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_standard_pars_fragment' ] = \"struct StandardMaterial {\\n\tvec3\tdiffuseColor;\\n\tfloat\tspecularRoughness;\\n\tvec3\tspecularColor;\\n};\\nvoid RE_Direct_Standard( const in IncidentLight directLight, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n}\\nvoid RE_IndirectDiffuse_Standard( const in vec3 irradiance, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Standard( const in vec3 radiance, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_Standard\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Standard\\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Standard\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_template.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_template' ] = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tdirectLight = getPointDirectLightIrradiance( pointLight, geometry );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tdirectLight = getSpotDirectLightIrradiance( spotLight, geometry );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tdirectLight = getDirectionalDirectLightIrradiance( directionalLight, geometry );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\t#ifdef USE_LIGHTMAP\\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tlightMapIrradiance *= PI;\\n\t\t#endif\\n\t\tirradiance += lightMapIrradiance;\\n\t#endif\\n\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t}\\n\t#endif\\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\n\t#endif\\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n\tRE_IndirectSpecular( radiance, geometry, material, reflectedLight );\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_fragment' ] = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_pars_fragment' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tuniform float logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_pars_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n\tuniform float logDepthBufFC;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvFragDepth = 1.0 + gl_Position.w;\\n\t#else\\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 texelColor = texture2D( map, vUv );\\n\ttexelColor = mapTexelToLinear( texelColor );\\n\tdiffuseColor *= texelColor;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform sampler2D map;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_particle_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_particle_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform vec4 offsetRepeat;\\n\tuniform sampler2D map;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'metalnessmap_fragment' ] = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\tmetalnessFactor *= texelMetalness.r;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'metalnessmap_pars_fragment' ] = \"#ifdef USE_METALNESSMAP\\n\tuniform sampler2D metalnessMap;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'morphnormal_vertex' ] = \"#ifdef USE_MORPHNORMALS\\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'morphtarget_pars_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\t#ifndef USE_MORPHNORMALS\\n\tuniform float morphTargetInfluences[ 8 ];\\n\t#else\\n\tuniform float morphTargetInfluences[ 4 ];\\n\t#endif\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'morphtarget_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\t#ifndef USE_MORPHNORMALS\\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/normal_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'normal_fragment' ] = \"#ifdef FLAT_SHADED\\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\tvec3 normal = normalize( vNormal );\\n\t#ifdef DOUBLE_SIDED\\n\t\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\n\t#endif\\n#endif\\n#ifdef USE_NORMALMAP\\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'normalmap_pars_fragment' ] = \"#ifdef USE_NORMALMAP\\n\tuniform sampler2D normalMap;\\n\tuniform vec2 normalScale;\\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\\n\t\tvec2 st0 = dFdx( vUv.st );\\n\t\tvec2 st1 = dFdy( vUv.st );\\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\t\tvec3 N = normalize( surf_norm );\\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\t\tmapN.xy = normalScale * mapN.xy;\\n\t\tmat3 tsn = mat3( S, T, N );\\n\t\treturn normalize( tsn * mapN );\\n\t}\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/premultiplied_alpha_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'premultiplied_alpha_fragment' ] = \"#ifdef PREMULTIPLIED_ALPHA\\n\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'project_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 mvPosition = modelViewMatrix * skinned;\\n#else\\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'roughnessmap_fragment' ] = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\troughnessFactor *= texelRoughness.r;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'roughnessmap_pars_fragment' ] = \"#ifdef USE_ROUGHNESSMAP\\n\tuniform sampler2D roughnessMap;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_pars_fragment' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n\tfloat unpackDepth( const in vec4 rgba_depth ) {\\n\t\tconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\\n\t\treturn dot( rgba_depth, bit_shift );\\n\t}\\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\t\treturn step( compare, unpackDepth( texture2D( depths, uv ) ) );\\n\t}\\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\t\tvec2 f = fract( uv * size + 0.5 );\\n\t\tfloat a = mix( lb, lt, f.y );\\n\t\tfloat b = mix( rb, rt, f.y );\\n\t\tfloat c = mix( a, b, f.x );\\n\t\treturn c;\\n\t}\\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tshadowCoord.xyz /= shadowCoord.w;\\n\t\tshadowCoord.z += shadowBias;\\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\t\tbool inFrustum = all( inFrustumVec );\\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\t\tbool frustumTest = all( frustumTestVec );\\n\t\tif ( frustumTest ) {\\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\t\t#endif\\n\t\t}\\n\t\treturn 1.0;\\n\t}\\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\t\tvec3 absV = abs( v );\\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\t\tabsV *= scaleToCube;\\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\t\tvec2 planar = v.xy;\\n\t\tfloat almostATexel = 1.5 * texelSizeY;\\n\t\tfloat almostOne = 1.0 - almostATexel;\\n\t\tif ( absV.z >= almostOne ) {\\n\t\t\tif ( v.z > 0.0 )\\n\t\t\t\tplanar.x = 4.0 - v.x;\\n\t\t} else if ( absV.x >= almostOne ) {\\n\t\t\tfloat signX = sign( v.x );\\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\\n\t\t} else if ( absV.y >= almostOne ) {\\n\t\t\tfloat signY = sign( v.y );\\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\t\t\tplanar.y = v.z * signY - 2.0;\\n\t\t}\\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\t}\\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\t\tvec3 lightToPosition = shadowCoord.xyz;\\n\t\tvec3 bd3D = normalize( lightToPosition );\\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\t\t#endif\\n\t}\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_pars_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmask_pars_fragment' ] = \"float getShadowMask() {\\n\tfloat shadow = 1.0;\\n\t#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#endif\\n\treturn shadow;\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinbase_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinning_pars_vertex' ] = \"#ifdef USE_SKINNING\\n\tuniform mat4 bindMatrix;\\n\tuniform mat4 bindMatrixInverse;\\n\t#ifdef BONE_TEXTURE\\n\t\tuniform sampler2D boneTexture;\\n\t\tuniform int boneTextureWidth;\\n\t\tuniform int boneTextureHeight;\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tfloat j = i * 4.0;\\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\\n\t\t\ty = dy * ( y + 0.5 );\\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\t\t\treturn bone;\\n\t\t}\\n\t#else\\n\t\tuniform mat4 boneGlobalMatrices[ MAX_BONES ];\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tmat4 bone = boneGlobalMatrices[ int(i) ];\\n\t\t\treturn bone;\\n\t\t}\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinning_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\tvec4 skinned = vec4( 0.0 );\\n\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\tskinned  = bindMatrixInverse * skinned;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinnormal_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 skinMatrix = mat4( 0.0 );\\n\tskinMatrix += skinWeight.x * boneMatX;\\n\tskinMatrix += skinWeight.y * boneMatY;\\n\tskinMatrix += skinWeight.z * boneMatZ;\\n\tskinMatrix += skinWeight.w * boneMatW;\\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'specularmap_fragment' ] = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\tspecularStrength = texelSpecular.r;\\n#else\\n\tspecularStrength = 1.0;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'specularmap_pars_fragment' ] = \"#ifdef USE_SPECULARMAP\\n\tuniform sampler2D specularMap;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/tonemapping_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'tonemapping_fragment' ] = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/tonemapping_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'tonemapping_pars_fragment' ] = \"#define saturate(a) clamp( a, 0.0, 1.0 )\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n  return toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  color = max( vec3( 0.0 ), color - 0.004 );\\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv2_pars_fragment' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvarying vec2 vUv2;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv2_pars_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tattribute vec2 uv2;\\n\tvarying vec2 vUv2;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv2_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvUv2 = uv2;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv_pars_fragment' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv_pars_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n\tuniform vec4 offsetRepeat;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'worldpos_vertex' ] = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( STANDARD ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\t#ifdef USE_SKINNING\\n\t\tvec4 worldPosition = modelMatrix * skinned;\\n\t#else\\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/UniformsUtils.js\r\n\r\n/**\r\n * Uniform Utilities\r\n */\r\n\r\nTHREE.UniformsUtils = {\r\n\r\n\tmerge: function ( uniforms ) {\r\n\r\n\t\tvar merged = {};\r\n\r\n\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\r\n\r\n\t\t\tvar tmp = this.clone( uniforms[ u ] );\r\n\r\n\t\t\tfor ( var p in tmp ) {\r\n\r\n\t\t\t\tmerged[ p ] = tmp[ p ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn merged;\r\n\r\n\t},\r\n\r\n\tclone: function ( uniforms_src ) {\r\n\r\n\t\tvar uniforms_dst = {};\r\n\r\n\t\tfor ( var u in uniforms_src ) {\r\n\r\n\t\t\tuniforms_dst[ u ] = {};\r\n\r\n\t\t\tfor ( var p in uniforms_src[ u ] ) {\r\n\r\n\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\r\n\r\n\t\t\t\tif ( parameter_src instanceof THREE.Color ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Vector2 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Vector3 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Vector4 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Matrix3 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Matrix4 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Texture ) {\r\n\r\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\r\n\r\n\t\t\t\t} else if ( Array.isArray( parameter_src ) ) {\r\n\r\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn uniforms_dst;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/renderers/shaders/UniformsLib.js\r\n\r\n/**\r\n * Uniforms library for shared webgl shaders\r\n */\r\n\r\nTHREE.UniformsLib = {\r\n\r\n\tcommon: {\r\n\r\n\t\t\"diffuse\": { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n\t\t\"opacity\": { type: \"f\", value: 1.0 },\r\n\r\n\t\t\"map\": { type: \"t\", value: null },\r\n\t\t\"offsetRepeat\": { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\r\n\r\n\t\t\"specularMap\": { type: \"t\", value: null },\r\n\t\t\"alphaMap\": { type: \"t\", value: null },\r\n\r\n\t\t\"envMap\": { type: \"t\", value: null },\r\n\t\t\"flipEnvMap\": { type: \"f\", value: - 1 },\r\n\t\t\"reflectivity\": { type: \"f\", value: 1.0 },\r\n\t\t\"refractionRatio\": { type: \"f\", value: 0.98 }\r\n\r\n\t},\r\n\r\n\taomap: {\r\n\r\n\t\t\"aoMap\": { type: \"t\", value: null },\r\n\t\t\"aoMapIntensity\": { type: \"f\", value: 1 }\r\n\r\n\t},\r\n\r\n\tlightmap: {\r\n\r\n\t\t\"lightMap\": { type: \"t\", value: null },\r\n\t\t\"lightMapIntensity\": { type: \"f\", value: 1 }\r\n\r\n\t},\r\n\r\n\temissivemap: {\r\n\r\n\t\t\"emissiveMap\": { type: \"t\", value: null }\r\n\r\n\t},\r\n\r\n\tbumpmap: {\r\n\r\n\t\t\"bumpMap\": { type: \"t\", value: null },\r\n\t\t\"bumpScale\": { type: \"f\", value: 1 }\r\n\r\n\t},\r\n\r\n\tnormalmap: {\r\n\r\n\t\t\"normalMap\": { type: \"t\", value: null },\r\n\t\t\"normalScale\": { type: \"v2\", value: new THREE.Vector2( 1, 1 ) }\r\n\r\n\t},\r\n\r\n\tdisplacementmap: {\r\n\r\n\t\t\"displacementMap\": { type: \"t\", value: null },\r\n\t\t\"displacementScale\": { type: \"f\", value: 1 },\r\n\t\t\"displacementBias\": { type: \"f\", value: 0 }\r\n\r\n\t},\r\n\r\n\troughnessmap: {\r\n\r\n\t\t\"roughnessMap\": { type: \"t\", value: null }\r\n\r\n\t},\r\n\r\n\tmetalnessmap: {\r\n\r\n\t\t\"metalnessMap\": { type: \"t\", value: null }\r\n\r\n\t},\r\n\r\n\tfog: {\r\n\r\n\t\t\"fogDensity\": { type: \"f\", value: 0.00025 },\r\n\t\t\"fogNear\": { type: \"f\", value: 1 },\r\n\t\t\"fogFar\": { type: \"f\", value: 2000 },\r\n\t\t\"fogColor\": { type: \"c\", value: new THREE.Color( 0xffffff ) }\r\n\r\n\t},\r\n\r\n\tlights: {\r\n\r\n\t\t\"ambientLightColor\": { type: \"fv\", value: [] },\r\n\r\n\t\t\"directionalLights\": { type: \"sa\", value: [], properties: {\r\n\t\t\t\"direction\": { type: \"v3\" },\r\n\t\t\t\"color\": { type: \"c\" },\r\n\r\n\t\t\t\"shadow\": { type: \"i\" },\r\n\t\t\t\"shadowBias\": { type: \"f\" },\r\n\t\t\t\"shadowRadius\": { type: \"f\" },\r\n\t\t\t\"shadowMapSize\": { type: \"v2\" }\r\n\t\t} },\r\n\r\n\t\t\"directionalShadowMap\": { type: \"tv\", value: [] },\r\n\t\t\"directionalShadowMatrix\": { type: \"m4v\", value: [] },\r\n\r\n\t\t\"spotLights\": { type: \"sa\", value: [], properties: {\r\n\t\t\t\"color\": { type: \"c\" },\r\n\t\t\t\"position\": { type: \"v3\" },\r\n\t\t\t\"direction\": { type: \"v3\" },\r\n\t\t\t\"distance\": { type: \"f\" },\r\n\t\t\t\"coneCos\": { type: \"f\" },\r\n\t\t\t\"penumbraCos\": { type: \"f\" },\r\n\t\t\t\"decay\": { type: \"f\" },\r\n\r\n\t\t\t\"shadow\": { type: \"i\" },\r\n\t\t\t\"shadowBias\": { type: \"f\" },\r\n\t\t\t\"shadowRadius\": { type: \"f\" },\r\n\t\t\t\"shadowMapSize\": { type: \"v2\" }\r\n\t\t} },\r\n\r\n\t\t\"spotShadowMap\": { type: \"tv\", value: [] },\r\n\t\t\"spotShadowMatrix\": { type: \"m4v\", value: [] },\r\n\r\n\t\t\"pointLights\": { type: \"sa\", value: [], properties: {\r\n\t\t\t\"color\": { type: \"c\" },\r\n\t\t\t\"position\": { type: \"v3\" },\r\n\t\t\t\"decay\": { type: \"f\" },\r\n\t\t\t\"distance\": { type: \"f\" },\r\n\r\n\t\t\t\"shadow\": { type: \"i\" },\r\n\t\t\t\"shadowBias\": { type: \"f\" },\r\n\t\t\t\"shadowRadius\": { type: \"f\" },\r\n\t\t\t\"shadowMapSize\": { type: \"v2\" }\r\n\t\t} },\r\n\r\n\t\t\"pointShadowMap\": { type: \"tv\", value: [] },\r\n\t\t\"pointShadowMatrix\": { type: \"m4v\", value: [] },\r\n\r\n\t\t\"hemisphereLights\": { type: \"sa\", value: [], properties: {\r\n\t\t\t\"direction\": { type: \"v3\" },\r\n\t\t\t\"skyColor\": { type: \"c\" },\r\n\t\t\t\"groundColor\": { type: \"c\" }\r\n\t\t} }\r\n\r\n\t},\r\n\r\n\tpoints: {\r\n\r\n\t\t\"diffuse\": { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n\t\t\"opacity\": { type: \"f\", value: 1.0 },\r\n\t\t\"size\": { type: \"f\", value: 1.0 },\r\n\t\t\"scale\": { type: \"f\", value: 1.0 },\r\n\t\t\"map\": { type: \"t\", value: null },\r\n\t\t\"offsetRepeat\": { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) }\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/renderers/shaders/ShaderLib/cube_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'cube_frag' ] = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/cube_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'cube_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\t#include <logdepthbuf_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/depth_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'depth_frag' ] = \"uniform float mNear;\\nuniform float mFar;\\nuniform float opacity;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\t#include <logdepthbuf_fragment>\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\t#else\\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\t#endif\\n\tfloat color = 1.0 - smoothstep( mNear, mFar, depth );\\n\tgl_FragColor = vec4( vec3( color ), opacity );\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/depth_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'depth_vert' ] = \"#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/depthRGBA_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'depthRGBA_frag' ] = \"#include <common>\\n#include <logdepthbuf_pars_fragment>\\nvec4 pack_depth( const in float depth ) {\\n\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\\n\tconst vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\\n\tvec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\\n\tres -= res.xxyz * bit_mask;\\n\treturn res;\\n}\\nvoid main() {\\n\t#include <logdepthbuf_fragment>\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tgl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\\n\t#else\\n\t\tgl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\\n\t#endif\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/depthRGBA_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'depthRGBA_vert' ] = \"#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/distanceRGBA_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'distanceRGBA_frag' ] = \"uniform vec3 lightPos;\\nvarying vec4 vWorldPosition;\\n#include <common>\\nvec4 pack1K ( float depth ) {\\n\tdepth /= 1000.0;\\n\tconst vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\\n\tconst vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\\n\tvec4 res = mod( depth * bitSh * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\\n\tres -= res.xxyz * bitMsk;\\n\treturn res;\\n}\\nfloat unpack1K ( vec4 color ) {\\n\tconst vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\\n\treturn dot( color, bitSh ) * 1000.0;\\n}\\nvoid main () {\\n\tgl_FragColor = pack1K( length( vWorldPosition.xyz - lightPos.xyz ) );\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/distanceRGBA_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'distanceRGBA_vert' ] = \"varying vec4 vWorldPosition;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\nvoid main() {\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <worldpos_vertex>\\n\tvWorldPosition = worldPosition;\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/equirect_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'equirect_frag' ] = \"uniform sampler2D tEquirect;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\tvec3 direction = normalize( vWorldPosition );\\n\tvec2 sampleUV;\\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/equirect_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'equirect_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\t#include <logdepthbuf_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/linedashed_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'linedashed_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\t\tdiscard;\\n\t}\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <color_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/linedashed_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'linedashed_vert' ] = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\tvLineDistance = scale * lineDistance;\\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\tgl_Position = projectionMatrix * mvPosition;\\n\t#include <logdepthbuf_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/meshbasic_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'meshbasic_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\tReflectedLight reflectedLight;\\n\treflectedLight.directDiffuse = vec3( 0.0 );\\n\treflectedLight.directSpecular = vec3( 0.0 );\\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\\n\treflectedLight.indirectSpecular = vec3( 0.0 );\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/meshbasic_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'meshbasic_vert' ] = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <skinbase_vertex>\\n\t#ifdef USE_ENVMAP\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#endif\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/meshlambert_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'meshlambert_frag' ] = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <emissivemap_fragment>\\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\t#include <lightmap_fragment>\\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\t#ifdef DOUBLE_SIDED\\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\t#else\\n\t\treflectedLight.directDiffuse = vLightFront;\\n\t#endif\\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/meshlambert_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'meshlambert_vert' ] = \"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <lights_lambert_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/meshphong_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'meshphong_frag' ] = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_phong_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/meshphong_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'meshphong_vert' ] = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <lights_phong_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <lights_phong_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/meshstandard_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'meshstandard_frag' ] = \"#define STANDARD\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\nuniform float envMapIntensity;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_standard_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <roughnessmap_fragment>\\n\t#include <metalnessmap_fragment>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_standard_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/meshstandard_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'meshstandard_vert' ] = \"#define STANDARD\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/normal_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'normal_frag' ] = \"uniform float opacity;\\nvarying vec3 vNormal;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\tgl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/normal_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'normal_vert' ] = \"varying vec3 vNormal;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\tvNormal = normalize( normalMatrix * normal );\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/points_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'points_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_particle_fragment>\\n\t#include <color_fragment>\\n\t#include <alphatest_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/points_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'points_vert' ] = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#ifdef USE_SIZEATTENUATION\\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\t#else\\n\t\tgl_PointSize = size;\\n\t#endif\\n\t#include <logdepthbuf_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib.js\r\n\r\n/**\r\n * Webgl Shader Library for three.js\r\n *\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n */\r\n\r\n\r\nTHREE.ShaderLib = {\r\n\r\n\t'basic': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\tTHREE.UniformsLib[ \"aomap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ]\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: THREE.ShaderChunk['meshbasic_vert'],\r\n\t\tfragmentShader: THREE.ShaderChunk['meshbasic_frag']\r\n\r\n\t},\r\n\r\n\t'lambert': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\tTHREE.UniformsLib[ \"aomap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"lightmap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"emissivemap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) }\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: THREE.ShaderChunk['meshlambert_vert'],\r\n\t\tfragmentShader: THREE.ShaderChunk['meshlambert_frag']\r\n\r\n\t},\r\n\r\n\t'phong': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\tTHREE.UniformsLib[ \"aomap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"lightmap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"emissivemap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"bumpmap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"normalmap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"displacementmap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\"specular\" : { type: \"c\", value: new THREE.Color( 0x111111 ) },\r\n\t\t\t\t\"shininess\": { type: \"f\", value: 30 }\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: THREE.ShaderChunk['meshphong_vert'],\r\n\t\tfragmentShader: THREE.ShaderChunk['meshphong_frag']\r\n\r\n\t},\r\n\r\n\t'standard': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\tTHREE.UniformsLib[ \"aomap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"lightmap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"emissivemap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"bumpmap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"normalmap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"displacementmap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"roughnessmap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"metalnessmap\" ],\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\"roughness\": { type: \"f\", value: 0.5 },\r\n\t\t\t\t\"metalness\": { type: \"f\", value: 0 },\r\n\t\t\t\t\"envMapIntensity\" : { type: \"f\", value: 1 } // temporary\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: THREE.ShaderChunk['meshstandard_vert'],\r\n\t\tfragmentShader: THREE.ShaderChunk['meshstandard_frag']\r\n\r\n\t},\r\n\r\n\t'points': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"points\" ],\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ]\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: THREE.ShaderChunk['points_vert'],\r\n\t\tfragmentShader: THREE.ShaderChunk['points_frag']\r\n\r\n\t},\r\n\r\n\t'dashed': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ \"common\" ],\r\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"scale\"    : { type: \"f\", value: 1 },\r\n\t\t\t\t\"dashSize\" : { type: \"f\", value: 1 },\r\n\t\t\t\t\"totalSize\": { type: \"f\", value: 2 }\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: THREE.ShaderChunk['linedashed_vert'],\r\n\t\tfragmentShader: THREE.ShaderChunk['linedashed_frag']\r\n\r\n\t},\r\n\r\n\t'depth': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"mNear\": { type: \"f\", value: 1.0 },\r\n\t\t\t\"mFar\" : { type: \"f\", value: 2000.0 },\r\n\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: THREE.ShaderChunk['depth_vert'],\r\n\t\tfragmentShader: THREE.ShaderChunk['depth_frag']\r\n\r\n\t},\r\n\r\n\t'normal': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: THREE.ShaderChunk['normal_vert'],\r\n\t\tfragmentShader: THREE.ShaderChunk['normal_frag']\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tCube map shader\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'cube': {\r\n\r\n\t\tuniforms: {\r\n\t\t\t\"tCube\": { type: \"t\", value: null },\r\n\t\t\t\"tFlip\": { type: \"f\", value: - 1 }\r\n\t\t},\r\n\r\n\t\tvertexShader: THREE.ShaderChunk['cube_vert'],\r\n\t\tfragmentShader: THREE.ShaderChunk['cube_frag']\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tCube map shader\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'equirect': {\r\n\r\n\t\tuniforms: {\r\n\t\t\t\"tEquirect\": { type: \"t\", value: null },\r\n\t\t\t\"tFlip\": { type: \"f\", value: - 1 }\r\n\t\t},\r\n\r\n\t\tvertexShader: THREE.ShaderChunk['equirect_vert'],\r\n\t\tfragmentShader: THREE.ShaderChunk['equirect_frag']\r\n\r\n\t},\r\n\r\n\t/* Depth encoding into RGBA texture\r\n\t *\r\n\t * based on SpiderGL shadow map example\r\n\t * http://spidergl.org/example.php?id=6\r\n\t *\r\n\t * originally from\r\n\t * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD\r\n\t *\r\n\t * see also\r\n\t * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\r\n\t */\r\n\r\n\t'depthRGBA': {\r\n\r\n\t\tuniforms: {},\r\n\r\n\t\tvertexShader: THREE.ShaderChunk['depthRGBA_vert'],\r\n\t\tfragmentShader: THREE.ShaderChunk['depthRGBA_frag']\r\n\r\n\t},\r\n\r\n\r\n\t'distanceRGBA': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"lightPos\": { type: \"v3\", value: new THREE.Vector3( 0, 0, 0 ) }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: THREE.ShaderChunk['distanceRGBA_vert'],\r\n\t\tfragmentShader: THREE.ShaderChunk['distanceRGBA_frag']\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/renderers/WebGLRenderer.js\r\n\r\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author szimek / https://github.com/szimek/\r\n */\r\n\r\nTHREE.WebGLRenderer = function ( parameters ) {\r\n\r\n\tconsole.log( 'THREE.WebGLRenderer', THREE.REVISION );\r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),\r\n\t_context = parameters.context !== undefined ? parameters.context : null,\r\n\r\n\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\r\n\t_depth = parameters.depth !== undefined ? parameters.depth : true,\r\n\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\r\n\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\r\n\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\r\n\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;\r\n\r\n\tvar lights = [];\r\n\r\n\tvar opaqueObjects = [];\r\n\tvar opaqueObjectsLastIndex = - 1;\r\n\tvar transparentObjects = [];\r\n\tvar transparentObjectsLastIndex = - 1;\r\n\r\n\tvar morphInfluences = new Float32Array( 8 );\r\n\r\n\tvar sprites = [];\r\n\tvar lensFlares = [];\r\n\r\n\t// public properties\r\n\r\n\tthis.domElement = _canvas;\r\n\tthis.context = null;\r\n\r\n\t// clearing\r\n\r\n\tthis.autoClear = true;\r\n\tthis.autoClearColor = true;\r\n\tthis.autoClearDepth = true;\r\n\tthis.autoClearStencil = true;\r\n\r\n\t// scene graph\r\n\r\n\tthis.sortObjects = true;\r\n\r\n\t// physically based shading\r\n\r\n\tthis.gammaFactor = 2.0;\t// for backwards compatibility\r\n\tthis.gammaInput = false;\r\n\tthis.gammaOutput = false;\r\n\r\n\t// physical lights\r\n\r\n\tthis.physicallyCorrectLights = false;\r\n\r\n\t// tone mapping\r\n\r\n\tthis.toneMapping = THREE.LinearToneMapping;\r\n\tthis.toneMappingExposure = 1.0;\r\n\tthis.toneMappingWhitePoint = 1.0;\r\n\r\n\t// morphs\r\n\r\n\tthis.maxMorphTargets = 8;\r\n\tthis.maxMorphNormals = 4;\r\n\r\n\t// flags\r\n\r\n\tthis.autoScaleCubemaps = true;\r\n\r\n\t// internal properties\r\n\r\n\tvar _this = this,\r\n\r\n\t// internal state cache\r\n\r\n\t_currentProgram = null,\r\n\t_currentRenderTarget = null,\r\n\t_currentFramebuffer = null,\r\n\t_currentMaterialId = - 1,\r\n\t_currentGeometryProgram = '',\r\n\t_currentCamera = null,\r\n\r\n\t_currentScissor = new THREE.Vector4(),\r\n\t_currentScissorTest = null,\r\n\r\n\t_currentViewport = new THREE.Vector4(),\r\n\r\n\t//\r\n\r\n\t_usedTextureUnits = 0,\r\n\r\n\t//\r\n\r\n\t_clearColor = new THREE.Color( 0x000000 ),\r\n\t_clearAlpha = 0,\r\n\r\n\t_width = _canvas.width,\r\n\t_height = _canvas.height,\r\n\r\n\t_pixelRatio = 1,\r\n\r\n\t_scissor = new THREE.Vector4( 0, 0, _width, _height ),\r\n\t_scissorTest = false,\r\n\r\n\t_viewport = new THREE.Vector4( 0, 0, _width, _height ),\r\n\r\n\t// frustum\r\n\r\n\t_frustum = new THREE.Frustum(),\r\n\r\n\t// camera matrices cache\r\n\r\n\t_projScreenMatrix = new THREE.Matrix4(),\r\n\r\n\t_vector3 = new THREE.Vector3(),\r\n\r\n\t// light arrays cache\r\n\r\n\t_lights = {\r\n\r\n\t\thash: '',\r\n\r\n\t\tambient: [ 0, 0, 0 ],\r\n\t\tdirectional: [],\r\n\t\tdirectionalShadowMap: [],\r\n\t\tdirectionalShadowMatrix: [],\r\n\t\tspot: [],\r\n\t\tspotShadowMap: [],\r\n\t\tspotShadowMatrix: [],\r\n\t\tpoint: [],\r\n\t\tpointShadowMap: [],\r\n\t\tpointShadowMatrix: [],\r\n\t\themi: [],\r\n\r\n\t\tshadows: [],\r\n\t\tshadowsPointLight: 0\r\n\r\n\t},\r\n\r\n\t// info\r\n\r\n\t_infoMemory = {\r\n\r\n\t\tgeometries: 0,\r\n\t\ttextures: 0\r\n\r\n\t},\r\n\r\n\t_infoRender = {\r\n\r\n\t\tcalls: 0,\r\n\t\tvertices: 0,\r\n\t\tfaces: 0,\r\n\t\tpoints: 0\r\n\r\n\t};\r\n\r\n\tthis.info = {\r\n\r\n\t\trender: _infoRender,\r\n\t\tmemory: _infoMemory,\r\n\t\tprograms: null\r\n\r\n\t};\r\n\r\n\r\n\t// initialize\r\n\r\n\tvar _gl;\r\n\r\n\ttry {\r\n\r\n\t\tvar attributes = {\r\n\t\t\talpha: _alpha,\r\n\t\t\tdepth: _depth,\r\n\t\t\tstencil: _stencil,\r\n\t\t\tantialias: _antialias,\r\n\t\t\tpremultipliedAlpha: _premultipliedAlpha,\r\n\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\r\n\t\t};\r\n\r\n\t\t_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\r\n\r\n\t\tif ( _gl === null ) {\r\n\r\n\t\t\tif ( _canvas.getContext( 'webgl' ) !== null ) {\r\n\r\n\t\t\t\tthrow 'Error creating WebGL context with your selected attributes.';\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthrow 'Error creating WebGL context.';\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\r\n\r\n\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\r\n\r\n\t\t\t_gl.getShaderPrecisionFormat = function () {\r\n\r\n\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\r\n\r\n\t} catch ( error ) {\r\n\r\n\t\tconsole.error( 'THREE.WebGLRenderer: ' + error );\r\n\r\n\t}\r\n\r\n\tvar extensions = new THREE.WebGLExtensions( _gl );\r\n\r\n\textensions.get( 'OES_texture_float' );\r\n\textensions.get( 'OES_texture_float_linear' );\r\n\textensions.get( 'OES_texture_half_float' );\r\n\textensions.get( 'OES_texture_half_float_linear' );\r\n\textensions.get( 'OES_standard_derivatives' );\r\n\textensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n\tif ( extensions.get( 'OES_element_index_uint' ) ) {\r\n\r\n\t\tTHREE.BufferGeometry.MaxIndex = 4294967296;\r\n\r\n\t}\r\n\r\n\tvar capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );\r\n\r\n\tvar state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );\r\n\tvar properties = new THREE.WebGLProperties();\r\n\tvar objects = new THREE.WebGLObjects( _gl, properties, this.info );\r\n\tvar programCache = new THREE.WebGLPrograms( this, capabilities );\r\n\tvar lightCache = new THREE.WebGLLights();\r\n\r\n\tthis.info.programs = programCache.programs;\r\n\r\n\tvar bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );\r\n\tvar indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\r\n\r\n\t//\r\n\r\n\tfunction getTargetPixelRatio() {\r\n\r\n\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\r\n\r\n\t}\r\n\r\n\tfunction glClearColor( r, g, b, a ) {\r\n\r\n\t\tif ( _premultipliedAlpha === true ) {\r\n\r\n\t\t\tr *= a; g *= a; b *= a;\r\n\r\n\t\t}\r\n\r\n\t\tstate.clearColor( r, g, b, a );\r\n\r\n\t}\r\n\r\n\tfunction setDefaultGLState() {\r\n\r\n\t\tstate.init();\r\n\r\n\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\r\n\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\r\n\r\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n\t}\r\n\r\n\tfunction resetGLState() {\r\n\r\n\t\t_currentProgram = null;\r\n\t\t_currentCamera = null;\r\n\r\n\t\t_currentGeometryProgram = '';\r\n\t\t_currentMaterialId = - 1;\r\n\r\n\t\tstate.reset();\r\n\r\n\t}\r\n\r\n\tsetDefaultGLState();\r\n\r\n\tthis.context = _gl;\r\n\tthis.capabilities = capabilities;\r\n\tthis.extensions = extensions;\r\n\tthis.properties = properties;\r\n\tthis.state = state;\r\n\r\n\t// shadow map\r\n\r\n\tvar shadowMap = new THREE.WebGLShadowMap( this, _lights, objects );\r\n\r\n\tthis.shadowMap = shadowMap;\r\n\r\n\r\n\t// Plugins\r\n\r\n\tvar spritePlugin = new THREE.SpritePlugin( this, sprites );\r\n\tvar lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );\r\n\r\n\t// API\r\n\r\n\tthis.getContext = function () {\r\n\r\n\t\treturn _gl;\r\n\r\n\t};\r\n\r\n\tthis.getContextAttributes = function () {\r\n\r\n\t\treturn _gl.getContextAttributes();\r\n\r\n\t};\r\n\r\n\tthis.forceContextLoss = function () {\r\n\r\n\t\textensions.get( 'WEBGL_lose_context' ).loseContext();\r\n\r\n\t};\r\n\r\n\tthis.getMaxAnisotropy = ( function () {\r\n\r\n\t\tvar value;\r\n\r\n\t\treturn function getMaxAnisotropy() {\r\n\r\n\t\t\tif ( value !== undefined ) return value;\r\n\r\n\t\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\r\n\t\t\tif ( extension !== null ) {\r\n\r\n\t\t\t\tvalue = _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvalue = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn value;\r\n\r\n\t\t};\r\n\r\n\t} )();\r\n\r\n\tthis.getPrecision = function () {\r\n\r\n\t\treturn capabilities.precision;\r\n\r\n\t};\r\n\r\n\tthis.getPixelRatio = function () {\r\n\r\n\t\treturn _pixelRatio;\r\n\r\n\t};\r\n\r\n\tthis.setPixelRatio = function ( value ) {\r\n\r\n\t\tif ( value === undefined ) return;\r\n\r\n\t\t_pixelRatio = value;\r\n\r\n\t\tthis.setSize( _viewport.z, _viewport.w, false );\r\n\r\n\t};\r\n\r\n\tthis.getSize = function () {\r\n\r\n\t\treturn {\r\n\t\t\twidth: _width,\r\n\t\t\theight: _height\r\n\t\t};\r\n\r\n\t};\r\n\r\n\tthis.setSize = function ( width, height, updateStyle ) {\r\n\r\n\t\t_width = width;\r\n\t\t_height = height;\r\n\r\n\t\t_canvas.width = width * _pixelRatio;\r\n\t\t_canvas.height = height * _pixelRatio;\r\n\r\n\t\tif ( updateStyle !== false ) {\r\n\r\n\t\t\t_canvas.style.width = width + 'px';\r\n\t\t\t_canvas.style.height = height + 'px';\r\n\r\n\t\t}\r\n\r\n\t\tthis.setViewport( 0, 0, width, height );\r\n\r\n\t};\r\n\r\n\tthis.setViewport = function ( x, y, width, height ) {\r\n\r\n\t\tstate.viewport( _viewport.set( x, y, width, height ) );\r\n\r\n\t};\r\n\r\n\tthis.setScissor = function ( x, y, width, height ) {\r\n\r\n\t\tstate.scissor( _scissor.set( x, y, width, height ) );\r\n\r\n\t};\r\n\r\n\tthis.setScissorTest = function ( boolean ) {\r\n\r\n\t\tstate.setScissorTest( _scissorTest = boolean );\r\n\r\n\t};\r\n\r\n\t// Clearing\r\n\r\n\tthis.getClearColor = function () {\r\n\r\n\t\treturn _clearColor;\r\n\r\n\t};\r\n\r\n\tthis.setClearColor = function ( color, alpha ) {\r\n\r\n\t\t_clearColor.set( color );\r\n\r\n\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\r\n\r\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n\t};\r\n\r\n\tthis.getClearAlpha = function () {\r\n\r\n\t\treturn _clearAlpha;\r\n\r\n\t};\r\n\r\n\tthis.setClearAlpha = function ( alpha ) {\r\n\r\n\t\t_clearAlpha = alpha;\r\n\r\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n\t};\r\n\r\n\tthis.clear = function ( color, depth, stencil ) {\r\n\r\n\t\tvar bits = 0;\r\n\r\n\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\r\n\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\r\n\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\r\n\r\n\t\t_gl.clear( bits );\r\n\r\n\t};\r\n\r\n\tthis.clearColor = function () {\r\n\r\n\t\tthis.clear( true, false, false );\r\n\r\n\t};\r\n\r\n\tthis.clearDepth = function () {\r\n\r\n\t\tthis.clear( false, true, false );\r\n\r\n\t};\r\n\r\n\tthis.clearStencil = function () {\r\n\r\n\t\tthis.clear( false, false, true );\r\n\r\n\t};\r\n\r\n\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\r\n\r\n\t\tthis.setRenderTarget( renderTarget );\r\n\t\tthis.clear( color, depth, stencil );\r\n\r\n\t};\r\n\r\n\t// Reset\r\n\r\n\tthis.resetGLState = resetGLState;\r\n\r\n\tthis.dispose = function() {\r\n\r\n\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\r\n\r\n\t};\r\n\r\n\t// Events\r\n\r\n\tfunction onContextLost( event ) {\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\tresetGLState();\r\n\t\tsetDefaultGLState();\r\n\r\n\t\tproperties.clear();\r\n\r\n\t}\r\n\r\n\tfunction onTextureDispose( event ) {\r\n\r\n\t\tvar texture = event.target;\r\n\r\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\tdeallocateTexture( texture );\r\n\r\n\t\t_infoMemory.textures --;\r\n\r\n\r\n\t}\r\n\r\n\tfunction onRenderTargetDispose( event ) {\r\n\r\n\t\tvar renderTarget = event.target;\r\n\r\n\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\r\n\r\n\t\tdeallocateRenderTarget( renderTarget );\r\n\r\n\t\t_infoMemory.textures --;\r\n\r\n\t}\r\n\r\n\tfunction onMaterialDispose( event ) {\r\n\r\n\t\tvar material = event.target;\r\n\r\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\r\n\r\n\t\tdeallocateMaterial( material );\r\n\r\n\t}\r\n\r\n\t// Buffer deallocation\r\n\r\n\tfunction deallocateTexture( texture ) {\r\n\r\n\t\tvar textureProperties = properties.get( texture );\r\n\r\n\t\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\r\n\r\n\t\t\t// cube texture\r\n\r\n\t\t\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// 2D texture\r\n\r\n\t\t\tif ( textureProperties.__webglInit === undefined ) return;\r\n\r\n\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\r\n\r\n\t\t}\r\n\r\n\t\t// remove all webgl properties\r\n\t\tproperties.delete( texture );\r\n\r\n\t}\r\n\r\n\tfunction deallocateRenderTarget( renderTarget ) {\r\n\r\n\t\tvar renderTargetProperties = properties.get( renderTarget );\r\n\t\tvar textureProperties = properties.get( renderTarget.texture );\r\n\r\n\t\tif ( ! renderTarget || textureProperties.__webglTexture === undefined ) return;\r\n\r\n\t\t_gl.deleteTexture( textureProperties.__webglTexture );\r\n\r\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\r\n\t\t\t\t_gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\r\n\t\t\t_gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\r\n\r\n\t\t}\r\n\r\n\t\tproperties.delete( renderTarget.texture );\r\n\t\tproperties.delete( renderTarget );\r\n\r\n\t}\r\n\r\n\tfunction deallocateMaterial( material ) {\r\n\r\n\t\treleaseMaterialProgramReference( material );\r\n\r\n\t\tproperties.delete( material );\r\n\r\n\t}\r\n\r\n\r\n\tfunction releaseMaterialProgramReference( material ) {\r\n\r\n\t\tvar programInfo = properties.get( material ).program;\r\n\r\n\t\tmaterial.program = undefined;\r\n\r\n\t\tif ( programInfo !== undefined ) {\r\n\r\n\t\t\tprogramCache.releaseProgram( programInfo );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Buffer rendering\r\n\r\n\tthis.renderBufferImmediate = function ( object, program, material ) {\r\n\r\n\t\tstate.initAttributes();\r\n\r\n\t\tvar buffers = properties.get( object );\r\n\r\n\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\r\n\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\r\n\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\r\n\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\r\n\r\n\t\tvar attributes = program.getAttributes();\r\n\r\n\t\tif ( object.hasPositions ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\tstate.enableAttribute( attributes.position );\r\n\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.hasNormals ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\r\n\r\n\t\t\tif ( material.type !== 'MeshPhongMaterial' && material.type !== 'MeshStandardMaterial' && material.shading === THREE.FlatShading ) {\r\n\r\n\t\t\t\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\r\n\r\n\t\t\t\t\tvar array = object.normalArray;\r\n\r\n\t\t\t\t\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\r\n\t\t\t\t\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\r\n\t\t\t\t\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\r\n\r\n\t\t\t\t\tarray[ i + 0 ] = nx;\r\n\t\t\t\t\tarray[ i + 1 ] = ny;\r\n\t\t\t\t\tarray[ i + 2 ] = nz;\r\n\r\n\t\t\t\t\tarray[ i + 3 ] = nx;\r\n\t\t\t\t\tarray[ i + 4 ] = ny;\r\n\t\t\t\t\tarray[ i + 5 ] = nz;\r\n\r\n\t\t\t\t\tarray[ i + 6 ] = nx;\r\n\t\t\t\t\tarray[ i + 7 ] = ny;\r\n\t\t\t\t\tarray[ i + 8 ] = nz;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\tstate.enableAttribute( attributes.normal );\r\n\r\n\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.hasUvs && material.map ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\tstate.enableAttribute( attributes.uv );\r\n\r\n\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\tstate.enableAttribute( attributes.color );\r\n\r\n\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tstate.disableUnusedAttributes();\r\n\r\n\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\r\n\r\n\t\tobject.count = 0;\r\n\r\n\t};\r\n\r\n\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\r\n\r\n\t\tsetMaterial( material );\r\n\r\n\t\tvar program = setProgram( camera, fog, material, object );\r\n\r\n\t\tvar updateBuffers = false;\r\n\t\tvar geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;\r\n\r\n\t\tif ( geometryProgram !== _currentGeometryProgram ) {\r\n\r\n\t\t\t_currentGeometryProgram = geometryProgram;\r\n\t\t\tupdateBuffers = true;\r\n\r\n\t\t}\r\n\r\n\t\t// morph targets\r\n\r\n\t\tvar morphTargetInfluences = object.morphTargetInfluences;\r\n\r\n\t\tif ( morphTargetInfluences !== undefined ) {\r\n\r\n\t\t\tvar activeInfluences = [];\r\n\r\n\t\t\tfor ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar influence = morphTargetInfluences[ i ];\r\n\t\t\t\tactiveInfluences.push( [ influence, i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tactiveInfluences.sort( absNumericalSort );\r\n\r\n\t\t\tif ( activeInfluences.length > 8 ) {\r\n\r\n\t\t\t\tactiveInfluences.length = 8;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar morphAttributes = geometry.morphAttributes;\r\n\r\n\t\t\tfor ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar influence = activeInfluences[ i ];\r\n\t\t\t\tmorphInfluences[ i ] = influence[ 0 ];\r\n\r\n\t\t\t\tif ( influence[ 0 ] !== 0 ) {\r\n\r\n\t\t\t\t\tvar index = influence[ 1 ];\r\n\r\n\t\t\t\t\tif ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );\r\n\t\t\t\t\tif ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );\r\n\t\t\t\t\tif ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar uniforms = program.getUniforms();\r\n\r\n\t\t\tif ( uniforms.morphTargetInfluences !== null ) {\r\n\r\n\t\t\t\t_gl.uniform1fv( uniforms.morphTargetInfluences, morphInfluences );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tupdateBuffers = true;\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tvar index = geometry.index;\r\n\t\tvar position = geometry.attributes.position;\r\n\r\n\t\tif ( material.wireframe === true ) {\r\n\r\n\t\t\tindex = objects.getWireframeAttribute( geometry );\r\n\r\n\t\t}\r\n\r\n\t\tvar renderer;\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\trenderer = indexedBufferRenderer;\r\n\t\t\trenderer.setIndex( index );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer = bufferRenderer;\r\n\r\n\t\t}\r\n\r\n\t\tif ( updateBuffers ) {\r\n\r\n\t\t\tsetupVertexAttributes( material, program, geometry );\r\n\r\n\t\t\tif ( index !== null ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tvar dataStart = 0;\r\n\t\tvar dataCount = Infinity;\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tdataCount = index.count;\r\n\r\n\t\t} else if ( position !== undefined ) {\r\n\r\n\t\t\tdataCount = position.count;\r\n\r\n\t\t}\r\n\r\n\t\tvar rangeStart = geometry.drawRange.start;\r\n\t\tvar rangeCount = geometry.drawRange.count;\r\n\r\n\t\tvar groupStart = group !== null ? group.start : 0;\r\n\t\tvar groupCount = group !== null ? group.count : Infinity;\r\n\r\n\t\tvar drawStart = Math.max( dataStart, rangeStart, groupStart );\r\n\t\tvar drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\r\n\r\n\t\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\r\n\r\n\t\t//\r\n\r\n\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\tif ( material.wireframe === true ) {\r\n\r\n\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\r\n\t\t\t\trenderer.setMode( _gl.LINES );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tswitch ( object.drawMode ) {\r\n\r\n\t\t\t\t\tcase THREE.TrianglesDrawMode:\r\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase THREE.TriangleStripDrawMode:\r\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_STRIP );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase THREE.TriangleFanDrawMode:\r\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_FAN );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n\t\t\tvar lineWidth = material.linewidth;\r\n\r\n\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\r\n\r\n\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\r\n\r\n\t\t\tif ( object instanceof THREE.LineSegments ) {\r\n\r\n\t\t\t\trenderer.setMode( _gl.LINES );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( object instanceof THREE.Points ) {\r\n\r\n\t\t\trenderer.setMode( _gl.POINTS );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\r\n\r\n\t\t\tif ( geometry.maxInstancedCount > 0 ) {\r\n\r\n\t\t\t\trenderer.renderInstances( geometry, drawStart, drawCount );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.render( drawStart, drawCount );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\r\n\r\n\t\tvar extension;\r\n\r\n\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\r\n\r\n\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n\t\t\tif ( extension === null ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( startIndex === undefined ) startIndex = 0;\r\n\r\n\t\tstate.initAttributes();\r\n\r\n\t\tvar geometryAttributes = geometry.attributes;\r\n\r\n\t\tvar programAttributes = program.getAttributes();\r\n\r\n\t\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\r\n\r\n\t\tfor ( var name in programAttributes ) {\r\n\r\n\t\t\tvar programAttribute = programAttributes[ name ];\r\n\r\n\t\t\tif ( programAttribute >= 0 ) {\r\n\r\n\t\t\t\tvar geometryAttribute = geometryAttributes[ name ];\r\n\r\n\t\t\t\tif ( geometryAttribute !== undefined ) {\r\n\r\n\t\t\t\t\tvar size = geometryAttribute.itemSize;\r\n\t\t\t\t\tvar buffer = objects.getAttributeBuffer( geometryAttribute );\r\n\r\n\t\t\t\t\tif ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\r\n\t\t\t\t\t\tvar data = geometryAttribute.data;\r\n\t\t\t\t\t\tvar stride = data.stride;\r\n\t\t\t\t\t\tvar offset = geometryAttribute.offset;\r\n\r\n\t\t\t\t\t\tif ( data instanceof THREE.InstancedInterleavedBuffer ) {\r\n\r\n\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );\r\n\r\n\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tif ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {\r\n\r\n\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );\r\n\r\n\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\r\n\r\n\t\t\t\t\tvar value = materialDefaultAttributeValues[ name ];\r\n\r\n\t\t\t\t\tif ( value !== undefined ) {\r\n\r\n\t\t\t\t\t\tswitch ( value.length ) {\r\n\r\n\t\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, value );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, value );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\t\t\t_gl.vertexAttrib4fv( programAttribute, value );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t_gl.vertexAttrib1fv( programAttribute, value );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tstate.disableUnusedAttributes();\r\n\r\n\t}\r\n\r\n\t// Sorting\r\n\r\n\tfunction absNumericalSort( a, b ) {\r\n\r\n\t\treturn Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );\r\n\r\n\t}\r\n\r\n\tfunction painterSortStable ( a, b ) {\r\n\r\n\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\r\n\r\n\t\t\treturn a.object.renderOrder - b.object.renderOrder;\r\n\r\n\t\t} else if ( a.material.id !== b.material.id ) {\r\n\r\n\t\t\treturn a.material.id - b.material.id;\r\n\r\n\t\t} else if ( a.z !== b.z ) {\r\n\r\n\t\t\treturn a.z - b.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn a.id - b.id;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction reversePainterSortStable ( a, b ) {\r\n\r\n\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\r\n\r\n\t\t\treturn a.object.renderOrder - b.object.renderOrder;\r\n\r\n\t\t} if ( a.z !== b.z ) {\r\n\r\n\t\t\treturn b.z - a.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn a.id - b.id;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Rendering\r\n\r\n\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\r\n\r\n\t\tif ( camera instanceof THREE.Camera === false ) {\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar fog = scene.fog;\r\n\r\n\t\t// reset caching for this frame\r\n\r\n\t\t_currentGeometryProgram = '';\r\n\t\t_currentMaterialId = - 1;\r\n\t\t_currentCamera = null;\r\n\r\n\t\t// update scene graph\r\n\r\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\r\n\r\n\t\t// update camera matrices and frustum\r\n\r\n\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\r\n\r\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\r\n\r\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\r\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\r\n\t\tlights.length = 0;\r\n\r\n\t\topaqueObjectsLastIndex = - 1;\r\n\t\ttransparentObjectsLastIndex = - 1;\r\n\r\n\t\tsprites.length = 0;\r\n\t\tlensFlares.length = 0;\r\n\r\n\t\tprojectObject( scene, camera );\r\n\r\n\t\topaqueObjects.length = opaqueObjectsLastIndex + 1;\r\n\t\ttransparentObjects.length = transparentObjectsLastIndex + 1;\r\n\r\n\t\tif ( _this.sortObjects === true ) {\r\n\r\n\t\t\topaqueObjects.sort( painterSortStable );\r\n\t\t\ttransparentObjects.sort( reversePainterSortStable );\r\n\r\n\t\t}\r\n\r\n\t\tsetupLights( lights, camera );\r\n\r\n\t\t//\r\n\r\n\t\tshadowMap.render( scene, camera );\r\n\r\n\t\t//\r\n\r\n\t\t_infoRender.calls = 0;\r\n\t\t_infoRender.vertices = 0;\r\n\t\t_infoRender.faces = 0;\r\n\t\t_infoRender.points = 0;\r\n\r\n\t\tif ( renderTarget === undefined ) {\r\n\r\n\t\t\trenderTarget = null;\r\n\r\n\t\t}\r\n\r\n\t\tthis.setRenderTarget( renderTarget );\r\n\r\n\t\tif ( this.autoClear || forceClear ) {\r\n\r\n\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( scene.overrideMaterial ) {\r\n\r\n\t\t\tvar overrideMaterial = scene.overrideMaterial;\r\n\r\n\t\t\trenderObjects( opaqueObjects, camera, fog, overrideMaterial );\r\n\t\t\trenderObjects( transparentObjects, camera, fog, overrideMaterial );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// opaque pass (front-to-back order)\r\n\r\n\t\t\tstate.setBlending( THREE.NoBlending );\r\n\t\t\trenderObjects( opaqueObjects, camera, fog );\r\n\r\n\t\t\t// transparent pass (back-to-front order)\r\n\r\n\t\t\trenderObjects( transparentObjects, camera, fog );\r\n\r\n\t\t}\r\n\r\n\t\t// custom render plugins (post pass)\r\n\r\n\t\tspritePlugin.render( scene, camera );\r\n\t\tlensFlarePlugin.render( scene, camera, _currentViewport );\r\n\r\n\t\t// Generate mipmap if we're using any kind of mipmap filtering\r\n\r\n\t\tif ( renderTarget ) {\r\n\r\n\t\t\tvar texture = renderTarget.texture;\r\n\r\n\t\t\tif ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&\r\n\t\t\t\t\ttexture.minFilter !== THREE.NearestFilter &&\r\n\t\t\t\t\ttexture.minFilter !== THREE.LinearFilter ) {\r\n\r\n\t\t\t\tupdateRenderTargetMipmap( renderTarget );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\r\n\r\n\t\tstate.setDepthTest( true );\r\n\t\tstate.setDepthWrite( true );\r\n\t\tstate.setColorWrite( true );\r\n\r\n\t\t// _gl.finish();\r\n\r\n\t};\r\n\r\n\tfunction pushRenderItem( object, geometry, material, z, group ) {\r\n\r\n\t\tvar array, index;\r\n\r\n\t\t// allocate the next position in the appropriate array\r\n\r\n\t\tif ( material.transparent ) {\r\n\r\n\t\t\tarray = transparentObjects;\r\n\t\t\tindex = ++ transparentObjectsLastIndex;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tarray = opaqueObjects;\r\n\t\t\tindex = ++ opaqueObjectsLastIndex;\r\n\r\n\t\t}\r\n\r\n\t\t// recycle existing render item or grow the array\r\n\r\n\t\tvar renderItem = array[ index ];\r\n\r\n\t\tif ( renderItem !== undefined ) {\r\n\r\n\t\t\trenderItem.id = object.id;\r\n\t\t\trenderItem.object = object;\r\n\t\t\trenderItem.geometry = geometry;\r\n\t\t\trenderItem.material = material;\r\n\t\t\trenderItem.z = _vector3.z;\r\n\t\t\trenderItem.group = group;\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderItem = {\r\n\t\t\t\tid: object.id,\r\n\t\t\t\tobject: object,\r\n\t\t\t\tgeometry: geometry,\r\n\t\t\t\tmaterial: material,\r\n\t\t\t\tz: _vector3.z,\r\n\t\t\t\tgroup: group\r\n\t\t\t};\r\n\r\n\t\t\t// assert( index === array.length );\r\n\t\t\tarray.push( renderItem );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction projectObject( object, camera ) {\r\n\r\n\t\tif ( object.visible === false ) return;\r\n\r\n\t\tif ( object.layers.test( camera.layers ) ) {\r\n\r\n\t\t\tif ( object instanceof THREE.Light ) {\r\n\r\n\t\t\t\tlights.push( object );\r\n\r\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\r\n\r\n\t\t\t\tif ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {\r\n\r\n\t\t\t\t\tsprites.push( object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object instanceof THREE.LensFlare ) {\r\n\r\n\t\t\t\tlensFlares.push( object );\r\n\r\n\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject ) {\r\n\r\n\t\t\t\tif ( _this.sortObjects === true ) {\r\n\r\n\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\r\n\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tpushRenderItem( object, null, object.material, _vector3.z, null );\r\n\r\n\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {\r\n\r\n\t\t\t\tif ( object instanceof THREE.SkinnedMesh ) {\r\n\r\n\t\t\t\t\tobject.skeleton.update();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {\r\n\r\n\t\t\t\t\tvar material = object.material;\r\n\r\n\t\t\t\t\tif ( material.visible === true ) {\r\n\r\n\t\t\t\t\t\tif ( _this.sortObjects === true ) {\r\n\r\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\r\n\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar geometry = objects.update( object );\r\n\r\n\t\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\r\n\r\n\t\t\t\t\t\t\tvar groups = geometry.groups;\r\n\t\t\t\t\t\t\tvar materials = material.materials;\r\n\r\n\t\t\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvar group = groups[ i ];\r\n\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\r\n\r\n\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\r\n\r\n\t\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, groupMaterial, _vector3.z, group );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tpushRenderItem( object, geometry, material, _vector3.z, null );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar children = object.children;\r\n\r\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tprojectObject( children[ i ], camera );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction renderObjects( renderList, camera, fog, overrideMaterial ) {\r\n\r\n\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar renderItem = renderList[ i ];\r\n\r\n\t\t\tvar object = renderItem.object;\r\n\t\t\tvar geometry = renderItem.geometry;\r\n\t\t\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\r\n\t\t\tvar group = renderItem.group;\r\n\r\n\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\r\n\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\r\n\r\n\t\t\tif ( object instanceof THREE.ImmediateRenderObject ) {\r\n\r\n\t\t\t\tsetMaterial( material );\r\n\r\n\t\t\t\tvar program = setProgram( camera, fog, material, object );\r\n\r\n\t\t\t\t_currentGeometryProgram = '';\r\n\r\n\t\t\t\tobject.render( function ( object ) {\r\n\r\n\t\t\t\t\t_this.renderBufferImmediate( object, program, material );\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_this.renderBufferDirect( camera, fog, geometry, material, object, group );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction initMaterial( material, fog, object ) {\r\n\r\n\t\tvar materialProperties = properties.get( material );\r\n\r\n\t\tvar parameters = programCache.getParameters( material, _lights, fog, object );\r\n\t\tvar code = programCache.getProgramCode( material, parameters );\r\n\r\n\t\tvar program = materialProperties.program;\r\n\t\tvar programChange = true;\r\n\r\n\t\tif ( program === undefined ) {\r\n\r\n\t\t\t// new material\r\n\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\r\n\r\n\t\t} else if ( program.code !== code ) {\r\n\r\n\t\t\t// changed glsl or parameters\r\n\t\t\treleaseMaterialProgramReference( material );\r\n\r\n\t\t} else if ( parameters.shaderID !== undefined ) {\r\n\r\n\t\t\t// same glsl and uniform list\r\n\t\t\treturn;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// only rebuild uniform list\r\n\t\t\tprogramChange = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( programChange ) {\r\n\r\n\t\t\tif ( parameters.shaderID ) {\r\n\r\n\t\t\t\tvar shader = THREE.ShaderLib[ parameters.shaderID ];\r\n\r\n\t\t\t\tmaterialProperties.__webglShader = {\r\n\t\t\t\t\tname: material.type,\r\n\t\t\t\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\r\n\t\t\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\t\t\tfragmentShader: shader.fragmentShader\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmaterialProperties.__webglShader = {\r\n\t\t\t\t\tname: material.type,\r\n\t\t\t\t\tuniforms: material.uniforms,\r\n\t\t\t\t\tvertexShader: material.vertexShader,\r\n\t\t\t\t\tfragmentShader: material.fragmentShader\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterial.__webglShader = materialProperties.__webglShader;\r\n\r\n\t\t\tprogram = programCache.acquireProgram( material, parameters, code );\r\n\r\n\t\t\tmaterialProperties.program = program;\r\n\t\t\tmaterial.program = program;\r\n\r\n\t\t}\r\n\r\n\t\tvar attributes = program.getAttributes();\r\n\r\n\t\tif ( material.morphTargets ) {\r\n\r\n\t\t\tmaterial.numSupportedMorphTargets = 0;\r\n\r\n\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\r\n\r\n\t\t\t\tif ( attributes[ 'morphTarget' + i ] >= 0 ) {\r\n\r\n\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\tmaterial.numSupportedMorphNormals = 0;\r\n\r\n\t\t\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\r\n\r\n\t\t\t\tif ( attributes[ 'morphNormal' + i ] >= 0 ) {\r\n\r\n\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tmaterialProperties.uniformsList = [];\r\n\r\n\t\tvar uniforms = materialProperties.__webglShader.uniforms,\r\n\t\t\tuniformLocations = materialProperties.program.getUniforms();\r\n\r\n\t\tfor ( var u in uniforms ) {\r\n\r\n\t\t\tvar location = uniformLocations[ u ];\r\n\r\n\t\t\tif ( location ) {\r\n\r\n\t\t\t\tmaterialProperties.uniformsList.push( [ materialProperties.__webglShader.uniforms[ u ], location ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\tmaterial instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\tmaterial instanceof THREE.MeshStandardMaterial ||\r\n\t\t\t\tmaterial.lights ) {\r\n\r\n\t\t\t// store the light setup it was created for\r\n\r\n\t\t\tmaterialProperties.lightsHash = _lights.hash;\r\n\r\n\t\t\t// wire up the material to this renderer's lighting state\r\n\r\n\t\t\tuniforms.ambientLightColor.value = _lights.ambient;\r\n\t\t\tuniforms.directionalLights.value = _lights.directional;\r\n\t\t\tuniforms.spotLights.value = _lights.spot;\r\n\t\t\tuniforms.pointLights.value = _lights.point;\r\n\t\t\tuniforms.hemisphereLights.value = _lights.hemi;\r\n\r\n\t\t\tuniforms.directionalShadowMap.value = _lights.directionalShadowMap;\r\n\t\t\tuniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;\r\n\t\t\tuniforms.spotShadowMap.value = _lights.spotShadowMap;\r\n\t\t\tuniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;\r\n\t\t\tuniforms.pointShadowMap.value = _lights.pointShadowMap;\r\n\t\t\tuniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;\r\n\r\n\t\t}\r\n\r\n\t\t// detect dynamic uniforms\r\n\r\n\t\tmaterialProperties.hasDynamicUniforms = false;\r\n\r\n\t\tfor ( var j = 0, jl = materialProperties.uniformsList.length; j < jl; j ++ ) {\r\n\r\n\t\t\tvar uniform = materialProperties.uniformsList[ j ][ 0 ];\r\n\r\n\t\t\tif ( uniform.dynamic === true ) {\r\n\r\n\t\t\t\tmaterialProperties.hasDynamicUniforms = true;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setMaterial( material ) {\r\n\r\n\t\tsetMaterialFaces( material );\r\n\r\n\t\tif ( material.transparent === true ) {\r\n\r\n\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tstate.setBlending( THREE.NoBlending );\r\n\r\n\t\t}\r\n\r\n\t\tstate.setDepthFunc( material.depthFunc );\r\n\t\tstate.setDepthTest( material.depthTest );\r\n\t\tstate.setDepthWrite( material.depthWrite );\r\n\t\tstate.setColorWrite( material.colorWrite );\r\n\t\tstate.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\r\n\r\n\t}\r\n\r\n\tfunction setMaterialFaces( material ) {\r\n\r\n\t\tmaterial.side !== THREE.DoubleSide ? state.enable( _gl.CULL_FACE ) : state.disable( _gl.CULL_FACE );\r\n\t\tstate.setFlipSided( material.side === THREE.BackSide );\r\n\r\n\t}\r\n\r\n\tfunction setProgram( camera, fog, material, object ) {\r\n\r\n\t\t_usedTextureUnits = 0;\r\n\r\n\t\tvar materialProperties = properties.get( material );\r\n\r\n\t\tif ( materialProperties.program === undefined ) {\r\n\r\n\t\t\tmaterial.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialProperties.lightsHash !== undefined &&\r\n\t\t\tmaterialProperties.lightsHash !== _lights.hash ) {\r\n\r\n\t\t\tmaterial.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.needsUpdate ) {\r\n\r\n\t\t\tinitMaterial( material, fog, object );\r\n\t\t\tmaterial.needsUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tvar refreshProgram = false;\r\n\t\tvar refreshMaterial = false;\r\n\t\tvar refreshLights = false;\r\n\r\n\t\tvar program = materialProperties.program,\r\n\t\t\tp_uniforms = program.getUniforms(),\r\n\t\t\tm_uniforms = materialProperties.__webglShader.uniforms;\r\n\r\n\t\tif ( program.id !== _currentProgram ) {\r\n\r\n\t\t\t_gl.useProgram( program.program );\r\n\t\t\t_currentProgram = program.id;\r\n\r\n\t\t\trefreshProgram = true;\r\n\t\t\trefreshMaterial = true;\r\n\t\t\trefreshLights = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.id !== _currentMaterialId ) {\r\n\r\n\t\t\t_currentMaterialId = material.id;\r\n\r\n\t\t\trefreshMaterial = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( refreshProgram || camera !== _currentCamera ) {\r\n\r\n\t\t\t_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\r\n\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\r\n\r\n\t\t\t\t_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif ( camera !== _currentCamera ) {\r\n\r\n\t\t\t\t_currentCamera = camera;\r\n\r\n\t\t\t\t// lighting uniforms depend on the camera so enforce an update\r\n\t\t\t\t// now, in case this material supports lights - or later, when\r\n\t\t\t\t// the next material that does gets activated:\r\n\r\n\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\r\n\t\t\t\trefreshLights = true;\t\t// remains set until update done\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// load material specific uniforms\r\n\t\t\t// (shader material also gets them for the sake of genericity)\r\n\r\n\t\t\tif ( material instanceof THREE.ShaderMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\r\n\t\t\t\t material.envMap ) {\r\n\r\n\t\t\t\tif ( p_uniforms.cameraPosition !== undefined ) {\r\n\r\n\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\t\t\t_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshBasicMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\r\n\t\t\t\t material instanceof THREE.ShaderMaterial ||\r\n\t\t\t\t material.skinning ) {\r\n\r\n\t\t\t\tif ( p_uniforms.viewMatrix !== undefined ) {\r\n\r\n\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif ( p_uniforms.toneMappingExposure !== undefined ) {\r\n\r\n\t\t\t\t_gl.uniform1f( p_uniforms.toneMappingExposure, _this.toneMappingExposure );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( p_uniforms.toneMappingWhitePoint !== undefined ) {\r\n\r\n\t\t\t\t_gl.uniform1f( p_uniforms.toneMappingWhitePoint, _this.toneMappingWhitePoint );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// skinning uniforms must be set even if material didn't change\r\n\t\t// auto-setting of texture unit for bone texture must go before other textures\r\n\t\t// not sure why, but otherwise weird things happen\r\n\r\n\t\tif ( material.skinning ) {\r\n\r\n\t\t\tif ( object.bindMatrix && p_uniforms.bindMatrix !== undefined ) {\r\n\r\n\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== undefined ) {\r\n\r\n\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( capabilities.floatVertexTextures && object.skeleton && object.skeleton.useVertexTexture ) {\r\n\r\n\t\t\t\tif ( p_uniforms.boneTexture !== undefined ) {\r\n\r\n\t\t\t\t\tvar textureUnit = getTextureUnit();\r\n\r\n\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTexture, textureUnit );\r\n\t\t\t\t\t_this.setTexture( object.skeleton.boneTexture, textureUnit );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( p_uniforms.boneTextureWidth !== undefined ) {\r\n\r\n\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( p_uniforms.boneTextureHeight !== undefined ) {\r\n\r\n\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object.skeleton && object.skeleton.boneMatrices ) {\r\n\r\n\t\t\t\tif ( p_uniforms.boneGlobalMatrices !== undefined ) {\r\n\r\n\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( refreshMaterial ) {\r\n\r\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\r\n\t\t\t\t material.lights ) {\r\n\r\n\t\t\t\t// the current material requires lighting info\r\n\r\n\t\t\t\t// note: all lighting uniforms are always set correctly\r\n\t\t\t\t// they simply reference the renderer's state for their\r\n\t\t\t\t// values\r\n\t\t\t\t//\r\n\t\t\t\t// use the current material's .needsUpdate flags to set\r\n\t\t\t\t// the GL state when required\r\n\r\n\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// refresh uniforms common to several materials\r\n\r\n\t\t\tif ( fog && material.fog ) {\r\n\r\n\t\t\t\trefreshUniformsFog( m_uniforms, fog );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material instanceof THREE.MeshBasicMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// refresh single material specific uniforms\r\n\r\n\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\r\n\t\t\t\trefreshUniformsDash( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.PointsMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsPoints( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsLambert( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsPhong( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshStandardMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsStandard( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\r\n\r\n\t\t\t\tm_uniforms.mNear.value = camera.near;\r\n\t\t\t\tm_uniforms.mFar.value = camera.far;\r\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\r\n\r\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// load common uniforms\r\n\r\n\t\t\tloadUniformsGeneric( materialProperties.uniformsList );\r\n\r\n\t\t}\r\n\r\n\t\tloadUniformsMatrices( p_uniforms, object );\r\n\r\n\t\tif ( p_uniforms.modelMatrix !== undefined ) {\r\n\r\n\t\t\t_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialProperties.hasDynamicUniforms === true ) {\r\n\r\n\t\t\tupdateDynamicUniforms( materialProperties.uniformsList, object, camera );\r\n\r\n\t\t}\r\n\r\n\t\treturn program;\r\n\r\n\t}\r\n\r\n\tfunction updateDynamicUniforms ( uniforms, object, camera ) {\r\n\r\n\t\tvar dynamicUniforms = [];\r\n\r\n\t\tfor ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {\r\n\r\n\t\t\tvar uniform = uniforms[ j ][ 0 ];\r\n\t\t\tvar onUpdateCallback = uniform.onUpdateCallback;\r\n\r\n\t\t\tif ( onUpdateCallback !== undefined ) {\r\n\r\n\t\t\t\tonUpdateCallback.bind( uniform )( object, camera );\r\n\t\t\t\tdynamicUniforms.push( uniforms[ j ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tloadUniformsGeneric( dynamicUniforms );\r\n\r\n\t}\r\n\r\n\t// Uniforms (refresh uniforms objects)\r\n\r\n\tfunction refreshUniformsCommon ( uniforms, material ) {\r\n\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\r\n\t\tuniforms.diffuse.value = material.color;\r\n\r\n\t\tif ( material.emissive ) {\r\n\r\n\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\r\n\r\n\t\t}\r\n\r\n\t\tuniforms.map.value = material.map;\r\n\t\tuniforms.specularMap.value = material.specularMap;\r\n\t\tuniforms.alphaMap.value = material.alphaMap;\r\n\r\n\t\tif ( material.aoMap ) {\r\n\r\n\t\t\tuniforms.aoMap.value = material.aoMap;\r\n\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\r\n\r\n\t\t}\r\n\r\n\t\t// uv repeat and offset setting priorities\r\n\t\t// 1. color map\r\n\t\t// 2. specular map\r\n\t\t// 3. normal map\r\n\t\t// 4. bump map\r\n\t\t// 5. alpha map\r\n\t\t// 6. emissive map\r\n\r\n\t\tvar uvScaleMap;\r\n\r\n\t\tif ( material.map ) {\r\n\r\n\t\t\tuvScaleMap = material.map;\r\n\r\n\t\t} else if ( material.specularMap ) {\r\n\r\n\t\t\tuvScaleMap = material.specularMap;\r\n\r\n\t\t} else if ( material.displacementMap ) {\r\n\r\n\t\t\tuvScaleMap = material.displacementMap;\r\n\r\n\t\t} else if ( material.normalMap ) {\r\n\r\n\t\t\tuvScaleMap = material.normalMap;\r\n\r\n\t\t} else if ( material.bumpMap ) {\r\n\r\n\t\t\tuvScaleMap = material.bumpMap;\r\n\r\n\t\t} else if ( material.roughnessMap ) {\r\n\r\n\t\t\tuvScaleMap = material.roughnessMap;\r\n\r\n\t\t} else if ( material.metalnessMap ) {\r\n\r\n\t\t\tuvScaleMap = material.metalnessMap;\r\n\r\n\t\t} else if ( material.alphaMap ) {\r\n\r\n\t\t\tuvScaleMap = material.alphaMap;\r\n\r\n\t\t} else if ( material.emissiveMap ) {\r\n\r\n\t\t\tuvScaleMap = material.emissiveMap;\r\n\r\n\t\t}\r\n\r\n\t\tif ( uvScaleMap !== undefined ) {\r\n\r\n\t\t\tif ( uvScaleMap instanceof THREE.WebGLRenderTarget ) {\r\n\r\n\t\t\t\tuvScaleMap = uvScaleMap.texture;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar offset = uvScaleMap.offset;\r\n\t\t\tvar repeat = uvScaleMap.repeat;\r\n\r\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\r\n\r\n\t\t}\r\n\r\n\t\tuniforms.envMap.value = material.envMap;\r\n\t\tuniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;\r\n\r\n\t\tuniforms.reflectivity.value = material.reflectivity;\r\n\t\tuniforms.refractionRatio.value = material.refractionRatio;\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsLine ( uniforms, material ) {\r\n\r\n\t\tuniforms.diffuse.value = material.color;\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsDash ( uniforms, material ) {\r\n\r\n\t\tuniforms.dashSize.value = material.dashSize;\r\n\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\r\n\t\tuniforms.scale.value = material.scale;\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsPoints ( uniforms, material ) {\r\n\r\n\t\tuniforms.diffuse.value = material.color;\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\t\tuniforms.size.value = material.size * _pixelRatio;\r\n\t\tuniforms.scale.value = _canvas.clientHeight / 2.0; // TODO: Cache this.\r\n\r\n\t\tuniforms.map.value = material.map;\r\n\r\n\t\tif ( material.map !== null ) {\r\n\r\n\t\t\tvar offset = material.map.offset;\r\n\t\t\tvar repeat = material.map.repeat;\r\n\r\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsFog ( uniforms, fog ) {\r\n\r\n\t\tuniforms.fogColor.value = fog.color;\r\n\r\n\t\tif ( fog instanceof THREE.Fog ) {\r\n\r\n\t\t\tuniforms.fogNear.value = fog.near;\r\n\t\t\tuniforms.fogFar.value = fog.far;\r\n\r\n\t\t} else if ( fog instanceof THREE.FogExp2 ) {\r\n\r\n\t\t\tuniforms.fogDensity.value = fog.density;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsLambert ( uniforms, material ) {\r\n\r\n\t\tif ( material.lightMap ) {\r\n\r\n\t\t\tuniforms.lightMap.value = material.lightMap;\r\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.emissiveMap ) {\r\n\r\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsPhong ( uniforms, material ) {\r\n\r\n\t\tuniforms.specular.value = material.specular;\r\n\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\r\n\r\n\t\tif ( material.lightMap ) {\r\n\r\n\t\t\tuniforms.lightMap.value = material.lightMap;\r\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.emissiveMap ) {\r\n\r\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.bumpMap ) {\r\n\r\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\r\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.normalMap ) {\r\n\r\n\t\t\tuniforms.normalMap.value = material.normalMap;\r\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.displacementMap ) {\r\n\r\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\r\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\r\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsStandard ( uniforms, material ) {\r\n\r\n\t\tuniforms.roughness.value = material.roughness;\r\n\t\tuniforms.metalness.value = material.metalness;\r\n\r\n\t\tif ( material.roughnessMap ) {\r\n\r\n\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.metalnessMap ) {\r\n\r\n\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.lightMap ) {\r\n\r\n\t\t\tuniforms.lightMap.value = material.lightMap;\r\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.emissiveMap ) {\r\n\r\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.bumpMap ) {\r\n\r\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\r\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.normalMap ) {\r\n\r\n\t\t\tuniforms.normalMap.value = material.normalMap;\r\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.displacementMap ) {\r\n\r\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\r\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\r\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.envMap ) {\r\n\r\n\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\r\n\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\r\n\r\n\tfunction markUniformsLightsNeedsUpdate ( uniforms, value ) {\r\n\r\n\t\tuniforms.ambientLightColor.needsUpdate = value;\r\n\r\n\t\tuniforms.directionalLights.needsUpdate = value;\r\n\t\tuniforms.pointLights.needsUpdate = value;\r\n\t\tuniforms.spotLights.needsUpdate = value;\r\n\t\tuniforms.hemisphereLights.needsUpdate = value;\r\n\r\n\t}\r\n\r\n\t// Uniforms (load to GPU)\r\n\r\n\tfunction loadUniformsMatrices ( uniforms, object ) {\r\n\r\n\t\t_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object.modelViewMatrix.elements );\r\n\r\n\t\tif ( uniforms.normalMatrix ) {\r\n\r\n\t\t\t_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object.normalMatrix.elements );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction getTextureUnit() {\r\n\r\n\t\tvar textureUnit = _usedTextureUnits;\r\n\r\n\t\tif ( textureUnit >= capabilities.maxTextures ) {\r\n\r\n\t\t\tconsole.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\r\n\r\n\t\t}\r\n\r\n\t\t_usedTextureUnits += 1;\r\n\r\n\t\treturn textureUnit;\r\n\r\n\t}\r\n\r\n\tfunction loadUniform( uniform, type, location, value ) {\r\n\r\n\t\tvar texture, textureUnit;\r\n\r\n\t\tif ( type === '1i' ) {\r\n\r\n\t\t\t_gl.uniform1i( location, value );\r\n\r\n\t\t} else if ( type === '1f' ) {\r\n\r\n\t\t\t_gl.uniform1f( location, value );\r\n\r\n\t\t} else if ( type === '2f' ) {\r\n\r\n\t\t\t_gl.uniform2f( location, value[ 0 ], value[ 1 ] );\r\n\r\n\t\t} else if ( type === '3f' ) {\r\n\r\n\t\t\t_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );\r\n\r\n\t\t} else if ( type === '4f' ) {\r\n\r\n\t\t\t_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );\r\n\r\n\t\t} else if ( type === '1iv' ) {\r\n\r\n\t\t\t_gl.uniform1iv( location, value );\r\n\r\n\t\t} else if ( type === '3iv' ) {\r\n\r\n\t\t\t_gl.uniform3iv( location, value );\r\n\r\n\t\t} else if ( type === '1fv' ) {\r\n\r\n\t\t\t_gl.uniform1fv( location, value );\r\n\r\n\t\t} else if ( type === '2fv' ) {\r\n\r\n\t\t\t_gl.uniform2fv( location, value );\r\n\r\n\t\t} else if ( type === '3fv' ) {\r\n\r\n\t\t\t_gl.uniform3fv( location, value );\r\n\r\n\t\t} else if ( type === '4fv' ) {\r\n\r\n\t\t\t_gl.uniform4fv( location, value );\r\n\r\n\t\t} else if ( type === 'Matrix2fv' ) {\r\n\r\n\t\t\t_gl.uniformMatrix2fv( location, false, value );\r\n\r\n\t\t} else if ( type === 'Matrix3fv' ) {\r\n\r\n\t\t\t_gl.uniformMatrix3fv( location, false, value );\r\n\r\n\t\t} else if ( type === 'Matrix4fv' ) {\r\n\r\n\t\t\t_gl.uniformMatrix4fv( location, false, value );\r\n\r\n\t\t//\r\n\r\n\t\t} else if ( type === 'i' ) {\r\n\r\n\t\t\t// single integer\r\n\t\t\t_gl.uniform1i( location, value );\r\n\r\n\t\t} else if ( type === 'f' ) {\r\n\r\n\t\t\t// single float\r\n\t\t\t_gl.uniform1f( location, value );\r\n\r\n\t\t} else if ( type === 'v2' ) {\r\n\r\n\t\t\t// single THREE.Vector2\r\n\t\t\t_gl.uniform2f( location, value.x, value.y );\r\n\r\n\t\t} else if ( type === 'v3' ) {\r\n\r\n\t\t\t// single THREE.Vector3\r\n\t\t\t_gl.uniform3f( location, value.x, value.y, value.z );\r\n\r\n\t\t} else if ( type === 'v4' ) {\r\n\r\n\t\t\t// single THREE.Vector4\r\n\t\t\t_gl.uniform4f( location, value.x, value.y, value.z, value.w );\r\n\r\n\t\t} else if ( type === 'c' ) {\r\n\r\n\t\t\t// single THREE.Color\r\n\t\t\t_gl.uniform3f( location, value.r, value.g, value.b );\r\n\r\n\t\t} else if ( type === 's' ) {\r\n\r\n\t\t\t// TODO: Optimize this\r\n\r\n\t\t\tvar properties = uniform.properties;\r\n\r\n\t\t\tfor ( var name in properties ) {\r\n\r\n\t\t\t\tvar property = properties[ name ];\r\n\t\t\t\tvar locationProperty = location[ name ];\r\n\t\t\t\tvar valueProperty = value[ name ];\r\n\r\n\t\t\t\tloadUniform( property, property.type, locationProperty, valueProperty );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( type === 'sa' ) {\r\n\r\n\t\t\t// TODO: Optimize this\r\n\r\n\t\t\tvar properties = uniform.properties;\r\n\r\n\t\t\tfor ( var i = 0, l = value.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tfor ( var name in properties ) {\r\n\r\n\t\t\t\t\tvar property = properties[ name ];\r\n\t\t\t\t\tvar locationProperty =  location[ i ][ name ];\r\n\t\t\t\t\tvar valueProperty = value[ i ][ name ];\r\n\r\n\t\t\t\t\tloadUniform( property, property.type, locationProperty, valueProperty );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( type === 'iv1' ) {\r\n\r\n\t\t\t// flat array of integers (JS or typed array)\r\n\t\t\t_gl.uniform1iv( location, value );\r\n\r\n\t\t} else if ( type === 'iv' ) {\r\n\r\n\t\t\t// flat array of integers with 3 x N size (JS or typed array)\r\n\t\t\t_gl.uniform3iv( location, value );\r\n\r\n\t\t} else if ( type === 'fv1' ) {\r\n\r\n\t\t\t// flat array of floats (JS or typed array)\r\n\t\t\t_gl.uniform1fv( location, value );\r\n\r\n\t\t} else if ( type === 'fv' ) {\r\n\r\n\t\t\t// flat array of floats with 3 x N size (JS or typed array)\r\n\t\t\t_gl.uniform3fv( location, value );\r\n\r\n\t\t} else if ( type === 'v2v' ) {\r\n\r\n\t\t\t// array of THREE.Vector2\r\n\r\n\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\tuniform._array = new Float32Array( 2 * value.length );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0, i2 = 0, il = value.length; i < il; i ++, i2 += 2 ) {\r\n\r\n\t\t\t\tuniform._array[ i2 + 0 ] = value[ i ].x;\r\n\t\t\t\tuniform._array[ i2 + 1 ] = value[ i ].y;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.uniform2fv( location, uniform._array );\r\n\r\n\t\t} else if ( type === 'v3v' ) {\r\n\r\n\t\t\t// array of THREE.Vector3\r\n\r\n\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\tuniform._array = new Float32Array( 3 * value.length );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0, i3 = 0, il = value.length; i < il; i ++, i3 += 3 ) {\r\n\r\n\t\t\t\tuniform._array[ i3 + 0 ] = value[ i ].x;\r\n\t\t\t\tuniform._array[ i3 + 1 ] = value[ i ].y;\r\n\t\t\t\tuniform._array[ i3 + 2 ] = value[ i ].z;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.uniform3fv( location, uniform._array );\r\n\r\n\t\t} else if ( type === 'v4v' ) {\r\n\r\n\t\t\t// array of THREE.Vector4\r\n\r\n\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\tuniform._array = new Float32Array( 4 * value.length );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0, i4 = 0, il = value.length; i < il; i ++, i4 += 4 ) {\r\n\r\n\t\t\t\tuniform._array[ i4 + 0 ] = value[ i ].x;\r\n\t\t\t\tuniform._array[ i4 + 1 ] = value[ i ].y;\r\n\t\t\t\tuniform._array[ i4 + 2 ] = value[ i ].z;\r\n\t\t\t\tuniform._array[ i4 + 3 ] = value[ i ].w;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.uniform4fv( location, uniform._array );\r\n\r\n\t\t} else if ( type === 'm2' ) {\r\n\r\n\t\t\t// single THREE.Matrix2\r\n\t\t\t_gl.uniformMatrix2fv( location, false, value.elements );\r\n\r\n\t\t} else if ( type === 'm3' ) {\r\n\r\n\t\t\t// single THREE.Matrix3\r\n\t\t\t_gl.uniformMatrix3fv( location, false, value.elements );\r\n\r\n\t\t} else if ( type === 'm3v' ) {\r\n\r\n\t\t\t// array of THREE.Matrix3\r\n\r\n\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\tuniform._array = new Float32Array( 9 * value.length );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvalue[ i ].flattenToArrayOffset( uniform._array, i * 9 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.uniformMatrix3fv( location, false, uniform._array );\r\n\r\n\t\t} else if ( type === 'm4' ) {\r\n\r\n\t\t\t// single THREE.Matrix4\r\n\t\t\t_gl.uniformMatrix4fv( location, false, value.elements );\r\n\r\n\t\t} else if ( type === 'm4v' ) {\r\n\r\n\t\t\t// array of THREE.Matrix4\r\n\r\n\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\tuniform._array = new Float32Array( 16 * value.length );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvalue[ i ].flattenToArrayOffset( uniform._array, i * 16 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.uniformMatrix4fv( location, false, uniform._array );\r\n\r\n\t\t} else if ( type === 't' ) {\r\n\r\n\t\t\t// single THREE.Texture (2d or cube)\r\n\r\n\t\t\ttexture = value;\r\n\t\t\ttextureUnit = getTextureUnit();\r\n\r\n\t\t\t_gl.uniform1i( location, textureUnit );\r\n\r\n\t\t\tif ( ! texture ) return;\r\n\r\n\t\t\tif ( texture instanceof THREE.CubeTexture ||\r\n\t\t\t\t ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\r\n\r\n\t\t\t\t// CompressedTexture can have Array in image :/\r\n\r\n\t\t\t\tsetCubeTexture( texture, textureUnit );\r\n\r\n\t\t\t} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n\t\t\t\tsetCubeTextureDynamic( texture.texture, textureUnit );\r\n\r\n\t\t\t} else if ( texture instanceof THREE.WebGLRenderTarget ) {\r\n\r\n\t\t\t\t_this.setTexture( texture.texture, textureUnit );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_this.setTexture( texture, textureUnit );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( type === 'tv' ) {\r\n\r\n\t\t\t// array of THREE.Texture (2d or cube)\r\n\r\n\t\t\tif ( uniform._array === undefined ) {\r\n\r\n\t\t\t\tuniform._array = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0, il = uniform.value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tuniform._array[ i ] = getTextureUnit();\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.uniform1iv( location, uniform._array );\r\n\r\n\t\t\tfor ( var i = 0, il = uniform.value.length; i < il; i ++ ) {\r\n\r\n\t\t\t\ttexture = uniform.value[ i ];\r\n\t\t\t\ttextureUnit = uniform._array[ i ];\r\n\r\n\t\t\t\tif ( ! texture ) continue;\r\n\r\n\t\t\t\tif ( texture instanceof THREE.CubeTexture ||\r\n\t\t\t\t\t ( texture.image instanceof Array && texture.image.length === 6 ) ) {\r\n\r\n\t\t\t\t\t// CompressedTexture can have Array in image :/\r\n\r\n\t\t\t\t\tsetCubeTexture( texture, textureUnit );\r\n\r\n\t\t\t\t} else if ( texture instanceof THREE.WebGLRenderTarget ) {\r\n\r\n\t\t\t\t\t_this.setTexture( texture.texture, textureUnit );\r\n\r\n\t\t\t\t} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n\t\t\t\t\tsetCubeTextureDynamic( texture.texture, textureUnit );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_this.setTexture( texture, textureUnit );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction loadUniformsGeneric( uniforms ) {\r\n\r\n\t\tfor ( var i = 0, l = uniforms.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar uniform = uniforms[ i ][ 0 ];\r\n\r\n\t\t\t// needsUpdate property is not added to all uniforms.\r\n\t\t\tif ( uniform.needsUpdate === false ) continue;\r\n\r\n\t\t\tvar type = uniform.type;\r\n\t\t\tvar location = uniforms[ i ][ 1 ];\r\n\t\t\tvar value = uniform.value;\r\n\r\n\t\t\tloadUniform( uniform, type, location, value );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setupLights ( lights, camera ) {\r\n\r\n\t\tvar l, ll, light,\r\n\t\tr = 0, g = 0, b = 0,\r\n\t\tcolor,\r\n\t\tintensity,\r\n\t\tdistance,\r\n\r\n\t\tviewMatrix = camera.matrixWorldInverse,\r\n\r\n\t\tdirectionalLength = 0,\r\n\t\tpointLength = 0,\r\n\t\tspotLength = 0,\r\n\t\themiLength = 0,\r\n\r\n\t\tshadowsLength = 0;\r\n\r\n\t\t_lights.shadowsPointLight = 0;\r\n\r\n\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\r\n\t\t\tlight = lights[ l ];\r\n\r\n\t\t\tcolor = light.color;\r\n\t\t\tintensity = light.intensity;\r\n\t\t\tdistance = light.distance;\r\n\r\n\t\t\tif ( light instanceof THREE.AmbientLight ) {\r\n\r\n\t\t\t\tr += color.r * intensity;\r\n\t\t\t\tg += color.g * intensity;\r\n\t\t\t\tb += color.b * intensity;\r\n\r\n\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\r\n\r\n\t\t\t\tvar uniforms = lightCache.get( light );\r\n\r\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\r\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\tuniforms.direction.sub( _vector3 );\r\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\r\n\r\n\t\t\t\tuniforms.shadow = light.castShadow;\r\n\r\n\t\t\t\tif ( light.castShadow ) {\r\n\r\n\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\r\n\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\r\n\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\r\n\r\n\t\t\t\t\t_lights.shadows[ shadowsLength ++ ] = light;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_lights.directionalShadowMap[ directionalLength ] = light.shadow.map;\r\n\t\t\t\t_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\r\n\t\t\t\t_lights.directional[ directionalLength ++ ] = uniforms;\r\n\r\n\t\t\t} else if ( light instanceof THREE.SpotLight ) {\r\n\r\n\t\t\t\tvar uniforms = lightCache.get( light );\r\n\r\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\r\n\r\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\r\n\t\t\t\tuniforms.distance = distance;\r\n\r\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\tuniforms.direction.sub( _vector3 );\r\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\r\n\r\n\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\r\n\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\r\n\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\r\n\r\n\t\t\t\tuniforms.shadow = light.castShadow;\r\n\r\n\t\t\t\tif ( light.castShadow ) {\r\n\r\n\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\r\n\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\r\n\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\r\n\r\n\t\t\t\t\t_lights.shadows[ shadowsLength ++ ] = light;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_lights.spotShadowMap[ spotLength ] = light.shadow.map;\r\n\t\t\t\t_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\r\n\t\t\t\t_lights.spot[ spotLength ++ ] = uniforms;\r\n\r\n\t\t\t} else if ( light instanceof THREE.PointLight ) {\r\n\r\n\t\t\t\tvar uniforms = lightCache.get( light );\r\n\r\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\r\n\r\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\r\n\t\t\t\tuniforms.distance = light.distance;\r\n\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\r\n\r\n\t\t\t\tuniforms.shadow = light.castShadow;\r\n\r\n\t\t\t\tif ( light.castShadow ) {\r\n\r\n\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\r\n\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\r\n\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\r\n\r\n\t\t\t\t\t_lights.shadows[ shadowsLength ++ ] = light;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_lights.pointShadowMap[ pointLength ] = light.shadow.map;\r\n\r\n\t\t\t\tif ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {\r\n\r\n\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ] = new THREE.Matrix4();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// for point lights we set the shadow matrix to be a translation-only matrix\r\n\t\t\t\t// equal to inverse of the light's position\r\n\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld ).negate();\r\n\t\t\t\t_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );\r\n\r\n\t\t\t\t_lights.point[ pointLength ++ ] = uniforms;\r\n\r\n\t\t\t} else if ( light instanceof THREE.HemisphereLight ) {\r\n\r\n\t\t\t\tvar uniforms = lightCache.get( light );\r\n\r\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\r\n\t\t\t\tuniforms.direction.normalize();\r\n\r\n\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\r\n\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\r\n\r\n\t\t\t\t_lights.hemi[ hemiLength ++ ] = uniforms;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t_lights.ambient[ 0 ] = r;\r\n\t\t_lights.ambient[ 1 ] = g;\r\n\t\t_lights.ambient[ 2 ] = b;\r\n\r\n\t\t_lights.directional.length = directionalLength;\r\n\t\t_lights.spot.length = spotLength;\r\n\t\t_lights.point.length = pointLength;\r\n\t\t_lights.hemi.length = hemiLength;\r\n\r\n\t\t_lights.shadows.length = shadowsLength;\r\n\r\n\t\t_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + shadowsLength;\r\n\r\n\t}\r\n\r\n\t// GL state setting\r\n\r\n\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\r\n\r\n\t\tif ( cullFace === THREE.CullFaceNone ) {\r\n\r\n\t\t\tstate.disable( _gl.CULL_FACE );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {\r\n\r\n\t\t\t\t_gl.frontFace( _gl.CW );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.frontFace( _gl.CCW );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( cullFace === THREE.CullFaceBack ) {\r\n\r\n\t\t\t\t_gl.cullFace( _gl.BACK );\r\n\r\n\t\t\t} else if ( cullFace === THREE.CullFaceFront ) {\r\n\r\n\t\t\t\t_gl.cullFace( _gl.FRONT );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.cullFace( _gl.FRONT_AND_BACK );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tstate.enable( _gl.CULL_FACE );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Textures\r\n\r\n\tfunction setTextureParameters ( textureType, texture, isPowerOfTwoImage ) {\r\n\r\n\t\tvar extension;\r\n\r\n\t\tif ( isPowerOfTwoImage ) {\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\r\n\r\n\t\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\r\n\r\n\t\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\r\n\t\tif ( extension ) {\r\n\r\n\t\t\tif ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\r\n\t\t\tif ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\r\n\r\n\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\r\n\r\n\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );\r\n\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction uploadTexture( textureProperties, texture, slot ) {\r\n\r\n\t\tif ( textureProperties.__webglInit === undefined ) {\r\n\r\n\t\t\ttextureProperties.__webglInit = true;\r\n\r\n\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\r\n\r\n\t\t\t_infoMemory.textures ++;\r\n\r\n\t\t}\r\n\r\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\r\n\r\n\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\r\n\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\r\n\r\n\t\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\r\n\r\n\t\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\r\n\r\n\t\t\timage = makePowerOfTwo( image );\r\n\r\n\t\t}\r\n\r\n\t\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\r\n\t\tglFormat = paramThreeToGL( texture.format ),\r\n\t\tglType = paramThreeToGL( texture.type );\r\n\r\n\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\r\n\r\n\t\tvar mipmap, mipmaps = texture.mipmaps;\r\n\r\n\t\tif ( texture instanceof THREE.DataTexture ) {\r\n\r\n\t\t\t// use manually created mipmaps if available\r\n\t\t\t// if there are no manual mipmaps\r\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\r\n\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\r\n\r\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.generateMipmaps = false;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( texture instanceof THREE.CompressedTexture ) {\r\n\r\n\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tmipmap = mipmaps[ i ];\r\n\r\n\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\r\n\r\n\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\r\n\r\n\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// regular Texture (image, video, canvas)\r\n\r\n\t\t\t// use manually created mipmaps if available\r\n\t\t\t// if there are no manual mipmaps\r\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\r\n\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\r\n\r\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.generateMipmaps = false;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\r\n\t\ttextureProperties.__version = texture.version;\r\n\r\n\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\r\n\r\n\t}\r\n\r\n\tthis.setTexture = function ( texture, slot ) {\r\n\r\n\t\tvar textureProperties = properties.get( texture );\r\n\r\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\r\n\r\n\t\t\tvar image = texture.image;\r\n\r\n\t\t\tif ( image === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( image.complete === false ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuploadTexture( textureProperties, texture, slot );\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\r\n\r\n\t};\r\n\r\n\tfunction clampToMaxSize ( image, maxSize ) {\r\n\r\n\t\tif ( image.width > maxSize || image.height > maxSize ) {\r\n\r\n\t\t\t// Warning: Scaling through the canvas will only work with images that use\r\n\t\t\t// premultiplied alpha.\r\n\r\n\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\r\n\r\n\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\tcanvas.width = Math.floor( image.width * scale );\r\n\t\t\tcanvas.height = Math.floor( image.height * scale );\r\n\r\n\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\r\n\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\r\n\r\n\t\t\treturn canvas;\r\n\r\n\t\t}\r\n\r\n\t\treturn image;\r\n\r\n\t}\r\n\r\n\tfunction isPowerOfTwo( image ) {\r\n\r\n\t\treturn THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );\r\n\r\n\t}\r\n\r\n\tfunction textureNeedsPowerOfTwo( texture ) {\r\n\r\n\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) return true;\r\n\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) return true;\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tfunction makePowerOfTwo( image ) {\r\n\r\n\t\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {\r\n\r\n\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\tcanvas.width = THREE.Math.nearestPowerOfTwo( image.width );\r\n\t\t\tcanvas.height = THREE.Math.nearestPowerOfTwo( image.height );\r\n\r\n\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\r\n\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\r\n\r\n\t\t\treturn canvas;\r\n\r\n\t\t}\r\n\r\n\t\treturn image;\r\n\r\n\t}\r\n\r\n\tfunction setCubeTexture ( texture, slot ) {\r\n\r\n\t\tvar textureProperties = properties.get( texture );\r\n\r\n\t\tif ( texture.image.length === 6 ) {\r\n\r\n\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\r\n\r\n\t\t\t\tif ( ! textureProperties.__image__webglTextureCube ) {\r\n\r\n\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\t\t\t\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\r\n\r\n\t\t\t\t\t_infoMemory.textures ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\r\n\r\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\r\n\t\t\t\tvar isCompressed = texture instanceof THREE.CompressedTexture;\r\n\t\t\t\tvar isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;\r\n\r\n\t\t\t\tvar cubeImage = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t\tif ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {\r\n\r\n\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar image = cubeImage[ 0 ],\r\n\t\t\t\tisPowerOfTwoImage = isPowerOfTwo( image ),\r\n\t\t\t\tglFormat = paramThreeToGL( texture.format ),\r\n\t\t\t\tglType = paramThreeToGL( texture.type );\r\n\r\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\r\n\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t\tif ( ! isCompressed ) {\r\n\r\n\t\t\t\t\t\tif ( isDataTexture ) {\r\n\r\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\r\n\r\n\t\t\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\r\n\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()\" );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) {\r\n\r\n\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttextureProperties.__version = texture.version;\r\n\r\n\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setCubeTextureDynamic ( texture, slot ) {\r\n\r\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\r\n\r\n\t}\r\n\r\n\t// Render targets\r\n\r\n\t// Setup storage for target texture and bind it to correct framebuffer\r\n\tfunction setupFrameBufferTexture ( framebuffer, renderTarget, attachment, textureTarget ) {\r\n\r\n\t\tvar glFormat = paramThreeToGL( renderTarget.texture.format );\r\n\t\tvar glType = paramThreeToGL( renderTarget.texture.type );\r\n\t\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\r\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\r\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\r\n\r\n\t}\r\n\r\n\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\r\n\tfunction setupRenderBufferStorage ( renderbuffer, renderTarget ) {\r\n\r\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\r\n\r\n\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\r\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\r\n\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\r\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// FIXME: We don't support !depth !stencil\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\r\n\r\n\t\t}\r\n\r\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\r\n\r\n\t}\r\n\r\n\t// Setup GL resources for a non-texture depth buffer\r\n\tfunction setupDepthRenderbuffer( renderTarget ) {\r\n\r\n\t\tvar renderTargetProperties = properties.get( renderTarget );\r\n\r\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\r\n\t\tif ( isCube ) {\r\n\r\n\t\t\trenderTargetProperties.__webglDepthbuffer = [];\r\n\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\r\n\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\r\n\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\r\n\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\r\n\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\r\n\r\n\t\t}\r\n\r\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\r\n\r\n\t}\r\n\r\n\t// Set up GL resources for the render target\r\n\tfunction setupRenderTarget( renderTarget ) {\r\n\r\n\t\tvar renderTargetProperties = properties.get( renderTarget );\r\n\t\tvar textureProperties = properties.get( renderTarget.texture );\r\n\r\n\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\r\n\r\n\t\ttextureProperties.__webglTexture = _gl.createTexture();\r\n\r\n\t\t_infoMemory.textures ++;\r\n\r\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\t\tvar isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height );\r\n\r\n\t\t// Setup framebuffer\r\n\r\n\t\tif ( isCube ) {\r\n\r\n\t\t\trenderTargetProperties.__webglFramebuffer = [];\r\n\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\r\n\r\n\t\t}\r\n\r\n\t\t// Setup color buffer\r\n\r\n\t\tif ( isCube ) {\r\n\r\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\r\n\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\r\n\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\r\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\r\n\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\r\n\r\n\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, null );\r\n\r\n\t\t}\r\n\r\n\t\t// Setup depth and stencil buffers\r\n\r\n\t\tif ( renderTarget.depthBuffer ) {\r\n\r\n\t\t\tsetupDepthRenderbuffer( renderTarget );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.getCurrentRenderTarget = function() {\r\n\r\n\t\treturn _currentRenderTarget;\r\n\r\n\t}\r\n\r\n\tthis.setRenderTarget = function ( renderTarget ) {\r\n\r\n\t\t_currentRenderTarget = renderTarget;\r\n\r\n\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\r\n\r\n\t\t\tsetupRenderTarget( renderTarget );\r\n\r\n\t\t}\r\n\r\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\t\tvar framebuffer;\r\n\r\n\t\tif ( renderTarget ) {\r\n\r\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\r\n\r\n\t\t\tif ( isCube ) {\r\n\r\n\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_currentScissor.copy( renderTarget.scissor );\r\n\t\t\t_currentScissorTest = renderTarget.scissorTest;\r\n\r\n\t\t\t_currentViewport.copy( renderTarget.viewport );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tframebuffer = null;\r\n\r\n\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\r\n\t\t\t_currentScissorTest = _scissorTest;\r\n\r\n\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\r\n\r\n\t\t}\r\n\r\n\t\tif ( _currentFramebuffer !== framebuffer ) {\r\n\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t\t_currentFramebuffer = framebuffer;\r\n\r\n\t\t}\r\n\r\n\t\tstate.scissor( _currentScissor );\r\n\t\tstate.setScissorTest( _currentScissorTest );\r\n\r\n\t\tstate.viewport( _currentViewport );\r\n\r\n\t\tif ( isCube ) {\r\n\r\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\r\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\r\n\r\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTarget === false ) {\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\r\n\r\n\t\tif ( framebuffer ) {\r\n\r\n\t\t\tvar restore = false;\r\n\r\n\t\t\tif ( framebuffer !== _currentFramebuffer ) {\r\n\r\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\r\n\t\t\t\trestore = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttry {\r\n\r\n\t\t\t\tvar texture = renderTarget.texture;\r\n\r\n\t\t\t\tif ( texture.format !== THREE.RGBAFormat\r\n\t\t\t\t\t&& paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\r\n\r\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( texture.type !== THREE.UnsignedByteType\r\n\t\t\t\t\t&& paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE )\r\n\t\t\t\t\t&& ! ( texture.type === THREE.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) )\r\n\t\t\t\t\t&& ! ( texture.type === THREE.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\r\n\r\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\r\n\r\n\t\t\t\t\t_gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} finally {\r\n\r\n\t\t\t\tif ( restore ) {\r\n\r\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction updateRenderTargetMipmap( renderTarget ) {\r\n\r\n\t\tvar target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\r\n\t\tvar texture = properties.get( renderTarget.texture ).__webglTexture;\r\n\r\n\t\tstate.bindTexture( target, texture );\r\n\t\t_gl.generateMipmap( target );\r\n\t\tstate.bindTexture( target, null );\r\n\r\n\t}\r\n\r\n\t// Fallback filters for non-power-of-2 textures\r\n\r\n\tfunction filterFallback ( f ) {\r\n\r\n\t\tif ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\r\n\r\n\t\t\treturn _gl.NEAREST;\r\n\r\n\t\t}\r\n\r\n\t\treturn _gl.LINEAR;\r\n\r\n\t}\r\n\r\n\t// Map three.js constants to WebGL constants\r\n\r\n\tfunction paramThreeToGL ( p ) {\r\n\r\n\t\tvar extension;\r\n\r\n\t\tif ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\r\n\t\tif ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\r\n\t\tif ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\r\n\r\n\t\tif ( p === THREE.NearestFilter ) return _gl.NEAREST;\r\n\t\tif ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\r\n\t\tif ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\r\n\r\n\t\tif ( p === THREE.LinearFilter ) return _gl.LINEAR;\r\n\t\tif ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\r\n\t\tif ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\r\n\r\n\t\tif ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\r\n\t\tif ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\r\n\t\tif ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\r\n\t\tif ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\r\n\r\n\t\tif ( p === THREE.ByteType ) return _gl.BYTE;\r\n\t\tif ( p === THREE.ShortType ) return _gl.SHORT;\r\n\t\tif ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\r\n\t\tif ( p === THREE.IntType ) return _gl.INT;\r\n\t\tif ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\r\n\t\tif ( p === THREE.FloatType ) return _gl.FLOAT;\r\n\r\n\t\textension = extensions.get( 'OES_texture_half_float' );\r\n\r\n\t\tif ( extension !== null ) {\r\n\r\n\t\t\tif ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;\r\n\r\n\t\t}\r\n\r\n\t\tif ( p === THREE.AlphaFormat ) return _gl.ALPHA;\r\n\t\tif ( p === THREE.RGBFormat ) return _gl.RGB;\r\n\t\tif ( p === THREE.RGBAFormat ) return _gl.RGBA;\r\n\t\tif ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\r\n\t\tif ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\r\n\r\n\t\tif ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\r\n\t\tif ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\r\n\t\tif ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\r\n\r\n\t\tif ( p === THREE.ZeroFactor ) return _gl.ZERO;\r\n\t\tif ( p === THREE.OneFactor ) return _gl.ONE;\r\n\t\tif ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\r\n\t\tif ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\r\n\t\tif ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\r\n\t\tif ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\r\n\t\tif ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\r\n\t\tif ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\r\n\r\n\t\tif ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\r\n\t\tif ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\r\n\t\tif ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\r\n\r\n\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\r\n\r\n\t\tif ( extension !== null ) {\r\n\r\n\t\t\tif ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\r\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\r\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\r\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\r\n\r\n\t\t}\r\n\r\n\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\r\n\r\n\t\tif ( extension !== null ) {\r\n\r\n\t\t\tif ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\r\n\t\t\tif ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\r\n\t\t\tif ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\r\n\t\t\tif ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\r\n\r\n\t\t}\r\n\r\n\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\r\n\r\n\t\tif ( extension !== null ) {\r\n\r\n\t\t\tif ( p === THREE.RGB_ETC1_Format ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\r\n\r\n\t\t}\r\n\r\n\t\textension = extensions.get( 'EXT_blend_minmax' );\r\n\r\n\t\tif ( extension !== null ) {\r\n\r\n\t\t\tif ( p === THREE.MinEquation ) return extension.MIN_EXT;\r\n\t\t\tif ( p === THREE.MaxEquation ) return extension.MAX_EXT;\r\n\r\n\t\t}\r\n\r\n\t\treturn 0;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/renderers/WebGLRenderTarget.js\r\n\r\n/**\r\n * @author szimek / https://github.com/szimek/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author Marius Kintel / https://github.com/kintel\r\n */\r\n\r\n/*\r\n In options, we can specify:\r\n * Texture parameters for an auto-generated target texture\r\n * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\r\n*/\r\nTHREE.WebGLRenderTarget = function ( width, height, options ) {\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.width = width;\r\n\tthis.height = height;\r\n\r\n\tthis.scissor = new THREE.Vector4( 0, 0, width, height );\r\n\tthis.scissorTest = false;\r\n\r\n\tthis.viewport = new THREE.Vector4( 0, 0, width, height );\r\n\r\n\toptions = options || {};\r\n\r\n\tif ( options.minFilter === undefined ) options.minFilter = THREE.LinearFilter;\r\n\r\n\tthis.texture = new THREE.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy );\r\n\r\n\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\r\n\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\r\n\r\n};\r\n\r\nTHREE.WebGLRenderTarget.prototype = {\r\n\r\n\tconstructor: THREE.WebGLRenderTarget,\r\n\r\n\tsetSize: function ( width, height ) {\r\n\r\n\t\tif ( this.width !== width || this.height !== height ) {\r\n\r\n\t\t\tthis.width = width;\r\n\t\t\tthis.height = height;\r\n\r\n\t\t\tthis.dispose();\r\n\r\n\t\t}\r\n\r\n\t\tthis.viewport.set( 0, 0, width, height );\r\n\t\tthis.scissor.set( 0, 0, width, height );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.width = source.width;\r\n\t\tthis.height = source.height;\r\n\r\n\t\tthis.viewport.copy( source.viewport );\r\n\r\n\t\tthis.texture = source.texture.clone();\r\n\r\n\t\tthis.depthBuffer = source.depthBuffer;\r\n\t\tthis.stencilBuffer = source.stencilBuffer;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );\r\n\r\n// File:src/renderers/WebGLRenderTargetCube.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com\r\n */\r\n\r\nTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\r\n\r\n\tTHREE.WebGLRenderTarget.call( this, width, height, options );\r\n\r\n\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\r\n\tthis.activeMipMapLevel = 0;\r\n\r\n};\r\n\r\nTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\r\nTHREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;\r\n\r\n// File:src/renderers/webgl/WebGLBufferRenderer.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {\r\n\r\n\tvar mode;\r\n\r\n\tfunction setMode( value ) {\r\n\r\n\t\tmode = value;\r\n\r\n\t}\r\n\r\n\tfunction render( start, count ) {\r\n\r\n\t\t_gl.drawArrays( mode, start, count );\r\n\r\n\t\t_infoRender.calls ++;\r\n\t\t_infoRender.vertices += count;\r\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\r\n\r\n\t}\r\n\r\n\tfunction renderInstances( geometry ) {\r\n\r\n\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n\t\tif ( extension === null ) {\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar position = geometry.attributes.position;\r\n\r\n\t\tvar count = 0;\r\n\r\n\t\tif ( position instanceof THREE.InterleavedBufferAttribute ) {\r\n\r\n\t\t\tcount = position.data.count;\r\n\r\n\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcount = position.count;\r\n\r\n\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\r\n\r\n\t\t}\r\n\r\n\t\t_infoRender.calls ++;\r\n\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\r\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\r\n\r\n\t}\r\n\r\n\tthis.setMode = setMode;\r\n\tthis.render = render;\r\n\tthis.renderInstances = renderInstances;\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {\r\n\r\n\tvar mode;\r\n\r\n\tfunction setMode( value ) {\r\n\r\n\t\tmode = value;\r\n\r\n\t}\r\n\r\n\tvar type, size;\r\n\r\n\tfunction setIndex( index ) {\r\n\r\n\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\r\n\r\n\t\t\ttype = _gl.UNSIGNED_INT;\r\n\t\t\tsize = 4;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttype = _gl.UNSIGNED_SHORT;\r\n\t\t\tsize = 2;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction render( start, count ) {\r\n\r\n\t\t_gl.drawElements( mode, count, type, start * size );\r\n\r\n\t\t_infoRender.calls ++;\r\n\t\t_infoRender.vertices += count;\r\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\r\n\r\n\t}\r\n\r\n\tfunction renderInstances( geometry, start, count ) {\r\n\r\n\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n\t\tif ( extension === null ) {\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\textension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );\r\n\r\n\t\t_infoRender.calls ++;\r\n\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\r\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\r\n\t}\r\n\r\n\tthis.setMode = setMode;\r\n\tthis.setIndex = setIndex;\r\n\tthis.render = render;\r\n\tthis.renderInstances = renderInstances;\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLExtensions.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLExtensions = function ( gl ) {\r\n\r\n\tvar extensions = {};\r\n\r\n\tthis.get = function ( name ) {\r\n\r\n\t\tif ( extensions[ name ] !== undefined ) {\r\n\r\n\t\t\treturn extensions[ name ];\r\n\r\n\t\t}\r\n\r\n\t\tvar extension;\r\n\r\n\t\tswitch ( name ) {\r\n\r\n\t\t\tcase 'EXT_texture_filter_anisotropic':\r\n\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'WEBGL_compressed_texture_s3tc':\r\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\r\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'WEBGL_compressed_texture_etc1':\r\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\textension = gl.getExtension( name );\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension === null ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\r\n\r\n\t\t}\r\n\r\n\t\textensions[ name ] = extension;\r\n\r\n\t\treturn extension;\r\n\r\n\t};\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLCapabilities.js\r\n\r\nTHREE.WebGLCapabilities = function ( gl, extensions, parameters ) {\r\n\r\n\tfunction getMaxPrecision( precision ) {\r\n\r\n\t\tif ( precision === 'highp' ) {\r\n\r\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\r\n\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\r\n\r\n\t\t\t\treturn 'highp';\r\n\r\n\t\t\t}\r\n\r\n\t\t\tprecision = 'mediump';\r\n\r\n\t\t}\r\n\r\n\t\tif ( precision === 'mediump' ) {\r\n\r\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\r\n\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\r\n\r\n\t\t\t\treturn 'mediump';\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn 'lowp';\r\n\r\n\t}\r\n\r\n\tthis.getMaxPrecision = getMaxPrecision;\r\n\r\n\tthis.precision = parameters.precision !== undefined ? parameters.precision : 'highp',\r\n\tthis.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;\r\n\r\n\tthis.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\r\n\tthis.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\r\n\tthis.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\r\n\tthis.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\r\n\r\n\tthis.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\r\n\tthis.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\r\n\tthis.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\r\n\tthis.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\r\n\r\n\tthis.vertexTextures = this.maxVertexTextures > 0;\r\n\tthis.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\r\n\tthis.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;\r\n\r\n\tvar _maxPrecision = getMaxPrecision( this.precision );\r\n\r\n\tif ( _maxPrecision !== this.precision ) {\r\n\r\n\t\tconsole.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );\r\n\t\tthis.precision = _maxPrecision;\r\n\r\n\t}\r\n\r\n\tif ( this.logarithmicDepthBuffer ) {\r\n\r\n\t\tthis.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLGeometries.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLGeometries = function ( gl, properties, info ) {\r\n\r\n\tvar geometries = {};\r\n\r\n\tfunction get( object ) {\r\n\r\n\t\tvar geometry = object.geometry;\r\n\r\n\t\tif ( geometries[ geometry.id ] !== undefined ) {\r\n\r\n\t\t\treturn geometries[ geometry.id ];\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\r\n\r\n\t\tvar buffergeometry;\r\n\r\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\tbuffergeometry = geometry;\r\n\r\n\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\tif ( geometry._bufferGeometry === undefined ) {\r\n\r\n\t\t\t\tgeometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbuffergeometry = geometry._bufferGeometry;\r\n\r\n\t\t}\r\n\r\n\t\tgeometries[ geometry.id ] = buffergeometry;\r\n\r\n\t\tinfo.memory.geometries ++;\r\n\r\n\t\treturn buffergeometry;\r\n\r\n\t}\r\n\r\n\tfunction onGeometryDispose( event ) {\r\n\r\n\t\tvar geometry = event.target;\r\n\t\tvar buffergeometry = geometries[ geometry.id ];\r\n\r\n\t\tif ( buffergeometry.index !== null ) {\r\n\r\n\t\t\tdeleteAttribute( buffergeometry.index );\r\n\r\n\t\t}\r\n\r\n\t\tdeleteAttributes( buffergeometry.attributes );\r\n\r\n\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\r\n\r\n\t\tdelete geometries[ geometry.id ];\r\n\r\n\t\t// TODO\r\n\r\n\t\tvar property = properties.get( geometry );\r\n\r\n\t\tif ( property.wireframe ) {\r\n\r\n\t\t\tdeleteAttribute( property.wireframe );\r\n\r\n\t\t}\r\n\r\n\t\tproperties.delete( geometry );\r\n\r\n\t\tvar bufferproperty = properties.get( buffergeometry );\r\n\r\n\t\tif ( bufferproperty.wireframe ) {\r\n\r\n\t\t\tdeleteAttribute( bufferproperty.wireframe );\r\n\r\n\t\t}\r\n\r\n\t\tproperties.delete( buffergeometry );\r\n\r\n\t\t//\r\n\r\n\t\tinfo.memory.geometries --;\r\n\r\n\t}\r\n\r\n\tfunction getAttributeBuffer( attribute ) {\r\n\r\n\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\r\n\t\t\treturn properties.get( attribute.data ).__webglBuffer;\r\n\r\n\t\t}\r\n\r\n\t\treturn properties.get( attribute ).__webglBuffer;\r\n\r\n\t}\r\n\r\n\tfunction deleteAttribute( attribute ) {\r\n\r\n\t\tvar buffer = getAttributeBuffer( attribute );\r\n\r\n\t\tif ( buffer !== undefined ) {\r\n\r\n\t\t\tgl.deleteBuffer( buffer );\r\n\t\t\tremoveAttributeBuffer( attribute );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction deleteAttributes( attributes ) {\r\n\r\n\t\tfor ( var name in attributes ) {\r\n\r\n\t\t\tdeleteAttribute( attributes[ name ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction removeAttributeBuffer( attribute ) {\r\n\r\n\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\r\n\t\t\tproperties.delete( attribute.data );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tproperties.delete( attribute );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.get = get;\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLLights.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLLights = function () {\r\n\r\n\tvar lights = {};\r\n\r\n\tthis.get = function ( light ) {\r\n\r\n\t\tif ( lights[ light.id ] !== undefined ) {\r\n\r\n\t\t\treturn lights[ light.id ];\r\n\r\n\t\t}\r\n\r\n\t\tvar uniforms;\r\n\r\n\t\tswitch ( light.type ) {\r\n\r\n\t\t\tcase 'DirectionalLight':\r\n\t\t\t\tuniforms = {\r\n\t\t\t\t\tdirection: new THREE.Vector3(),\r\n\t\t\t\t\tcolor: new THREE.Color(),\r\n\r\n\t\t\t\t\tshadow: false,\r\n\t\t\t\t\tshadowBias: 0,\r\n\t\t\t\t\tshadowRadius: 1,\r\n\t\t\t\t\tshadowMapSize: new THREE.Vector2()\r\n\t\t\t\t};\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'SpotLight':\r\n\t\t\t\tuniforms = {\r\n\t\t\t\t\tposition: new THREE.Vector3(),\r\n\t\t\t\t\tdirection: new THREE.Vector3(),\r\n\t\t\t\t\tcolor: new THREE.Color(),\r\n\t\t\t\t\tdistance: 0,\r\n\t\t\t\t\tconeCos: 0,\r\n\t\t\t\t\tpenumbraCos: 0,\r\n\t\t\t\t\tdecay: 0,\r\n\r\n\t\t\t\t\tshadow: false,\r\n\t\t\t\t\tshadowBias: 0,\r\n\t\t\t\t\tshadowRadius: 1,\r\n\t\t\t\t\tshadowMapSize: new THREE.Vector2()\r\n\t\t\t\t};\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'PointLight':\r\n\t\t\t\tuniforms = {\r\n\t\t\t\t\tposition: new THREE.Vector3(),\r\n\t\t\t\t\tcolor: new THREE.Color(),\r\n\t\t\t\t\tdistance: 0,\r\n\t\t\t\t\tdecay: 0,\r\n\r\n\t\t\t\t\tshadow: false,\r\n\t\t\t\t\tshadowBias: 0,\r\n\t\t\t\t\tshadowRadius: 1,\r\n\t\t\t\t\tshadowMapSize: new THREE.Vector2()\r\n\t\t\t\t};\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'HemisphereLight':\r\n\t\t\t\tuniforms = {\r\n\t\t\t\t\tdirection: new THREE.Vector3(),\r\n\t\t\t\t\tskyColor: new THREE.Color(),\r\n\t\t\t\t\tgroundColor: new THREE.Color()\r\n\t\t\t\t};\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\tlights[ light.id ] = uniforms;\r\n\r\n\t\treturn uniforms;\r\n\r\n\t};\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLObjects.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLObjects = function ( gl, properties, info ) {\r\n\r\n\tvar geometries = new THREE.WebGLGeometries( gl, properties, info );\r\n\r\n\t//\r\n\r\n\tfunction update( object ) {\r\n\r\n\t\t// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.\r\n\r\n\t\tvar geometry = geometries.get( object );\r\n\r\n\t\tif ( object.geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\tgeometry.updateFromObject( object );\r\n\r\n\t\t}\r\n\r\n\t\tvar index = geometry.index;\r\n\t\tvar attributes = geometry.attributes;\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tupdateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var name in attributes ) {\r\n\r\n\t\t\tupdateAttribute( attributes[ name ], gl.ARRAY_BUFFER );\r\n\r\n\t\t}\r\n\r\n\t\t// morph targets\r\n\r\n\t\tvar morphAttributes = geometry.morphAttributes;\r\n\r\n\t\tfor ( var name in morphAttributes ) {\r\n\r\n\t\t\tvar array = morphAttributes[ name ];\r\n\r\n\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tupdateAttribute( array[ i ], gl.ARRAY_BUFFER );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry;\r\n\r\n\t}\r\n\r\n\tfunction updateAttribute( attribute, bufferType ) {\r\n\r\n\t\tvar data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;\r\n\r\n\t\tvar attributeProperties = properties.get( data );\r\n\r\n\t\tif ( attributeProperties.__webglBuffer === undefined ) {\r\n\r\n\t\t\tcreateBuffer( attributeProperties, data, bufferType );\r\n\r\n\t\t} else if ( attributeProperties.version !== data.version ) {\r\n\r\n\t\t\tupdateBuffer( attributeProperties, data, bufferType );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction createBuffer( attributeProperties, data, bufferType ) {\r\n\r\n\t\tattributeProperties.__webglBuffer = gl.createBuffer();\r\n\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\r\n\r\n\t\tvar usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\r\n\r\n\t\tgl.bufferData( bufferType, data.array, usage );\r\n\r\n\t\tattributeProperties.version = data.version;\r\n\r\n\t}\r\n\r\n\tfunction updateBuffer( attributeProperties, data, bufferType ) {\r\n\r\n\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\r\n\r\n\t\tif ( data.dynamic === false || data.updateRange.count === - 1 ) {\r\n\r\n\t\t\t// Not using update ranges\r\n\r\n\t\t\tgl.bufferSubData( bufferType, 0, data.array );\r\n\r\n\t\t} else if ( data.updateRange.count === 0 ) {\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tgl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,\r\n\t\t\t\t\t\t\t  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );\r\n\r\n\t\t\tdata.updateRange.count = 0; // reset range\r\n\r\n\t\t}\r\n\r\n\t\tattributeProperties.version = data.version;\r\n\r\n\t}\r\n\r\n\tfunction getAttributeBuffer( attribute ) {\r\n\r\n\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\r\n\t\t\treturn properties.get( attribute.data ).__webglBuffer;\r\n\r\n\t\t}\r\n\r\n\t\treturn properties.get( attribute ).__webglBuffer;\r\n\r\n\t}\r\n\r\n\tfunction getWireframeAttribute( geometry ) {\r\n\r\n\t\tvar property = properties.get( geometry );\r\n\r\n\t\tif ( property.wireframe !== undefined ) {\r\n\r\n\t\t\treturn property.wireframe;\r\n\r\n\t\t}\r\n\r\n\t\tvar indices = [];\r\n\r\n\t\tvar index = geometry.index;\r\n\t\tvar attributes = geometry.attributes;\r\n\t\tvar position = attributes.position;\r\n\r\n\t\t// console.time( 'wireframe' );\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tvar edges = {};\r\n\t\t\tvar array = index.array;\r\n\r\n\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\r\n\r\n\t\t\t\tvar a = array[ i + 0 ];\r\n\t\t\t\tvar b = array[ i + 1 ];\r\n\t\t\t\tvar c = array[ i + 2 ];\r\n\r\n\t\t\t\tif ( checkEdge( edges, a, b ) ) indices.push( a, b );\r\n\t\t\t\tif ( checkEdge( edges, b, c ) ) indices.push( b, c );\r\n\t\t\t\tif ( checkEdge( edges, c, a ) ) indices.push( c, a );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar array = attributes.position.array;\r\n\r\n\t\t\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\r\n\r\n\t\t\t\tvar a = i + 0;\r\n\t\t\t\tvar b = i + 1;\r\n\t\t\t\tvar c = i + 2;\r\n\r\n\t\t\t\tindices.push( a, b, b, c, c, a );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// console.timeEnd( 'wireframe' );\r\n\r\n\t\tvar TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;\r\n\t\tvar attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );\r\n\r\n\t\tupdateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\r\n\r\n\t\tproperty.wireframe = attribute;\r\n\r\n\t\treturn attribute;\r\n\r\n\t}\r\n\r\n\tfunction checkEdge( edges, a, b ) {\r\n\r\n\t\tif ( a > b ) {\r\n\r\n\t\t\tvar tmp = a;\r\n\t\t\ta = b;\r\n\t\t\tb = tmp;\r\n\r\n\t\t}\r\n\r\n\t\tvar list = edges[ a ];\r\n\r\n\t\tif ( list === undefined ) {\r\n\r\n\t\t\tedges[ a ] = [ b ];\r\n\t\t\treturn true;\r\n\r\n\t\t} else if ( list.indexOf( b ) === -1 ) {\r\n\r\n\t\t\tlist.push( b );\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tthis.getAttributeBuffer = getAttributeBuffer;\r\n\tthis.getWireframeAttribute = getWireframeAttribute;\r\n\r\n\tthis.update = update;\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLProgram.js\r\n\r\nTHREE.WebGLProgram = ( function () {\r\n\r\n\tvar programIdCount = 0;\r\n\r\n\t// TODO: Combine the regex\r\n\tvar structRe = /^([\\w\\d_]+)\\.([\\w\\d_]+)$/;\r\n\tvar arrayStructRe = /^([\\w\\d_]+)\\[(\\d+)\\]\\.([\\w\\d_]+)$/;\r\n\tvar arrayRe = /^([\\w\\d_]+)\\[0\\]$/;\r\n\r\n\tfunction getEncodingComponents( encoding ) {\r\n\r\n\t\tswitch ( encoding ) {\r\n\r\n\t\t\tcase THREE.LinearEncoding:\r\n\t\t\t\treturn [ 'Linear','( value )' ];\r\n\t\t\tcase THREE.sRGBEncoding:\r\n\t\t\t\treturn [ 'sRGB','( value )' ];\r\n\t\t\tcase THREE.RGBEEncoding:\r\n\t\t\t\treturn [ 'RGBE','( value )' ];\r\n\t\t\tcase THREE.RGBM7Encoding:\r\n\t\t\t\treturn [ 'RGBM','( value, 7.0 )' ];\r\n\t\t\tcase THREE.RGBM16Encoding:\r\n\t\t\t\treturn [ 'RGBM','( value, 16.0 )' ];\r\n\t\t\tcase THREE.RGBDEncoding:\r\n\t\t\t\treturn [ 'RGBD','( value, 256.0 )' ];\r\n\t\t\tcase THREE.GammaEncoding:\r\n\t\t\t\treturn [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error( 'unsupported encoding: ' + encoding );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction getTexelDecodingFunction( functionName, encoding ) {\r\n\r\n\t\tvar components = getEncodingComponents( encoding );\r\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return \" + components[ 0 ] + \"ToLinear\" + components[ 1 ] + \"; }\";\r\n\r\n\t}\r\n\r\n\tfunction getTexelEncodingFunction( functionName, encoding ) {\r\n\r\n\t\tvar components = getEncodingComponents( encoding );\r\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return LinearTo\" + components[ 0 ] + components[ 1 ] + \"; }\";\r\n\r\n\t}\r\n\r\n\tfunction getToneMappingFunction( functionName, toneMapping ) {\r\n\r\n\t\tvar toneMappingName;\r\n\r\n\t\tswitch ( toneMapping ) {\r\n\r\n\t\t\tcase THREE.LinearToneMapping:\r\n\t\t\t\ttoneMappingName = \"Linear\";\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase THREE.ReinhardToneMapping:\r\n\t\t\t\ttoneMappingName = \"Reinhard\";\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase THREE.Uncharted2ToneMapping:\r\n\t\t\t\ttoneMappingName = \"Uncharted2\";\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase THREE.CineonToneMapping:\r\n\t\t\t\ttoneMappingName = \"OptimizedCineon\";\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\r\n\r\n\t\t}\r\n\r\n\t\treturn \"vec3 \" + functionName + \"( vec3 color ) { return \" + toneMappingName + \"ToneMapping( color ); }\";\r\n\r\n\t}\r\n\r\n\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\r\n\r\n\t\textensions = extensions || {};\r\n\r\n\t\tvar chunks = [\r\n\t\t\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\r\n\t\t\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\r\n\t\t\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\r\n\t\t\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',\r\n\t\t];\r\n\r\n\t\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\r\n\r\n\t}\r\n\r\n\tfunction generateDefines( defines ) {\r\n\r\n\t\tvar chunks = [];\r\n\r\n\t\tfor ( var name in defines ) {\r\n\r\n\t\t\tvar value = defines[ name ];\r\n\r\n\t\t\tif ( value === false ) continue;\r\n\r\n\t\t\tchunks.push( '#define ' + name + ' ' + value );\r\n\r\n\t\t}\r\n\r\n\t\treturn chunks.join( '\\n' );\r\n\r\n\t}\r\n\r\n\tfunction fetchUniformLocations( gl, program, identifiers ) {\r\n\r\n\t\tvar uniforms = {};\r\n\r\n\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\r\n\r\n\t\tfor ( var i = 0; i < n; i ++ ) {\r\n\r\n\t\t\tvar info = gl.getActiveUniform( program, i );\r\n\t\t\tvar name = info.name;\r\n\t\t\tvar location = gl.getUniformLocation( program, name );\r\n\r\n\t\t\t//console.log(\"THREE.WebGLProgram: ACTIVE UNIFORM:\", name);\r\n\r\n\t\t\tvar matches = structRe.exec( name );\r\n\t\t\tif ( matches ) {\r\n\r\n\t\t\t\tvar structName = matches[ 1 ];\r\n\t\t\t\tvar structProperty = matches[ 2 ];\r\n\r\n\t\t\t\tvar uniformsStruct = uniforms[ structName ];\r\n\r\n\t\t\t\tif ( ! uniformsStruct ) {\r\n\r\n\t\t\t\t\tuniformsStruct = uniforms[ structName ] = {};\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tuniformsStruct[ structProperty ] = location;\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmatches = arrayStructRe.exec( name );\r\n\r\n\t\t\tif ( matches ) {\r\n\r\n\t\t\t\tvar arrayName = matches[ 1 ];\r\n\t\t\t\tvar arrayIndex = matches[ 2 ];\r\n\t\t\t\tvar arrayProperty = matches[ 3 ];\r\n\r\n\t\t\t\tvar uniformsArray = uniforms[ arrayName ];\r\n\r\n\t\t\t\tif ( ! uniformsArray ) {\r\n\r\n\t\t\t\t\tuniformsArray = uniforms[ arrayName ] = [];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar uniformsArrayIndex = uniformsArray[ arrayIndex ];\r\n\r\n\t\t\t\tif ( ! uniformsArrayIndex ) {\r\n\r\n\t\t\t\t\tuniformsArrayIndex = uniformsArray[ arrayIndex ] = {};\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tuniformsArrayIndex[ arrayProperty ] = location;\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmatches = arrayRe.exec( name );\r\n\r\n\t\t\tif ( matches ) {\r\n\r\n\t\t\t\tvar arrayName = matches[ 1 ];\r\n\r\n\t\t\t\tuniforms[ arrayName ] = location;\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuniforms[ name ] = location;\r\n\r\n\t\t}\r\n\r\n\t\treturn uniforms;\r\n\r\n\t}\r\n\r\n\tfunction fetchAttributeLocations( gl, program, identifiers ) {\r\n\r\n\t\tvar attributes = {};\r\n\r\n\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\r\n\r\n\t\tfor ( var i = 0; i < n; i ++ ) {\r\n\r\n\t\t\tvar info = gl.getActiveAttrib( program, i );\r\n\t\t\tvar name = info.name;\r\n\r\n\t\t\t// console.log(\"THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\", name, i );\r\n\r\n\t\t\tattributes[ name ] = gl.getAttribLocation( program, name );\r\n\r\n\t\t}\r\n\r\n\t\treturn attributes;\r\n\r\n\t}\r\n\r\n\tfunction filterEmptyLine( string ) {\r\n\r\n\t\treturn string !== '';\r\n\r\n\t}\r\n\r\n\tfunction replaceLightNums( string, parameters ) {\r\n\r\n\t\treturn string\r\n\t\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\r\n\t\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\r\n\t\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\r\n\t\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\r\n\r\n\t}\r\n\r\n\tfunction parseIncludes( string ) {\r\n\r\n\t\tvar pattern = /#include +<([\\w\\d.]+)>/g;\r\n\r\n\t\tfunction replace( match, include ) {\r\n\r\n\t\t\tvar replace = THREE.ShaderChunk[ include ];\r\n\r\n\t\t\tif ( replace === undefined ) {\r\n\r\n\t\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn parseIncludes( replace );\r\n\r\n\t\t}\r\n\r\n\t\treturn string.replace( pattern, replace );\r\n\r\n\t}\r\n\r\n\tfunction unrollLoops( string ) {\r\n\r\n\t\tvar pattern = /for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\r\n\r\n\t\tfunction replace( match, start, end, snippet ) {\r\n\r\n\t\t\tvar unroll = '';\r\n\r\n\t\t\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\r\n\r\n\t\t\t\tunroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn unroll;\r\n\r\n\t\t}\r\n\r\n\t\treturn string.replace( pattern, replace );\r\n\r\n\t}\r\n\r\n\treturn function WebGLProgram( renderer, code, material, parameters ) {\r\n\r\n\t\tvar gl = renderer.context;\r\n\r\n\t\tvar extensions = material.extensions;\r\n\t\tvar defines = material.defines;\r\n\r\n\t\tvar vertexShader = material.__webglShader.vertexShader;\r\n\t\tvar fragmentShader = material.__webglShader.fragmentShader;\r\n\r\n\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\r\n\r\n\t\tif ( parameters.shadowMapType === THREE.PCFShadowMap ) {\r\n\r\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\r\n\r\n\t\t} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\r\n\r\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\r\n\r\n\t\t}\r\n\r\n\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\r\n\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n\r\n\t\tif ( parameters.envMap ) {\r\n\r\n\t\t\tswitch ( material.envMap.mapping ) {\r\n\r\n\t\t\t\tcase THREE.CubeReflectionMapping:\r\n\t\t\t\tcase THREE.CubeRefractionMapping:\r\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.CubeUVReflectionMapping:\r\n\t\t\t\tcase THREE.CubeUVRefractionMapping:\r\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.EquirectangularReflectionMapping:\r\n\t\t\t\tcase THREE.EquirectangularRefractionMapping:\r\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.SphericalReflectionMapping:\r\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tswitch ( material.envMap.mapping ) {\r\n\r\n\t\t\t\tcase THREE.CubeRefractionMapping:\r\n\t\t\t\tcase THREE.EquirectangularRefractionMapping:\r\n\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tswitch ( material.combine ) {\r\n\r\n\t\t\t\tcase THREE.MultiplyOperation:\r\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.MixOperation:\r\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.AddOperation:\r\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\r\n\r\n\t\t// console.log( 'building new program ' );\r\n\r\n\t\t//\r\n\r\n\t\tvar customExtensions = generateExtensions( extensions, parameters, renderer.extensions );\r\n\r\n\t\tvar customDefines = generateDefines( defines );\r\n\r\n\t\t//\r\n\r\n\t\tvar program = gl.createProgram();\r\n\r\n\t\tvar prefixVertex, prefixFragment;\r\n\r\n\t\tif ( material instanceof THREE.RawShaderMaterial ) {\r\n\r\n\t\t\tprefixVertex = '';\r\n\t\t\tprefixFragment = '';\r\n\r\n\t\t} else {\r\n\r\n\t\t\tprefixVertex = [\r\n\r\n\t\t\t\t'precision ' + parameters.precision + ' float;',\r\n\t\t\t\t'precision ' + parameters.precision + ' int;',\r\n\r\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\r\n\r\n\t\t\t\tcustomDefines,\r\n\r\n\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\r\n\r\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n\r\n\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\r\n\r\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\r\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\r\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\r\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\r\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\r\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n\t\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\r\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\r\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\r\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\r\n\r\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\r\n\r\n\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\r\n\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\r\n\r\n\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\r\n\t\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\r\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\r\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n\t\t\t\tparameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',\r\n\r\n\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\r\n\r\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\r\n\r\n\t\t\t\t'uniform mat4 modelMatrix;',\r\n\t\t\t\t'uniform mat4 modelViewMatrix;',\r\n\t\t\t\t'uniform mat4 projectionMatrix;',\r\n\t\t\t\t'uniform mat4 viewMatrix;',\r\n\t\t\t\t'uniform mat3 normalMatrix;',\r\n\t\t\t\t'uniform vec3 cameraPosition;',\r\n\r\n\t\t\t\t'attribute vec3 position;',\r\n\t\t\t\t'attribute vec3 normal;',\r\n\t\t\t\t'attribute vec2 uv;',\r\n\r\n\t\t\t\t'#ifdef USE_COLOR',\r\n\r\n\t\t\t\t'\tattribute vec3 color;',\r\n\r\n\t\t\t\t'#endif',\r\n\r\n\t\t\t\t'#ifdef USE_MORPHTARGETS',\r\n\r\n\t\t\t\t'\tattribute vec3 morphTarget0;',\r\n\t\t\t\t'\tattribute vec3 morphTarget1;',\r\n\t\t\t\t'\tattribute vec3 morphTarget2;',\r\n\t\t\t\t'\tattribute vec3 morphTarget3;',\r\n\r\n\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\r\n\r\n\t\t\t\t'\t\tattribute vec3 morphNormal0;',\r\n\t\t\t\t'\t\tattribute vec3 morphNormal1;',\r\n\t\t\t\t'\t\tattribute vec3 morphNormal2;',\r\n\t\t\t\t'\t\tattribute vec3 morphNormal3;',\r\n\r\n\t\t\t\t'\t#else',\r\n\r\n\t\t\t\t'\t\tattribute vec3 morphTarget4;',\r\n\t\t\t\t'\t\tattribute vec3 morphTarget5;',\r\n\t\t\t\t'\t\tattribute vec3 morphTarget6;',\r\n\t\t\t\t'\t\tattribute vec3 morphTarget7;',\r\n\r\n\t\t\t\t'\t#endif',\r\n\r\n\t\t\t\t'#endif',\r\n\r\n\t\t\t\t'#ifdef USE_SKINNING',\r\n\r\n\t\t\t\t'\tattribute vec4 skinIndex;',\r\n\t\t\t\t'\tattribute vec4 skinWeight;',\r\n\r\n\t\t\t\t'#endif',\r\n\r\n\t\t\t\t'\\n'\r\n\r\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\r\n\r\n\t\t\tprefixFragment = [\r\n\r\n\t\t\t\tcustomExtensions,\r\n\r\n\t\t\t\t'precision ' + parameters.precision + ' float;',\r\n\t\t\t\t'precision ' + parameters.precision + ' int;',\r\n\r\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\r\n\r\n\t\t\t\tcustomDefines,\r\n\r\n\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\r\n\r\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n\r\n\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\r\n\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\r\n\r\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\r\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\r\n\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\r\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\r\n\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\r\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\r\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\r\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\r\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\r\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\r\n\r\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\r\n\r\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\r\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n\t\t\t\tparameters.pointLightShadows > 0 ? '#define POINT_LIGHT_SHADOWS' : '',\r\n\r\n\t\t\t\tparameters.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : '',\r\n\r\n\t\t\t\tparameters.physicallyCorrectLights ? \"#define PHYSICALLY_CORRECT_LIGHTS\" : '',\r\n\r\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\r\n\t\t\t\tparameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\r\n\r\n\t\t\t\t'uniform mat4 viewMatrix;',\r\n\t\t\t\t'uniform vec3 cameraPosition;',\r\n\r\n\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? \"#define TONE_MAPPING\" : '',\r\n\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? THREE.ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below\r\n\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? getToneMappingFunction( \"toneMapping\", parameters.toneMapping ) : '',\r\n\r\n\t\t\t\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? THREE.ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\r\n\t\t\t\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\r\n\t\t\t\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\r\n\t\t\t\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\r\n\t\t\t\tparameters.outputEncoding ? getTexelEncodingFunction( \"linearToOutputTexel\", parameters.outputEncoding ) : '',\r\n\r\n\t\t\t\t'\\n'\r\n\r\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\r\n\r\n\t\t}\r\n\r\n\t\tvertexShader = parseIncludes( vertexShader, parameters );\r\n\t\tvertexShader = replaceLightNums( vertexShader, parameters );\r\n\r\n\t\tfragmentShader = parseIncludes( fragmentShader, parameters );\r\n\t\tfragmentShader = replaceLightNums( fragmentShader, parameters );\r\n\r\n\t\tif ( material instanceof THREE.ShaderMaterial === false ) {\r\n\r\n\t\t\tvertexShader = unrollLoops( vertexShader );\r\n\t\t\tfragmentShader = unrollLoops( fragmentShader );\r\n\r\n\t\t}\r\n\r\n\t\tvar vertexGlsl = prefixVertex + vertexShader;\r\n\t\tvar fragmentGlsl = prefixFragment + fragmentShader;\r\n\r\n\t\t// console.log( '*VERTEX*', vertexGlsl );\r\n\t\t// console.log( '*FRAGMENT*', fragmentGlsl );\r\n\r\n\t\tvar glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\r\n\t\tvar glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\r\n\r\n\t\tgl.attachShader( program, glVertexShader );\r\n\t\tgl.attachShader( program, glFragmentShader );\r\n\r\n\t\t// Force a particular attribute to index 0.\r\n\r\n\t\tif ( material.index0AttributeName !== undefined ) {\r\n\r\n\t\t\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\r\n\r\n\t\t} else if ( parameters.morphTargets === true ) {\r\n\r\n\t\t\t// programs with morphTargets displace position out of attribute 0\r\n\t\t\tgl.bindAttribLocation( program, 0, 'position' );\r\n\r\n\t\t}\r\n\r\n\t\tgl.linkProgram( program );\r\n\r\n\t\tvar programLog = gl.getProgramInfoLog( program );\r\n\t\tvar vertexLog = gl.getShaderInfoLog( glVertexShader );\r\n\t\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader );\r\n\r\n\t\tvar runnable = true;\r\n\t\tvar haveDiagnostics = true;\r\n\r\n\t\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\r\n\t\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\r\n\r\n\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\r\n\r\n\t\t\trunnable = false;\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\r\n\r\n\t\t} else if ( programLog !== '' ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\r\n\r\n\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\r\n\r\n\t\t\thaveDiagnostics = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( haveDiagnostics ) {\r\n\r\n\t\t\tthis.diagnostics = {\r\n\r\n\t\t\t\trunnable: runnable,\r\n\t\t\t\tmaterial: material,\r\n\r\n\t\t\t\tprogramLog: programLog,\r\n\r\n\t\t\t\tvertexShader: {\r\n\r\n\t\t\t\t\tlog: vertexLog,\r\n\t\t\t\t\tprefix: prefixVertex\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tfragmentShader: {\r\n\r\n\t\t\t\t\tlog: fragmentLog,\r\n\t\t\t\t\tprefix: prefixFragment\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\t// clean up\r\n\r\n\t\tgl.deleteShader( glVertexShader );\r\n\t\tgl.deleteShader( glFragmentShader );\r\n\r\n\t\t// set up caching for uniform locations\r\n\r\n\t\tvar cachedUniforms;\r\n\r\n\t\tthis.getUniforms = function() {\r\n\r\n\t\t\tif ( cachedUniforms === undefined ) {\r\n\r\n\t\t\t\tcachedUniforms = fetchUniformLocations( gl, program );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn cachedUniforms;\r\n\r\n\t\t};\r\n\r\n\t\t// set up caching for attribute locations\r\n\r\n\t\tvar cachedAttributes;\r\n\r\n\t\tthis.getAttributes = function() {\r\n\r\n\t\t\tif ( cachedAttributes === undefined ) {\r\n\r\n\t\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn cachedAttributes;\r\n\r\n\t\t};\r\n\r\n\t\t// free resource\r\n\r\n\t\tthis.destroy = function() {\r\n\r\n\t\t\tgl.deleteProgram( program );\r\n\t\t\tthis.program = undefined;\r\n\r\n\t\t};\r\n\r\n\t\t// DEPRECATED\r\n\r\n\t\tObject.defineProperties( this, {\r\n\r\n\t\t\tuniforms: {\r\n\t\t\t\tget: function() {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\r\n\t\t\t\t\treturn this.getUniforms();\r\n\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tattributes: {\r\n\t\t\t\tget: function() {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\r\n\t\t\t\t\treturn this.getAttributes();\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\r\n\t\t//\r\n\r\n\t\tthis.id = programIdCount ++;\r\n\t\tthis.code = code;\r\n\t\tthis.usedTimes = 1;\r\n\t\tthis.program = program;\r\n\t\tthis.vertexShader = glVertexShader;\r\n\t\tthis.fragmentShader = glFragmentShader;\r\n\r\n\t\treturn this;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n// File:src/renderers/webgl/WebGLPrograms.js\r\n\r\nTHREE.WebGLPrograms = function ( renderer, capabilities ) {\r\n\r\n\tvar programs = [];\r\n\r\n\tvar shaderIDs = {\r\n\t\tMeshDepthMaterial: 'depth',\r\n\t\tMeshNormalMaterial: 'normal',\r\n\t\tMeshBasicMaterial: 'basic',\r\n\t\tMeshLambertMaterial: 'lambert',\r\n\t\tMeshPhongMaterial: 'phong',\r\n\t\tMeshStandardMaterial: 'standard',\r\n\t\tLineBasicMaterial: 'basic',\r\n\t\tLineDashedMaterial: 'dashed',\r\n\t\tPointsMaterial: 'points'\r\n\t};\r\n\r\n\tvar parameterNames = [\r\n\t\t\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\r\n\t\t\"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"displacementMap\", \"specularMap\",\r\n\t\t\"roughnessMap\", \"metalnessMap\",\r\n\t\t\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\r\n\t\t\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\r\n\t\t\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\r\n\t\t\"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\r\n\t\t\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\",\r\n\t\t\"shadowMapEnabled\", \"pointLightShadows\", \"toneMapping\", 'physicallyCorrectLights',\r\n\t\t\"shadowMapType\",\r\n\t\t\"alphaTest\", \"doubleSided\", \"flipSided\"\r\n\t];\r\n\r\n\r\n\tfunction allocateBones ( object ) {\r\n\r\n\t\tif ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\r\n\r\n\t\t\treturn 1024;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// default for when object is not specified\r\n\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\r\n\t\t\t//\r\n\t\t\t//  - leave some extra space for other uniforms\r\n\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\r\n\t\t\t//    (up to 54 should be safe)\r\n\r\n\t\t\tvar nVertexUniforms = capabilities.maxVertexUniforms;\r\n\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\r\n\r\n\t\t\tvar maxBones = nVertexMatrices;\r\n\r\n\t\t\tif ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\r\n\r\n\t\t\t\tmaxBones = Math.min( object.skeleton.bones.length, maxBones );\r\n\r\n\t\t\t\tif ( maxBones < object.skeleton.bones.length ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn maxBones;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\r\n\r\n\t\tvar encoding;\r\n\r\n\t\tif ( ! map ) {\r\n\r\n\t\t\tencoding = THREE.LinearEncoding;\r\n\r\n\t\t} else if ( map instanceof THREE.Texture ) {\r\n\r\n\t\t\tencoding = map.encoding;\r\n\r\n\t\t} else if ( map instanceof THREE.WebGLRenderTarget ) {\r\n\r\n\t\t\tencoding = map.texture.encoding;\r\n\r\n\t\t}\r\n\r\n\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\r\n\t\tif ( encoding === THREE.LinearEncoding && gammaOverrideLinear ) {\r\n\r\n\t\t\tencoding = THREE.GammaEncoding;\r\n\r\n\t\t}\r\n\r\n\t\treturn encoding;\r\n\r\n\t}\r\n\r\n\tthis.getParameters = function ( material, lights, fog, object ) {\r\n\r\n\t\tvar shaderID = shaderIDs[ material.type ];\r\n\r\n\t\t// heuristics to create shader parameters according to lights in the scene\r\n\t\t// (not to blow over maxLights budget)\r\n\r\n\t\tvar maxBones = allocateBones( object );\r\n\t\tvar precision = renderer.getPrecision();\r\n\r\n\t\tif ( material.precision !== null ) {\r\n\r\n\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\r\n\r\n\t\t\tif ( precision !== material.precision ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar parameters = {\r\n\r\n\t\t\tshaderID: shaderID,\r\n\r\n\t\t\tprecision: precision,\r\n\t\t\tsupportsVertexTextures: capabilities.vertexTextures,\r\n\t\t\toutputEncoding: getTextureEncodingFromMap( renderer.getCurrentRenderTarget(), renderer.gammaOutput ),\r\n\t\t\tmap: !! material.map,\r\n\t\t\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\r\n\t\t\tenvMap: !! material.envMap,\r\n\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\r\n\t\t\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\r\n\t\t\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === THREE.CubeUVReflectionMapping ) || ( material.envMap.mapping === THREE.CubeUVRefractionMapping ) ),\r\n\t\t\tlightMap: !! material.lightMap,\r\n\t\t\taoMap: !! material.aoMap,\r\n\t\t\temissiveMap: !! material.emissiveMap,\r\n\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\r\n\t\t\tbumpMap: !! material.bumpMap,\r\n\t\t\tnormalMap: !! material.normalMap,\r\n\t\t\tdisplacementMap: !! material.displacementMap,\r\n\t\t\troughnessMap: !! material.roughnessMap,\r\n\t\t\tmetalnessMap: !! material.metalnessMap,\r\n\t\t\tspecularMap: !! material.specularMap,\r\n\t\t\talphaMap: !! material.alphaMap,\r\n\r\n\t\t\tcombine: material.combine,\r\n\r\n\t\t\tvertexColors: material.vertexColors,\r\n\r\n\t\t\tfog: fog,\r\n\t\t\tuseFog: material.fog,\r\n\t\t\tfogExp: fog instanceof THREE.FogExp2,\r\n\r\n\t\t\tflatShading: material.shading === THREE.FlatShading,\r\n\r\n\t\t\tsizeAttenuation: material.sizeAttenuation,\r\n\t\t\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\r\n\r\n\t\t\tskinning: material.skinning,\r\n\t\t\tmaxBones: maxBones,\r\n\t\t\tuseVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,\r\n\r\n\t\t\tmorphTargets: material.morphTargets,\r\n\t\t\tmorphNormals: material.morphNormals,\r\n\t\t\tmaxMorphTargets: renderer.maxMorphTargets,\r\n\t\t\tmaxMorphNormals: renderer.maxMorphNormals,\r\n\r\n\t\t\tnumDirLights: lights.directional.length,\r\n\t\t\tnumPointLights: lights.point.length,\r\n\t\t\tnumSpotLights: lights.spot.length,\r\n\t\t\tnumHemiLights: lights.hemi.length,\r\n\r\n\t\t\tpointLightShadows: lights.shadowsPointLight,\r\n\r\n\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,\r\n\t\t\tshadowMapType: renderer.shadowMap.type,\r\n\r\n\t\t\ttoneMapping: renderer.toneMapping,\r\n\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\r\n\r\n\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\r\n\r\n\t\t\talphaTest: material.alphaTest,\r\n\t\t\tdoubleSided: material.side === THREE.DoubleSide,\r\n\t\t\tflipSided: material.side === THREE.BackSide\r\n\r\n\t\t};\r\n\r\n\t\treturn parameters;\r\n\r\n\t};\r\n\r\n\tthis.getProgramCode = function ( material, parameters ) {\r\n\r\n\t\tvar chunks = [];\r\n\r\n\t\tif ( parameters.shaderID ) {\r\n\r\n\t\t\tchunks.push( parameters.shaderID );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tchunks.push( material.fragmentShader );\r\n\t\t\tchunks.push( material.vertexShader );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.defines !== undefined ) {\r\n\r\n\t\t\tfor ( var name in material.defines ) {\r\n\r\n\t\t\t\tchunks.push( name );\r\n\t\t\t\tchunks.push( material.defines[ name ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\r\n\r\n\t\t\tvar parameterName = parameterNames[ i ];\r\n\t\t\tchunks.push( parameterName );\r\n\t\t\tchunks.push( parameters[ parameterName ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn chunks.join();\r\n\r\n\t};\r\n\r\n\tthis.acquireProgram = function ( material, parameters, code ) {\r\n\r\n\t\tvar program;\r\n\r\n\t\t// Check if code has been already compiled\r\n\t\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\r\n\r\n\t\t\tvar programInfo = programs[ p ];\r\n\r\n\t\t\tif ( programInfo.code === code ) {\r\n\r\n\t\t\t\tprogram = programInfo;\r\n\t\t\t\t++ program.usedTimes;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( program === undefined ) {\r\n\r\n\t\t\tprogram = new THREE.WebGLProgram( renderer, code, material, parameters );\r\n\t\t\tprograms.push( program );\r\n\r\n\t\t}\r\n\r\n\t\treturn program;\r\n\r\n\t};\r\n\r\n\tthis.releaseProgram = function( program ) {\r\n\r\n\t\tif ( -- program.usedTimes === 0 ) {\r\n\r\n\t\t\t// Remove from unordered set\r\n\t\t\tvar i = programs.indexOf( program );\r\n\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\r\n\t\t\tprograms.pop();\r\n\r\n\t\t\t// Free WebGL resources\r\n\t\t\tprogram.destroy();\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Exposed for resource monitoring & error feedback via renderer.info:\r\n\tthis.programs = programs;\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLProperties.js\r\n\r\n/**\r\n* @author fordacious / fordacious.github.io\r\n*/\r\n\r\nTHREE.WebGLProperties = function () {\r\n\r\n\tvar properties = {};\r\n\r\n\tthis.get = function ( object ) {\r\n\r\n\t\tvar uuid = object.uuid;\r\n\t\tvar map = properties[ uuid ];\r\n\r\n\t\tif ( map === undefined ) {\r\n\r\n\t\t\tmap = {};\r\n\t\t\tproperties[ uuid ] = map;\r\n\r\n\t\t}\r\n\r\n\t\treturn map;\r\n\r\n\t};\r\n\r\n\tthis.delete = function ( object ) {\r\n\r\n\t\tdelete properties[ object.uuid ];\r\n\r\n\t};\r\n\r\n\tthis.clear = function () {\r\n\r\n\t\tproperties = {};\r\n\r\n\t};\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLShader.js\r\n\r\nTHREE.WebGLShader = ( function () {\r\n\r\n\tfunction addLineNumbers( string ) {\r\n\r\n\t\tvar lines = string.split( '\\n' );\r\n\r\n\t\tfor ( var i = 0; i < lines.length; i ++ ) {\r\n\r\n\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn lines.join( '\\n' );\r\n\r\n\t}\r\n\r\n\treturn function WebGLShader( gl, type, string ) {\r\n\r\n\t\tvar shader = gl.createShader( type );\r\n\r\n\t\tgl.shaderSource( shader, string );\r\n\t\tgl.compileShader( shader );\r\n\r\n\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\r\n\r\n\t\t}\r\n\r\n\t\t// --enable-privileged-webgl-extension\r\n\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\r\n\r\n\t\treturn shader;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n// File:src/renderers/webgl/WebGLShadowMap.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {\r\n\r\n\tvar _gl = _renderer.context,\r\n\t_state = _renderer.state,\r\n\t_frustum = new THREE.Frustum(),\r\n\t_projScreenMatrix = new THREE.Matrix4(),\r\n\r\n\t_shadowMapSize = new THREE.Vector2(),\r\n\r\n\t_lookTarget = new THREE.Vector3(),\r\n\t_lightPositionWorld = new THREE.Vector3(),\r\n\r\n\t_renderList = [],\r\n\r\n\t_MorphingFlag = 1,\r\n\t_SkinningFlag = 2,\r\n\r\n\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\r\n\r\n\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\r\n\t_distanceMaterials = new Array( _NumberOfMaterialVariants );\r\n\r\n\tvar cubeDirections = [\r\n\t\tnew THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( - 1, 0, 0 ), new THREE.Vector3( 0, 0, 1 ),\r\n\t\tnew THREE.Vector3( 0, 0, - 1 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, - 1, 0 )\r\n\t];\r\n\r\n\tvar cubeUps = [\r\n\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ),\r\n\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ),\tnew THREE.Vector3( 0, 0, - 1 )\r\n\t];\r\n\r\n\tvar cube2DViewPorts = [\r\n\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),\r\n\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()\r\n\t];\r\n\r\n\t// init\r\n\r\n\tvar depthShader = THREE.ShaderLib[ \"depthRGBA\" ];\r\n\tvar depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );\r\n\r\n\tvar distanceShader = THREE.ShaderLib[ \"distanceRGBA\" ];\r\n\tvar distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms );\r\n\r\n\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\r\n\r\n\t\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\r\n\t\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\r\n\r\n\t\tvar depthMaterial = new THREE.ShaderMaterial( {\r\n\t\t\tuniforms: depthUniforms,\r\n\t\t\tvertexShader: depthShader.vertexShader,\r\n\t\t\tfragmentShader: depthShader.fragmentShader,\r\n\t\t\tmorphTargets: useMorphing,\r\n\t\t\tskinning: useSkinning\r\n\t\t} );\r\n\r\n\t\t_depthMaterials[ i ] = depthMaterial;\r\n\r\n\t\tvar distanceMaterial = new THREE.ShaderMaterial( {\r\n\t\t\tdefines: {\r\n\t\t\t\t'USE_SHADOWMAP': ''\r\n\t\t\t},\r\n\t\t\tuniforms: distanceUniforms,\r\n\t\t\tvertexShader: distanceShader.vertexShader,\r\n\t\t\tfragmentShader: distanceShader.fragmentShader,\r\n\t\t\tmorphTargets: useMorphing,\r\n\t\t\tskinning: useSkinning\r\n\t\t} );\r\n\r\n\t\t_distanceMaterials[ i ] = distanceMaterial;\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar scope = this;\r\n\r\n\tthis.enabled = false;\r\n\r\n\tthis.autoUpdate = true;\r\n\tthis.needsUpdate = false;\r\n\r\n\tthis.type = THREE.PCFShadowMap;\r\n\tthis.cullFace = THREE.CullFaceFront;\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tvar faceCount, isPointLight;\r\n\t\tvar shadows = _lights.shadows;\r\n\r\n\t\tif ( shadows.length === 0 ) return;\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\r\n\r\n\t\t// Set GL state for depth map.\r\n\t\t_state.clearColor( 1, 1, 1, 1 );\r\n\t\t_state.disable( _gl.BLEND );\r\n\t\t_state.enable( _gl.CULL_FACE );\r\n\t\t_gl.frontFace( _gl.CCW );\r\n\t\t_gl.cullFace( scope.cullFace === THREE.CullFaceFront ? _gl.FRONT : _gl.BACK );\r\n\t\t_state.setDepthTest( true );\r\n\t\t_state.setScissorTest( false );\r\n\r\n\t\t// render depth map\r\n\r\n\t\tfor ( var i = 0, il = shadows.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar light = shadows[ i ];\r\n\r\n\t\t\tvar shadow = light.shadow;\r\n\t\t\tvar shadowCamera = shadow.camera;\r\n\r\n\t\t\t_shadowMapSize.copy( shadow.mapSize );\r\n\r\n\t\t\tif ( light instanceof THREE.PointLight ) {\r\n\r\n\t\t\t\tfaceCount = 6;\r\n\t\t\t\tisPointLight = true;\r\n\r\n\t\t\t\tvar vpWidth = _shadowMapSize.x;\r\n\t\t\t\tvar vpHeight = _shadowMapSize.y;\r\n\r\n\t\t\t\t// These viewports map a cube-map onto a 2D texture with the\r\n\t\t\t\t// following orientation:\r\n\t\t\t\t//\r\n\t\t\t\t//  xzXZ\r\n\t\t\t\t//   y Y\r\n\t\t\t\t//\r\n\t\t\t\t// X - Positive x direction\r\n\t\t\t\t// x - Negative x direction\r\n\t\t\t\t// Y - Positive y direction\r\n\t\t\t\t// y - Negative y direction\r\n\t\t\t\t// Z - Positive z direction\r\n\t\t\t\t// z - Negative z direction\r\n\r\n\t\t\t\t// positive X\r\n\t\t\t\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t// negative X\r\n\t\t\t\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t// positive Z\r\n\t\t\t\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t// negative Z\r\n\t\t\t\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t// positive Y\r\n\t\t\t\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\r\n\t\t\t\t// negative Y\r\n\t\t\t\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\r\n\r\n\t\t\t\t_shadowMapSize.x *= 4.0;\r\n\t\t\t\t_shadowMapSize.y *= 2.0;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfaceCount = 1;\r\n\t\t\t\tisPointLight = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( shadow.map === null ) {\r\n\r\n\t\t\t\tvar pars = { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\r\n\r\n\t\t\t\tshadow.map = new THREE.WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\r\n\r\n\t\t\t\t//\r\n\r\n\t\t\t\tif ( light instanceof THREE.SpotLight ) {\r\n\r\n\t\t\t\t\tshadowCamera.aspect = _shadowMapSize.x / _shadowMapSize.y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tshadowCamera.updateProjectionMatrix();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar shadowMap = shadow.map;\r\n\t\t\tvar shadowMatrix = shadow.matrix;\r\n\r\n\t\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\tshadowCamera.position.copy( _lightPositionWorld );\r\n\r\n\t\t\t_renderer.setRenderTarget( shadowMap );\r\n\t\t\t_renderer.clear();\r\n\r\n\t\t\t// render shadow map for each cube face (if omni-directional) or\r\n\t\t\t// run a single pass if not\r\n\r\n\t\t\tfor ( var face = 0; face < faceCount; face ++ ) {\r\n\r\n\t\t\t\tif ( isPointLight ) {\r\n\r\n\t\t\t\t\t_lookTarget.copy( shadowCamera.position );\r\n\t\t\t\t\t_lookTarget.add( cubeDirections[ face ] );\r\n\t\t\t\t\tshadowCamera.up.copy( cubeUps[ face ] );\r\n\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\r\n\r\n\t\t\t\t\tvar vpDimensions = cube2DViewPorts[ face ];\r\n\t\t\t\t\t_state.viewport( vpDimensions );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tshadowCamera.updateMatrixWorld();\r\n\t\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\r\n\r\n\t\t\t\t// compute shadow matrix\r\n\r\n\t\t\t\tshadowMatrix.set(\r\n\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\r\n\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\r\n\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\r\n\t\t\t\t\t0.0, 0.0, 0.0, 1.0\r\n\t\t\t\t);\r\n\r\n\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\r\n\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\r\n\r\n\t\t\t\t// update camera matrices and frustum\r\n\r\n\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\r\n\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\r\n\t\t\t\t// set object matrices & frustum culling\r\n\r\n\t\t\t\t_renderList.length = 0;\r\n\r\n\t\t\t\tprojectObject( scene, camera, shadowCamera );\r\n\r\n\t\t\t\t// render shadow map\r\n\t\t\t\t// render regular objects\r\n\r\n\t\t\t\tfor ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tvar object = _renderList[ j ];\r\n\t\t\t\t\tvar geometry = _objects.update( object );\r\n\t\t\t\t\tvar material = object.material;\r\n\r\n\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\r\n\r\n\t\t\t\t\t\tvar groups = geometry.groups;\r\n\t\t\t\t\t\tvar materials = material.materials;\r\n\r\n\t\t\t\t\t\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar group = groups[ k ];\r\n\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\r\n\r\n\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\r\n\r\n\t\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );\r\n\t\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );\r\n\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Restore GL state.\r\n\t\tvar clearColor = _renderer.getClearColor(),\r\n\t\tclearAlpha = _renderer.getClearAlpha();\r\n\t\t_renderer.setClearColor( clearColor, clearAlpha );\r\n\r\n\t\t_state.enable( _gl.BLEND );\r\n\r\n\t\tif ( scope.cullFace === THREE.CullFaceFront ) {\r\n\r\n\t\t\t_gl.cullFace( _gl.BACK );\r\n\r\n\t\t}\r\n\r\n\t\tscope.needsUpdate = false;\r\n\r\n\t};\r\n\r\n\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {\r\n\r\n\t\tvar geometry = object.geometry;\r\n\r\n\t\tvar newMaterial = null;\r\n\r\n\t\tvar materialVariants = _depthMaterials;\r\n\t\tvar customMaterial = object.customDepthMaterial;\r\n\r\n\t\tif ( isPointLight ) {\r\n\r\n\t\t\tmaterialVariants = _distanceMaterials;\r\n\t\t\tcustomMaterial = object.customDistanceMaterial;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! customMaterial ) {\r\n\r\n\t\t\tvar useMorphing = geometry.morphTargets !== undefined &&\r\n\t\t\t\t\tgeometry.morphTargets.length > 0 && material.morphTargets;\r\n\r\n\t\t\tvar useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;\r\n\r\n\t\t\tvar variantIndex = 0;\r\n\r\n\t\t\tif ( useMorphing ) variantIndex |= _MorphingFlag;\r\n\t\t\tif ( useSkinning ) variantIndex |= _SkinningFlag;\r\n\r\n\t\t\tnewMaterial = materialVariants[ variantIndex ];\r\n\r\n\t\t} else {\r\n\r\n\t\t\tnewMaterial = customMaterial;\r\n\r\n\t\t}\r\n\r\n\t\tnewMaterial.visible = material.visible;\r\n\t\tnewMaterial.wireframe = material.wireframe;\r\n\t\tnewMaterial.wireframeLinewidth = material.wireframeLinewidth;\r\n\r\n\t\tif ( isPointLight && newMaterial.uniforms.lightPos !== undefined ) {\r\n\r\n\t\t\tnewMaterial.uniforms.lightPos.value.copy( lightPositionWorld );\r\n\r\n\t\t}\r\n\r\n\t\treturn newMaterial;\r\n\r\n\t}\r\n\r\n\tfunction projectObject( object, camera, shadowCamera ) {\r\n\r\n\t\tif ( object.visible === false ) return;\r\n\r\n\t\tif ( object.layers.test( camera.layers ) && ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) ) {\r\n\r\n\t\t\tif ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\r\n\r\n\t\t\t\tvar material = object.material;\r\n\r\n\t\t\t\tif ( material.visible === true ) {\r\n\r\n\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\r\n\t\t\t\t\t_renderList.push( object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar children = object.children;\r\n\r\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tprojectObject( children[ i ], camera, shadowCamera );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLState.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {\r\n\r\n\tvar _this = this;\r\n\r\n\tvar color = new THREE.Vector4();\r\n\r\n\tvar newAttributes = new Uint8Array( 16 );\r\n\tvar enabledAttributes = new Uint8Array( 16 );\r\n\tvar attributeDivisors = new Uint8Array( 16 );\r\n\r\n\tvar capabilities = {};\r\n\r\n\tvar compressedTextureFormats = null;\r\n\r\n\tvar currentBlending = null;\r\n\tvar currentBlendEquation = null;\r\n\tvar currentBlendSrc = null;\r\n\tvar currentBlendDst = null;\r\n\tvar currentBlendEquationAlpha = null;\r\n\tvar currentBlendSrcAlpha = null;\r\n\tvar currentBlendDstAlpha = null;\r\n\tvar currentPremultipledAlpha = false;\r\n\r\n\tvar currentDepthFunc = null;\r\n\tvar currentDepthWrite = null;\r\n\r\n\tvar currentColorWrite = null;\r\n\r\n\tvar currentStencilWrite = null;\r\n\tvar currentStencilFunc = null;\r\n\tvar currentStencilRef = null;\r\n\tvar currentStencilMask = null;\r\n\tvar currentStencilFail  = null;\r\n\tvar currentStencilZFail = null;\r\n\tvar currentStencilZPass = null;\r\n\r\n\tvar currentFlipSided = null;\r\n\r\n\tvar currentLineWidth = null;\r\n\r\n\tvar currentPolygonOffsetFactor = null;\r\n\tvar currentPolygonOffsetUnits = null;\r\n\r\n\tvar currentScissorTest = null;\r\n\r\n\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\r\n\r\n\tvar currentTextureSlot = undefined;\r\n\tvar currentBoundTextures = {};\r\n\r\n\tvar currentClearColor = new THREE.Vector4();\r\n\tvar currentClearDepth = null;\r\n\tvar currentClearStencil = null;\r\n\r\n\tvar currentScissor = new THREE.Vector4();\r\n\tvar currentViewport = new THREE.Vector4();\r\n\r\n\tvar emptyTexture = gl.createTexture();\r\n\tgl.bindTexture( gl.TEXTURE_2D, emptyTexture );\r\n\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR );\r\n\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 1, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, new Uint8Array( 3 ) );\r\n\r\n\tthis.init = function () {\r\n\r\n\t\tthis.clearColor( 0, 0, 0, 1 );\r\n\t\tthis.clearDepth( 1 );\r\n\t\tthis.clearStencil( 0 );\r\n\r\n\t\tthis.enable( gl.DEPTH_TEST );\r\n\t\tgl.depthFunc( gl.LEQUAL );\r\n\r\n\t\tgl.frontFace( gl.CCW );\r\n\t\tgl.cullFace( gl.BACK );\r\n\t\tthis.enable( gl.CULL_FACE );\r\n\r\n\t\tthis.enable( gl.BLEND );\r\n\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n\t};\r\n\r\n\tthis.initAttributes = function () {\r\n\r\n\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\r\n\r\n\t\t\tnewAttributes[ i ] = 0;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.enableAttribute = function ( attribute ) {\r\n\r\n\t\tnewAttributes[ attribute ] = 1;\r\n\r\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\r\n\r\n\t\t\tgl.enableVertexAttribArray( attribute );\r\n\t\t\tenabledAttributes[ attribute ] = 1;\r\n\r\n\t\t}\r\n\r\n\t\tif ( attributeDivisors[ attribute ] !== 0 ) {\r\n\r\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n\t\t\textension.vertexAttribDivisorANGLE( attribute, 0 );\r\n\t\t\tattributeDivisors[ attribute ] = 0;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {\r\n\r\n\t\tnewAttributes[ attribute ] = 1;\r\n\r\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\r\n\r\n\t\t\tgl.enableVertexAttribArray( attribute );\r\n\t\t\tenabledAttributes[ attribute ] = 1;\r\n\r\n\t\t}\r\n\r\n\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\r\n\r\n\t\t\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\r\n\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.disableUnusedAttributes = function () {\r\n\r\n\t\tfor ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {\r\n\r\n\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\r\n\r\n\t\t\t\tgl.disableVertexAttribArray( i );\r\n\t\t\t\tenabledAttributes[ i ] = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.enable = function ( id ) {\r\n\r\n\t\tif ( capabilities[ id ] !== true ) {\r\n\r\n\t\t\tgl.enable( id );\r\n\t\t\tcapabilities[ id ] = true;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.disable = function ( id ) {\r\n\r\n\t\tif ( capabilities[ id ] !== false ) {\r\n\r\n\t\t\tgl.disable( id );\r\n\t\t\tcapabilities[ id ] = false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.getCompressedTextureFormats = function () {\r\n\r\n\t\tif ( compressedTextureFormats === null ) {\r\n\r\n\t\t\tcompressedTextureFormats = [];\r\n\r\n\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\r\n\t\t\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\r\n\t\t\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {\r\n\r\n\t\t\t\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\r\n\r\n\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\r\n\r\n\t\t\t\t\tcompressedTextureFormats.push( formats[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn compressedTextureFormats;\r\n\r\n\t};\r\n\r\n\tthis.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\r\n\r\n\t\tif ( blending === THREE.NoBlending ) {\r\n\r\n\t\t\tthis.disable( gl.BLEND );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.enable( gl.BLEND );\r\n\r\n\t\t}\r\n\r\n\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\r\n\r\n\t\t\tif ( blending === THREE.AdditiveBlending ) {\r\n\r\n\t\t\t\tif ( premultipliedAlpha ) {\r\n\r\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( blending === THREE.SubtractiveBlending ) {\r\n\r\n\t\t\t\tif ( premultipliedAlpha ) {\r\n\r\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( blending === THREE.MultiplyBlending ) {\r\n\r\n\t\t\t\tif ( premultipliedAlpha ) {\r\n\r\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.SRC_COLOR, gl.SRC_ALPHA );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( premultipliedAlpha ) {\r\n\r\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentBlending = blending;\r\n\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\r\n\r\n\t\t}\r\n\r\n\t\tif ( blending === THREE.CustomBlending ) {\r\n\r\n\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\r\n\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\r\n\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\r\n\r\n\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\r\n\r\n\t\t\t\tgl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\r\n\r\n\t\t\t\tcurrentBlendEquation = blendEquation;\r\n\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\r\n\r\n\t\t\t\tgl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\r\n\r\n\t\t\t\tcurrentBlendSrc = blendSrc;\r\n\t\t\t\tcurrentBlendDst = blendDst;\r\n\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\r\n\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcurrentBlendEquation = null;\r\n\t\t\tcurrentBlendSrc = null;\r\n\t\t\tcurrentBlendDst = null;\r\n\t\t\tcurrentBlendEquationAlpha = null;\r\n\t\t\tcurrentBlendSrcAlpha = null;\r\n\t\t\tcurrentBlendDstAlpha = null;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setDepthFunc = function ( depthFunc ) {\r\n\r\n\t\tif ( currentDepthFunc !== depthFunc ) {\r\n\r\n\t\t\tif ( depthFunc ) {\r\n\r\n\t\t\t\tswitch ( depthFunc ) {\r\n\r\n\t\t\t\t\tcase THREE.NeverDepth:\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase THREE.AlwaysDepth:\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase THREE.LessDepth:\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.LESS );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase THREE.LessEqualDepth:\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase THREE.EqualDepth:\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase THREE.GreaterEqualDepth:\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase THREE.GreaterDepth:\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase THREE.NotEqualDepth:\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgl.depthFunc( gl.LEQUAL );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentDepthFunc = depthFunc;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setDepthTest = function ( depthTest ) {\r\n\r\n\t\tif ( depthTest ) {\r\n\r\n\t\t\tthis.enable( gl.DEPTH_TEST );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.disable( gl.DEPTH_TEST );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setDepthWrite = function ( depthWrite ) {\r\n\r\n\t\t// TODO: Rename to setDepthMask\r\n\r\n\t\tif ( currentDepthWrite !== depthWrite ) {\r\n\r\n\t\t\tgl.depthMask( depthWrite );\r\n\t\t\tcurrentDepthWrite = depthWrite;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setColorWrite = function ( colorWrite ) {\r\n\r\n\t\t// TODO: Rename to setColorMask\r\n\r\n\t\tif ( currentColorWrite !== colorWrite ) {\r\n\r\n\t\t\tgl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );\r\n\t\t\tcurrentColorWrite = colorWrite;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setStencilFunc = function ( stencilFunc, stencilRef, stencilMask ) {\r\n\r\n\t\tif ( currentStencilFunc !== stencilFunc ||\r\n\t\t\t\t currentStencilRef \t!== stencilRef \t||\r\n\t\t\t\t currentStencilMask !== stencilMask ) {\r\n\r\n\t\t\tgl.stencilFunc( stencilFunc,  stencilRef, stencilMask );\r\n\r\n\t\t\tcurrentStencilFunc = stencilFunc;\r\n\t\t\tcurrentStencilRef  = stencilRef;\r\n\t\t\tcurrentStencilMask = stencilMask;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setStencilOp = function ( stencilFail, stencilZFail, stencilZPass ) {\r\n\r\n\t\tif ( currentStencilFail\t !== stencilFail \t||\r\n\t\t\t\t currentStencilZFail !== stencilZFail ||\r\n\t\t\t\t currentStencilZPass !== stencilZPass ) {\r\n\r\n\t\t\tgl.stencilOp( stencilFail,  stencilZFail, stencilZPass );\r\n\r\n\t\t\tcurrentStencilFail  = stencilFail;\r\n\t\t\tcurrentStencilZFail = stencilZFail;\r\n\t\t\tcurrentStencilZPass = stencilZPass;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setStencilTest = function ( stencilTest ) {\r\n\r\n\t\tif ( stencilTest ) {\r\n\r\n\t\t\tthis.enable( gl.STENCIL_TEST );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.disable( gl.STENCIL_TEST );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setStencilWrite = function ( stencilWrite ) {\r\n\r\n\t\t// TODO: Rename to setStencilMask\r\n\r\n\t\tif ( currentStencilWrite !== stencilWrite ) {\r\n\r\n\t\t\tgl.stencilMask( stencilWrite );\r\n\t\t\tcurrentStencilWrite = stencilWrite;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setFlipSided = function ( flipSided ) {\r\n\r\n\t\tif ( currentFlipSided !== flipSided ) {\r\n\r\n\t\t\tif ( flipSided ) {\r\n\r\n\t\t\t\tgl.frontFace( gl.CW );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgl.frontFace( gl.CCW );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentFlipSided = flipSided;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setLineWidth = function ( width ) {\r\n\r\n\t\tif ( width !== currentLineWidth ) {\r\n\r\n\t\t\tgl.lineWidth( width );\r\n\r\n\t\t\tcurrentLineWidth = width;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setPolygonOffset = function ( polygonOffset, factor, units ) {\r\n\r\n\t\tif ( polygonOffset ) {\r\n\r\n\t\t\tthis.enable( gl.POLYGON_OFFSET_FILL );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.disable( gl.POLYGON_OFFSET_FILL );\r\n\r\n\t\t}\r\n\r\n\t\tif ( polygonOffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {\r\n\r\n\t\t\tgl.polygonOffset( factor, units );\r\n\r\n\t\t\tcurrentPolygonOffsetFactor = factor;\r\n\t\t\tcurrentPolygonOffsetUnits = units;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.getScissorTest = function () {\r\n\r\n\t\treturn currentScissorTest;\r\n\r\n\t};\r\n\r\n\tthis.setScissorTest = function ( scissorTest ) {\r\n\r\n\t\tcurrentScissorTest = scissorTest;\r\n\r\n\t\tif ( scissorTest ) {\r\n\r\n\t\t\tthis.enable( gl.SCISSOR_TEST );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.disable( gl.SCISSOR_TEST );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// texture\r\n\r\n\tthis.activeTexture = function ( webglSlot ) {\r\n\r\n\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\r\n\r\n\t\tif ( currentTextureSlot !== webglSlot ) {\r\n\r\n\t\t\tgl.activeTexture( webglSlot );\r\n\t\t\tcurrentTextureSlot = webglSlot;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.bindTexture = function ( webglType, webglTexture ) {\r\n\r\n\t\tif ( currentTextureSlot === undefined ) {\r\n\r\n\t\t\t_this.activeTexture();\r\n\r\n\t\t}\r\n\r\n\t\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\r\n\r\n\t\tif ( boundTexture === undefined ) {\r\n\r\n\t\t\tboundTexture = { type: undefined, texture: undefined };\r\n\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\r\n\r\n\t\t}\r\n\r\n\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\r\n\r\n\t\t\tgl.bindTexture( webglType, webglTexture || emptyTexture );\r\n\r\n\t\t\tboundTexture.type = webglType;\r\n\t\t\tboundTexture.texture = webglTexture;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.compressedTexImage2D = function () {\r\n\r\n\t\ttry {\r\n\r\n\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\r\n\r\n\t\t} catch ( error ) {\r\n\r\n\t\t\tconsole.error( error );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.texImage2D = function () {\r\n\r\n\t\ttry {\r\n\r\n\t\t\tgl.texImage2D.apply( gl, arguments );\r\n\r\n\t\t} catch ( error ) {\r\n\r\n\t\t\tconsole.error( error );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// clear values\r\n\r\n\tthis.clearColor = function ( r, g, b, a ) {\r\n\r\n\t\tcolor.set( r, g, b, a );\r\n\r\n\t\tif ( currentClearColor.equals( color ) === false ) {\r\n\r\n\t\t\tgl.clearColor( r, g, b, a );\r\n\t\t\tcurrentClearColor.copy( color );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.clearDepth = function ( depth ) {\r\n\r\n\t\tif ( currentClearDepth !== depth ) {\r\n\r\n\t\t\tgl.clearDepth( depth );\r\n\t\t\tcurrentClearDepth = depth;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.clearStencil = function ( stencil ) {\r\n\r\n\t\tif ( currentClearStencil !== stencil ) {\r\n\r\n\t\t\tgl.clearStencil( stencil );\r\n\t\t\tcurrentClearStencil = stencil;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\tthis.scissor = function ( scissor ) {\r\n\r\n\t\tif ( currentScissor.equals( scissor ) === false ) {\r\n\r\n\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\r\n\t\t\tcurrentScissor.copy( scissor );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.viewport = function ( viewport ) {\r\n\r\n\t\tif ( currentViewport.equals( viewport ) === false ) {\r\n\r\n\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\r\n\t\t\tcurrentViewport.copy( viewport );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\tthis.reset = function () {\r\n\r\n\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\r\n\r\n\t\t\tif ( enabledAttributes[ i ] === 1 ) {\r\n\r\n\t\t\t\tgl.disableVertexAttribArray( i );\r\n\t\t\t\tenabledAttributes[ i ] = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tcapabilities = {};\r\n\r\n\t\tcompressedTextureFormats = null;\r\n\r\n\t\tcurrentTextureSlot = undefined;\r\n\t\tcurrentBoundTextures = {};\r\n\r\n\t\tcurrentBlending = null;\r\n\r\n\t\tcurrentColorWrite = null;\r\n\t\tcurrentDepthWrite = null;\r\n\t\tcurrentStencilWrite = null;\r\n\r\n\t\tcurrentFlipSided = null;\r\n\r\n\t};\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/plugins/LensFlarePlugin.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.LensFlarePlugin = function ( renderer, flares ) {\r\n\r\n\tvar gl = renderer.context;\r\n\tvar state = renderer.state;\r\n\r\n\tvar vertexBuffer, elementBuffer;\r\n\tvar program, attributes, uniforms;\r\n\tvar hasVertexTexture;\r\n\r\n\tvar tempTexture, occlusionTexture;\r\n\r\n\tfunction init() {\r\n\r\n\t\tvar vertices = new Float32Array( [\r\n\t\t\t- 1, - 1,  0, 0,\r\n\t\t\t 1, - 1,  1, 0,\r\n\t\t\t 1,  1,  1, 1,\r\n\t\t\t- 1,  1,  0, 1\r\n\t\t] );\r\n\r\n\t\tvar faces = new Uint16Array( [\r\n\t\t\t0, 1, 2,\r\n\t\t\t0, 2, 3\r\n\t\t] );\r\n\r\n\t\t// buffers\r\n\r\n\t\tvertexBuffer     = gl.createBuffer();\r\n\t\telementBuffer    = gl.createBuffer();\r\n\r\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\r\n\r\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\r\n\r\n\t\t// textures\r\n\r\n\t\ttempTexture      = gl.createTexture();\r\n\t\tocclusionTexture = gl.createTexture();\r\n\r\n\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\r\n\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\r\n\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\r\n\t\thasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;\r\n\r\n\t\tvar shader;\r\n\r\n\t\tif ( hasVertexTexture ) {\r\n\r\n\t\t\tshader = {\r\n\r\n\t\t\t\tvertexShader: [\r\n\r\n\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\t\t\"uniform vec3 screenPosition;\",\r\n\t\t\t\t\t\"uniform vec2 scale;\",\r\n\t\t\t\t\t\"uniform float rotation;\",\r\n\r\n\t\t\t\t\t\"uniform sampler2D occlusionMap;\",\r\n\r\n\t\t\t\t\t\"attribute vec2 position;\",\r\n\t\t\t\t\t\"attribute vec2 uv;\",\r\n\r\n\t\t\t\t\t\"varying vec2 vUV;\",\r\n\t\t\t\t\t\"varying float vVisibility;\",\r\n\r\n\t\t\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\t\t\"vUV = uv;\",\r\n\r\n\t\t\t\t\t\t\"vec2 pos = position;\",\r\n\r\n\t\t\t\t\t\t\"if ( renderType == 2 ) {\",\r\n\r\n\t\t\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\r\n\r\n\t\t\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\r\n\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\r\n\t\t\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\r\n\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\r\n\r\n\t\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n\t\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\r\n\t\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\r\n\t\t\t\t\t\"}\"\r\n\r\n\t\t\t\t].join( \"\\n\" ),\r\n\r\n\t\t\t\tfragmentShader: [\r\n\r\n\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\t\t\"uniform sampler2D map;\",\r\n\t\t\t\t\t\"uniform float opacity;\",\r\n\t\t\t\t\t\"uniform vec3 color;\",\r\n\r\n\t\t\t\t\t\"varying vec2 vUV;\",\r\n\t\t\t\t\t\"varying float vVisibility;\",\r\n\r\n\t\t\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\t\t// pink square\r\n\r\n\t\t\t\t\t\t\"if ( renderType == 0 ) {\",\r\n\r\n\t\t\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\r\n\r\n\t\t\t\t\t\t// restore\r\n\r\n\t\t\t\t\t\t\"} else if ( renderType == 1 ) {\",\r\n\r\n\t\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\r\n\r\n\t\t\t\t\t\t// flare\r\n\r\n\t\t\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\r\n\t\t\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\r\n\t\t\t\t\t\t\t\"gl_FragColor = texture;\",\r\n\t\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\r\n\r\n\t\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\"}\"\r\n\r\n\t\t\t\t].join( \"\\n\" )\r\n\r\n\t\t\t};\r\n\r\n\t\t} else {\r\n\r\n\t\t\tshader = {\r\n\r\n\t\t\t\tvertexShader: [\r\n\r\n\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\t\t\"uniform vec3 screenPosition;\",\r\n\t\t\t\t\t\"uniform vec2 scale;\",\r\n\t\t\t\t\t\"uniform float rotation;\",\r\n\r\n\t\t\t\t\t\"attribute vec2 position;\",\r\n\t\t\t\t\t\"attribute vec2 uv;\",\r\n\r\n\t\t\t\t\t\"varying vec2 vUV;\",\r\n\r\n\t\t\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\t\t\"vUV = uv;\",\r\n\r\n\t\t\t\t\t\t\"vec2 pos = position;\",\r\n\r\n\t\t\t\t\t\t\"if ( renderType == 2 ) {\",\r\n\r\n\t\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n\t\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\r\n\t\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\r\n\t\t\t\t\t\"}\"\r\n\r\n\t\t\t\t].join( \"\\n\" ),\r\n\r\n\t\t\t\tfragmentShader: [\r\n\r\n\t\t\t\t\t\"precision mediump float;\",\r\n\r\n\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\t\t\"uniform sampler2D map;\",\r\n\t\t\t\t\t\"uniform sampler2D occlusionMap;\",\r\n\t\t\t\t\t\"uniform float opacity;\",\r\n\t\t\t\t\t\"uniform vec3 color;\",\r\n\r\n\t\t\t\t\t\"varying vec2 vUV;\",\r\n\r\n\t\t\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\t\t// pink square\r\n\r\n\t\t\t\t\t\t\"if ( renderType == 0 ) {\",\r\n\r\n\t\t\t\t\t\t\t\"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\",\r\n\r\n\t\t\t\t\t\t// restore\r\n\r\n\t\t\t\t\t\t\"} else if ( renderType == 1 ) {\",\r\n\r\n\t\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\r\n\r\n\t\t\t\t\t\t// flare\r\n\r\n\t\t\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\t\t\"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\",\r\n\t\t\t\t\t\t\t\"visibility = ( 1.0 - visibility / 4.0 );\",\r\n\r\n\t\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\r\n\t\t\t\t\t\t\t\"texture.a *= opacity * visibility;\",\r\n\t\t\t\t\t\t\t\"gl_FragColor = texture;\",\r\n\t\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\r\n\r\n\t\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\"}\"\r\n\r\n\t\t\t\t].join( \"\\n\" )\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tprogram = createProgram( shader );\r\n\r\n\t\tattributes = {\r\n\t\t\tvertex: gl.getAttribLocation ( program, \"position\" ),\r\n\t\t\tuv:     gl.getAttribLocation ( program, \"uv\" )\r\n\t\t};\r\n\r\n\t\tuniforms = {\r\n\t\t\trenderType:     gl.getUniformLocation( program, \"renderType\" ),\r\n\t\t\tmap:            gl.getUniformLocation( program, \"map\" ),\r\n\t\t\tocclusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\r\n\t\t\topacity:        gl.getUniformLocation( program, \"opacity\" ),\r\n\t\t\tcolor:          gl.getUniformLocation( program, \"color\" ),\r\n\t\t\tscale:          gl.getUniformLocation( program, \"scale\" ),\r\n\t\t\trotation:       gl.getUniformLocation( program, \"rotation\" ),\r\n\t\t\tscreenPosition: gl.getUniformLocation( program, \"screenPosition\" )\r\n\t\t};\r\n\r\n\t}\r\n\r\n\t/*\r\n\t * Render lens flares\r\n\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\r\n\t *         reads these back and calculates occlusion.\r\n\t */\r\n\r\n\tthis.render = function ( scene, camera, viewport ) {\r\n\r\n\t\tif ( flares.length === 0 ) return;\r\n\r\n\t\tvar tempPosition = new THREE.Vector3();\r\n\r\n\t\tvar invAspect = viewport.w / viewport.z,\r\n\t\t\thalfViewportWidth = viewport.z * 0.5,\r\n\t\t\thalfViewportHeight = viewport.w * 0.5;\r\n\r\n\t\tvar size = 16 / viewport.w,\r\n\t\t\tscale = new THREE.Vector2( size * invAspect, size );\r\n\r\n\t\tvar screenPosition = new THREE.Vector3( 1, 1, 0 ),\r\n\t\t\tscreenPositionPixels = new THREE.Vector2( 1, 1 );\r\n\r\n\t\tif ( program === undefined ) {\r\n\r\n\t\t\tinit();\r\n\r\n\t\t}\r\n\r\n\t\tgl.useProgram( program );\r\n\r\n\t\tstate.initAttributes();\r\n\t\tstate.enableAttribute( attributes.vertex );\r\n\t\tstate.enableAttribute( attributes.uv );\r\n\t\tstate.disableUnusedAttributes();\r\n\r\n\t\t// loop through all lens flares to update their occlusion and positions\r\n\t\t// setup gl and common used attribs/uniforms\r\n\r\n\t\tgl.uniform1i( uniforms.occlusionMap, 0 );\r\n\t\tgl.uniform1i( uniforms.map, 1 );\r\n\r\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\r\n\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\r\n\r\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\r\n\t\tstate.disable( gl.CULL_FACE );\r\n\t\tstate.setDepthWrite( false );\r\n\r\n\t\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\r\n\r\n\t\t\tsize = 16 / viewport.w;\r\n\t\t\tscale.set( size * invAspect, size );\r\n\r\n\t\t\t// calc object screen position\r\n\r\n\t\t\tvar flare = flares[ i ];\r\n\r\n\t\t\ttempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\r\n\r\n\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\r\n\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\r\n\r\n\t\t\t// setup arrays for gl programs\r\n\r\n\t\t\tscreenPosition.copy( tempPosition );\r\n\r\n\t\t\tscreenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;\r\n\t\t\tscreenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;\r\n\r\n\t\t\t// screen cull\r\n\r\n\t\t\tif ( hasVertexTexture || (\r\n\t\t\t\tscreenPositionPixels.x > 0 &&\r\n\t\t\t\tscreenPositionPixels.x < viewport.z &&\r\n\t\t\t\tscreenPositionPixels.y > 0 &&\r\n\t\t\t\tscreenPositionPixels.y < viewport.w ) ) {\r\n\r\n\t\t\t\t// save current RGB to temp texture\r\n\r\n\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\r\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, null );\r\n\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\r\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, viewport.x + screenPositionPixels.x - 8, viewport.y + screenPositionPixels.y - 8, 16, 16, 0 );\r\n\r\n\r\n\t\t\t\t// render pink quad\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.renderType, 0 );\r\n\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\r\n\t\t\t\tstate.disable( gl.BLEND );\r\n\t\t\t\tstate.enable( gl.DEPTH_TEST );\r\n\r\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n\r\n\t\t\t\t// copy result to occlusionMap\r\n\r\n\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\r\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\r\n\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, viewport.x + screenPositionPixels.x - 8, viewport.y + screenPositionPixels.y - 8, 16, 16, 0 );\r\n\r\n\r\n\t\t\t\t// restore graphics\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.renderType, 1 );\r\n\t\t\t\tstate.disable( gl.DEPTH_TEST );\r\n\r\n\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\r\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n\r\n\t\t\t\t// update object positions\r\n\r\n\t\t\t\tflare.positionScreen.copy( screenPosition );\r\n\r\n\t\t\t\tif ( flare.customUpdateCallback ) {\r\n\r\n\t\t\t\t\tflare.customUpdateCallback( flare );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tflare.updateLensFlares();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// render flares\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.renderType, 2 );\r\n\t\t\t\tstate.enable( gl.BLEND );\r\n\r\n\t\t\t\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tvar sprite = flare.lensFlares[ j ];\r\n\r\n\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\r\n\r\n\t\t\t\t\t\tscreenPosition.x = sprite.x;\r\n\t\t\t\t\t\tscreenPosition.y = sprite.y;\r\n\t\t\t\t\t\tscreenPosition.z = sprite.z;\r\n\r\n\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewport.w;\r\n\r\n\t\t\t\t\t\tscale.x = size * invAspect;\r\n\t\t\t\t\t\tscale.y = size;\r\n\r\n\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n\t\t\t\t\t\tgl.uniform1f( uniforms.rotation, sprite.rotation );\r\n\r\n\t\t\t\t\t\tgl.uniform1f( uniforms.opacity, sprite.opacity );\r\n\t\t\t\t\t\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\r\n\r\n\t\t\t\t\t\tstate.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\r\n\t\t\t\t\t\trenderer.setTexture( sprite.texture, 1 );\r\n\r\n\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore gl\r\n\r\n\t\tstate.enable( gl.CULL_FACE );\r\n\t\tstate.enable( gl.DEPTH_TEST );\r\n\t\tstate.setDepthWrite( true );\r\n\r\n\t\trenderer.resetGLState();\r\n\r\n\t};\r\n\r\n\tfunction createProgram ( shader ) {\r\n\r\n\t\tvar program = gl.createProgram();\r\n\r\n\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\r\n\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\r\n\r\n\t\tvar prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\r\n\r\n\t\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\r\n\t\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\r\n\r\n\t\tgl.compileShader( fragmentShader );\r\n\t\tgl.compileShader( vertexShader );\r\n\r\n\t\tgl.attachShader( program, fragmentShader );\r\n\t\tgl.attachShader( program, vertexShader );\r\n\r\n\t\tgl.linkProgram( program );\r\n\r\n\t\treturn program;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/plugins/SpritePlugin.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SpritePlugin = function ( renderer, sprites ) {\r\n\r\n\tvar gl = renderer.context;\r\n\tvar state = renderer.state;\r\n\r\n\tvar vertexBuffer, elementBuffer;\r\n\tvar program, attributes, uniforms;\r\n\r\n\tvar texture;\r\n\r\n\t// decompose matrixWorld\r\n\r\n\tvar spritePosition = new THREE.Vector3();\r\n\tvar spriteRotation = new THREE.Quaternion();\r\n\tvar spriteScale = new THREE.Vector3();\r\n\r\n\tfunction init() {\r\n\r\n\t\tvar vertices = new Float32Array( [\r\n\t\t\t- 0.5, - 0.5,  0, 0,\r\n\t\t\t  0.5, - 0.5,  1, 0,\r\n\t\t\t  0.5,   0.5,  1, 1,\r\n\t\t\t- 0.5,   0.5,  0, 1\r\n\t\t] );\r\n\r\n\t\tvar faces = new Uint16Array( [\r\n\t\t\t0, 1, 2,\r\n\t\t\t0, 2, 3\r\n\t\t] );\r\n\r\n\t\tvertexBuffer  = gl.createBuffer();\r\n\t\telementBuffer = gl.createBuffer();\r\n\r\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\r\n\r\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\r\n\r\n\t\tprogram = createProgram();\r\n\r\n\t\tattributes = {\r\n\t\t\tposition:\t\t\tgl.getAttribLocation ( program, 'position' ),\r\n\t\t\tuv:\t\t\t\t\tgl.getAttribLocation ( program, 'uv' )\r\n\t\t};\r\n\r\n\t\tuniforms = {\r\n\t\t\tuvOffset:\t\t\tgl.getUniformLocation( program, 'uvOffset' ),\r\n\t\t\tuvScale:\t\t\tgl.getUniformLocation( program, 'uvScale' ),\r\n\r\n\t\t\trotation:\t\t\tgl.getUniformLocation( program, 'rotation' ),\r\n\t\t\tscale:\t\t\t\tgl.getUniformLocation( program, 'scale' ),\r\n\r\n\t\t\tcolor:\t\t\t\tgl.getUniformLocation( program, 'color' ),\r\n\t\t\tmap:\t\t\t\tgl.getUniformLocation( program, 'map' ),\r\n\t\t\topacity:\t\t\tgl.getUniformLocation( program, 'opacity' ),\r\n\r\n\t\t\tmodelViewMatrix: \tgl.getUniformLocation( program, 'modelViewMatrix' ),\r\n\t\t\tprojectionMatrix:\tgl.getUniformLocation( program, 'projectionMatrix' ),\r\n\r\n\t\t\tfogType:\t\t\tgl.getUniformLocation( program, 'fogType' ),\r\n\t\t\tfogDensity:\t\t\tgl.getUniformLocation( program, 'fogDensity' ),\r\n\t\t\tfogNear:\t\t\tgl.getUniformLocation( program, 'fogNear' ),\r\n\t\t\tfogFar:\t\t\t\tgl.getUniformLocation( program, 'fogFar' ),\r\n\t\t\tfogColor:\t\t\tgl.getUniformLocation( program, 'fogColor' ),\r\n\r\n\t\t\talphaTest:\t\t\tgl.getUniformLocation( program, 'alphaTest' )\r\n\t\t};\r\n\r\n\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\tcanvas.width = 8;\r\n\t\tcanvas.height = 8;\r\n\r\n\t\tvar context = canvas.getContext( '2d' );\r\n\t\tcontext.fillStyle = 'white';\r\n\t\tcontext.fillRect( 0, 0, 8, 8 );\r\n\r\n\t\ttexture = new THREE.Texture( canvas );\r\n\t\ttexture.needsUpdate = true;\r\n\r\n\t}\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tif ( sprites.length === 0 ) return;\r\n\r\n\t\t// setup gl\r\n\r\n\t\tif ( program === undefined ) {\r\n\r\n\t\t\tinit();\r\n\r\n\t\t}\r\n\r\n\t\tgl.useProgram( program );\r\n\r\n\t\tstate.initAttributes();\r\n\t\tstate.enableAttribute( attributes.position );\r\n\t\tstate.enableAttribute( attributes.uv );\r\n\t\tstate.disableUnusedAttributes();\r\n\r\n\t\tstate.disable( gl.CULL_FACE );\r\n\t\tstate.enable( gl.BLEND );\r\n\r\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\r\n\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\r\n\r\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\r\n\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\r\n\t\tstate.activeTexture( gl.TEXTURE0 );\r\n\t\tgl.uniform1i( uniforms.map, 0 );\r\n\r\n\t\tvar oldFogType = 0;\r\n\t\tvar sceneFogType = 0;\r\n\t\tvar fog = scene.fog;\r\n\r\n\t\tif ( fog ) {\r\n\r\n\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\r\n\r\n\t\t\tif ( fog instanceof THREE.Fog ) {\r\n\r\n\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\r\n\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\r\n\t\t\t\toldFogType = 1;\r\n\t\t\t\tsceneFogType = 1;\r\n\r\n\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\r\n\r\n\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\r\n\t\t\t\toldFogType = 2;\r\n\t\t\t\tsceneFogType = 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tgl.uniform1i( uniforms.fogType, 0 );\r\n\t\t\toldFogType = 0;\r\n\t\t\tsceneFogType = 0;\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// update positions and sort\r\n\r\n\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar sprite = sprites[ i ];\r\n\r\n\t\t\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\r\n\t\t\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\r\n\r\n\t\t}\r\n\r\n\t\tsprites.sort( painterSortStable );\r\n\r\n\t\t// render all sprites\r\n\r\n\t\tvar scale = [];\r\n\r\n\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar sprite = sprites[ i ];\r\n\t\t\tvar material = sprite.material;\r\n\r\n\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\r\n\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\r\n\r\n\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\r\n\r\n\t\t\tscale[ 0 ] = spriteScale.x;\r\n\t\t\tscale[ 1 ] = spriteScale.y;\r\n\r\n\t\t\tvar fogType = 0;\r\n\r\n\t\t\tif ( scene.fog && material.fog ) {\r\n\r\n\t\t\t\tfogType = sceneFogType;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( oldFogType !== fogType ) {\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\r\n\t\t\t\toldFogType = fogType;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material.map !== null ) {\r\n\r\n\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\r\n\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\r\n\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\r\n\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\r\n\r\n\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\r\n\t\t\tgl.uniform2fv( uniforms.scale, scale );\r\n\r\n\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n\t\t\tstate.setDepthTest( material.depthTest );\r\n\t\t\tstate.setDepthWrite( material.depthWrite );\r\n\r\n\t\t\tif ( material.map && material.map.image && material.map.image.width ) {\r\n\r\n\t\t\t\trenderer.setTexture( material.map, 0 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\trenderer.setTexture( texture, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n\t\t}\r\n\r\n\t\t// restore gl\r\n\r\n\t\tstate.enable( gl.CULL_FACE );\r\n\r\n\t\trenderer.resetGLState();\r\n\r\n\t};\r\n\r\n\tfunction createProgram () {\r\n\r\n\t\tvar program = gl.createProgram();\r\n\r\n\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\r\n\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\r\n\r\n\t\tgl.shaderSource( vertexShader, [\r\n\r\n\t\t\t'precision ' + renderer.getPrecision() + ' float;',\r\n\r\n\t\t\t'uniform mat4 modelViewMatrix;',\r\n\t\t\t'uniform mat4 projectionMatrix;',\r\n\t\t\t'uniform float rotation;',\r\n\t\t\t'uniform vec2 scale;',\r\n\t\t\t'uniform vec2 uvOffset;',\r\n\t\t\t'uniform vec2 uvScale;',\r\n\r\n\t\t\t'attribute vec2 position;',\r\n\t\t\t'attribute vec2 uv;',\r\n\r\n\t\t\t'varying vec2 vUV;',\r\n\r\n\t\t\t'void main() {',\r\n\r\n\t\t\t\t'vUV = uvOffset + uv * uvScale;',\r\n\r\n\t\t\t\t'vec2 alignedPosition = position * scale;',\r\n\r\n\t\t\t\t'vec2 rotatedPosition;',\r\n\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\r\n\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\r\n\r\n\t\t\t\t'vec4 finalPosition;',\r\n\r\n\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\r\n\t\t\t\t'finalPosition.xy += rotatedPosition;',\r\n\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\r\n\r\n\t\t\t\t'gl_Position = finalPosition;',\r\n\r\n\t\t\t'}'\r\n\r\n\t\t].join( '\\n' ) );\r\n\r\n\t\tgl.shaderSource( fragmentShader, [\r\n\r\n\t\t\t'precision ' + renderer.getPrecision() + ' float;',\r\n\r\n\t\t\t'uniform vec3 color;',\r\n\t\t\t'uniform sampler2D map;',\r\n\t\t\t'uniform float opacity;',\r\n\r\n\t\t\t'uniform int fogType;',\r\n\t\t\t'uniform vec3 fogColor;',\r\n\t\t\t'uniform float fogDensity;',\r\n\t\t\t'uniform float fogNear;',\r\n\t\t\t'uniform float fogFar;',\r\n\t\t\t'uniform float alphaTest;',\r\n\r\n\t\t\t'varying vec2 vUV;',\r\n\r\n\t\t\t'void main() {',\r\n\r\n\t\t\t\t'vec4 texture = texture2D( map, vUV );',\r\n\r\n\t\t\t\t'if ( texture.a < alphaTest ) discard;',\r\n\r\n\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\r\n\r\n\t\t\t\t'if ( fogType > 0 ) {',\r\n\r\n\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\r\n\t\t\t\t\t'float fogFactor = 0.0;',\r\n\r\n\t\t\t\t\t'if ( fogType == 1 ) {',\r\n\r\n\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\r\n\r\n\t\t\t\t\t'} else {',\r\n\r\n\t\t\t\t\t\t'const float LOG2 = 1.442695;',\r\n\t\t\t\t\t\t'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\r\n\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\r\n\r\n\t\t\t\t\t'}',\r\n\r\n\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\r\n\r\n\t\t\t\t'}',\r\n\r\n\t\t\t'}'\r\n\r\n\t\t].join( '\\n' ) );\r\n\r\n\t\tgl.compileShader( vertexShader );\r\n\t\tgl.compileShader( fragmentShader );\r\n\r\n\t\tgl.attachShader( program, vertexShader );\r\n\t\tgl.attachShader( program, fragmentShader );\r\n\r\n\t\tgl.linkProgram( program );\r\n\r\n\t\treturn program;\r\n\r\n\t}\r\n\r\n\tfunction painterSortStable ( a, b ) {\r\n\t\t\r\n\t\tif ( a.renderOrder !== b.renderOrder ) {\r\n\r\n\t\t\treturn a.renderOrder - b.renderOrder;\r\n\r\n\t\t} else if ( a.z !== b.z ) {\r\n\r\n\t\t\treturn b.z - a.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn b.id - a.id;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/Three.Legacy.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nObject.defineProperties( THREE.Box2.prototype, {\r\n\tempty: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\r\n\t\t\treturn this.isEmpty();\r\n\t\t}\r\n\t},\r\n\tisIntersectionBox: {\r\n\t\tvalue: function ( box ) {\r\n\t\t\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\r\n\t\t\treturn this.intersectsBox( box );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE.Box3.prototype, {\r\n\tempty: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\r\n\t\t\treturn this.isEmpty();\r\n\t\t}\r\n\t},\r\n\tisIntersectionBox: {\r\n\t\tvalue: function ( box ) {\r\n\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\r\n\t\t\treturn this.intersectsBox( box );\r\n\t\t}\r\n\t},\r\n\tisIntersectionSphere: {\r\n\t\tvalue: function ( sphere ) {\r\n\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\r\n\t\t\treturn this.intersectsSphere( sphere );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE.Matrix3.prototype, {\r\n\tmultiplyVector3: {\r\n\t\tvalue: function ( vector ) {\r\n\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\r\n\t\t\treturn vector.applyMatrix3( this );\r\n\t\t}\r\n\t},\r\n\tmultiplyVector3Array: {\r\n\t\tvalue: function ( a ) {\r\n\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\r\n\t\t\treturn this.applyToVector3Array( a );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE.Matrix4.prototype, {\r\n\textractPosition: {\r\n\t\tvalue: function ( m ) {\r\n\t\t\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\r\n\t\t\treturn this.copyPosition( m );\r\n\t\t}\r\n\t},\r\n\tsetRotationFromQuaternion: {\r\n\t\tvalue: function ( q ) {\r\n\t\t\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\r\n\t\t\treturn this.makeRotationFromQuaternion( q );\r\n\t\t}\r\n\t},\r\n\tmultiplyVector3: {\r\n\t\tvalue: function ( vector ) {\r\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\r\n\t\t\treturn vector.applyProjection( this );\r\n\t\t}\r\n\t},\r\n\tmultiplyVector4: {\r\n\t\tvalue: function ( vector ) {\r\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n\t\t\treturn vector.applyMatrix4( this );\r\n\t\t}\r\n\t},\r\n\tmultiplyVector3Array: {\r\n\t\tvalue: function ( a ) {\r\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\r\n\t\t\treturn this.applyToVector3Array( a );\r\n\t\t}\r\n\t},\r\n\trotateAxis: {\r\n\t\tvalue: function ( v ) {\r\n\t\t\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\r\n\t\t\tv.transformDirection( this );\r\n\t\t}\r\n\t},\r\n\tcrossVector: {\r\n\t\tvalue: function ( vector ) {\r\n\t\t\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n\t\t\treturn vector.applyMatrix4( this );\r\n\t\t}\r\n\t},\r\n\ttranslate: {\r\n\t\tvalue: function ( v ) {\r\n\t\t\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\r\n\t\t}\r\n\t},\r\n\trotateX: {\r\n\t\tvalue: function ( angle ) {\r\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\r\n\t\t}\r\n\t},\r\n\trotateY: {\r\n\t\tvalue: function ( angle ) {\r\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\r\n\t\t}\r\n\t},\r\n\trotateZ: {\r\n\t\tvalue: function ( angle ) {\r\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\r\n\t\t}\r\n\t},\r\n\trotateByAxis: {\r\n\t\tvalue: function ( axis, angle ) {\r\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE.Plane.prototype, {\r\n\tisIntersectionLine: {\r\n\t\tvalue: function ( line ) {\r\n\t\t\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\r\n\t\t\treturn this.intersectsLine( line );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE.Quaternion.prototype, {\r\n\tmultiplyVector3: {\r\n\t\tvalue: function ( vector ) {\r\n\t\t\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\r\n\t\t\treturn vector.applyQuaternion( this );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE.Ray.prototype, {\r\n\tisIntersectionBox: {\r\n\t\tvalue: function ( box ) {\r\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\r\n\t\t\treturn this.intersectsBox( box );\r\n\t\t}\r\n\t},\r\n\tisIntersectionPlane: {\r\n\t\tvalue: function ( plane ) {\r\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\r\n\t\t\treturn this.intersectsPlane( plane );\r\n\t\t}\r\n\t},\r\n\tisIntersectionSphere: {\r\n\t\tvalue: function ( sphere ) {\r\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\r\n\t\t\treturn this.intersectsSphere( sphere );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE.Vector3.prototype, {\r\n\tsetEulerFromRotationMatrix: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\r\n\t\t}\r\n\t},\r\n\tsetEulerFromQuaternion: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\r\n\t\t}\r\n\t},\r\n\tgetPositionFromMatrix: {\r\n\t\tvalue: function ( m ) {\r\n\t\t\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\r\n\t\t\treturn this.setFromMatrixPosition( m );\r\n\t\t}\r\n\t},\r\n\tgetScaleFromMatrix: {\r\n\t\tvalue: function ( m ) {\r\n\t\t\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\r\n\t\t\treturn this.setFromMatrixScale( m );\r\n\t\t}\r\n\t},\r\n\tgetColumnFromMatrix: {\r\n\t\tvalue: function ( index, matrix ) {\r\n\t\t\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\r\n\t\t\treturn this.setFromMatrixColumn( index, matrix );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n//\r\n\r\nTHREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {\r\n\r\n\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\r\n\treturn new THREE.Face3( a, b, c, normal, color, materialIndex );\r\n\r\n};\r\n\r\nTHREE.Vertex = function ( x, y, z ) {\r\n\r\n\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\r\n\treturn new THREE.Vector3( x, y, z );\r\n\r\n};\r\n\r\n//\r\n\r\nObject.defineProperties( THREE.Object3D.prototype, {\r\n\teulerOrder: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\r\n\t\t\treturn this.rotation.order;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\r\n\t\t\tthis.rotation.order = value;\r\n\t\t}\r\n\t},\r\n\tgetChildByName: {\r\n\t\tvalue: function ( name ) {\r\n\t\t\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\r\n\t\t\treturn this.getObjectByName( name );\r\n\t\t}\r\n\t},\r\n\trenderDepth: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\r\n\t\t}\r\n\t},\r\n\ttranslate: {\r\n\t\tvalue: function ( distance, axis ) {\r\n\t\t\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\r\n\t\t\treturn this.translateOnAxis( axis, distance );\r\n\t\t}\r\n\t},\r\n\tuseQuaternion: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n//\r\n\r\nObject.defineProperties( THREE, {\r\n\tPointCloud: {\r\n\t\tvalue: function ( geometry, material ) {\r\n\t\t\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\r\n\t\t\treturn new THREE.Points( geometry, material );\r\n\t\t}\r\n\t},\r\n\tParticleSystem: {\r\n\t\tvalue: function ( geometry, material ) {\r\n\t\t\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\r\n\t\t\treturn new THREE.Points( geometry, material );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n//\r\n\r\nObject.defineProperties( THREE.Light.prototype, {\r\n\tonlyShadow: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\r\n\t\t}\r\n\t},\r\n\tshadowCameraFov: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\r\n\t\t\tthis.shadow.camera.fov = value;\r\n\t\t}\r\n\t},\r\n\tshadowCameraLeft: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\r\n\t\t\tthis.shadow.camera.left = value;\r\n\t\t}\r\n\t},\r\n\tshadowCameraRight: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\r\n\t\t\tthis.shadow.camera.right = value;\r\n\t\t}\r\n\t},\r\n\tshadowCameraTop: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\r\n\t\t\tthis.shadow.camera.top = value;\r\n\t\t}\r\n\t},\r\n\tshadowCameraBottom: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\r\n\t\t\tthis.shadow.camera.bottom = value;\r\n\t\t}\r\n\t},\r\n\tshadowCameraNear: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\r\n\t\t\tthis.shadow.camera.near = value;\r\n\t\t}\r\n\t},\r\n\tshadowCameraFar: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\r\n\t\t\tthis.shadow.camera.far = value;\r\n\t\t}\r\n\t},\r\n\tshadowCameraVisible: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\r\n\t\t}\r\n\t},\r\n\tshadowBias: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\r\n\t\t\tthis.shadow.bias = value;\r\n\t\t}\r\n\t},\r\n\tshadowDarkness: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\r\n\t\t}\r\n\t},\r\n\tshadowMapWidth: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\r\n\t\t\tthis.shadow.mapSize.width = value;\r\n\t\t}\r\n\t},\r\n\tshadowMapHeight: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\r\n\t\t\tthis.shadow.mapSize.height = value;\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n//\r\n\r\nObject.defineProperties( THREE.BufferAttribute.prototype, {\r\n\tlength: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\r\n\t\t\treturn this.array.length;\r\n\t\t}\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE.BufferGeometry.prototype, {\r\n\tdrawcalls: {\r\n\t\tget: function () {\r\n\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\r\n\t\t\treturn this.groups;\r\n\t\t}\r\n\t},\r\n\toffsets: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\r\n\t\t\treturn this.groups;\r\n\t\t}\r\n\t},\r\n\taddIndex: {\r\n\t\tvalue: function ( index ) {\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\r\n\t\t\tthis.setIndex( index );\r\n\t\t}\r\n\t},\r\n\taddDrawCall: {\r\n\t\tvalue: function ( start, count, indexOffset ) {\r\n\t\t\tif ( indexOffset !== undefined ) {\r\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\r\n\t\t\t}\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\r\n\t\t\tthis.addGroup( start, count );\r\n\t\t}\r\n\t},\r\n\tclearDrawCalls: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\r\n\t\t\tthis.clearGroups();\r\n\t\t}\r\n\t},\r\n\tcomputeTangents: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\r\n\t\t}\r\n\t},\r\n\tcomputeOffsets: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n//\r\n\r\nObject.defineProperties( THREE.Material.prototype, {\r\n\twrapAround: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\r\n\t\t}\r\n\t},\r\n\twrapRGB: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );\r\n\t\t\treturn new THREE.Color();\r\n\t\t}\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE, {\r\n\tPointCloudMaterial: {\r\n\t\tvalue: function ( parameters ) {\r\n\t\t\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\r\n\t\t\treturn new THREE.PointsMaterial( parameters );\r\n\t\t}\r\n\t},\r\n\tParticleBasicMaterial: {\r\n\t\tvalue: function ( parameters ) {\r\n\t\t\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\r\n\t\t\treturn new THREE.PointsMaterial( parameters );\r\n\t\t}\r\n\t},\r\n\tParticleSystemMaterial:{\r\n\t\tvalue: function ( parameters ) {\r\n\t\t\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\r\n\t\t\treturn new THREE.PointsMaterial( parameters );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE.MeshPhongMaterial.prototype, {\r\n\tmetal: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\r\n\t\t\treturn false;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE.ShaderMaterial.prototype, {\r\n\tderivatives: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\r\n\t\t\treturn this.extensions.derivatives;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\r\n\t\t\tthis.extensions.derivatives = value;\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n//\r\n\r\nObject.defineProperties( THREE.WebGLRenderer.prototype, {\r\n\tsupportsFloatTextures: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\r\n\t\t\treturn this.extensions.get( 'OES_texture_float' );\r\n\t\t}\r\n\t},\r\n\tsupportsHalfFloatTextures: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\r\n\t\t\treturn this.extensions.get( 'OES_texture_half_float' );\r\n\t\t}\r\n\t},\r\n\tsupportsStandardDerivatives: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\r\n\t\t\treturn this.extensions.get( 'OES_standard_derivatives' );\r\n\t\t}\r\n\t},\r\n\tsupportsCompressedTextureS3TC: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\r\n\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\r\n\t\t}\r\n\t},\r\n\tsupportsCompressedTexturePVRTC: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\r\n\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\r\n\t\t}\r\n\t},\r\n\tsupportsBlendMinMax: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\r\n\t\t\treturn this.extensions.get( 'EXT_blend_minmax' );\r\n\t\t}\r\n\t},\r\n\tsupportsVertexTextures: {\r\n\t\tvalue: function () {\r\n\t\t\treturn this.capabilities.vertexTextures;\r\n\t\t}\r\n\t},\r\n\tsupportsInstancedArrays: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\r\n\t\t\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\r\n\t\t}\r\n\t},\r\n\tenableScissorTest: {\r\n\t\tvalue: function ( boolean ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\r\n\t\t\tthis.setScissorTest( boolean );\r\n\t\t}\r\n\t},\r\n\tinitMaterial: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\r\n\t\t}\r\n\t},\r\n\taddPrePlugin: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\r\n\t\t}\r\n\t},\r\n\taddPostPlugin: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\r\n\t\t}\r\n\t},\r\n\tupdateShadowMap: {\r\n\t\tvalue: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\r\n\t\t}\r\n\t},\r\n\tshadowMapEnabled: {\r\n\t\tget: function () {\r\n\t\t\treturn this.shadowMap.enabled;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\r\n\t\t\tthis.shadowMap.enabled = value;\r\n\t\t}\r\n\t},\r\n\tshadowMapType: {\r\n\t\tget: function () {\r\n\t\t\treturn this.shadowMap.type;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\r\n\t\t\tthis.shadowMap.type = value;\r\n\t\t}\r\n\t},\r\n\tshadowMapCullFace: {\r\n\t\tget: function () {\r\n\t\t\treturn this.shadowMap.cullFace;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\r\n\t\t\tthis.shadowMap.cullFace = value;\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n//\r\n\r\nObject.defineProperties( THREE.WebGLRenderTarget.prototype, {\r\n\twrapS: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\r\n\t\t\treturn this.texture.wrapS;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\r\n\t\t\tthis.texture.wrapS = value;\r\n\t\t}\r\n\t},\r\n\twrapT: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\r\n\t\t\treturn this.texture.wrapT;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\r\n\t\t\tthis.texture.wrapT = value;\r\n\t\t}\r\n\t},\r\n\tmagFilter: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\r\n\t\t\treturn this.texture.magFilter;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\r\n\t\t\tthis.texture.magFilter = value;\r\n\t\t}\r\n\t},\r\n\tminFilter: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\r\n\t\t\treturn this.texture.minFilter;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\r\n\t\t\tthis.texture.minFilter = value;\r\n\t\t}\r\n\t},\r\n\tanisotropy: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\r\n\t\t\treturn this.texture.anisotropy;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\r\n\t\t\tthis.texture.anisotropy = value;\r\n\t\t}\r\n\t},\r\n\toffset: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\r\n\t\t\treturn this.texture.offset;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\r\n\t\t\tthis.texture.offset = value;\r\n\t\t}\r\n\t},\r\n\trepeat: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\r\n\t\t\treturn this.texture.repeat;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\r\n\t\t\tthis.texture.repeat = value;\r\n\t\t}\r\n\t},\r\n\tformat: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\r\n\t\t\treturn this.texture.format;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\r\n\t\t\tthis.texture.format = value;\r\n\t\t}\r\n\t},\r\n\ttype: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\r\n\t\t\treturn this.texture.type;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\r\n\t\t\tthis.texture.type = value;\r\n\t\t}\r\n\t},\r\n\tgenerateMipmaps: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\r\n\t\t\treturn this.texture.generateMipmaps;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\r\n\t\t\tthis.texture.generateMipmaps = value;\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n//\r\n\r\nTHREE.GeometryUtils = {\r\n\r\n\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\r\n\r\n\t\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\r\n\r\n\t\tvar matrix;\r\n\r\n\t\tif ( geometry2 instanceof THREE.Mesh ) {\r\n\r\n\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\r\n\r\n\t\t\tmatrix = geometry2.matrix;\r\n\t\t\tgeometry2 = geometry2.geometry;\r\n\r\n\t\t}\r\n\r\n\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\r\n\r\n\t},\r\n\r\n\tcenter: function ( geometry ) {\r\n\r\n\t\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\r\n\t\treturn geometry.center();\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ImageUtils = {\r\n\r\n\tcrossOrigin: undefined,\r\n\r\n\tloadTexture: function ( url, mapping, onLoad, onError ) {\r\n\r\n\t\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\r\n\r\n\t\tvar loader = new THREE.TextureLoader();\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\r\n\t\tvar texture = loader.load( url, onLoad, undefined, onError );\r\n\r\n\t\tif ( mapping ) texture.mapping = mapping;\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\r\n\r\n\t\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\r\n\r\n\t\tvar loader = new THREE.CubeTextureLoader();\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\r\n\t\tvar texture = loader.load( urls, onLoad, undefined, onError );\r\n\r\n\t\tif ( mapping ) texture.mapping = mapping;\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tloadCompressedTexture: function () {\r\n\r\n\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\r\n\r\n\t},\r\n\r\n\tloadCompressedTextureCube: function () {\r\n\r\n\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\r\n\r\n\t}\r\n\r\n};\r\n\r\n//\r\n\r\nTHREE.Projector = function () {\r\n\r\n\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\r\n\r\n\tthis.projectVector = function ( vector, camera ) {\r\n\r\n\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\r\n\t\tvector.project( camera );\r\n\r\n\t};\r\n\r\n\tthis.unprojectVector = function ( vector, camera ) {\r\n\r\n\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\r\n\t\tvector.unproject( camera );\r\n\r\n\t};\r\n\r\n\tthis.pickingRay = function ( vector, camera ) {\r\n\r\n\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\r\n\r\n\t};\r\n\r\n};\r\n\r\n//\r\n\r\nTHREE.CanvasRenderer = function () {\r\n\r\n\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\r\n\r\n\tthis.domElement = document.createElement( 'canvas' );\r\n\tthis.clear = function () {};\r\n\tthis.render = function () {};\r\n\tthis.setClearColor = function () {};\r\n\tthis.setSize = function () {};\r\n\r\n};\r\n\r\n//\r\n\r\nTHREE.MeshFaceMaterial = THREE.MultiMaterial;\r\n\r\n// File:src/extras/CurveUtils.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.CurveUtils = {\r\n\r\n\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\r\n\r\n\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\r\n\r\n\t},\r\n\r\n\t// Puay Bing, thanks for helping with this derivative!\r\n\r\n\ttangentCubicBezier: function ( t, p0, p1, p2, p3 ) {\r\n\r\n\t\treturn - 3 * p0 * ( 1 - t ) * ( 1 - t )  +\r\n\t\t\t3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +\r\n\t\t\t6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +\r\n\t\t\t3 * t * t * p3;\r\n\r\n\t},\r\n\r\n\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\r\n\r\n\t\t// To check if my formulas are correct\r\n\r\n\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3  3t^2 + 1\r\n\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t\r\n\t\tvar h01 = - 6 * t * t + 6 * t; \t//  2t3 + 3t2\r\n\t\tvar h11 = 3 * t * t - 2 * t;\t// t3  t2\r\n\r\n\t\treturn h00 + h10 + h01 + h11;\r\n\r\n\t},\r\n\r\n\t// Catmull-Rom\r\n\r\n\tinterpolate: function( p0, p1, p2, p3, t ) {\r\n\r\n\t\tvar v0 = ( p2 - p0 ) * 0.5;\r\n\t\tvar v1 = ( p3 - p1 ) * 0.5;\r\n\t\tvar t2 = t * t;\r\n\t\tvar t3 = t * t2;\r\n\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/SceneUtils.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SceneUtils = {\r\n\r\n\tcreateMultiMaterialObject: function ( geometry, materials ) {\r\n\r\n\t\tvar group = new THREE.Group();\r\n\r\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\r\n\r\n\t\t\tgroup.add( new THREE.Mesh( geometry, materials[ i ] ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn group;\r\n\r\n\t},\r\n\r\n\tdetach: function ( child, parent, scene ) {\r\n\r\n\t\tchild.applyMatrix( parent.matrixWorld );\r\n\t\tparent.remove( child );\r\n\t\tscene.add( child );\r\n\r\n\t},\r\n\r\n\tattach: function ( child, scene, parent ) {\r\n\r\n\t\tvar matrixWorldInverse = new THREE.Matrix4();\r\n\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\r\n\t\tchild.applyMatrix( matrixWorldInverse );\r\n\r\n\t\tscene.remove( child );\r\n\t\tparent.add( child );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/ShapeUtils.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.ShapeUtils = {\r\n\r\n\t// calculate area of the contour polygon\r\n\r\n\tarea: function ( contour ) {\r\n\r\n\t\tvar n = contour.length;\r\n\t\tvar a = 0.0;\r\n\r\n\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\r\n\r\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\r\n\r\n\t\t}\r\n\r\n\t\treturn a * 0.5;\r\n\r\n\t},\r\n\r\n\ttriangulate: ( function () {\r\n\r\n\t\t/**\r\n\t\t * This code is a quick port of code written in C++ which was submitted to\r\n\t\t * flipcode.com by John W. Ratcliff  // July 22, 2000\r\n\t\t * See original code and more information here:\r\n\t\t * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\r\n\t\t *\r\n\t\t * ported to actionscript by Zevan Rosser\r\n\t\t * www.actionsnippet.com\r\n\t\t *\r\n\t\t * ported to javascript by Joshua Koo\r\n\t\t * http://www.lab4games.net/zz85/blog\r\n\t\t *\r\n\t\t */\r\n\r\n\t\tfunction snip( contour, u, v, w, n, verts ) {\r\n\r\n\t\t\tvar p;\r\n\t\t\tvar ax, ay, bx, by;\r\n\t\t\tvar cx, cy, px, py;\r\n\r\n\t\t\tax = contour[ verts[ u ] ].x;\r\n\t\t\tay = contour[ verts[ u ] ].y;\r\n\r\n\t\t\tbx = contour[ verts[ v ] ].x;\r\n\t\t\tby = contour[ verts[ v ] ].y;\r\n\r\n\t\t\tcx = contour[ verts[ w ] ].x;\r\n\t\t\tcy = contour[ verts[ w ] ].y;\r\n\r\n\t\t\tif ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;\r\n\r\n\t\t\tvar aX, aY, bX, bY, cX, cY;\r\n\t\t\tvar apx, apy, bpx, bpy, cpx, cpy;\r\n\t\t\tvar cCROSSap, bCROSScp, aCROSSbp;\r\n\r\n\t\t\taX = cx - bx;  aY = cy - by;\r\n\t\t\tbX = ax - cx;  bY = ay - cy;\r\n\t\t\tcX = bx - ax;  cY = by - ay;\r\n\r\n\t\t\tfor ( p = 0; p < n; p ++ ) {\r\n\r\n\t\t\t\tpx = contour[ verts[ p ] ].x;\r\n\t\t\t\tpy = contour[ verts[ p ] ].y;\r\n\r\n\t\t\t\tif ( ( ( px === ax ) && ( py === ay ) ) ||\r\n\t\t\t\t\t ( ( px === bx ) && ( py === by ) ) ||\r\n\t\t\t\t\t ( ( px === cx ) && ( py === cy ) ) )\tcontinue;\r\n\r\n\t\t\t\tapx = px - ax;  apy = py - ay;\r\n\t\t\t\tbpx = px - bx;  bpy = py - by;\r\n\t\t\t\tcpx = px - cx;  cpy = py - cy;\r\n\r\n\t\t\t\t// see if p is inside triangle abc\r\n\r\n\t\t\t\taCROSSbp = aX * bpy - aY * bpx;\r\n\t\t\t\tcCROSSap = cX * apy - cY * apx;\r\n\t\t\t\tbCROSScp = bX * cpy - bY * cpx;\r\n\r\n\t\t\t\tif ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\t// takes in an contour array and returns\r\n\r\n\t\treturn function ( contour, indices ) {\r\n\r\n\t\t\tvar n = contour.length;\r\n\r\n\t\t\tif ( n < 3 ) return null;\r\n\r\n\t\t\tvar result = [],\r\n\t\t\t\tverts = [],\r\n\t\t\t\tvertIndices = [];\r\n\r\n\t\t\t/* we want a counter-clockwise polygon in verts */\r\n\r\n\t\t\tvar u, v, w;\r\n\r\n\t\t\tif ( THREE.ShapeUtils.area( contour ) > 0.0 ) {\r\n\r\n\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = v;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar nv = n;\r\n\r\n\t\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\r\n\r\n\t\t\tvar count = 2 * nv;   /* error detection */\r\n\r\n\t\t\tfor ( v = nv - 1; nv > 2; ) {\r\n\r\n\t\t\t\t/* if we loop, it is probably a non-simple polygon */\r\n\r\n\t\t\t\tif ( ( count -- ) <= 0 ) {\r\n\r\n\t\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\r\n\r\n\t\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\r\n\t\t\t\t\t//return null;\r\n\t\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\r\n\t\t\t\t\tconsole.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );\r\n\r\n\t\t\t\t\tif ( indices ) return vertIndices;\r\n\t\t\t\t\treturn result;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\r\n\r\n\t\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\r\n\t\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\r\n\t\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\r\n\r\n\t\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\r\n\r\n\t\t\t\t\tvar a, b, c, s, t;\r\n\r\n\t\t\t\t\t/* true names of the vertices */\r\n\r\n\t\t\t\t\ta = verts[ u ];\r\n\t\t\t\t\tb = verts[ v ];\r\n\t\t\t\t\tc = verts[ w ];\r\n\r\n\t\t\t\t\t/* output Triangle */\r\n\r\n\t\t\t\t\tresult.push( [ contour[ a ],\r\n\t\t\t\t\t\tcontour[ b ],\r\n\t\t\t\t\t\tcontour[ c ] ] );\r\n\r\n\r\n\t\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\r\n\r\n\t\t\t\t\t/* remove v from the remaining polygon */\r\n\r\n\t\t\t\t\tfor ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\r\n\r\n\t\t\t\t\t\tverts[ s ] = verts[ t ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tnv --;\r\n\r\n\t\t\t\t\t/* reset error detection counter */\r\n\r\n\t\t\t\t\tcount = 2 * nv;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( indices ) return vertIndices;\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t} )(),\r\n\r\n\ttriangulateShape: function ( contour, holes ) {\r\n\r\n\t\tfunction point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\r\n\r\n\t\t\t// inOtherPt needs to be collinear to the inSegment\r\n\t\t\tif ( inSegPt1.x !== inSegPt2.x ) {\r\n\r\n\t\t\t\tif ( inSegPt1.x < inSegPt2.x ) {\r\n\r\n\t\t\t\t\treturn\t( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\treturn\t( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( inSegPt1.y < inSegPt2.y ) {\r\n\r\n\t\t\t\t\treturn\t( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\treturn\t( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\r\n\r\n\t\t\tvar seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\r\n\t\t\tvar seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\r\n\r\n\t\t\tvar seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\r\n\t\t\tvar seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\r\n\r\n\t\t\tvar limit\t\t= seg1dy * seg2dx - seg1dx * seg2dy;\r\n\t\t\tvar perpSeg1\t= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\r\n\r\n\t\t\tif ( Math.abs( limit ) > Number.EPSILON ) {\r\n\r\n\t\t\t\t// not parallel\r\n\r\n\t\t\t\tvar perpSeg2;\r\n\t\t\t\tif ( limit > 0 ) {\r\n\r\n\t\t\t\t\tif ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) \t\treturn [];\r\n\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n\t\t\t\t\tif ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) \t\treturn [];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) \t\treturn [];\r\n\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n\t\t\t\t\tif ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) \t\treturn [];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// i.e. to reduce rounding errors\r\n\t\t\t\t// intersection at endpoint of segment#1?\r\n\t\t\t\tif ( perpSeg2 === 0 ) {\r\n\r\n\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\r\n\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\r\n\t\t\t\t\treturn [ inSeg1Pt1 ];\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif ( perpSeg2 === limit ) {\r\n\r\n\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\r\n\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\r\n\t\t\t\t\treturn [ inSeg1Pt2 ];\r\n\r\n\t\t\t\t}\r\n\t\t\t\t// intersection at endpoint of segment#2?\r\n\t\t\t\tif ( perpSeg1 === 0 )\t\treturn [ inSeg2Pt1 ];\r\n\t\t\t\tif ( perpSeg1 === limit )\treturn [ inSeg2Pt2 ];\r\n\r\n\t\t\t\t// return real intersection point\r\n\t\t\t\tvar factorSeg1 = perpSeg2 / limit;\r\n\t\t\t\treturn\t[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\r\n\t\t\t\t\t\t\ty: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// parallel or collinear\r\n\t\t\t\tif ( ( perpSeg1 !== 0 ) ||\r\n\t\t\t\t\t ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) \t\t\treturn [];\r\n\r\n\t\t\t\t// they are collinear or degenerate\r\n\t\t\t\tvar seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );\t// segment1 is just a point?\r\n\t\t\t\tvar seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );\t// segment2 is just a point?\r\n\t\t\t\t// both segments are points\r\n\t\t\t\tif ( seg1Pt && seg2Pt ) {\r\n\r\n\t\t\t\t\tif ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||\r\n\t\t\t\t\t\t ( inSeg1Pt1.y !== inSeg2Pt1.y ) )\t\treturn [];\t// they are distinct  points\r\n\t\t\t\t\treturn [ inSeg1Pt1 ];                 \t\t\t\t\t\t// they are the same point\r\n\r\n\t\t\t\t}\r\n\t\t\t\t// segment#1  is a single point\r\n\t\t\t\tif ( seg1Pt ) {\r\n\r\n\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )\t\treturn [];\t\t// but not in segment#2\r\n\t\t\t\t\treturn [ inSeg1Pt1 ];\r\n\r\n\t\t\t\t}\r\n\t\t\t\t// segment#2  is a single point\r\n\t\t\t\tif ( seg2Pt ) {\r\n\r\n\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )\t\treturn [];\t\t// but not in segment#1\r\n\t\t\t\t\treturn [ inSeg2Pt1 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// they are collinear segments, which might overlap\r\n\t\t\t\tvar seg1min, seg1max, seg1minVal, seg1maxVal;\r\n\t\t\t\tvar seg2min, seg2max, seg2minVal, seg2maxVal;\r\n\t\t\t\tif ( seg1dx !== 0 ) {\r\n\r\n\t\t\t\t\t// the segments are NOT on a vertical line\r\n\t\t\t\t\tif ( inSeg1Pt1.x < inSeg1Pt2.x ) {\r\n\r\n\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\r\n\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\r\n\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( inSeg2Pt1.x < inSeg2Pt2.x ) {\r\n\r\n\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\r\n\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\r\n\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// the segments are on a vertical line\r\n\t\t\t\t\tif ( inSeg1Pt1.y < inSeg1Pt2.y ) {\r\n\r\n\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\r\n\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\r\n\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( inSeg2Pt1.y < inSeg2Pt2.y ) {\r\n\r\n\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\r\n\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\r\n\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif ( seg1minVal <= seg2minVal ) {\r\n\r\n\t\t\t\t\tif ( seg1maxVal <  seg2minVal )\treturn [];\r\n\t\t\t\t\tif ( seg1maxVal === seg2minVal )\t{\r\n\r\n\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\r\n\t\t\t\t\t\treturn [ seg2min ];\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg2min, seg1max ];\r\n\t\t\t\t\treturn\t[ seg2min, seg2max ];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( seg1minVal >  seg2maxVal )\treturn [];\r\n\t\t\t\t\tif ( seg1minVal === seg2maxVal )\t{\r\n\r\n\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\r\n\t\t\t\t\t\treturn [ seg1min ];\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg1min, seg1max ];\r\n\t\t\t\t\treturn\t[ seg1min, seg2max ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\r\n\r\n\t\t\t// The order of legs is important\r\n\r\n\t\t\t// translation of all points, so that Vertex is at (0,0)\r\n\t\t\tvar legFromPtX\t= inLegFromPt.x - inVertex.x,  legFromPtY\t= inLegFromPt.y - inVertex.y;\r\n\t\t\tvar legToPtX\t= inLegToPt.x\t- inVertex.x,  legToPtY\t\t= inLegToPt.y\t- inVertex.y;\r\n\t\t\tvar otherPtX\t= inOtherPt.x\t- inVertex.x,  otherPtY\t\t= inOtherPt.y\t- inVertex.y;\r\n\r\n\t\t\t// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\r\n\t\t\tvar from2toAngle\t= legFromPtX * legToPtY - legFromPtY * legToPtX;\r\n\t\t\tvar from2otherAngle\t= legFromPtX * otherPtY - legFromPtY * otherPtX;\r\n\r\n\t\t\tif ( Math.abs( from2toAngle ) > Number.EPSILON ) {\r\n\r\n\t\t\t\t// angle != 180 deg.\r\n\r\n\t\t\t\tvar other2toAngle\t\t= otherPtX * legToPtY - otherPtY * legToPtX;\r\n\t\t\t\t// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\r\n\r\n\t\t\t\tif ( from2toAngle > 0 ) {\r\n\r\n\t\t\t\t\t// main angle < 180 deg.\r\n\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// main angle > 180 deg.\r\n\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// angle == 180 deg.\r\n\t\t\t\t// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\r\n\t\t\t\treturn\t( from2otherAngle > 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\tfunction removeHoles( contour, holes ) {\r\n\r\n\t\t\tvar shape = contour.concat(); // work on this shape\r\n\t\t\tvar hole;\r\n\r\n\t\t\tfunction isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\r\n\r\n\t\t\t\t// Check if hole point lies within angle around shape point\r\n\t\t\t\tvar lastShapeIdx = shape.length - 1;\r\n\r\n\t\t\t\tvar prevShapeIdx = inShapeIdx - 1;\r\n\t\t\t\tif ( prevShapeIdx < 0 )\t\t\tprevShapeIdx = lastShapeIdx;\r\n\r\n\t\t\t\tvar nextShapeIdx = inShapeIdx + 1;\r\n\t\t\t\tif ( nextShapeIdx > lastShapeIdx )\tnextShapeIdx = 0;\r\n\r\n\t\t\t\tvar insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );\r\n\t\t\t\tif ( ! insideAngle ) {\r\n\r\n\t\t\t\t\t// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\r\n\t\t\t\t\treturn\tfalse;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Check if shape point lies within angle around hole point\r\n\t\t\t\tvar lastHoleIdx = hole.length - 1;\r\n\r\n\t\t\t\tvar prevHoleIdx = inHoleIdx - 1;\r\n\t\t\t\tif ( prevHoleIdx < 0 )\t\t\tprevHoleIdx = lastHoleIdx;\r\n\r\n\t\t\t\tvar nextHoleIdx = inHoleIdx + 1;\r\n\t\t\t\tif ( nextHoleIdx > lastHoleIdx )\tnextHoleIdx = 0;\r\n\r\n\t\t\t\tinsideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );\r\n\t\t\t\tif ( ! insideAngle ) {\r\n\r\n\t\t\t\t\t// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\r\n\t\t\t\t\treturn\tfalse;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn\ttrue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction intersectsShapeEdge( inShapePt, inHolePt ) {\r\n\r\n\t\t\t\t// checks for intersections with shape edges\r\n\t\t\t\tvar sIdx, nextIdx, intersection;\r\n\t\t\t\tfor ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\r\n\r\n\t\t\t\t\tnextIdx = sIdx + 1; nextIdx %= shape.length;\r\n\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );\r\n\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn\tfalse;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar indepHoles = [];\r\n\r\n\t\t\tfunction intersectsHoleEdge( inShapePt, inHolePt ) {\r\n\r\n\t\t\t\t// checks for intersections with hole edges\r\n\t\t\t\tvar ihIdx, chkHole,\r\n\t\t\t\t\thIdx, nextIdx, intersection;\r\n\t\t\t\tfor ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\r\n\r\n\t\t\t\t\tchkHole = holes[ indepHoles[ ihIdx ]];\r\n\t\t\t\t\tfor ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\r\n\r\n\t\t\t\t\t\tnextIdx = hIdx + 1; nextIdx %= chkHole.length;\r\n\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );\r\n\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t\treturn\tfalse;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar holeIndex, shapeIndex,\r\n\t\t\t\tshapePt, holePt,\r\n\t\t\t\tholeIdx, cutKey, failedCuts = [],\r\n\t\t\t\ttmpShape1, tmpShape2,\r\n\t\t\t\ttmpHole1, tmpHole2;\r\n\r\n\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\t\tindepHoles.push( h );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar minShapeIndex = 0;\r\n\t\t\tvar counter = indepHoles.length * 2;\r\n\t\t\twhile ( indepHoles.length > 0 ) {\r\n\r\n\t\t\t\tcounter --;\r\n\t\t\t\tif ( counter < 0 ) {\r\n\r\n\t\t\t\t\tconsole.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// search for shape-vertex and hole-vertex,\r\n\t\t\t\t// which can be connected without intersections\r\n\t\t\t\tfor ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\r\n\r\n\t\t\t\t\tshapePt = shape[ shapeIndex ];\r\n\t\t\t\t\tholeIndex\t= - 1;\r\n\r\n\t\t\t\t\t// search for hole which can be reached without intersections\r\n\t\t\t\t\tfor ( var h = 0; h < indepHoles.length; h ++ ) {\r\n\r\n\t\t\t\t\t\tholeIdx = indepHoles[ h ];\r\n\r\n\t\t\t\t\t\t// prevent multiple checks\r\n\t\t\t\t\t\tcutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\r\n\t\t\t\t\t\tif ( failedCuts[ cutKey ] !== undefined )\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\thole = holes[ holeIdx ];\r\n\t\t\t\t\t\tfor ( var h2 = 0; h2 < hole.length; h2 ++ ) {\r\n\r\n\t\t\t\t\t\t\tholePt = hole[ h2 ];\r\n\t\t\t\t\t\t\tif ( ! isCutLineInsideAngles( shapeIndex, h2 ) )\t\tcontinue;\r\n\t\t\t\t\t\t\tif ( intersectsShapeEdge( shapePt, holePt ) )\t\tcontinue;\r\n\t\t\t\t\t\t\tif ( intersectsHoleEdge( shapePt, holePt ) )\t\tcontinue;\r\n\r\n\t\t\t\t\t\t\tholeIndex = h2;\r\n\t\t\t\t\t\t\tindepHoles.splice( h, 1 );\r\n\r\n\t\t\t\t\t\t\ttmpShape1 = shape.slice( 0, shapeIndex + 1 );\r\n\t\t\t\t\t\t\ttmpShape2 = shape.slice( shapeIndex );\r\n\t\t\t\t\t\t\ttmpHole1 = hole.slice( holeIndex );\r\n\t\t\t\t\t\t\ttmpHole2 = hole.slice( 0, holeIndex + 1 );\r\n\r\n\t\t\t\t\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\r\n\r\n\t\t\t\t\t\t\tminShapeIndex = shapeIndex;\r\n\r\n\t\t\t\t\t\t\t// Debug only, to show the selected cuts\r\n\t\t\t\t\t\t\t// glob_CutLines.push( [ shapePt, holePt ] );\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\r\n\r\n\t\t\t\t\t\tfailedCuts[ cutKey ] = true;\t\t\t// remember failure\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shape; \t\t\t/* shape with no holes */\r\n\r\n\t\t}\r\n\r\n\r\n\t\tvar i, il, f, face,\r\n\t\t\tkey, index,\r\n\t\t\tallPointsMap = {};\r\n\r\n\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\r\n\r\n\t\tvar allpoints = contour.concat();\r\n\r\n\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tArray.prototype.push.apply( allpoints, holes[ h ] );\r\n\r\n\t\t}\r\n\r\n\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\r\n\r\n\t\t// prepare all points map\r\n\r\n\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\r\n\r\n\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\r\n\r\n\t\t\tif ( allPointsMap[ key ] !== undefined ) {\r\n\r\n\t\t\t\tconsole.warn( \"THREE.Shape: Duplicate point\", key );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tallPointsMap[ key ] = i;\r\n\r\n\t\t}\r\n\r\n\t\t// remove holes by cutting paths to holes and adding them to the shape\r\n\t\tvar shapeWithoutHoles = removeHoles( contour, holes );\r\n\r\n\t\tvar triangles = THREE.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\r\n\t\t//console.log( \"triangles\",triangles, triangles.length );\r\n\r\n\t\t// check all face vertices against all points map\r\n\r\n\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\r\n\r\n\t\t\tface = triangles[ i ];\r\n\r\n\t\t\tfor ( f = 0; f < 3; f ++ ) {\r\n\r\n\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\r\n\r\n\t\t\t\tindex = allPointsMap[ key ];\r\n\r\n\t\t\t\tif ( index !== undefined ) {\r\n\r\n\t\t\t\t\tface[ f ] = index;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn triangles.concat();\r\n\r\n\t},\r\n\r\n\tisClockWise: function ( pts ) {\r\n\r\n\t\treturn THREE.ShapeUtils.area( pts ) < 0;\r\n\r\n\t},\r\n\r\n\t// Bezier Curves formulas obtained from\r\n\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\r\n\r\n\t// Quad Bezier Functions\r\n\r\n\tb2: ( function () {\r\n\r\n\t\tfunction b2p0( t, p ) {\r\n\r\n\t\t\tvar k = 1 - t;\r\n\t\t\treturn k * k * p;\r\n\r\n\t\t}\r\n\r\n\t\tfunction b2p1( t, p ) {\r\n\r\n\t\t\treturn 2 * ( 1 - t ) * t * p;\r\n\r\n\t\t}\r\n\r\n\t\tfunction b2p2( t, p ) {\r\n\r\n\t\t\treturn t * t * p;\r\n\r\n\t\t}\r\n\r\n\t\treturn function ( t, p0, p1, p2 ) {\r\n\r\n\t\t\treturn b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\t// Cubic Bezier Functions\r\n\r\n\tb3: ( function () {\r\n\r\n\t\tfunction b3p0( t, p ) {\r\n\r\n\t\t\tvar k = 1 - t;\r\n\t\t\treturn k * k * k * p;\r\n\r\n\t\t}\r\n\r\n\t\tfunction b3p1( t, p ) {\r\n\r\n\t\t\tvar k = 1 - t;\r\n\t\t\treturn 3 * k * k * t * p;\r\n\r\n\t\t}\r\n\r\n\t\tfunction b3p2( t, p ) {\r\n\r\n\t\t\tvar k = 1 - t;\r\n\t\t\treturn 3 * k * t * t * p;\r\n\r\n\t\t}\r\n\r\n\t\tfunction b3p3( t, p ) {\r\n\r\n\t\t\treturn t * t * t * p;\r\n\r\n\t\t}\r\n\r\n\t\treturn function ( t, p0, p1, p2, p3 ) {\r\n\r\n\t\t\treturn b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );\r\n\r\n\t\t};\r\n\r\n\t} )()\r\n\r\n};\r\n\r\n// File:src/extras/core/Curve.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Extensible curve object\r\n *\r\n * Some common of Curve methods\r\n * .getPoint(t), getTangent(t)\r\n * .getPointAt(u), getTagentAt(u)\r\n * .getPoints(), .getSpacedPoints()\r\n * .getLength()\r\n * .updateArcLengths()\r\n *\r\n * This following classes subclasses THREE.Curve:\r\n *\r\n * -- 2d classes --\r\n * THREE.LineCurve\r\n * THREE.QuadraticBezierCurve\r\n * THREE.CubicBezierCurve\r\n * THREE.SplineCurve\r\n * THREE.ArcCurve\r\n * THREE.EllipseCurve\r\n *\r\n * -- 3d classes --\r\n * THREE.LineCurve3\r\n * THREE.QuadraticBezierCurve3\r\n * THREE.CubicBezierCurve3\r\n * THREE.SplineCurve3\r\n * THREE.ClosedSplineCurve3\r\n *\r\n * A series of curves can be represented as a THREE.CurvePath\r\n *\r\n **/\r\n\r\n/**************************************************************\r\n *\tAbstract Curve base class\r\n **************************************************************/\r\n\r\nTHREE.Curve = function () {\r\n\r\n};\r\n\r\nTHREE.Curve.prototype = {\r\n\r\n\tconstructor: THREE.Curve,\r\n\r\n\t// Virtual base class method to overwrite and implement in subclasses\r\n\t//\t- t [0 .. 1]\r\n\r\n\tgetPoint: function ( t ) {\r\n\r\n\t\tconsole.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\r\n\t\treturn null;\r\n\r\n\t},\r\n\r\n\t// Get point at relative position in curve according to arc length\r\n\t// - u [0 .. 1]\r\n\r\n\tgetPointAt: function ( u ) {\r\n\r\n\t\tvar t = this.getUtoTmapping( u );\r\n\t\treturn this.getPoint( t );\r\n\r\n\t},\r\n\r\n\t// Get sequence of points using getPoint( t )\r\n\r\n\tgetPoints: function ( divisions ) {\r\n\r\n\t\tif ( ! divisions ) divisions = 5;\r\n\r\n\t\tvar d, pts = [];\r\n\r\n\t\tfor ( d = 0; d <= divisions; d ++ ) {\r\n\r\n\t\t\tpts.push( this.getPoint( d / divisions ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn pts;\r\n\r\n\t},\r\n\r\n\t// Get sequence of points using getPointAt( u )\r\n\r\n\tgetSpacedPoints: function ( divisions ) {\r\n\r\n\t\tif ( ! divisions ) divisions = 5;\r\n\r\n\t\tvar d, pts = [];\r\n\r\n\t\tfor ( d = 0; d <= divisions; d ++ ) {\r\n\r\n\t\t\tpts.push( this.getPointAt( d / divisions ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn pts;\r\n\r\n\t},\r\n\r\n\t// Get total curve arc length\r\n\r\n\tgetLength: function () {\r\n\r\n\t\tvar lengths = this.getLengths();\r\n\t\treturn lengths[ lengths.length - 1 ];\r\n\r\n\t},\r\n\r\n\t// Get list of cumulative segment lengths\r\n\r\n\tgetLengths: function ( divisions ) {\r\n\r\n\t\tif ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;\r\n\r\n\t\tif ( this.cacheArcLengths\r\n\t\t\t&& ( this.cacheArcLengths.length === divisions + 1 )\r\n\t\t\t&& ! this.needsUpdate ) {\r\n\r\n\t\t\t//console.log( \"cached\", this.cacheArcLengths );\r\n\t\t\treturn this.cacheArcLengths;\r\n\r\n\t\t}\r\n\r\n\t\tthis.needsUpdate = false;\r\n\r\n\t\tvar cache = [];\r\n\t\tvar current, last = this.getPoint( 0 );\r\n\t\tvar p, sum = 0;\r\n\r\n\t\tcache.push( 0 );\r\n\r\n\t\tfor ( p = 1; p <= divisions; p ++ ) {\r\n\r\n\t\t\tcurrent = this.getPoint ( p / divisions );\r\n\t\t\tsum += current.distanceTo( last );\r\n\t\t\tcache.push( sum );\r\n\t\t\tlast = current;\r\n\r\n\t\t}\r\n\r\n\t\tthis.cacheArcLengths = cache;\r\n\r\n\t\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\r\n\r\n\t},\r\n\r\n\tupdateArcLengths: function() {\r\n\r\n\t\tthis.needsUpdate = true;\r\n\t\tthis.getLengths();\r\n\r\n\t},\r\n\r\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\r\n\r\n\tgetUtoTmapping: function ( u, distance ) {\r\n\r\n\t\tvar arcLengths = this.getLengths();\r\n\r\n\t\tvar i = 0, il = arcLengths.length;\r\n\r\n\t\tvar targetArcLength; // The targeted u distance value to get\r\n\r\n\t\tif ( distance ) {\r\n\r\n\t\t\ttargetArcLength = distance;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\r\n\r\n\t\t}\r\n\r\n\t\t//var time = Date.now();\r\n\r\n\t\t// binary search for the index with largest value smaller than target u distance\r\n\r\n\t\tvar low = 0, high = il - 1, comparison;\r\n\r\n\t\twhile ( low <= high ) {\r\n\r\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\r\n\r\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\r\n\r\n\t\t\tif ( comparison < 0 ) {\r\n\r\n\t\t\t\tlow = i + 1;\r\n\r\n\t\t\t} else if ( comparison > 0 ) {\r\n\r\n\t\t\t\thigh = i - 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\thigh = i;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t\t// DONE\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\ti = high;\r\n\r\n\t\t//console.log('b' , i, low, high, Date.now()- time);\r\n\r\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\r\n\r\n\t\t\tvar t = i / ( il - 1 );\r\n\t\t\treturn t;\r\n\r\n\t\t}\r\n\r\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\r\n\r\n\t\tvar lengthBefore = arcLengths[ i ];\r\n\t\tvar lengthAfter = arcLengths[ i + 1 ];\r\n\r\n\t\tvar segmentLength = lengthAfter - lengthBefore;\r\n\r\n\t\t// determine where we are between the 'before' and 'after' points\r\n\r\n\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\r\n\r\n\t\t// add that fractional amount to t\r\n\r\n\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\r\n\r\n\t\treturn t;\r\n\r\n\t},\r\n\r\n\t// Returns a unit vector tangent at t\r\n\t// In case any sub curve does not implement its tangent derivation,\r\n\t// 2 points a small delta apart will be used to find its gradient\r\n\t// which seems to give a reasonable approximation\r\n\r\n\tgetTangent: function( t ) {\r\n\r\n\t\tvar delta = 0.0001;\r\n\t\tvar t1 = t - delta;\r\n\t\tvar t2 = t + delta;\r\n\r\n\t\t// Capping in case of danger\r\n\r\n\t\tif ( t1 < 0 ) t1 = 0;\r\n\t\tif ( t2 > 1 ) t2 = 1;\r\n\r\n\t\tvar pt1 = this.getPoint( t1 );\r\n\t\tvar pt2 = this.getPoint( t2 );\r\n\r\n\t\tvar vec = pt2.clone().sub( pt1 );\r\n\t\treturn vec.normalize();\r\n\r\n\t},\r\n\r\n\tgetTangentAt: function ( u ) {\r\n\r\n\t\tvar t = this.getUtoTmapping( u );\r\n\t\treturn this.getTangent( t );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// TODO: Transformation for Curves?\r\n\r\n/**************************************************************\r\n *\t3D Curves\r\n **************************************************************/\r\n\r\n// A Factory method for creating new curve subclasses\r\n\r\nTHREE.Curve.create = function ( constructor, getPointFunc ) {\r\n\r\n\tconstructor.prototype = Object.create( THREE.Curve.prototype );\r\n\tconstructor.prototype.constructor = constructor;\r\n\tconstructor.prototype.getPoint = getPointFunc;\r\n\r\n\treturn constructor;\r\n\r\n};\r\n\r\n// File:src/extras/core/CurvePath.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n **/\r\n\r\n/**************************************************************\r\n *\tCurved Path - a curve path is simply a array of connected\r\n *  curves, but retains the api of a curve\r\n **************************************************************/\r\n\r\nTHREE.CurvePath = function () {\r\n\r\n\tthis.curves = [];\r\n\r\n\tthis.autoClose = false; // Automatically closes the path\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.CurvePath.prototype.constructor = THREE.CurvePath;\r\n\r\nTHREE.CurvePath.prototype.add = function ( curve ) {\r\n\r\n\tthis.curves.push( curve );\r\n\r\n};\r\n\r\n/*\r\nTHREE.CurvePath.prototype.checkConnection = function() {\r\n\t// TODO\r\n\t// If the ending of curve is not connected to the starting\r\n\t// or the next curve, then, this is not a real path\r\n};\r\n*/\r\n\r\nTHREE.CurvePath.prototype.closePath = function() {\r\n\r\n\t// TODO Test\r\n\t// and verify for vector3 (needs to implement equals)\r\n\t// Add a line curve if start and end of lines are not connected\r\n\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\r\n\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\r\n\r\n\tif ( ! startPoint.equals( endPoint ) ) {\r\n\r\n\t\tthis.curves.push( new THREE.LineCurve( endPoint, startPoint ) );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// To get accurate point with reference to\r\n// entire path distance at time t,\r\n// following has to be done:\r\n\r\n// 1. Length of each sub path have to be known\r\n// 2. Locate and identify type of curve\r\n// 3. Get t for the curve\r\n// 4. Return curve.getPointAt(t')\r\n\r\nTHREE.CurvePath.prototype.getPoint = function( t ) {\r\n\r\n\tvar d = t * this.getLength();\r\n\tvar curveLengths = this.getCurveLengths();\r\n\tvar i = 0;\r\n\r\n\t// To think about boundaries points.\r\n\r\n\twhile ( i < curveLengths.length ) {\r\n\r\n\t\tif ( curveLengths[ i ] >= d ) {\r\n\r\n\t\t\tvar diff = curveLengths[ i ] - d;\r\n\t\t\tvar curve = this.curves[ i ];\r\n\r\n\t\t\tvar u = 1 - diff / curve.getLength();\r\n\r\n\t\t\treturn curve.getPointAt( u );\r\n\r\n\t\t}\r\n\r\n\t\ti ++;\r\n\r\n\t}\r\n\r\n\treturn null;\r\n\r\n\t// loop where sum != 0, sum > d , sum+1 <d\r\n\r\n};\r\n\r\n/*\r\nTHREE.CurvePath.prototype.getTangent = function( t ) {\r\n};\r\n*/\r\n\r\n// We cannot use the default THREE.Curve getPoint() with getLength() because in\r\n// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\r\n// getPoint() depends on getLength\r\n\r\nTHREE.CurvePath.prototype.getLength = function() {\r\n\r\n\tvar lens = this.getCurveLengths();\r\n\treturn lens[ lens.length - 1 ];\r\n\r\n};\r\n\r\n// Compute lengths and cache them\r\n// We cannot overwrite getLengths() because UtoT mapping uses it.\r\n\r\nTHREE.CurvePath.prototype.getCurveLengths = function() {\r\n\r\n\t// We use cache values if curves and cache array are same length\r\n\r\n\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\r\n\r\n\t\treturn this.cacheLengths;\r\n\r\n\t}\r\n\r\n\t// Get length of sub-curve\r\n\t// Push sums into cached array\r\n\r\n\tvar lengths = [], sums = 0;\r\n\r\n\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\r\n\r\n\t\tsums += this.curves[ i ].getLength();\r\n\t\tlengths.push( sums );\r\n\r\n\t}\r\n\r\n\tthis.cacheLengths = lengths;\r\n\r\n\treturn lengths;\r\n\r\n};\r\n\r\n\r\n\r\n/**************************************************************\r\n *\tCreate Geometries Helpers\r\n **************************************************************/\r\n\r\n/// Generate geometry from path points (for Line or Points objects)\r\n\r\nTHREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {\r\n\r\n\tvar pts = this.getPoints( divisions );\r\n\treturn this.createGeometry( pts );\r\n\r\n};\r\n\r\n// Generate geometry from equidistant sampling along the path\r\n\r\nTHREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {\r\n\r\n\tvar pts = this.getSpacedPoints( divisions );\r\n\treturn this.createGeometry( pts );\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.createGeometry = function( points ) {\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\r\n\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\tvar point = points[ i ];\r\n\t\tgeometry.vertices.push( new THREE.Vector3( point.x, point.y, point.z || 0 ) );\r\n\r\n\t}\r\n\r\n\treturn geometry;\r\n\r\n};\r\n\r\n// File:src/extras/core/Font.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Font = function ( data ) {\r\n\r\n\tthis.data = data;\r\n\r\n};\r\n\r\nTHREE.Font.prototype = {\r\n\r\n\tconstructor: THREE.Font,\r\n\r\n\tgenerateShapes: function ( text, size, divisions ) {\r\n\r\n\t\tfunction createPaths( text ) {\r\n\r\n\t\t\tvar chars = String( text ).split( '' );\r\n\t\t\tvar scale = size / data.resolution;\r\n\t\t\tvar offset = 0;\r\n\r\n\t\t\tvar paths = [];\r\n\r\n\t\t\tfor ( var i = 0; i < chars.length; i ++ ) {\r\n\r\n\t\t\t\tvar ret = createPath( chars[ i ], scale, offset );\r\n\t\t\t\toffset += ret.offset;\r\n\r\n\t\t\t\tpaths.push( ret.path );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn paths;\r\n\r\n\t\t}\r\n\r\n\t\tfunction createPath( c, scale, offset ) {\r\n\r\n\t\t\tvar glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\r\n\r\n\t\t\tif ( ! glyph ) return;\r\n\r\n\t\t\tvar path = new THREE.Path();\r\n\r\n\t\t\tvar pts = [], b2 = THREE.ShapeUtils.b2, b3 = THREE.ShapeUtils.b3;\r\n\t\t\tvar x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\r\n\r\n\t\t\tif ( glyph.o ) {\r\n\r\n\t\t\t\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\r\n\r\n\t\t\t\tfor ( var i = 0, l = outline.length; i < l; ) {\r\n\r\n\t\t\t\t\tvar action = outline[ i ++ ];\r\n\r\n\t\t\t\t\tswitch ( action ) {\r\n\r\n\t\t\t\t\t\tcase 'm': // moveTo\r\n\r\n\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\r\n\r\n\t\t\t\t\t\t\tpath.moveTo( x, y );\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'l': // lineTo\r\n\r\n\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\r\n\r\n\t\t\t\t\t\t\tpath.lineTo( x, y );\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'q': // quadraticCurveTo\r\n\r\n\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\r\n\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\r\n\r\n\t\t\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\r\n\r\n\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\r\n\r\n\t\t\t\t\t\t\tif ( laste ) {\r\n\r\n\t\t\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\r\n\t\t\t\t\t\t\t\t\tb2( t, cpx0, cpx1, cpx );\r\n\t\t\t\t\t\t\t\t\tb2( t, cpy0, cpy1, cpy );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'b': // bezierCurveTo\r\n\r\n\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\r\n\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\r\n\t\t\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\tcpy2 = outline[ i ++ ] * scale;\r\n\r\n\t\t\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\r\n\r\n\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\r\n\r\n\t\t\t\t\t\t\tif ( laste ) {\r\n\r\n\t\t\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\r\n\t\t\t\t\t\t\t\t\tb3( t, cpx0, cpx1, cpx2, cpx );\r\n\t\t\t\t\t\t\t\t\tb3( t, cpy0, cpy1, cpy2, cpy );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn { offset: glyph.ha * scale, path: path };\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( size === undefined ) size = 100;\r\n\t\tif ( divisions === undefined ) divisions = 4;\r\n\r\n\t\tvar data = this.data;\r\n\r\n\t\tvar paths = createPaths( text );\r\n\t\tvar shapes = [];\r\n\r\n\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\r\n\r\n\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\r\n\r\n\t\t}\r\n\r\n\t\treturn shapes;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/core/Path.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Creates free form 2d path using series of points, lines or curves.\r\n *\r\n **/\r\n\r\nTHREE.Path = function ( points ) {\r\n\r\n\tTHREE.CurvePath.call( this );\r\n\r\n\tthis.actions = [];\r\n\r\n\tif ( points ) {\r\n\r\n\t\tthis.fromPoints( points );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Path.prototype = Object.create( THREE.CurvePath.prototype );\r\nTHREE.Path.prototype.constructor = THREE.Path;\r\n\r\n// TODO Clean up PATH API\r\n\r\n// Create path using straight lines to connect all points\r\n// - vectors: array of Vector2\r\n\r\nTHREE.Path.prototype.fromPoints = function ( vectors ) {\r\n\r\n\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\r\n\r\n\tfor ( var i = 1, l = vectors.length; i < l; i ++ ) {\r\n\r\n\t\tthis.lineTo( vectors[ i ].x, vectors[ i ].y );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// startPath() endPath()?\r\n\r\nTHREE.Path.prototype.moveTo = function ( x, y ) {\r\n\r\n\tthis.actions.push( { action: 'moveTo', args: [ x, y ] } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.lineTo = function ( x, y ) {\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tvar curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: 'lineTo', args: [ x, y ] } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tvar curve = new THREE.QuadraticBezierCurve(\r\n\t\tnew THREE.Vector2( x0, y0 ),\r\n\t\tnew THREE.Vector2( aCPx, aCPy ),\r\n\t\tnew THREE.Vector2( aX, aY )\r\n\t);\r\n\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: 'quadraticCurveTo', args: [ aCPx, aCPy, aX, aY ] } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tvar curve = new THREE.CubicBezierCurve(\r\n\t\tnew THREE.Vector2( x0, y0 ),\r\n\t\tnew THREE.Vector2( aCP1x, aCP1y ),\r\n\t\tnew THREE.Vector2( aCP2x, aCP2y ),\r\n\t\tnew THREE.Vector2( aX, aY )\r\n\t);\r\n\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: 'bezierCurveTo', args: [ aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ] } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {\r\n\r\n\tvar args = Array.prototype.slice.call( arguments );\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tvar npts = [ new THREE.Vector2( x0, y0 ) ];\r\n\tArray.prototype.push.apply( npts, pts );\r\n\r\n\tvar curve = new THREE.SplineCurve( npts );\r\n\tthis.curves.push( curve );\r\n\r\n\tthis.actions.push( { action: 'splineThru', args: args } );\r\n\r\n};\r\n\r\n// FUTURE: Change the API or follow canvas API?\r\n\r\nTHREE.Path.prototype.arc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tthis.absarc( aX + x0, aY + y0, aRadius,\r\n\t\taStartAngle, aEndAngle, aClockwise );\r\n\r\n };\r\n\r\n THREE.Path.prototype.absarc = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n\r\n };\r\n\r\nTHREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\r\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\r\n\r\n };\r\n\r\n\r\nTHREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\r\n\tvar args = [\r\n\t\taX, aY,\r\n\t\txRadius, yRadius,\r\n\t\taStartAngle, aEndAngle,\r\n\t\taClockwise,\r\n\t\taRotation || 0 // aRotation is optional.\r\n\t];\r\n\r\n\tvar curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\r\n\tthis.curves.push( curve );\r\n\r\n\tvar lastPoint = curve.getPoint( 1 );\r\n\targs.push( lastPoint.x );\r\n\targs.push( lastPoint.y );\r\n\r\n\tthis.actions.push( { action: 'ellipse', args: args } );\r\n\r\n };\r\n\r\nTHREE.Path.prototype.getSpacedPoints = function ( divisions ) {\r\n\r\n\tif ( ! divisions ) divisions = 40;\r\n\r\n\tvar points = [];\r\n\r\n\tfor ( var i = 0; i < divisions; i ++ ) {\r\n\r\n\t\tpoints.push( this.getPoint( i / divisions ) );\r\n\r\n\t\t//if ( !this.getPoint( i / divisions ) ) throw \"DIE\";\r\n\r\n\t}\r\n\r\n\tif ( this.autoClose ) {\r\n\r\n\t\tpoints.push( points[ 0 ] );\r\n\r\n\t}\r\n\r\n\treturn points;\r\n\r\n};\r\n\r\n/* Return an array of vectors based on contour of the path */\r\n\r\nTHREE.Path.prototype.getPoints = function( divisions ) {\r\n\r\n\tdivisions = divisions || 12;\r\n\r\n\tvar b2 = THREE.ShapeUtils.b2;\r\n\tvar b3 = THREE.ShapeUtils.b3;\r\n\r\n\tvar points = [];\r\n\r\n\tvar cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,\r\n\t\tlaste, tx, ty;\r\n\r\n\tfor ( var i = 0, l = this.actions.length; i < l; i ++ ) {\r\n\r\n\t\tvar item = this.actions[ i ];\r\n\r\n\t\tvar action = item.action;\r\n\t\tvar args = item.args;\r\n\r\n\t\tswitch ( action ) {\r\n\r\n\t\tcase 'moveTo':\r\n\r\n\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'lineTo':\r\n\r\n\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'quadraticCurveTo':\r\n\r\n\t\t\tcpx  = args[ 2 ];\r\n\t\t\tcpy  = args[ 3 ];\r\n\r\n\t\t\tcpx1 = args[ 0 ];\r\n\t\t\tcpy1 = args[ 1 ];\r\n\r\n\t\t\tif ( points.length > 0 ) {\r\n\r\n\t\t\t\tlaste = points[ points.length - 1 ];\r\n\r\n\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\r\n\t\t\t\tcpx0 = laste[ laste.length - 2 ];\r\n\t\t\t\tcpy0 = laste[ laste.length - 1 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 1; j <= divisions; j ++ ) {\r\n\r\n\t\t\t\tvar t = j / divisions;\r\n\r\n\t\t\t\ttx = b2( t, cpx0, cpx1, cpx );\r\n\t\t\t\tty = b2( t, cpy0, cpy1, cpy );\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'bezierCurveTo':\r\n\r\n\t\t\tcpx  = args[ 4 ];\r\n\t\t\tcpy  = args[ 5 ];\r\n\r\n\t\t\tcpx1 = args[ 0 ];\r\n\t\t\tcpy1 = args[ 1 ];\r\n\r\n\t\t\tcpx2 = args[ 2 ];\r\n\t\t\tcpy2 = args[ 3 ];\r\n\r\n\t\t\tif ( points.length > 0 ) {\r\n\r\n\t\t\t\tlaste = points[ points.length - 1 ];\r\n\r\n\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\r\n\t\t\t\tcpx0 = laste[ laste.length - 2 ];\r\n\t\t\t\tcpy0 = laste[ laste.length - 1 ];\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tfor ( var j = 1; j <= divisions; j ++ ) {\r\n\r\n\t\t\t\tvar t = j / divisions;\r\n\r\n\t\t\t\ttx = b3( t, cpx0, cpx1, cpx2, cpx );\r\n\t\t\t\tty = b3( t, cpy0, cpy1, cpy2, cpy );\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'splineThru':\r\n\r\n\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\r\n\t\t\tvar last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );\r\n\t\t\tvar spts = [ last ];\r\n\r\n\t\t\tvar n = divisions * args[ 0 ].length;\r\n\r\n\t\t\tspts = spts.concat( args[ 0 ] );\r\n\r\n\t\t\tvar spline = new THREE.SplineCurve( spts );\r\n\r\n\t\t\tfor ( var j = 1; j <= n; j ++ ) {\r\n\r\n\t\t\t\tpoints.push( spline.getPointAt( j / n ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'arc':\r\n\r\n\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\r\n\t\t\t\taRadius = args[ 2 ],\r\n\t\t\t\taStartAngle = args[ 3 ], aEndAngle = args[ 4 ],\r\n\t\t\t\taClockwise = !! args[ 5 ];\r\n\r\n\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\r\n\t\t\tvar angle;\r\n\t\t\tvar tdivisions = divisions * 2;\r\n\r\n\t\t\tfor ( var j = 1; j <= tdivisions; j ++ ) {\r\n\r\n\t\t\t\tvar t = j / tdivisions;\r\n\r\n\t\t\t\tif ( ! aClockwise ) {\r\n\r\n\t\t\t\t\tt = 1 - t;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tangle = aStartAngle + t * deltaAngle;\r\n\r\n\t\t\t\ttx = aX + aRadius * Math.cos( angle );\r\n\t\t\t\tty = aY + aRadius * Math.sin( angle );\r\n\r\n\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//console.log(points);\r\n\r\n\t\t\tbreak;\r\n\r\n\t\tcase 'ellipse':\r\n\r\n\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\r\n\t\t\t\txRadius = args[ 2 ],\r\n\t\t\t\tyRadius = args[ 3 ],\r\n\t\t\t\taStartAngle = args[ 4 ], aEndAngle = args[ 5 ],\r\n\t\t\t\taClockwise = !! args[ 6 ],\r\n\t\t\t\taRotation = args[ 7 ];\r\n\r\n\r\n\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\r\n\t\t\tvar angle;\r\n\t\t\tvar tdivisions = divisions * 2;\r\n\r\n\t\t\tvar cos, sin;\r\n\t\t\tif ( aRotation !== 0 ) {\r\n\r\n\t\t\t\tcos = Math.cos( aRotation );\r\n\t\t\t\tsin = Math.sin( aRotation );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 1; j <= tdivisions; j ++ ) {\r\n\r\n\t\t\t\tvar t = j / tdivisions;\r\n\r\n\t\t\t\tif ( ! aClockwise ) {\r\n\r\n\t\t\t\t\tt = 1 - t;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tangle = aStartAngle + t * deltaAngle;\r\n\r\n\t\t\t\ttx = aX + xRadius * Math.cos( angle );\r\n\t\t\t\tty = aY + yRadius * Math.sin( angle );\r\n\r\n\t\t\t\tif ( aRotation !== 0 ) {\r\n\r\n\t\t\t\t\tvar x = tx, y = ty;\r\n\r\n\t\t\t\t\t// Rotate the point about the center of the ellipse.\r\n\t\t\t\t\ttx = ( x - aX ) * cos - ( y - aY ) * sin + aX;\r\n\t\t\t\t\tty = ( x - aX ) * sin + ( y - aY ) * cos + aY;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//console.log(points);\r\n\r\n\t\t\tbreak;\r\n\r\n\t\t} // end switch\r\n\r\n\t}\r\n\r\n\r\n\r\n\t// Normalize to remove the closing point by default.\r\n\tvar lastPoint = points[ points.length - 1 ];\r\n\tif ( Math.abs( lastPoint.x - points[ 0 ].x ) < Number.EPSILON &&\r\n\t\t\t Math.abs( lastPoint.y - points[ 0 ].y ) < Number.EPSILON )\r\n\t\tpoints.splice( points.length - 1, 1 );\r\n\r\n\tif ( this.autoClose ) {\r\n\r\n\t\tpoints.push( points[ 0 ] );\r\n\r\n\t}\r\n\r\n\treturn points;\r\n\r\n};\r\n\r\n//\r\n// Breaks path into shapes\r\n//\r\n//\tAssumptions (if parameter isCCW==true the opposite holds):\r\n//\t- solid shapes are defined clockwise (CW)\r\n//\t- holes are defined counterclockwise (CCW)\r\n//\r\n//\tIf parameter noHoles==true:\r\n//  - all subPaths are regarded as solid shapes\r\n//  - definition order CW/CCW has no relevance\r\n//\r\n\r\nTHREE.Path.prototype.toShapes = function( isCCW, noHoles ) {\r\n\r\n\tfunction extractSubpaths( inActions ) {\r\n\r\n\t\tvar subPaths = [], lastPath = new THREE.Path();\r\n\r\n\t\tfor ( var i = 0, l = inActions.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar item = inActions[ i ];\r\n\r\n\t\t\tvar args = item.args;\r\n\t\t\tvar action = item.action;\r\n\r\n\t\t\tif ( action === 'moveTo' ) {\r\n\r\n\t\t\t\tif ( lastPath.actions.length !== 0 ) {\r\n\r\n\t\t\t\t\tsubPaths.push( lastPath );\r\n\t\t\t\t\tlastPath = new THREE.Path();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlastPath[ action ].apply( lastPath, args );\r\n\r\n\t\t}\r\n\r\n\t\tif ( lastPath.actions.length !== 0 ) {\r\n\r\n\t\t\tsubPaths.push( lastPath );\r\n\r\n\t\t}\r\n\r\n\t\t// console.log(subPaths);\r\n\r\n\t\treturn\tsubPaths;\r\n\r\n\t}\r\n\r\n\tfunction toShapesNoHoles( inSubpaths ) {\r\n\r\n\t\tvar shapes = [];\r\n\r\n\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar tmpPath = inSubpaths[ i ];\r\n\r\n\t\t\tvar tmpShape = new THREE.Shape();\r\n\t\t\ttmpShape.actions = tmpPath.actions;\r\n\t\t\ttmpShape.curves = tmpPath.curves;\r\n\r\n\t\t\tshapes.push( tmpShape );\r\n\r\n\t\t}\r\n\r\n\t\t//console.log(\"shape\", shapes);\r\n\r\n\t\treturn shapes;\r\n\r\n\t}\r\n\r\n\tfunction isPointInsidePolygon( inPt, inPolygon ) {\r\n\r\n\t\tvar polyLen = inPolygon.length;\r\n\r\n\t\t// inPt on polygon contour => immediate success    or\r\n\t\t// toggling of inside/outside at every single! intersection point of an edge\r\n\t\t//  with the horizontal line through inPt, left of inPt\r\n\t\t//  not counting lowerY endpoints of edges and whole edges on that line\r\n\t\tvar inside = false;\r\n\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\r\n\r\n\t\t\tvar edgeLowPt  = inPolygon[ p ];\r\n\t\t\tvar edgeHighPt = inPolygon[ q ];\r\n\r\n\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\r\n\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\r\n\r\n\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\r\n\r\n\t\t\t\t// not parallel\r\n\t\t\t\tif ( edgeDy < 0 ) {\r\n\r\n\t\t\t\t\tedgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\r\n\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\r\n\r\n\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\r\n\r\n\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\r\n\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\r\n\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\r\n\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\r\n\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// parallel or collinear\r\n\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\r\n\t\t\t\t// edge lies on the same horizontal line as inPt\r\n\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\r\n\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\r\n\t\t\t\t// continue;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn\tinside;\r\n\r\n\t}\r\n\r\n\tvar isClockWise = THREE.ShapeUtils.isClockWise;\r\n\r\n\tvar subPaths = extractSubpaths( this.actions );\r\n\tif ( subPaths.length === 0 ) return [];\r\n\r\n\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\r\n\r\n\r\n\tvar solid, tmpPath, tmpShape, shapes = [];\r\n\r\n\tif ( subPaths.length === 1 ) {\r\n\r\n\t\ttmpPath = subPaths[ 0 ];\r\n\t\ttmpShape = new THREE.Shape();\r\n\t\ttmpShape.actions = tmpPath.actions;\r\n\t\ttmpShape.curves = tmpPath.curves;\r\n\t\tshapes.push( tmpShape );\r\n\t\treturn shapes;\r\n\r\n\t}\r\n\r\n\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\r\n\tholesFirst = isCCW ? ! holesFirst : holesFirst;\r\n\r\n\t// console.log(\"Holes first\", holesFirst);\r\n\r\n\tvar betterShapeHoles = [];\r\n\tvar newShapes = [];\r\n\tvar newShapeHoles = [];\r\n\tvar mainIdx = 0;\r\n\tvar tmpPoints;\r\n\r\n\tnewShapes[ mainIdx ] = undefined;\r\n\tnewShapeHoles[ mainIdx ] = [];\r\n\r\n\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\r\n\r\n\t\ttmpPath = subPaths[ i ];\r\n\t\ttmpPoints = tmpPath.getPoints();\r\n\t\tsolid = isClockWise( tmpPoints );\r\n\t\tsolid = isCCW ? ! solid : solid;\r\n\r\n\t\tif ( solid ) {\r\n\r\n\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\r\n\r\n\t\t\tnewShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };\r\n\t\t\tnewShapes[ mainIdx ].s.actions = tmpPath.actions;\r\n\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\r\n\r\n\t\t\tif ( holesFirst )\tmainIdx ++;\r\n\t\t\tnewShapeHoles[ mainIdx ] = [];\r\n\r\n\t\t\t//console.log('cw', i);\r\n\r\n\t\t} else {\r\n\r\n\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\r\n\r\n\t\t\t//console.log('ccw', i);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// only Holes? -> probably all Shapes with wrong orientation\r\n\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\r\n\r\n\r\n\tif ( newShapes.length > 1 ) {\r\n\r\n\t\tvar ambiguous = false;\r\n\t\tvar toChange = [];\r\n\r\n\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\r\n\t\t\tbetterShapeHoles[ sIdx ] = [];\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\r\n\t\t\tvar sho = newShapeHoles[ sIdx ];\r\n\r\n\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\r\n\r\n\t\t\t\tvar ho = sho[ hIdx ];\r\n\t\t\t\tvar hole_unassigned = true;\r\n\r\n\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\r\n\r\n\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\r\n\r\n\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\r\n\t\t\t\t\t\tif ( hole_unassigned ) {\r\n\r\n\t\t\t\t\t\t\thole_unassigned = false;\r\n\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tambiguous = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif ( hole_unassigned ) {\r\n\r\n\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\t// console.log(\"ambiguous: \", ambiguous);\r\n\t\tif ( toChange.length > 0 ) {\r\n\r\n\t\t\t// console.log(\"to change: \", toChange);\r\n\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar tmpHoles;\r\n\r\n\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\r\n\r\n\t\ttmpShape = newShapes[ i ].s;\r\n\t\tshapes.push( tmpShape );\r\n\t\ttmpHoles = newShapeHoles[ i ];\r\n\r\n\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\r\n\r\n\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t//console.log(\"shape\", shapes);\r\n\r\n\treturn shapes;\r\n\r\n};\r\n\r\n// File:src/extras/core/Shape.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Defines a 2d shape plane using paths.\r\n **/\r\n\r\n// STEP 1 Create a path.\r\n// STEP 2 Turn path into shape.\r\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\r\n// STEP 3a - Extract points from each shape, turn to vertices\r\n// STEP 3b - Triangulate each shape, add faces.\r\n\r\nTHREE.Shape = function () {\r\n\r\n\tTHREE.Path.apply( this, arguments );\r\n\r\n\tthis.holes = [];\r\n\r\n};\r\n\r\nTHREE.Shape.prototype = Object.create( THREE.Path.prototype );\r\nTHREE.Shape.prototype.constructor = THREE.Shape;\r\n\r\n// Convenience method to return ExtrudeGeometry\r\n\r\nTHREE.Shape.prototype.extrude = function ( options ) {\r\n\r\n\treturn new THREE.ExtrudeGeometry( this, options );\r\n\r\n};\r\n\r\n// Convenience method to return ShapeGeometry\r\n\r\nTHREE.Shape.prototype.makeGeometry = function ( options ) {\r\n\r\n\treturn new THREE.ShapeGeometry( this, options );\r\n\r\n};\r\n\r\n// Get points of holes\r\n\r\nTHREE.Shape.prototype.getPointsHoles = function ( divisions ) {\r\n\r\n\tvar holesPts = [];\r\n\r\n\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\r\n\r\n\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\r\n\r\n\t}\r\n\r\n\treturn holesPts;\r\n\r\n};\r\n\r\n\r\n// Get points of shape and holes (keypoints based on segments parameter)\r\n\r\nTHREE.Shape.prototype.extractAllPoints = function ( divisions ) {\r\n\r\n\treturn {\r\n\r\n\t\tshape: this.getPoints( divisions ),\r\n\t\tholes: this.getPointsHoles( divisions )\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.Shape.prototype.extractPoints = function ( divisions ) {\r\n\r\n\treturn this.extractAllPoints( divisions );\r\n\r\n};\r\n\r\n// File:src/extras/curves/LineCurve.js\r\n\r\n/**************************************************************\r\n *\tLine\r\n **************************************************************/\r\n\r\nTHREE.LineCurve = function ( v1, v2 ) {\r\n\r\n\tthis.v1 = v1;\r\n\tthis.v2 = v2;\r\n\r\n};\r\n\r\nTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.LineCurve.prototype.constructor = THREE.LineCurve;\r\n\r\nTHREE.LineCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar point = this.v2.clone().sub( this.v1 );\r\n\tpoint.multiplyScalar( t ).add( this.v1 );\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\n// Line curve is linear, so we can overwrite default getPointAt\r\n\r\nTHREE.LineCurve.prototype.getPointAt = function ( u ) {\r\n\r\n\treturn this.getPoint( u );\r\n\r\n};\r\n\r\nTHREE.LineCurve.prototype.getTangent = function( t ) {\r\n\r\n\tvar tangent = this.v2.clone().sub( this.v1 );\r\n\r\n\treturn tangent.normalize();\r\n\r\n};\r\n\r\n// File:src/extras/curves/QuadraticBezierCurve.js\r\n\r\n/**************************************************************\r\n *\tQuadratic Bezier curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\r\n\r\n\tthis.v0 = v0;\r\n\tthis.v1 = v1;\r\n\tthis.v2 = v2;\r\n\r\n};\r\n\r\nTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;\r\n\r\n\r\nTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar b2 = THREE.ShapeUtils.b2;\r\n\r\n\treturn new THREE.Vector2(\r\n\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\r\n\t\tb2( t, this.v0.y, this.v1.y, this.v2.y )\r\n\t);\r\n\r\n};\r\n\r\n\r\nTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\r\n\r\n\tvar tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;\r\n\r\n\treturn new THREE.Vector2(\r\n\t\ttangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),\r\n\t\ttangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )\r\n\t).normalize();\r\n\r\n};\r\n\r\n// File:src/extras/curves/CubicBezierCurve.js\r\n\r\n/**************************************************************\r\n *\tCubic Bezier curve\r\n **************************************************************/\r\n\r\nTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\r\n\r\n\tthis.v0 = v0;\r\n\tthis.v1 = v1;\r\n\tthis.v2 = v2;\r\n\tthis.v3 = v3;\r\n\r\n};\r\n\r\nTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;\r\n\r\nTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar b3 = THREE.ShapeUtils.b3;\r\n\r\n\treturn new THREE.Vector2( \r\n\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\r\n\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\r\n\t);\r\n\r\n};\r\n\r\nTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\r\n\r\n\tvar tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;\r\n\r\n\treturn new THREE.Vector2( \r\n\t\ttangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\r\n\t\ttangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\r\n\t).normalize();\r\n\r\n};\r\n\r\n// File:src/extras/curves/SplineCurve.js\r\n\r\n/**************************************************************\r\n *\tSpline curve\r\n **************************************************************/\r\n\r\nTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\r\n\r\n\tthis.points = ( points == undefined ) ? [] : points;\r\n\r\n};\r\n\r\nTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.SplineCurve.prototype.constructor = THREE.SplineCurve;\r\n\r\nTHREE.SplineCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar points = this.points;\r\n\tvar point = ( points.length - 1 ) * t;\r\n\r\n\tvar intPoint = Math.floor( point );\r\n\tvar weight = point - intPoint;\r\n\r\n\tvar point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\r\n\tvar point1 = points[ intPoint ];\r\n\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\r\n\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\r\n\r\n\tvar interpolate = THREE.CurveUtils.interpolate;\r\n\r\n\treturn new THREE.Vector2(\r\n\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\r\n\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight )\r\n\t);\r\n\r\n};\r\n\r\n// File:src/extras/curves/EllipseCurve.js\r\n\r\n/**************************************************************\r\n *\tEllipse curve\r\n **************************************************************/\r\n\r\nTHREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\r\n\tthis.aX = aX;\r\n\tthis.aY = aY;\r\n\r\n\tthis.xRadius = xRadius;\r\n\tthis.yRadius = yRadius;\r\n\r\n\tthis.aStartAngle = aStartAngle;\r\n\tthis.aEndAngle = aEndAngle;\r\n\r\n\tthis.aClockwise = aClockwise;\r\n\t\r\n\tthis.aRotation = aRotation || 0;\r\n\r\n};\r\n\r\nTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;\r\n\r\nTHREE.EllipseCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\r\n\r\n\tif ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;\r\n\tif ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;\r\n\r\n\tvar angle;\r\n\r\n\tif ( this.aClockwise === true ) {\r\n\r\n\t\tangle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );\r\n\r\n\t} else {\r\n\r\n\t\tangle = this.aStartAngle + t * deltaAngle;\r\n\r\n\t}\r\n\t\r\n\tvar x = this.aX + this.xRadius * Math.cos( angle );\r\n\tvar y = this.aY + this.yRadius * Math.sin( angle );\r\n\r\n\tif ( this.aRotation !== 0 ) {\r\n\r\n\t\tvar cos = Math.cos( this.aRotation );\r\n\t\tvar sin = Math.sin( this.aRotation );\r\n\r\n\t\tvar tx = x, ty = y;\r\n\r\n\t\t// Rotate the point about the center of the ellipse.\r\n\t\tx = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;\r\n\t\ty = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;\r\n\r\n\t}\r\n\r\n\treturn new THREE.Vector2( x, y );\r\n\r\n};\r\n\r\n// File:src/extras/curves/ArcCurve.js\r\n\r\n/**************************************************************\r\n *\tArc curve\r\n **************************************************************/\r\n\r\nTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tTHREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n\r\n};\r\n\r\nTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\r\nTHREE.ArcCurve.prototype.constructor = THREE.ArcCurve;\r\n\r\n// File:src/extras/curves/LineCurve3.js\r\n\r\n/**************************************************************\r\n *\tLine3D\r\n **************************************************************/\r\n\r\nTHREE.LineCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( v1, v2 ) {\r\n\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar vector = new THREE.Vector3();\r\n\r\n\t\tvector.subVectors( this.v2, this.v1 ); // diff\r\n\t\tvector.multiplyScalar( t );\r\n\t\tvector.add( this.v1 );\r\n\r\n\t\treturn vector;\r\n\r\n\t}\r\n\r\n);\r\n\r\n// File:src/extras/curves/QuadraticBezierCurve3.js\r\n\r\n/**************************************************************\r\n *\tQuadratic Bezier 3D curve\r\n **************************************************************/\r\n\r\nTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( v0, v1, v2 ) {\r\n\r\n\t\tthis.v0 = v0;\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar b2 = THREE.ShapeUtils.b2;\t\t\r\n\r\n\t\treturn new THREE.Vector3(\r\n\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\r\n\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y ),\r\n\t\t\tb2( t, this.v0.z, this.v1.z, this.v2.z )\r\n\t\t);\r\n\r\n\t}\r\n\r\n);\r\n\r\n// File:src/extras/curves/CubicBezierCurve3.js\r\n\r\n/**************************************************************\r\n *\tCubic Bezier 3D curve\r\n **************************************************************/\r\n\r\nTHREE.CubicBezierCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( v0, v1, v2, v3 ) {\r\n\r\n\t\tthis.v0 = v0;\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\t\tthis.v3 = v3;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar b3 = THREE.ShapeUtils.b3;\r\n\r\n\t\treturn new THREE.Vector3(\r\n\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\r\n\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),\r\n\t\t\tb3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )\r\n\t\t);\r\n\r\n\t}\r\n\r\n);\r\n\r\n// File:src/extras/curves/SplineCurve3.js\r\n\r\n/**************************************************************\r\n *\tSpline 3D curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.SplineCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( points /* array of Vector3 */ ) {\r\n\r\n\t\tconsole.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );\r\n\t\tthis.points = ( points == undefined ) ? [] : points;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar points = this.points;\r\n\t\tvar point = ( points.length - 1 ) * t;\r\n\r\n\t\tvar intPoint = Math.floor( point );\r\n\t\tvar weight = point - intPoint;\r\n\r\n\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\r\n\t\tvar point1 = points[ intPoint ];\r\n\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\r\n\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\r\n\r\n\t\tvar interpolate = THREE.CurveUtils.interpolate;\r\n\r\n\t\treturn new THREE.Vector3(\r\n\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\r\n\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight ),\r\n\t\t\tinterpolate( point0.z, point1.z, point2.z, point3.z, weight )\r\n\t\t);\r\n\r\n\t}\r\n\r\n);\r\n\r\n// File:src/extras/curves/CatmullRomCurve3.js\r\n\r\n/**\r\n * @author zz85 https://github.com/zz85\r\n *\r\n * Centripetal CatmullRom Curve - which is useful for avoiding\r\n * cusps and self-intersections in non-uniform catmull rom curves.\r\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\r\n *\r\n * curve.type accepts centripetal(default), chordal and catmullrom\r\n * curve.tension is used for catmullrom which defaults to 0.5\r\n */\r\n\r\nTHREE.CatmullRomCurve3 = ( function() {\r\n\r\n\tvar\r\n\t\ttmp = new THREE.Vector3(),\r\n\t\tpx = new CubicPoly(),\r\n\t\tpy = new CubicPoly(),\r\n\t\tpz = new CubicPoly();\r\n\r\n\t/*\r\n\tBased on an optimized c++ solution in\r\n\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\r\n\t - http://ideone.com/NoEbVM\r\n\r\n\tThis CubicPoly class could be used for reusing some variables and calculations,\r\n\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\r\n\twhich can be placed in CurveUtils.\r\n\t*/\r\n\r\n\tfunction CubicPoly() {\r\n\r\n\t}\r\n\r\n\t/*\r\n\t * Compute coefficients for a cubic polynomial\r\n\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\r\n\t * such that\r\n\t *   p(0) = x0, p(1) = x1\r\n\t *  and\r\n\t *   p'(0) = t0, p'(1) = t1.\r\n\t */\r\n\tCubicPoly.prototype.init = function( x0, x1, t0, t1 ) {\r\n\r\n\t\tthis.c0 = x0;\r\n\t\tthis.c1 = t0;\r\n\t\tthis.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\r\n\t\tthis.c3 = 2 * x0 - 2 * x1 + t0 + t1;\r\n\r\n\t};\r\n\r\n\tCubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {\r\n\r\n\t\t// compute tangents when parameterized in [t1,t2]\r\n\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\r\n\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\r\n\r\n\t\t// rescale tangents for parametrization in [0,1]\r\n\t\tt1 *= dt1;\r\n\t\tt2 *= dt1;\r\n\r\n\t\t// initCubicPoly\r\n\t\tthis.init( x1, x2, t1, t2 );\r\n\r\n\t};\r\n\r\n\t// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4\r\n\tCubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {\r\n\r\n\t\tthis.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\r\n\r\n\t};\r\n\r\n\tCubicPoly.prototype.calc = function( t ) {\r\n\r\n\t\tvar t2 = t * t;\r\n\t\tvar t3 = t2 * t;\r\n\t\treturn this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;\r\n\r\n\t};\r\n\r\n\t// Subclass Three.js curve\r\n\treturn THREE.Curve.create(\r\n\r\n\t\tfunction ( p /* array of Vector3 */ ) {\r\n\r\n\t\t\tthis.points = p || [];\r\n\t\t\tthis.closed = false;\r\n\r\n\t\t},\r\n\r\n\t\tfunction ( t ) {\r\n\r\n\t\t\tvar points = this.points,\r\n\t\t\t\tpoint, intPoint, weight, l;\r\n\r\n\t\t\tl = points.length;\r\n\r\n\t\t\tif ( l < 2 ) console.log( 'duh, you need at least 2 points' );\r\n\r\n\t\t\tpoint = ( l - ( this.closed ? 0 : 1 ) ) * t;\r\n\t\t\tintPoint = Math.floor( point );\r\n\t\t\tweight = point - intPoint;\r\n\r\n\t\t\tif ( this.closed ) {\r\n\r\n\t\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\r\n\r\n\t\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\r\n\r\n\t\t\t\tintPoint = l - 2;\r\n\t\t\t\tweight = 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar p0, p1, p2, p3; // 4 points\r\n\r\n\t\t\tif ( this.closed || intPoint > 0 ) {\r\n\r\n\t\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// extrapolate first point\r\n\t\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\r\n\t\t\t\tp0 = tmp;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tp1 = points[ intPoint % l ];\r\n\t\t\tp2 = points[ ( intPoint + 1 ) % l ];\r\n\r\n\t\t\tif ( this.closed || intPoint + 2 < l ) {\r\n\r\n\t\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// extrapolate last point\r\n\t\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\r\n\t\t\t\tp3 = tmp;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {\r\n\r\n\t\t\t\t// init Centripetal / Chordal Catmull-Rom\r\n\t\t\t\tvar pow = this.type === 'chordal' ? 0.5 : 0.25;\r\n\t\t\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\r\n\t\t\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\r\n\t\t\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\r\n\r\n\t\t\t\t// safety check for repeated points\r\n\t\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\r\n\t\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\r\n\t\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\r\n\r\n\t\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\r\n\t\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\r\n\t\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\r\n\r\n\t\t\t} else if ( this.type === 'catmullrom' ) {\r\n\r\n\t\t\t\tvar tension = this.tension !== undefined ? this.tension : 0.5;\r\n\t\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );\r\n\t\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );\r\n\t\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar v = new THREE.Vector3(\r\n\t\t\t\tpx.calc( weight ),\r\n\t\t\t\tpy.calc( weight ),\r\n\t\t\t\tpz.calc( weight )\r\n\t\t\t);\r\n\r\n\t\t\treturn v;\r\n\r\n\t\t}\r\n\r\n\t);\r\n\r\n} )();\r\n\r\n// File:src/extras/curves/ClosedSplineCurve3.js\r\n\r\n/**************************************************************\r\n *\tClosed Spline 3D curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.ClosedSplineCurve3 = function ( points ) {\r\n\r\n\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );\r\n\r\n\tTHREE.CatmullRomCurve3.call( this, points );\r\n\tthis.type = 'catmullrom';\r\n\tthis.closed = true;\r\n\r\n};\r\n\r\nTHREE.ClosedSplineCurve3.prototype = Object.create( THREE.CatmullRomCurve3.prototype );\r\n\r\n// File:src/extras/geometries/BoxGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\r\n */\r\n\r\nTHREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'BoxGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\twidth: width,\r\n\t\theight: height,\r\n\t\tdepth: depth,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\tdepthSegments: depthSegments\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new THREE.BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\r\n\tthis.mergeVertices();\r\n\r\n};\r\n\r\nTHREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;\r\n\r\nTHREE.CubeGeometry = THREE.BoxGeometry;\r\n\r\n// File:src/extras/geometries/BoxBufferGeometry.js\r\n\r\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n\r\nTHREE.BoxBufferGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'BoxBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\twidth: width,\r\n\t\theight: height,\r\n\t\tdepth: depth,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\tdepthSegments: depthSegments\r\n\t};\r\n\r\n\tvar scope = this;\r\n\r\n\t// segments\r\n\twidthSegments = Math.floor( widthSegments ) || 1;\r\n\theightSegments = Math.floor( heightSegments ) || 1;\r\n\tdepthSegments = Math.floor( depthSegments ) || 1;\r\n\r\n\t// these are used to calculate buffer length\r\n\tvar vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );\r\n\tvar indexCount = ( vertexCount / 4 ) * 6;\r\n\r\n\t// buffers\r\n\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\r\n\tvar vertices = new Float32Array( vertexCount * 3 );\r\n\tvar normals = new Float32Array( vertexCount * 3 );\r\n\tvar uvs = new Float32Array( vertexCount * 2 );\r\n\r\n\t// offset variables\r\n\tvar vertexBufferOffset = 0;\r\n\tvar uvBufferOffset = 0;\r\n\tvar indexBufferOffset = 0;\r\n\tvar numberOfVertices = 0;\r\n\r\n\t// group variables\r\n\tvar groupStart = 0;\r\n\r\n\t// build each side of the box geometry\r\n\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px\r\n\tbuildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx\r\n\tbuildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py\r\n\tbuildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny\r\n\tbuildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz\r\n\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz\r\n\r\n\t// build geometry\r\n\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n\t// helper functions\r\n\r\n\tfunction calculateVertexCount ( w, h, d ) {\r\n\r\n\t\tvar segments = 0;\r\n\r\n\t\t// calculate the amount of segments for each side\r\n\t\tsegments += w * h * 2; // xy\r\n\t\tsegments += w * d * 2; // xz\r\n\t\tsegments += d * h * 2; // zy\r\n\r\n\t\treturn segments * 4; // four vertices per segments\r\n\r\n\t}\r\n\r\n\tfunction buildPlane ( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\r\n\r\n\t\tvar segmentWidth\t= width / gridX;\r\n\t\tvar segmentHeight = height / gridY;\r\n\r\n\t\tvar widthHalf = width / 2;\r\n\t\tvar heightHalf = height / 2;\r\n\t\tvar depthHalf = depth / 2;\r\n\r\n\t\tvar gridX1 = gridX + 1;\r\n\t\tvar gridY1 = gridY + 1;\r\n\r\n\t\tvar vertexCounter = 0;\r\n\t\tvar groupCount = 0;\r\n\r\n\t\tvar vector = new THREE.Vector3();\r\n\r\n\t\t// generate vertices, normals and uvs\r\n\r\n\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\r\n\r\n\t\t\tvar y = iy * segmentHeight - heightHalf;\r\n\r\n\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\r\n\r\n\t\t\t\tvar x = ix * segmentWidth - widthHalf;\r\n\r\n\t\t\t\t// set values to correct vector component\r\n\t\t\t\tvector[ u ] = x * udir;\r\n\t\t\t\tvector[ v ] = y * vdir;\r\n\t\t\t\tvector[ w ] = depthHalf;\r\n\r\n\t\t\t\t// now apply vector to vertex buffer\r\n\t\t\t\tvertices[ vertexBufferOffset ] = vector.x;\r\n\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vector.y;\r\n\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vector.z;\r\n\r\n\t\t\t\t// set values to correct vector component\r\n\t\t\t\tvector[ u ] = 0;\r\n\t\t\t\tvector[ v ] = 0;\r\n\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\r\n\r\n\t\t\t\t// now apply vector to normal buffer\r\n\t\t\t\tnormals[ vertexBufferOffset ] = vector.x;\r\n\t\t\t\tnormals[ vertexBufferOffset + 1 ] = vector.y;\r\n\t\t\t\tnormals[ vertexBufferOffset + 2 ] = vector.z;\r\n\r\n\t\t\t\t// uvs\r\n\t\t\t\tuvs[ uvBufferOffset ] = ix / gridX;\r\n\t\t\t\tuvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );\r\n\r\n\t\t\t\t// update offsets and counters\r\n\t\t\t\tvertexBufferOffset += 3;\r\n\t\t\t\tuvBufferOffset += 2;\r\n\t\t\t\tvertexCounter += 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// 1. you need three indices to draw a single face\r\n\t\t// 2. a single segment consists of two faces\r\n\t\t// 3. so we need to generate six (2*3) indices per segment\r\n\r\n\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\r\n\r\n\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\r\n\r\n\t\t\t\t// indices\r\n\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\r\n\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\r\n\r\n\t\t\t\t// face one\r\n\t\t\t\tindices[ indexBufferOffset ] = a;\r\n\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\r\n\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\r\n\r\n\t\t\t\t// face two\r\n\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\r\n\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\r\n\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\r\n\r\n\t\t\t\t// update offsets and counters\r\n\t\t\t\tindexBufferOffset += 6;\r\n\t\t\t\tgroupCount += 6;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// add a group to the geometry. this will ensure multi material support\r\n\t\tscope.addGroup( groupStart, groupCount, materialIndex );\r\n\r\n\t\t// calculate new start value for groups\r\n\t\tgroupStart += groupCount;\r\n\r\n\t\t// update total number of vertices\r\n\t\tnumberOfVertices += vertexCounter;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.BoxBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.BoxBufferGeometry.prototype.constructor = THREE.BoxBufferGeometry;\r\n\r\n// File:src/extras/geometries/CircleGeometry.js\r\n\r\n/**\r\n * @author hughes\r\n */\r\n\r\nTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'CircleGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tsegments: segments,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new THREE.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\r\n\r\n};\r\n\r\nTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;\r\n\r\n// File:src/extras/geometries/CircleBufferGeometry.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'CircleBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tsegments: segments,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tradius = radius || 50;\r\n\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\r\n\r\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\r\n\tvar vertices = segments + 2;\r\n\r\n\tvar positions = new Float32Array( vertices * 3 );\r\n\tvar normals = new Float32Array( vertices * 3 );\r\n\tvar uvs = new Float32Array( vertices * 2 );\r\n\r\n\t// center data is already zero, but need to set a few extras\r\n\tnormals[ 2 ] = 1.0;\r\n\tuvs[ 0 ] = 0.5;\r\n\tuvs[ 1 ] = 0.5;\r\n\r\n\tfor ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {\r\n\r\n\t\tvar segment = thetaStart + s / segments * thetaLength;\r\n\r\n\t\tpositions[ i ] = radius * Math.cos( segment );\r\n\t\tpositions[ i + 1 ] = radius * Math.sin( segment );\r\n\r\n\t\tnormals[ i + 2 ] = 1; // normal z\r\n\r\n\t\tuvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;\r\n\t\tuvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;\r\n\r\n\t}\r\n\r\n\tvar indices = [];\r\n\r\n\tfor ( var i = 1; i <= segments; i ++ ) {\r\n\r\n\t\tindices.push( i, i + 1, 0 );\r\n\r\n\t}\r\n\r\n\tthis.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );\r\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\r\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;\r\n\r\n// File:src/extras/geometries/CylinderBufferGeometry.js\r\n\r\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n\r\nTHREE.CylinderBufferGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'CylinderBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradiusTop: radiusTop,\r\n\t\tradiusBottom: radiusBottom,\r\n\t\theight: height,\r\n\t\tradialSegments: radialSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\topenEnded: openEnded,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\r\n\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\r\n\theight = height !== undefined ? height : 100;\r\n\r\n\tradialSegments = Math.floor( radialSegments )  || 8;\r\n\theightSegments = Math.floor( heightSegments ) || 1;\r\n\r\n\topenEnded = openEnded !== undefined ? openEnded : false;\r\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\tthetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;\r\n\r\n\t// used to calculate buffer length\r\n\r\n\tvar vertexCount = calculateVertexCount();\r\n\tvar indexCount = calculateIndexCount();\r\n\r\n\t// buffers\r\n\r\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\r\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\r\n\t// helper variables\r\n\r\n\tvar index = 0, indexOffset = 0, indexArray = [], halfHeight = height / 2;\r\n\r\n\t// generate geometry\r\n\r\n\tgenerateTorso();\r\n\r\n\tif( openEnded === false ) {\r\n\r\n\t\tif( radiusTop > 0 ) {\r\n\r\n\t\t\tgenerateCap( true );\r\n\r\n\t\t}\r\n\r\n\t\tif( radiusBottom > 0 ) {\r\n\r\n\t\t\tgenerateCap( false );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.setIndex( indices );\r\n\tthis.addAttribute( 'position', vertices );\r\n\tthis.addAttribute( 'normal', normals );\r\n\tthis.addAttribute( 'uv', uvs );\r\n\r\n\t// helper functions\r\n\r\n\tfunction calculateVertexCount () {\r\n\r\n\t\tvar count = ( radialSegments + 1 ) * ( heightSegments + 1 );\r\n\r\n\t\tif ( openEnded === false ) {\r\n\r\n\t\t\tcount += ( ( radialSegments + 1 ) * 2 ) + ( radialSegments * 2 );\r\n\r\n\t\t}\r\n\r\n\t\treturn count;\r\n\r\n\t}\r\n\r\n\tfunction calculateIndexCount () {\r\n\r\n\t\tvar count = radialSegments * heightSegments * 2 * 3;\r\n\r\n\t\tif ( openEnded === false ) {\r\n\r\n\t\t\tcount += radialSegments * 2 * 3;\r\n\r\n\t\t}\r\n\r\n\t\treturn count;\r\n\r\n\t}\r\n\r\n\tfunction generateTorso () {\r\n\r\n\t\tvar x, y;\r\n\t\tvar normal = new THREE.Vector3();\r\n\t\tvar vertex = new THREE.Vector3();\r\n\r\n\t\t// this will be used to calculate the normal\r\n\t\tvar tanTheta = ( radiusBottom - radiusTop ) / height;\r\n\r\n\t\t// generate vertices, normals and uvs\r\n\r\n\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\r\n\r\n\t\t\tvar indexRow = [];\r\n\r\n\t\t\tvar v = y / heightSegments;\r\n\r\n\t\t\t// calculate the radius of the current row\r\n\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\r\n\r\n\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\r\n\r\n\t\t\t\tvar u = x / radialSegments;\r\n\r\n\t\t\t\t// vertex\r\n\t\t\t\tvertex.x = radius * Math.sin( u * thetaLength + thetaStart );\r\n\t\t\t\tvertex.y = - v * height + halfHeight;\r\n\t\t\t\tvertex.z = radius * Math.cos( u * thetaLength + thetaStart );\r\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t\t// normal\r\n\t\t\t\tnormal.copy( vertex );\r\n\r\n\t\t\t\t// handle special case if radiusTop/radiusBottom is zero\r\n\t\t\t\tif( ( radiusTop === 0  && y === 0 ) || ( radiusBottom === 0  && y === heightSegments ) ) {\r\n\r\n\t\t\t\t\tnormal.x = Math.sin( u * thetaLength + thetaStart );\r\n\t\t\t\t\tnormal.z = Math.cos( u * thetaLength + thetaStart );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnormal.setY( Math.sqrt( normal.x * normal.x + normal.z * normal.z ) * tanTheta ).normalize();\r\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\r\n\r\n\t\t\t\t// uv\r\n\t\t\t\tuvs.setXY( index, u, 1 - v );\r\n\r\n\t\t\t\t// save index of vertex in respective row\r\n\t\t\t\tindexRow.push( index );\r\n\r\n\t\t\t\t// increase index\r\n\t\t\t\tindex ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// now save vertices of the row in our index array\r\n\t\t\tindexArray.push( indexRow );\r\n\r\n\t\t}\r\n\r\n\t\t// generate indices\r\n\r\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\r\n\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\r\n\r\n\t\t\t\t// we use the index array to access the correct indices\r\n\t\t\t\tvar i1 = indexArray[ y ][ x ];\r\n\t\t\t\tvar i2 = indexArray[ y + 1 ][ x ];\r\n\t\t\t\tvar i3 = indexArray[ y + 1 ][ x + 1 ];\r\n\t\t\t\tvar i4 = indexArray[ y ][ x + 1 ];\r\n\r\n\t\t\t\t// face one\r\n\t\t\t\tindices.setX( indexOffset, i1 ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset++;\r\n\r\n\t\t\t\t// face two\r\n\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, i3 ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset++;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction generateCap ( top ) {\r\n\r\n\t\tvar x, centerIndexStart, centerIndexEnd;\r\n\t\tvar uv = new THREE.Vector2();\r\n\t\tvar vertex = new THREE.Vector3();\r\n\r\n\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\r\n\t\tvar sign = ( top === true ) ? 1 : - 1;\r\n\r\n\t\t// save the index of the first center vertex\r\n\t\tcenterIndexStart = index;\r\n\r\n\t\t// first we generate the center vertex data of the cap.\r\n\t\t// because the geometry needs one set of uvs per face,\r\n\t\t// we must generate a center vertex per face/segment\r\n\r\n\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\r\n\r\n\t\t\t// vertex\r\n\t\t\tvertices.setXYZ( index, 0, halfHeight * sign, 0 );\r\n\r\n\t\t\t// normal\r\n\t\t\tnormals.setXYZ( index, 0, sign, 0 );\r\n\r\n\t\t\t// uv\r\n\t\t\tif( top === true ) {\r\n\r\n\t\t\t\tuv.x = x / radialSegments;\r\n\t\t\t\tuv.y = 0;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tuv.x = ( x - 1 ) / radialSegments;\r\n\t\t\t\tuv.y = 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuvs.setXY( index, uv.x, uv.y );\r\n\r\n\t\t\t// increase index\r\n\t\t\tindex++;\r\n\r\n\t\t}\r\n\r\n\t\t// save the index of the last center vertex\r\n\t\tcenterIndexEnd = index;\r\n\r\n\t\t// now we generate the surrounding vertices, normals and uvs\r\n\r\n\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\r\n\r\n\t\t\tvar u = x / radialSegments;\r\n\r\n\t\t\t// vertex\r\n\t\t\tvertex.x = radius * Math.sin( u * thetaLength + thetaStart );\r\n\t\t\tvertex.y = halfHeight * sign;\r\n\t\t\tvertex.z = radius * Math.cos( u * thetaLength + thetaStart );\r\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t// normal\r\n\t\t\tnormals.setXYZ( index, 0, sign, 0 );\r\n\r\n\t\t\t// uv\r\n\t\t\tuvs.setXY( index, u, ( top === true ) ? 1 : 0 );\r\n\r\n\t\t\t// increase index\r\n\t\t\tindex ++;\r\n\r\n\t\t}\r\n\r\n\t\t// generate indices\r\n\r\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\r\n\t\t\tvar c = centerIndexStart + x;\r\n\t\t\tvar i = centerIndexEnd + x;\r\n\r\n\t\t\tif( top === true ) {\r\n\r\n\t\t\t\t// face top\r\n\t\t\t\tindices.setX( indexOffset, i ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// face bottom\r\n\t\t\t\tindices.setX( indexOffset, i + 1); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, i ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.CylinderBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.CylinderBufferGeometry.prototype.constructor = THREE.CylinderBufferGeometry;\r\n\r\n// File:src/extras/geometries/CylinderGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'CylinderGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradiusTop: radiusTop,\r\n\t\tradiusBottom: radiusBottom,\r\n\t\theight: height,\r\n\t\tradialSegments: radialSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\topenEnded: openEnded,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new THREE.CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\r\n\tthis.mergeVertices();\r\n\r\n};\r\n\r\nTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;\r\n\r\n// File:src/extras/geometries/EdgesGeometry.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.EdgesGeometry = function ( geometry, thresholdAngle ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\r\n\r\n\tvar thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );\r\n\r\n\tvar edge = [ 0, 0 ], hash = {};\r\n\r\n\tfunction sortFunction( a, b ) {\r\n\r\n\t\treturn a - b;\r\n\r\n\t}\r\n\r\n\tvar keys = [ 'a', 'b', 'c' ];\r\n\r\n\tvar geometry2;\r\n\r\n\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\tgeometry2 = new THREE.Geometry();\r\n\t\tgeometry2.fromBufferGeometry( geometry );\r\n\r\n\t} else {\r\n\r\n\t\tgeometry2 = geometry.clone();\r\n\r\n\t}\r\n\r\n\tgeometry2.mergeVertices();\r\n\tgeometry2.computeFaceNormals();\r\n\r\n\tvar vertices = geometry2.vertices;\r\n\tvar faces = geometry2.faces;\r\n\r\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\tvar face = faces[ i ];\r\n\r\n\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\tedge[ 0 ] = face[ keys[ j ] ];\r\n\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n\t\t\tedge.sort( sortFunction );\r\n\r\n\t\t\tvar key = edge.toString();\r\n\r\n\t\t\tif ( hash[ key ] === undefined ) {\r\n\r\n\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\thash[ key ].face2 = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar coords = [];\r\n\r\n\tfor ( var key in hash ) {\r\n\r\n\t\tvar h = hash[ key ];\r\n\r\n\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\r\n\r\n\t\t\tvar vertex = vertices[ h.vert1 ];\r\n\t\t\tcoords.push( vertex.x );\r\n\t\t\tcoords.push( vertex.y );\r\n\t\t\tcoords.push( vertex.z );\r\n\r\n\t\t\tvertex = vertices[ h.vert2 ];\r\n\t\t\tcoords.push( vertex.x );\r\n\t\t\tcoords.push( vertex.y );\r\n\t\t\tcoords.push( vertex.z );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );\r\n\r\n};\r\n\r\nTHREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;\r\n\r\n// File:src/extras/geometries/ExtrudeGeometry.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n * Creates extruded geometry from a path shape.\r\n *\r\n * parameters = {\r\n *\r\n *  curveSegments: <int>, // number of points on the curves\r\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\r\n *  amount: <int>, // Depth to extrude the shape\r\n *\r\n *  bevelEnabled: <bool>, // turn on bevel\r\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\r\n *  bevelSize: <float>, // how far from shape outline is bevel\r\n *  bevelSegments: <int>, // number of bevel layers\r\n *\r\n *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\r\n *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\r\n *\r\n *  uvGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n **/\r\n\r\nTHREE.ExtrudeGeometry = function ( shapes, options ) {\r\n\r\n\tif ( typeof( shapes ) === \"undefined\" ) {\r\n\r\n\t\tshapes = [];\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'ExtrudeGeometry';\r\n\r\n\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\r\n\r\n\tthis.addShapeList( shapes, options );\r\n\r\n\tthis.computeFaceNormals();\r\n\r\n\t// can't really use automatic vertex normals\r\n\t// as then front and back sides get smoothed too\r\n\t// should do separate smoothing just for sides\r\n\r\n\t//this.computeVertexNormals();\r\n\r\n\t//console.log( \"took\", ( Date.now() - startTime ) );\r\n\r\n};\r\n\r\nTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;\r\n\r\nTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\r\n\tvar sl = shapes.length;\r\n\r\n\tfor ( var s = 0; s < sl; s ++ ) {\r\n\r\n\t\tvar shape = shapes[ s ];\r\n\t\tthis.addShape( shape, options );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\r\n\r\n\tvar amount = options.amount !== undefined ? options.amount : 100;\r\n\r\n\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\r\n\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\r\n\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\r\n\r\n\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\r\n\r\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\r\n\tvar steps = options.steps !== undefined ? options.steps : 1;\r\n\r\n\tvar extrudePath = options.extrudePath;\r\n\tvar extrudePts, extrudeByPath = false;\r\n\r\n\t// Use default WorldUVGenerator if no UV generators are specified.\r\n\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\r\n\r\n\tvar splineTube, binormal, normal, position2;\r\n\tif ( extrudePath ) {\r\n\r\n\t\textrudePts = extrudePath.getSpacedPoints( steps );\r\n\r\n\t\textrudeByPath = true;\r\n\t\tbevelEnabled = false; // bevels not supported for path extrusion\r\n\r\n\t\t// SETUP TNB variables\r\n\r\n\t\t// Reuse TNB from TubeGeomtry for now.\r\n\t\t// TODO1 - have a .isClosed in spline?\r\n\r\n\t\tsplineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );\r\n\r\n\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\r\n\r\n\t\tbinormal = new THREE.Vector3();\r\n\t\tnormal = new THREE.Vector3();\r\n\t\tposition2 = new THREE.Vector3();\r\n\r\n\t}\r\n\r\n\t// Safeguards if bevels are not enabled\r\n\r\n\tif ( ! bevelEnabled ) {\r\n\r\n\t\tbevelSegments = 0;\r\n\t\tbevelThickness = 0;\r\n\t\tbevelSize = 0;\r\n\r\n\t}\r\n\r\n\t// Variables initialization\r\n\r\n\tvar ahole, h, hl; // looping of holes\r\n\tvar scope = this;\r\n\r\n\tvar shapesOffset = this.vertices.length;\r\n\r\n\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\r\n\tvar vertices = shapePoints.shape;\r\n\tvar holes = shapePoints.holes;\r\n\r\n\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\r\n\r\n\tif ( reverse ) {\r\n\r\n\t\tvertices = vertices.reverse();\r\n\r\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\r\n\t\t\tif ( THREE.ShapeUtils.isClockWise( ahole ) ) {\r\n\r\n\t\t\t\tholes[ h ] = ahole.reverse();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\r\n\r\n\t}\r\n\r\n\r\n\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\r\n\r\n\t/* Vertices */\r\n\r\n\tvar contour = vertices; // vertices has all points but contour has only points of circumference\r\n\r\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\tahole = holes[ h ];\r\n\r\n\t\tvertices = vertices.concat( ahole );\r\n\r\n\t}\r\n\r\n\r\n\tfunction scalePt2 ( pt, vec, size ) {\r\n\r\n\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\r\n\r\n\t\treturn vec.clone().multiplyScalar( size ).add( pt );\r\n\r\n\t}\r\n\r\n\tvar b, bs, t, z,\r\n\t\tvert, vlen = vertices.length,\r\n\t\tface, flen = faces.length;\r\n\r\n\r\n\t// Find directions for point movement\r\n\r\n\r\n\tfunction getBevelVec( inPt, inPrev, inNext ) {\r\n\r\n\t\t// computes for inPt the corresponding point inPt' on a new contour\r\n\t\t//   shifted by 1 unit (length of normalized vector) to the left\r\n\t\t// if we walk along contour clockwise, this new contour is outside the old one\r\n\t\t//\r\n\t\t// inPt' is the intersection of the two lines parallel to the two\r\n\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\r\n\r\n\t\tvar v_trans_x, v_trans_y, shrink_by = 1;\t\t// resulting translation vector for inPt\r\n\r\n\t\t// good reading for geometry algorithms (here: line-line intersection)\r\n\t\t// http://geomalgorithms.com/a05-_intersect-1.html\r\n\r\n\t\tvar v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\r\n\t\tvar v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\r\n\r\n\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\r\n\r\n\t\t// check for collinear edges\r\n\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\r\n\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\r\n\r\n\t\t\t// not collinear\r\n\r\n\t\t\t// length of vectors for normalizing\r\n\r\n\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\r\n\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\r\n\r\n\t\t\t// shift adjacent points by unit vectors to the left\r\n\r\n\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\r\n\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\r\n\r\n\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\r\n\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\r\n\r\n\t\t\t// scaling factor for v_prev to intersection point\r\n\r\n\t\t\tvar sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\r\n\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\r\n\t\t\t\t\t  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\r\n\t\t\t// vector from inPt to intersection point\r\n\r\n\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\r\n\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\r\n\r\n\t\t\t// Don't normalize!, otherwise sharp corners become ugly\r\n\t\t\t//  but prevent crazy spikes\r\n\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\r\n\t\t\tif ( v_trans_lensq <= 2 ) {\r\n\r\n\t\t\t\treturn\tnew THREE.Vector2( v_trans_x, v_trans_y );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// handle special case of collinear edges\r\n\r\n\t\t\tvar direction_eq = false;\t\t// assumes: opposite\r\n\t\t\tif ( v_prev_x > Number.EPSILON ) {\r\n\r\n\t\t\t\tif ( v_next_x > Number.EPSILON ) {\r\n\r\n\t\t\t\t\tdirection_eq = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\r\n\r\n\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\r\n\r\n\t\t\t\t\t\tdirection_eq = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\r\n\r\n\t\t\t\t\t\tdirection_eq = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( direction_eq ) {\r\n\r\n\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\r\n\t\t\t\tv_trans_x = - v_prev_y;\r\n\t\t\t\tv_trans_y =  v_prev_x;\r\n\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\r\n\t\t\t\tv_trans_x = v_prev_x;\r\n\t\t\t\tv_trans_y = v_prev_y;\r\n\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn\tnew THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\r\n\r\n\t}\r\n\r\n\r\n\tvar contourMovements = [];\r\n\r\n\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n\t\tif ( j === il ) j = 0;\r\n\t\tif ( k === il ) k = 0;\r\n\r\n\t\t//  (j)---(i)---(k)\r\n\t\t// console.log('i,j,k', i, j , k)\r\n\r\n\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\r\n\r\n\t}\r\n\r\n\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\r\n\r\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\tahole = holes[ h ];\r\n\r\n\t\toneHoleMovements = [];\r\n\r\n\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n\t\t\tif ( j === il ) j = 0;\r\n\t\t\tif ( k === il ) k = 0;\r\n\r\n\t\t\t//  (j)---(i)---(k)\r\n\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\r\n\r\n\t\t}\r\n\r\n\t\tholesMovements.push( oneHoleMovements );\r\n\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\r\n\r\n\t}\r\n\r\n\r\n\t// Loop bevelSegments, 1 for the front, 1 for the back\r\n\r\n\tfor ( b = 0; b < bevelSegments; b ++ ) {\r\n\r\n\t\t//for ( b = bevelSegments; b > 0; b -- ) {\r\n\r\n\t\tt = b / bevelSegments;\r\n\t\tz = bevelThickness * ( 1 - t );\r\n\r\n\t\t//z = bevelThickness * t;\r\n\t\tbs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved\r\n\t\t//bs = bevelSize * t; // linear\r\n\r\n\t\t// contract shape\r\n\r\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\r\n\t\t\tv( vert.x, vert.y,  - z );\r\n\r\n\t\t}\r\n\r\n\t\t// expand holes\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\t\t\toneHoleMovements = holesMovements[ h ];\r\n\r\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\r\n\t\t\t\tv( vert.x, vert.y,  - z );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tbs = bevelSize;\r\n\r\n\t// Back facing vertices\r\n\r\n\tfor ( i = 0; i < vlen; i ++ ) {\r\n\r\n\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n\t\tif ( ! extrudeByPath ) {\r\n\r\n\t\t\tv( vert.x, vert.y, 0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\r\n\r\n\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\r\n\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\r\n\r\n\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\r\n\r\n\t\t\tv( position2.x, position2.y, position2.z );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Add stepped vertices...\r\n\t// Including front facing vertices\r\n\r\n\tvar s;\r\n\r\n\tfor ( s = 1; s <= steps; s ++ ) {\r\n\r\n\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\r\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n\t\t\tif ( ! extrudeByPath ) {\r\n\r\n\t\t\t\tv( vert.x, vert.y, amount / steps * s );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\r\n\r\n\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\r\n\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\r\n\r\n\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\r\n\r\n\t\t\t\tv( position2.x, position2.y, position2.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// Add bevel segments planes\r\n\r\n\t//for ( b = 1; b <= bevelSegments; b ++ ) {\r\n\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\r\n\r\n\t\tt = b / bevelSegments;\r\n\t\tz = bevelThickness * ( 1 - t );\r\n\t\t//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\r\n\t\tbs = bevelSize * Math.sin ( t * Math.PI / 2 );\r\n\r\n\t\t// contract shape\r\n\r\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\t\t\tv( vert.x, vert.y,  amount + z );\r\n\r\n\t\t}\r\n\r\n\t\t// expand holes\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\t\t\toneHoleMovements = holesMovements[ h ];\r\n\r\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\r\n\t\t\t\tif ( ! extrudeByPath ) {\r\n\r\n\t\t\t\t\tv( vert.x, vert.y,  amount + z );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/* Faces */\r\n\r\n\t// Top and bottom faces\r\n\r\n\tbuildLidFaces();\r\n\r\n\t// Sides faces\r\n\r\n\tbuildSideFaces();\r\n\r\n\r\n\t/////  Internal functions\r\n\r\n\tfunction buildLidFaces() {\r\n\r\n\t\tif ( bevelEnabled ) {\r\n\r\n\t\t\tvar layer = 0; // steps + 1\r\n\t\t\tvar offset = vlen * layer;\r\n\r\n\t\t\t// Bottom faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlayer = steps + bevelSegments * 2;\r\n\t\t\toffset = vlen * layer;\r\n\r\n\t\t\t// Top faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Bottom faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Top faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Create faces for the z-sides of the shape\r\n\r\n\tfunction buildSideFaces() {\r\n\r\n\t\tvar layeroffset = 0;\r\n\t\tsidewalls( contour, layeroffset );\r\n\t\tlayeroffset += contour.length;\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\t\t\tsidewalls( ahole, layeroffset );\r\n\r\n\t\t\t//, true\r\n\t\t\tlayeroffset += ahole.length;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction sidewalls( contour, layeroffset ) {\r\n\r\n\t\tvar j, k;\r\n\t\ti = contour.length;\r\n\r\n\t\twhile ( -- i >= 0 ) {\r\n\r\n\t\t\tj = i;\r\n\t\t\tk = i - 1;\r\n\t\t\tif ( k < 0 ) k = contour.length - 1;\r\n\r\n\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\r\n\r\n\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\r\n\r\n\t\t\tfor ( s = 0; s < sl; s ++ ) {\r\n\r\n\t\t\t\tvar slen1 = vlen * s;\r\n\t\t\t\tvar slen2 = vlen * ( s + 1 );\r\n\r\n\t\t\t\tvar a = layeroffset + j + slen1,\r\n\t\t\t\t\tb = layeroffset + k + slen1,\r\n\t\t\t\t\tc = layeroffset + k + slen2,\r\n\t\t\t\t\td = layeroffset + j + slen2;\r\n\r\n\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\tfunction v( x, y, z ) {\r\n\r\n\t\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\r\n\r\n\t}\r\n\r\n\tfunction f3( a, b, c ) {\r\n\r\n\t\ta += shapesOffset;\r\n\t\tb += shapesOffset;\r\n\t\tc += shapesOffset;\r\n\r\n\t\tscope.faces.push( new THREE.Face3( a, b, c, null, null, 0 ) );\r\n\r\n\t\tvar uvs = uvgen.generateTopUV( scope, a, b, c );\r\n\r\n\t\tscope.faceVertexUvs[ 0 ].push( uvs );\r\n\r\n\t}\r\n\r\n\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\r\n\r\n\t\ta += shapesOffset;\r\n\t\tb += shapesOffset;\r\n\t\tc += shapesOffset;\r\n\t\td += shapesOffset;\r\n\r\n\t\tscope.faces.push( new THREE.Face3( a, b, d, null, null, 1 ) );\r\n\t\tscope.faces.push( new THREE.Face3( b, c, d, null, null, 1 ) );\r\n\r\n\t\tvar uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\r\n\r\n\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\r\n\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ExtrudeGeometry.WorldUVGenerator = {\r\n\r\n\tgenerateTopUV: function ( geometry, indexA, indexB, indexC ) {\r\n\r\n\t\tvar vertices = geometry.vertices;\r\n\r\n\t\tvar a = vertices[ indexA ];\r\n\t\tvar b = vertices[ indexB ];\r\n\t\tvar c = vertices[ indexC ];\r\n\r\n\t\treturn [\r\n\t\t\tnew THREE.Vector2( a.x, a.y ),\r\n\t\t\tnew THREE.Vector2( b.x, b.y ),\r\n\t\t\tnew THREE.Vector2( c.x, c.y )\r\n\t\t];\r\n\r\n\t},\r\n\r\n\tgenerateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\r\n\r\n\t\tvar vertices = geometry.vertices;\r\n\r\n\t\tvar a = vertices[ indexA ];\r\n\t\tvar b = vertices[ indexB ];\r\n\t\tvar c = vertices[ indexC ];\r\n\t\tvar d = vertices[ indexD ];\r\n\r\n\t\tif ( Math.abs( a.y - b.y ) < 0.01 ) {\r\n\r\n\t\t\treturn [\r\n\t\t\t\tnew THREE.Vector2( a.x, 1 - a.z ),\r\n\t\t\t\tnew THREE.Vector2( b.x, 1 - b.z ),\r\n\t\t\t\tnew THREE.Vector2( c.x, 1 - c.z ),\r\n\t\t\t\tnew THREE.Vector2( d.x, 1 - d.z )\r\n\t\t\t];\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn [\r\n\t\t\t\tnew THREE.Vector2( a.y, 1 - a.z ),\r\n\t\t\t\tnew THREE.Vector2( b.y, 1 - b.z ),\r\n\t\t\t\tnew THREE.Vector2( c.y, 1 - c.z ),\r\n\t\t\t\tnew THREE.Vector2( d.y, 1 - d.z )\r\n\t\t\t];\r\n\r\n\t\t}\r\n\r\n\t}\r\n};\r\n\r\n// File:src/extras/geometries/ShapeGeometry.js\r\n\r\n/**\r\n * @author jonobr1 / http://jonobr1.com\r\n *\r\n * Creates a one-sided polygonal geometry from a path shape. Similar to\r\n * ExtrudeGeometry.\r\n *\r\n * parameters = {\r\n *\r\n *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\r\n *\r\n *\tmaterial: <int> // material index for front and back faces\r\n *\tuvGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n **/\r\n\r\nTHREE.ShapeGeometry = function ( shapes, options ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'ShapeGeometry';\r\n\r\n\tif ( Array.isArray( shapes ) === false ) shapes = [ shapes ];\r\n\r\n\tthis.addShapeList( shapes, options );\r\n\r\n\tthis.computeFaceNormals();\r\n\r\n};\r\n\r\nTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;\r\n\r\n/**\r\n * Add an array of shapes to THREE.ShapeGeometry.\r\n */\r\nTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\r\n\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\r\n\r\n\t\tthis.addShape( shapes[ i ], options );\r\n\r\n\t}\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n/**\r\n * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\r\n */\r\nTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\r\n\r\n\tif ( options === undefined ) options = {};\r\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\r\n\tvar material = options.material;\r\n\tvar uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\r\n\r\n\t//\r\n\r\n\tvar i, l, hole;\r\n\r\n\tvar shapesOffset = this.vertices.length;\r\n\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\r\n\tvar vertices = shapePoints.shape;\r\n\tvar holes = shapePoints.holes;\r\n\r\n\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\r\n\r\n\tif ( reverse ) {\r\n\r\n\t\tvertices = vertices.reverse();\r\n\r\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\r\n\r\n\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\r\n\r\n\t\t\thole = holes[ i ];\r\n\r\n\t\t\tif ( THREE.ShapeUtils.isClockWise( hole ) ) {\r\n\r\n\t\t\t\tholes[ i ] = hole.reverse();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treverse = false;\r\n\r\n\t}\r\n\r\n\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\r\n\r\n\t// Vertices\r\n\r\n\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\r\n\r\n\t\thole = holes[ i ];\r\n\t\tvertices = vertices.concat( hole );\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar vert, vlen = vertices.length;\r\n\tvar face, flen = faces.length;\r\n\r\n\tfor ( i = 0; i < vlen; i ++ ) {\r\n\r\n\t\tvert = vertices[ i ];\r\n\r\n\t\tthis.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\r\n\r\n\t}\r\n\r\n\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\tface = faces[ i ];\r\n\r\n\t\tvar a = face[ 0 ] + shapesOffset;\r\n\t\tvar b = face[ 1 ] + shapesOffset;\r\n\t\tvar c = face[ 2 ] + shapesOffset;\r\n\r\n\t\tthis.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\r\n\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/geometries/LatheBufferGeometry.js\r\n\r\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n\r\n // points - to create a closed torus, one must use a set of points\r\n //    like so: [ a, b, c, d, a ], see first is the same as last.\r\n // segments - the number of circumference segments to create\r\n // phiStart - the starting radian\r\n // phiLength - the radian (0 to 2PI) range of the lathed section\r\n //    2PI is a closed lathe, less than 2PI is a portion.\r\n\r\nTHREE.LatheBufferGeometry = function ( points, segments, phiStart, phiLength ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'LatheBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tpoints: points,\r\n\t\tsegments: segments,\r\n\t\tphiStart: phiStart,\r\n\t\tphiLength: phiLength\r\n\t};\r\n\r\n\tsegments = Math.floor( segments ) || 12;\r\n\tphiStart = phiStart || 0;\r\n\tphiLength = phiLength || Math.PI * 2;\r\n\r\n\t// clamp phiLength so it's in range of [ 0, 2PI ]\r\n\tphiLength = THREE.Math.clamp( phiLength, 0, Math.PI * 2 );\r\n\r\n\t// these are used to calculate buffer length\r\n\tvar vertexCount = ( segments + 1 ) * points.length;\r\n\tvar indexCount = segments * points.length * 2 * 3;\r\n\r\n\t// buffers\r\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\r\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\r\n\t// helper variables\r\n\tvar index = 0, indexOffset = 0, base;\r\n\tvar inversePointLength = 1.0 / ( points.length - 1 );\r\n\tvar inverseSegments = 1.0 / segments;\r\n\tvar vertex = new THREE.Vector3();\r\n\tvar uv = new THREE.Vector2();\r\n\tvar i, j;\r\n\r\n\t// generate vertices and uvs\r\n\r\n\tfor ( i = 0; i <= segments; i ++ ) {\r\n\r\n\t\tvar phi = phiStart + i * inverseSegments * phiLength;\r\n\r\n\t\tvar sin = Math.sin( phi );\r\n\t\tvar cos = Math.cos( phi );\r\n\r\n\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\r\n\r\n\t\t\t// vertex\r\n\t\t\tvertex.x = points[ j ].x * sin;\r\n\t\t\tvertex.y = points[ j ].y;\r\n\t\t\tvertex.z = points[ j ].x * cos;\r\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t// uv\r\n\t\t\tuv.x = i / segments;\r\n\t\t\tuv.y = j / ( points.length - 1 );\r\n\t\t\tuvs.setXY( index, uv.x, uv.y );\r\n\r\n\t\t\t// increase index\r\n\t\t\tindex ++;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// generate indices\r\n\r\n\tfor ( i = 0; i < segments; i ++ ) {\r\n\r\n\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\r\n\r\n\t\t\tbase = j + i * points.length;\r\n\r\n\t\t\t// indices\r\n\t\t\tvar a = base;\r\n\t\t\tvar b = base + points.length;\r\n\t\t\tvar c = base + points.length + 1;\r\n\t\t\tvar d = base + 1;\r\n\r\n\t\t\t// face one\r\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\r\n\t\t\t// face two\r\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.setIndex( indices );\r\n\tthis.addAttribute( 'position', vertices );\r\n\tthis.addAttribute( 'uv', uvs );\r\n\r\n\t// generate normals\r\n\r\n\tthis.computeVertexNormals();\r\n\r\n\t// if the geometry is closed, we need to average the normals along the seam.\r\n\t// because the corresponding vertices are identical (but still have different UVs).\r\n\r\n\tif( phiLength === Math.PI * 2 ) {\r\n\r\n\t\tvar normals = this.attributes.normal.array;\r\n\t\tvar n1 = new THREE.Vector3();\r\n\t\tvar n2 = new THREE.Vector3();\r\n\t\tvar n = new THREE.Vector3();\r\n\r\n\t\t// this is the buffer offset for the last line of vertices\r\n\t\tbase = segments * points.length * 3;\r\n\r\n\t\tfor( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\r\n\r\n\t\t\t// select the normal of the vertex in the first line\r\n\t\t\tn1.x = normals[ j + 0 ];\r\n\t\t\tn1.y = normals[ j + 1 ];\r\n\t\t\tn1.z = normals[ j + 2 ];\r\n\r\n\t\t\t// select the normal of the vertex in the last line\r\n\t\t\tn2.x = normals[ base + j + 0 ];\r\n\t\t\tn2.y = normals[ base + j + 1 ];\r\n\t\t\tn2.z = normals[ base + j + 2 ];\r\n\r\n\t\t\t// average normals\r\n\t\t\tn.addVectors( n1, n2 ).normalize();\r\n\r\n\t\t\t// assign the new values to both normals\r\n\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\r\n\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\r\n\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\r\n\r\n\t\t} // next row\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.LatheBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.LatheBufferGeometry.prototype.constructor = THREE.LatheBufferGeometry;\r\n\r\n// File:src/extras/geometries/LatheGeometry.js\r\n\r\n/**\r\n * @author astrodud / http://astrodud.isgreat.org/\r\n * @author zz85 / https://github.com/zz85\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\n// points - to create a closed torus, one must use a set of points\r\n//    like so: [ a, b, c, d, a ], see first is the same as last.\r\n// segments - the number of circumference segments to create\r\n// phiStart - the starting radian\r\n// phiLength - the radian (0 to 2PI) range of the lathed section\r\n//    2PI is a closed lathe, less than 2PI is a portion.\r\n\r\nTHREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'LatheGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tpoints: points,\r\n\t\tsegments: segments,\r\n\t\tphiStart: phiStart,\r\n\t\tphiLength: phiLength\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new THREE.LatheBufferGeometry( points, segments, phiStart, phiLength ) );\r\n\tthis.mergeVertices();\r\n\r\n};\r\n\r\nTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;\r\n\r\n// File:src/extras/geometries/PlaneGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n */\r\n\r\nTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'PlaneGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\twidth: width,\r\n\t\theight: height,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\r\n\r\n};\r\n\r\nTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;\r\n\r\n// File:src/extras/geometries/PlaneBufferGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n */\r\n\r\nTHREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'PlaneBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\twidth: width,\r\n\t\theight: height,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments\r\n\t};\r\n\r\n\tvar width_half = width / 2;\r\n\tvar height_half = height / 2;\r\n\r\n\tvar gridX = Math.floor( widthSegments ) || 1;\r\n\tvar gridY = Math.floor( heightSegments ) || 1;\r\n\r\n\tvar gridX1 = gridX + 1;\r\n\tvar gridY1 = gridY + 1;\r\n\r\n\tvar segment_width = width / gridX;\r\n\tvar segment_height = height / gridY;\r\n\r\n\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\r\n\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\r\n\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\r\n\r\n\tvar offset = 0;\r\n\tvar offset2 = 0;\r\n\r\n\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\r\n\r\n\t\tvar y = iy * segment_height - height_half;\r\n\r\n\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\r\n\r\n\t\t\tvar x = ix * segment_width - width_half;\r\n\r\n\t\t\tvertices[ offset ] = x;\r\n\t\t\tvertices[ offset + 1 ] = - y;\r\n\r\n\t\t\tnormals[ offset + 2 ] = 1;\r\n\r\n\t\t\tuvs[ offset2 ] = ix / gridX;\r\n\t\t\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\r\n\r\n\t\t\toffset += 3;\r\n\t\t\toffset2 += 2;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\toffset = 0;\r\n\r\n\tvar indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\r\n\r\n\tfor ( var iy = 0; iy < gridY; iy ++ ) {\r\n\r\n\t\tfor ( var ix = 0; ix < gridX; ix ++ ) {\r\n\r\n\t\t\tvar a = ix + gridX1 * iy;\r\n\t\t\tvar b = ix + gridX1 * ( iy + 1 );\r\n\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\r\n\r\n\t\t\tindices[ offset ] = a;\r\n\t\t\tindices[ offset + 1 ] = b;\r\n\t\t\tindices[ offset + 2 ] = d;\r\n\r\n\t\t\tindices[ offset + 3 ] = b;\r\n\t\t\tindices[ offset + 4 ] = c;\r\n\t\t\tindices[ offset + 5 ] = d;\r\n\r\n\t\t\toffset += 6;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n};\r\n\r\nTHREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;\r\n\r\n// File:src/extras/geometries/RingBufferGeometry.js\r\n\r\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n\r\nTHREE.RingBufferGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'RingBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tinnerRadius: innerRadius,\r\n\t\touterRadius: outerRadius,\r\n\t\tthetaSegments: thetaSegments,\r\n\t\tphiSegments: phiSegments,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tinnerRadius = innerRadius || 20;\r\n\touterRadius = outerRadius || 50;\r\n\r\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\r\n\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\r\n\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\r\n\r\n\t// these are used to calculate buffer length\r\n\tvar vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );\r\n\tvar indexCount = thetaSegments * phiSegments * 2 * 3;\r\n\r\n\t// buffers\r\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\r\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\r\n\t// some helper variables\r\n\tvar index = 0, indexOffset = 0, segment;\r\n\tvar radius = innerRadius;\r\n\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\r\n\tvar vertex = new THREE.Vector3();\r\n\tvar uv = new THREE.Vector2();\r\n\tvar j, i;\r\n\r\n\t// generate vertices, normals and uvs\r\n\r\n\t// values are generate from the inside of the ring to the outside\r\n\r\n\tfor ( j = 0; j <= phiSegments; j ++ ) {\r\n\r\n\t\tfor ( i = 0; i <= thetaSegments; i ++ ) {\r\n\r\n\t\t\tsegment = thetaStart + i / thetaSegments * thetaLength;\r\n\r\n\t\t\t// vertex\r\n\t\t\tvertex.x = radius * Math.cos( segment );\r\n\t\t\tvertex.y = radius * Math.sin( segment );\r\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t// normal\r\n\t\t\tnormals.setXYZ( index, 0, 0, 1 );\r\n\r\n\t\t\t// uv\r\n\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\r\n\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\r\n\t\t\tuvs.setXY( index, uv.x, uv.y );\r\n\r\n\t\t\t// increase index\r\n\t\t\tindex++;\r\n\r\n\t\t}\r\n\r\n\t\t// increase the radius for next row of vertices\r\n\t\tradius += radiusStep;\r\n\r\n\t}\r\n\r\n\t// generate indices\r\n\r\n\tfor ( j = 0; j < phiSegments; j ++ ) {\r\n\r\n\t\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\r\n\r\n\t\tfor ( i = 0; i < thetaSegments; i ++ ) {\r\n\r\n\t\t\tsegment = i + thetaSegmentLevel;\r\n\r\n\t\t\t// indices\r\n\t\t\tvar a = segment;\r\n\t\t\tvar b = segment + thetaSegments + 1;\r\n\t\t\tvar c = segment + thetaSegments + 2;\r\n\t\t\tvar d = segment + 1;\r\n\r\n\t\t\t// face one\r\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\r\n\t\t\t// face two\r\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.setIndex( indices );\r\n\tthis.addAttribute( 'position', vertices );\r\n\tthis.addAttribute( 'normal', normals );\r\n\tthis.addAttribute( 'uv', uvs );\r\n\r\n};\r\n\r\nTHREE.RingBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.RingBufferGeometry.prototype.constructor = THREE.RingBufferGeometry;\r\n\r\n// File:src/extras/geometries/RingGeometry.js\r\n\r\n/**\r\n * @author Kaleb Murphy\r\n */\r\n\r\nTHREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'RingGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tinnerRadius: innerRadius,\r\n\t\touterRadius: outerRadius,\r\n\t\tthetaSegments: thetaSegments,\r\n\t\tphiSegments: phiSegments,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new THREE.RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\r\n\r\n};\r\n\r\nTHREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.RingGeometry.prototype.constructor = THREE.RingGeometry;\r\n\r\n// File:src/extras/geometries/SphereGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'SphereGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\tphiStart: phiStart,\r\n\t\tphiLength: phiLength,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\r\n\r\n};\r\n\r\nTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;\r\n\r\n// File:src/extras/geometries/SphereBufferGeometry.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n * based on THREE.SphereGeometry\r\n */\r\n\r\nTHREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'SphereBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\tphiStart: phiStart,\r\n\t\tphiLength: phiLength,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tradius = radius || 50;\r\n\r\n\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\r\n\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\r\n\r\n\tphiStart = phiStart !== undefined ? phiStart : 0;\r\n\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\r\n\r\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\r\n\r\n\tvar thetaEnd = thetaStart + thetaLength;\r\n\r\n\tvar vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );\r\n\r\n\tvar positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\r\n\tvar index = 0, vertices = [], normal = new THREE.Vector3();\r\n\r\n\tfor ( var y = 0; y <= heightSegments; y ++ ) {\r\n\r\n\t\tvar verticesRow = [];\r\n\r\n\t\tvar v = y / heightSegments;\r\n\r\n\t\tfor ( var x = 0; x <= widthSegments; x ++ ) {\r\n\r\n\t\t\tvar u = x / widthSegments;\r\n\r\n\t\t\tvar px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\t\t\tvar py = radius * Math.cos( thetaStart + v * thetaLength );\r\n\t\t\tvar pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\r\n\t\t\tnormal.set( px, py, pz ).normalize();\r\n\r\n\t\t\tpositions.setXYZ( index, px, py, pz );\r\n\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\r\n\t\t\tuvs.setXY( index, u, 1 - v );\r\n\r\n\t\t\tverticesRow.push( index );\r\n\r\n\t\t\tindex ++;\r\n\r\n\t\t}\r\n\r\n\t\tvertices.push( verticesRow );\r\n\r\n\t}\r\n\r\n\tvar indices = [];\r\n\r\n\tfor ( var y = 0; y < heightSegments; y ++ ) {\r\n\r\n\t\tfor ( var x = 0; x < widthSegments; x ++ ) {\r\n\r\n\t\t\tvar v1 = vertices[ y ][ x + 1 ];\r\n\t\t\tvar v2 = vertices[ y ][ x ];\r\n\t\t\tvar v3 = vertices[ y + 1 ][ x ];\r\n\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\r\n\r\n\t\t\tif ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );\r\n\t\t\tif ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.setIndex( new ( positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute )( indices, 1 ) );\r\n\tthis.addAttribute( 'position', positions );\r\n\tthis.addAttribute( 'normal', normals );\r\n\tthis.addAttribute( 'uv', uvs );\r\n\r\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;\r\n\r\n// File:src/extras/geometries/TextGeometry.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * Text = 3D Text\r\n *\r\n * parameters = {\r\n *  font: <THREE.Font>, // font\r\n *\r\n *  size: <float>, // size of the text\r\n *  height: <float>, // thickness to extrude text\r\n *  curveSegments: <int>, // number of points on the curves\r\n *\r\n *  bevelEnabled: <bool>, // turn on bevel\r\n *  bevelThickness: <float>, // how deep into text bevel goes\r\n *  bevelSize: <float> // how far from text outline is bevel\r\n * }\r\n */\r\n\r\nTHREE.TextGeometry = function ( text, parameters ) {\r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar font = parameters.font;\r\n\r\n\tif ( font instanceof THREE.Font === false ) {\r\n\r\n\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\r\n\t\treturn new THREE.Geometry();\r\n\r\n\t}\r\n\r\n\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\r\n\r\n\t// translate parameters to ExtrudeGeometry API\r\n\r\n\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\r\n\r\n\t// defaults\r\n\r\n\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\r\n\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\r\n\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\r\n\r\n\tTHREE.ExtrudeGeometry.call( this, shapes, parameters );\r\n\r\n\tthis.type = 'TextGeometry';\r\n\r\n};\r\n\r\nTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\r\nTHREE.TextGeometry.prototype.constructor = THREE.TextGeometry;\r\n\r\n// File:src/extras/geometries/TorusBufferGeometry.js\r\n\r\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n\r\nTHREE.TorusBufferGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'TorusBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\ttube: tube,\r\n\t\tradialSegments: radialSegments,\r\n\t\ttubularSegments: tubularSegments,\r\n\t\tarc: arc\r\n\t};\r\n\r\n\tradius = radius || 100;\r\n\ttube = tube || 40;\r\n\tradialSegments = Math.floor( radialSegments ) || 8;\r\n\ttubularSegments = Math.floor( tubularSegments ) || 6;\r\n\tarc = arc || Math.PI * 2;\r\n\r\n\t// used to calculate buffer length\r\n\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\r\n\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\r\n\r\n\t// buffers\r\n\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\r\n\tvar vertices = new Float32Array( vertexCount * 3 );\r\n\tvar normals = new Float32Array( vertexCount * 3 );\r\n\tvar uvs = new Float32Array( vertexCount * 2 );\r\n\r\n\t// offset variables\r\n\tvar vertexBufferOffset = 0;\r\n\tvar uvBufferOffset = 0;\r\n\tvar indexBufferOffset = 0;\r\n\r\n\t// helper variables\r\n\tvar center = new THREE.Vector3();\r\n\tvar vertex = new THREE.Vector3();\r\n\tvar normal = new THREE.Vector3();\r\n\r\n\tvar j, i;\r\n\r\n\t// generate vertices, normals and uvs\r\n\r\n\tfor ( j = 0; j <= radialSegments; j ++ ) {\r\n\r\n\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\r\n\r\n\t\t\tvar u = i / tubularSegments * arc;\r\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\r\n\r\n\t\t\t// vertex\r\n\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\r\n\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\r\n\t\t\tvertex.z = tube * Math.sin( v );\r\n\r\n\t\t\tvertices[ vertexBufferOffset ] = vertex.x;\r\n\t\t\tvertices[ vertexBufferOffset + 1 ] = vertex.y;\r\n\t\t\tvertices[ vertexBufferOffset + 2 ] = vertex.z;\r\n\r\n\t\t\t// this vector is used to calculate the normal\r\n\t\t\tcenter.x = radius * Math.cos( u );\r\n\t\t\tcenter.y = radius * Math.sin( u );\r\n\r\n\t\t\t// normal\r\n\t\t\tnormal.subVectors( vertex, center ).normalize();\r\n\r\n\t\t\tnormals[ vertexBufferOffset ] = normal.x;\r\n\t\t\tnormals[ vertexBufferOffset + 1 ] = normal.y;\r\n\t\t\tnormals[ vertexBufferOffset + 2 ] = normal.z;\r\n\r\n\t\t\t// uv\r\n\t\t\tuvs[ uvBufferOffset ] = i / tubularSegments;\r\n\t\t\tuvs[ uvBufferOffset + 1 ] = j / radialSegments;\r\n\r\n\t\t\t// update offsets\r\n\t\t\tvertexBufferOffset += 3;\r\n\t\t\tuvBufferOffset += 2;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// generate indices\r\n\r\n\tfor ( j = 1; j <= radialSegments; j ++ ) {\r\n\r\n\t\tfor ( i = 1; i <= tubularSegments; i ++ ) {\r\n\r\n\t\t\t// indices\r\n\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\r\n\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\r\n\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\r\n\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\r\n\r\n\t\t\t// face one\r\n\t\t\tindices[ indexBufferOffset ] = a;\r\n\t\t\tindices[ indexBufferOffset + 1 ] = b;\r\n\t\t\tindices[ indexBufferOffset + 2 ] = d;\r\n\r\n\t\t\t// face two\r\n\t\t\tindices[ indexBufferOffset + 3 ] = b;\r\n\t\t\tindices[ indexBufferOffset + 4 ] = c;\r\n\t\t\tindices[ indexBufferOffset + 5 ] = d;\r\n\r\n\t\t\t// update offset\r\n\t\t\tindexBufferOffset += 6;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n};\r\n\r\nTHREE.TorusBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.TorusBufferGeometry.prototype.constructor = THREE.TorusBufferGeometry;\r\n\r\n// File:src/extras/geometries/TorusGeometry.js\r\n\r\n/**\r\n * @author oosmoxiecode\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\r\n */\r\n\r\nTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'TorusGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\ttube: tube,\r\n\t\tradialSegments: radialSegments,\r\n\t\ttubularSegments: tubularSegments,\r\n\t\tarc: arc\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new THREE.TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\r\n\r\n};\r\n\r\nTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;\r\n\r\n// File:src/extras/geometries/TorusKnotBufferGeometry.js\r\n\r\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n *\r\n * see: http://www.blackpawn.com/texts/pqtorus/\r\n */\r\nTHREE.TorusKnotBufferGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'TorusKnotBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\ttube: tube,\r\n\t\ttubularSegments: tubularSegments,\r\n\t\tradialSegments: radialSegments,\r\n\t\tp: p,\r\n\t\tq: q\r\n\t};\r\n\r\n\tradius = radius || 100;\r\n\ttube = tube || 40;\r\n\ttubularSegments = Math.floor( tubularSegments ) || 64;\r\n\tradialSegments = Math.floor( radialSegments ) || 8;\r\n\tp = p || 2;\r\n\tq = q || 3;\r\n\r\n\t// used to calculate buffer length\r\n\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\r\n\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\r\n\r\n\t// buffers\r\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\r\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\r\n\t// helper variables\r\n\tvar i, j, index = 0, indexOffset = 0;\r\n\r\n\tvar vertex = new THREE.Vector3();\r\n\tvar normal = new THREE.Vector3();\r\n\tvar uv = new THREE.Vector2();\r\n\r\n\tvar P1 = new THREE.Vector3();\r\n\tvar P2 = new THREE.Vector3();\r\n\r\n\tvar B = new THREE.Vector3();\r\n\tvar T = new THREE.Vector3();\r\n\tvar N = new THREE.Vector3();\r\n\r\n\t// generate vertices, normals and uvs\r\n\r\n\tfor ( i = 0; i <= tubularSegments; ++ i ) {\r\n\r\n\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\r\n\r\n\t\tvar u = i / tubularSegments * p * Math.PI * 2;\r\n\r\n\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\r\n\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\r\n\r\n\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\r\n\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\r\n\r\n\t\t// calculate orthonormal basis\r\n\r\n\t\tT.subVectors( P2, P1 );\r\n\t\tN.addVectors( P2, P1 );\r\n\t\tB.crossVectors( T, N );\r\n\t\tN.crossVectors( B, T );\r\n\r\n\t\t// normalize B, N. T can be ignored, we don't use it\r\n\r\n\t\tB.normalize();\r\n\t\tN.normalize();\r\n\r\n\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\r\n\r\n\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\r\n\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\r\n\r\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\r\n\t\t\tvar cx = - tube * Math.cos( v );\r\n\t\t\tvar cy = tube * Math.sin( v );\r\n\r\n\t\t\t// now calculate the final vertex position.\r\n\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\r\n\r\n\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\r\n\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\r\n\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\r\n\r\n\t\t\t// vertex\r\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\r\n\t\t\tnormal.subVectors( vertex, P1 ).normalize();\r\n\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\r\n\r\n\t\t\t// uv\r\n\t\t\tuv.x = i / tubularSegments;\r\n\t\t\tuv.y = j / radialSegments;\r\n\t\t\tuvs.setXY( index, uv.x, uv.y );\r\n\r\n\t\t\t// increase index\r\n\t\t\tindex ++;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// generate indices\r\n\r\n\tfor ( j = 1; j <= tubularSegments; j ++ ) {\r\n\r\n\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\r\n\r\n\t\t\t// indices\r\n\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\r\n\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\r\n\t\t\tvar c = ( radialSegments + 1 ) * j + i;\r\n\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\r\n\r\n\t\t\t// face one\r\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\r\n\t\t\t// face two\r\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.setIndex( indices );\r\n\tthis.addAttribute( 'position', vertices );\r\n\tthis.addAttribute( 'normal', normals );\r\n\tthis.addAttribute( 'uv', uvs );\r\n\r\n\t// this function calculates the current position on the torus curve\r\n\r\n\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\r\n\r\n\t\tvar cu = Math.cos( u );\r\n\t\tvar su = Math.sin( u );\r\n\t\tvar quOverP = q / p * u;\r\n\t\tvar cs = Math.cos( quOverP );\r\n\r\n\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\r\n\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\r\n\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.TorusKnotBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.TorusKnotBufferGeometry.prototype.constructor = THREE.TorusKnotBufferGeometry;\r\n\r\n// File:src/extras/geometries/TorusKnotGeometry.js\r\n\r\n/**\r\n * @author oosmoxiecode\r\n */\r\n\r\nTHREE.TorusKnotGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'TorusKnotGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\ttube: tube,\r\n\t\ttubularSegments: tubularSegments,\r\n\t\tradialSegments: radialSegments,\r\n\t\tp: p,\r\n\t\tq: q\r\n\t};\r\n\r\n\tif( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\r\n\r\n\tthis.fromBufferGeometry( new THREE.TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\r\n\tthis.mergeVertices();\r\n\r\n};\r\n\r\nTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;\r\n\r\n// File:src/extras/geometries/TubeGeometry.js\r\n\r\n/**\r\n * @author WestLangley / https://github.com/WestLangley\r\n * @author zz85 / https://github.com/zz85\r\n * @author miningold / https://github.com/miningold\r\n * @author jonobr1 / https://github.com/jonobr1\r\n *\r\n * Modified from the TorusKnotGeometry by @oosmoxiecode\r\n *\r\n * Creates a tube which extrudes along a 3d spline\r\n *\r\n * Uses parallel transport frames as described in\r\n * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\r\n */\r\n\r\nTHREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'TubeGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tpath: path,\r\n\t\tsegments: segments,\r\n\t\tradius: radius,\r\n\t\tradialSegments: radialSegments,\r\n\t\tclosed: closed,\r\n\t\ttaper: taper\r\n\t};\r\n\r\n\tsegments = segments || 64;\r\n\tradius = radius || 1;\r\n\tradialSegments = radialSegments || 8;\r\n\tclosed = closed || false;\r\n\ttaper = taper || THREE.TubeGeometry.NoTaper;\r\n\r\n\tvar grid = [];\r\n\r\n\tvar scope = this,\r\n\r\n\t\ttangent,\r\n\t\tnormal,\r\n\t\tbinormal,\r\n\r\n\t\tnumpoints = segments + 1,\r\n\r\n\t\tu, v, r,\r\n\r\n\t\tcx, cy,\r\n\t\tpos, pos2 = new THREE.Vector3(),\r\n\t\ti, j,\r\n\t\tip, jp,\r\n\t\ta, b, c, d,\r\n\t\tuva, uvb, uvc, uvd;\r\n\r\n\tvar frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),\r\n\t\ttangents = frames.tangents,\r\n\t\tnormals = frames.normals,\r\n\t\tbinormals = frames.binormals;\r\n\r\n\t// proxy internals\r\n\tthis.tangents = tangents;\r\n\tthis.normals = normals;\r\n\tthis.binormals = binormals;\r\n\r\n\tfunction vert( x, y, z ) {\r\n\r\n\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\r\n\r\n\t}\r\n\r\n\t// construct the grid\r\n\r\n\tfor ( i = 0; i < numpoints; i ++ ) {\r\n\r\n\t\tgrid[ i ] = [];\r\n\r\n\t\tu = i / ( numpoints - 1 );\r\n\r\n\t\tpos = path.getPointAt( u );\r\n\r\n\t\ttangent = tangents[ i ];\r\n\t\tnormal = normals[ i ];\r\n\t\tbinormal = binormals[ i ];\r\n\r\n\t\tr = radius * taper( u );\r\n\r\n\t\tfor ( j = 0; j < radialSegments; j ++ ) {\r\n\r\n\t\t\tv = j / radialSegments * 2 * Math.PI;\r\n\r\n\t\t\tcx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\r\n\t\t\tcy = r * Math.sin( v );\r\n\r\n\t\t\tpos2.copy( pos );\r\n\t\t\tpos2.x += cx * normal.x + cy * binormal.x;\r\n\t\t\tpos2.y += cx * normal.y + cy * binormal.y;\r\n\t\t\tpos2.z += cx * normal.z + cy * binormal.z;\r\n\r\n\t\t\tgrid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// construct the mesh\r\n\r\n\tfor ( i = 0; i < segments; i ++ ) {\r\n\r\n\t\tfor ( j = 0; j < radialSegments; j ++ ) {\r\n\r\n\t\t\tip = ( closed ) ? ( i + 1 ) % segments : i + 1;\r\n\t\t\tjp = ( j + 1 ) % radialSegments;\r\n\r\n\t\t\ta = grid[ i ][ j ];\t\t// *** NOT NECESSARILY PLANAR ! ***\r\n\t\t\tb = grid[ ip ][ j ];\r\n\t\t\tc = grid[ ip ][ jp ];\r\n\t\t\td = grid[ i ][ jp ];\r\n\r\n\t\t\tuva = new THREE.Vector2( i / segments, j / radialSegments );\r\n\t\t\tuvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );\r\n\t\t\tuvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );\r\n\t\t\tuvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;\r\n\r\nTHREE.TubeGeometry.NoTaper = function ( u ) {\r\n\r\n\treturn 1;\r\n\r\n};\r\n\r\nTHREE.TubeGeometry.SinusoidalTaper = function ( u ) {\r\n\r\n\treturn Math.sin( Math.PI * u );\r\n\r\n};\r\n\r\n// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\r\nTHREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {\r\n\r\n\tvar\tnormal = new THREE.Vector3(),\r\n\r\n\t\ttangents = [],\r\n\t\tnormals = [],\r\n\t\tbinormals = [],\r\n\r\n\t\tvec = new THREE.Vector3(),\r\n\t\tmat = new THREE.Matrix4(),\r\n\r\n\t\tnumpoints = segments + 1,\r\n\t\ttheta,\r\n\t\tsmallest,\r\n\r\n\t\ttx, ty, tz,\r\n\t\ti, u;\r\n\r\n\r\n\t// expose internals\r\n\tthis.tangents = tangents;\r\n\tthis.normals = normals;\r\n\tthis.binormals = binormals;\r\n\r\n\t// compute the tangent vectors for each segment on the path\r\n\r\n\tfor ( i = 0; i < numpoints; i ++ ) {\r\n\r\n\t\tu = i / ( numpoints - 1 );\r\n\r\n\t\ttangents[ i ] = path.getTangentAt( u );\r\n\t\ttangents[ i ].normalize();\r\n\r\n\t}\r\n\r\n\tinitialNormal3();\r\n\r\n\t/*\r\n\tfunction initialNormal1(lastBinormal) {\r\n\t\t// fixed start binormal. Has dangers of 0 vectors\r\n\t\tnormals[ 0 ] = new THREE.Vector3();\r\n\t\tbinormals[ 0 ] = new THREE.Vector3();\r\n\t\tif (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\r\n\t\tnormals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\t}\r\n\r\n\tfunction initialNormal2() {\r\n\r\n\t\t// This uses the Frenet-Serret formula for deriving binormal\r\n\t\tvar t2 = path.getTangentAt( epsilon );\r\n\r\n\t\tnormals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\r\n\t\tbinormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\r\n\t\tnormals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\r\n\t}\r\n\t*/\r\n\r\n\tfunction initialNormal3() {\r\n\r\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\r\n\t\t// and in the direction of the smallest tangent xyz component\r\n\r\n\t\tnormals[ 0 ] = new THREE.Vector3();\r\n\t\tbinormals[ 0 ] = new THREE.Vector3();\r\n\t\tsmallest = Number.MAX_VALUE;\r\n\t\ttx = Math.abs( tangents[ 0 ].x );\r\n\t\tty = Math.abs( tangents[ 0 ].y );\r\n\t\ttz = Math.abs( tangents[ 0 ].z );\r\n\r\n\t\tif ( tx <= smallest ) {\r\n\r\n\t\t\tsmallest = tx;\r\n\t\t\tnormal.set( 1, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ty <= smallest ) {\r\n\r\n\t\t\tsmallest = ty;\r\n\t\t\tnormal.set( 0, 1, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( tz <= smallest ) {\r\n\r\n\t\t\tnormal.set( 0, 0, 1 );\r\n\r\n\t\t}\r\n\r\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\r\n\r\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\r\n\t}\r\n\r\n\r\n\t// compute the slowly-varying normal and binormal vectors for each segment on the path\r\n\r\n\tfor ( i = 1; i < numpoints; i ++ ) {\r\n\r\n\t\tnormals[ i ] = normals[ i - 1 ].clone();\r\n\r\n\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\r\n\r\n\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\r\n\r\n\t\tif ( vec.length() > Number.EPSILON ) {\r\n\r\n\t\t\tvec.normalize();\r\n\r\n\t\t\ttheta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\r\n\r\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\r\n\r\n\t\t}\r\n\r\n\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n\t}\r\n\r\n\r\n\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\r\n\r\n\tif ( closed ) {\r\n\r\n\t\ttheta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );\r\n\t\ttheta /= ( numpoints - 1 );\r\n\r\n\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {\r\n\r\n\t\t\ttheta = - theta;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = 1; i < numpoints; i ++ ) {\r\n\r\n\t\t\t// twist a little...\r\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\r\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/geometries/PolyhedronGeometry.js\r\n\r\n/**\r\n * @author clockworkgeek / https://github.com/clockworkgeek\r\n * @author timothypratley / https://github.com/timothypratley\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'PolyhedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tvertices: vertices,\r\n\t\tindices: indices,\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n\tradius = radius || 1;\r\n\tdetail = detail || 0;\r\n\r\n\tvar that = this;\r\n\r\n\tfor ( var i = 0, l = vertices.length; i < l; i += 3 ) {\r\n\r\n\t\tprepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );\r\n\r\n\t}\r\n\r\n\tvar p = this.vertices;\r\n\r\n\tvar faces = [];\r\n\r\n\tfor ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {\r\n\r\n\t\tvar v1 = p[ indices[ i ] ];\r\n\t\tvar v2 = p[ indices[ i + 1 ] ];\r\n\t\tvar v3 = p[ indices[ i + 2 ] ];\r\n\r\n\t\tfaces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, j );\r\n\r\n\t}\r\n\r\n\tvar centroid = new THREE.Vector3();\r\n\r\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\tsubdivide( faces[ i ], detail );\r\n\r\n\t}\r\n\r\n\r\n\t// Handle case when face straddles the seam\r\n\r\n\tfor ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {\r\n\r\n\t\tvar uvs = this.faceVertexUvs[ 0 ][ i ];\r\n\r\n\t\tvar x0 = uvs[ 0 ].x;\r\n\t\tvar x1 = uvs[ 1 ].x;\r\n\t\tvar x2 = uvs[ 2 ].x;\r\n\r\n\t\tvar max = Math.max( x0, x1, x2 );\r\n\t\tvar min = Math.min( x0, x1, x2 );\r\n\r\n\t\tif ( max > 0.9 && min < 0.1 ) {\r\n\r\n\t\t\t// 0.9 is somewhat arbitrary\r\n\r\n\t\t\tif ( x0 < 0.2 ) uvs[ 0 ].x += 1;\r\n\t\t\tif ( x1 < 0.2 ) uvs[ 1 ].x += 1;\r\n\t\t\tif ( x2 < 0.2 ) uvs[ 2 ].x += 1;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// Apply radius\r\n\r\n\tfor ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\r\n\r\n\t\tthis.vertices[ i ].multiplyScalar( radius );\r\n\r\n\t}\r\n\r\n\r\n\t// Merge vertices\r\n\r\n\tthis.mergeVertices();\r\n\r\n\tthis.computeFaceNormals();\r\n\r\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n\r\n\t// Project vector onto sphere's surface\r\n\r\n\tfunction prepare( vector ) {\r\n\r\n\t\tvar vertex = vector.normalize().clone();\r\n\t\tvertex.index = that.vertices.push( vertex ) - 1;\r\n\r\n\t\t// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\r\n\r\n\t\tvar u = azimuth( vector ) / 2 / Math.PI + 0.5;\r\n\t\tvar v = inclination( vector ) / Math.PI + 0.5;\r\n\t\tvertex.uv = new THREE.Vector2( u, 1 - v );\r\n\r\n\t\treturn vertex;\r\n\r\n\t}\r\n\r\n\r\n\t// Approximate a curved face with recursively sub-divided triangles.\r\n\r\n\tfunction make( v1, v2, v3, materialIndex ) {\r\n\r\n\t\tvar face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, materialIndex );\r\n\t\tthat.faces.push( face );\r\n\r\n\t\tcentroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\r\n\r\n\t\tvar azi = azimuth( centroid );\r\n\r\n\t\tthat.faceVertexUvs[ 0 ].push( [\r\n\t\t\tcorrectUV( v1.uv, v1, azi ),\r\n\t\t\tcorrectUV( v2.uv, v2, azi ),\r\n\t\t\tcorrectUV( v3.uv, v3, azi )\r\n\t\t] );\r\n\r\n\t}\r\n\r\n\r\n\t// Analytically subdivide a face to the required detail level.\r\n\r\n\tfunction subdivide( face, detail ) {\r\n\r\n\t\tvar cols = Math.pow( 2, detail );\r\n\t\tvar a = prepare( that.vertices[ face.a ] );\r\n\t\tvar b = prepare( that.vertices[ face.b ] );\r\n\t\tvar c = prepare( that.vertices[ face.c ] );\r\n\t\tvar v = [];\r\n\r\n\t\tvar materialIndex = face.materialIndex;\r\n\r\n\t\t// Construct all of the vertices for this subdivision.\r\n\r\n\t\tfor ( var i = 0 ; i <= cols; i ++ ) {\r\n\r\n\t\t\tv[ i ] = [];\r\n\r\n\t\t\tvar aj = prepare( a.clone().lerp( c, i / cols ) );\r\n\t\t\tvar bj = prepare( b.clone().lerp( c, i / cols ) );\r\n\t\t\tvar rows = cols - i;\r\n\r\n\t\t\tfor ( var j = 0; j <= rows; j ++ ) {\r\n\r\n\t\t\t\tif ( j === 0 && i === cols ) {\r\n\r\n\t\t\t\t\tv[ i ][ j ] = aj;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tv[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Construct all of the faces.\r\n\r\n\t\tfor ( var i = 0; i < cols ; i ++ ) {\r\n\r\n\t\t\tfor ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\r\n\r\n\t\t\t\tvar k = Math.floor( j / 2 );\r\n\r\n\t\t\t\tif ( j % 2 === 0 ) {\r\n\r\n\t\t\t\t\tmake(\r\n\t\t\t\t\t\tv[ i ][ k + 1 ],\r\n\t\t\t\t\t\tv[ i + 1 ][ k ],\r\n\t\t\t\t\t\tv[ i ][ k ],\r\n\t\t\t\t\t\tmaterialIndex\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmake(\r\n\t\t\t\t\t\tv[ i ][ k + 1 ],\r\n\t\t\t\t\t\tv[ i + 1 ][ k + 1 ],\r\n\t\t\t\t\t\tv[ i + 1 ][ k ],\r\n\t\t\t\t\t\tmaterialIndex\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// Angle around the Y axis, counter-clockwise when looking from above.\r\n\r\n\tfunction azimuth( vector ) {\r\n\r\n\t\treturn Math.atan2( vector.z, - vector.x );\r\n\r\n\t}\r\n\r\n\r\n\t// Angle above the XZ plane.\r\n\r\n\tfunction inclination( vector ) {\r\n\r\n\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\r\n\r\n\t}\r\n\r\n\r\n\t// Texture fixing helper. Spheres have some odd behaviours.\r\n\r\n\tfunction correctUV( uv, vector, azimuth ) {\r\n\r\n\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\r\n\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\r\n\t\treturn uv.clone();\r\n\r\n\t}\r\n\r\n\r\n};\r\n\r\nTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;\r\n\r\n// File:src/extras/geometries/DodecahedronGeometry.js\r\n\r\n/**\r\n * @author Abe Pazos / https://hamoid.com\r\n */\r\n\r\nTHREE.DodecahedronGeometry = function ( radius, detail ) {\r\n\r\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\tvar r = 1 / t;\r\n\r\n\tvar vertices = [\r\n\r\n\t\t// (1, 1, 1)\r\n\t\t- 1, - 1, - 1,    - 1, - 1,  1,\r\n\t\t- 1,  1, - 1,    - 1,  1,  1,\r\n\t\t 1, - 1, - 1,     1, - 1,  1,\r\n\t\t 1,  1, - 1,     1,  1,  1,\r\n\r\n\t\t// (0, 1/, )\r\n\t\t 0, - r, - t,     0, - r,  t,\r\n\t\t 0,  r, - t,     0,  r,  t,\r\n\r\n\t\t// (1/, , 0)\r\n\t\t- r, - t,  0,    - r,  t,  0,\r\n\t\t r, - t,  0,     r,  t,  0,\r\n\r\n\t\t// (, 0, 1/)\r\n\t\t- t,  0, - r,     t,  0, - r,\r\n\t\t- t,  0,  r,     t,  0,  r\r\n\t];\r\n\r\n\tvar indices = [\r\n\t\t 3, 11,  7,      3,  7, 15,      3, 15, 13,\r\n\t\t 7, 19, 17,      7, 17,  6,      7,  6, 15,\r\n\t\t17,  4,  8,     17,  8, 10,     17, 10,  6,\r\n\t\t 8,  0, 16,      8, 16,  2,      8,  2, 10,\r\n\t\t 0, 12,  1,      0,  1, 18,      0, 18, 16,\r\n\t\t 6, 10,  2,      6,  2, 13,      6, 13, 15,\r\n\t\t 2, 16, 18,      2, 18,  3,      2,  3, 13,\r\n\t\t18,  1,  9,     18,  9, 11,     18, 11,  3,\r\n\t\t 4, 14, 12,      4, 12,  0,      4,  0,  8,\r\n\t\t11,  9,  5,     11,  5, 19,     11, 19,  7,\r\n\t\t19,  5, 14,     19, 14,  4,     19,  4, 17,\r\n\t\t 1, 12, 14,      1, 14,  5,      1,  5,  9\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n\tthis.type = 'DodecahedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n};\r\n\r\nTHREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\nTHREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;\r\n\r\n// File:src/extras/geometries/IcosahedronGeometry.js\r\n\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.IcosahedronGeometry = function ( radius, detail ) {\r\n\r\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\r\n\tvar vertices = [\r\n\t\t- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\r\n\t\t 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\r\n\t\t t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\r\n\t];\r\n\r\n\tvar indices = [\r\n\t\t 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\r\n\t\t 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\r\n\t\t 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\r\n\t\t 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n\tthis.type = 'IcosahedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n};\r\n\r\nTHREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\nTHREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;\r\n\r\n// File:src/extras/geometries/OctahedronGeometry.js\r\n\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.OctahedronGeometry = function ( radius, detail ) {\r\n\r\n\tvar vertices = [\r\n\t\t1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1\r\n\t];\r\n\r\n\tvar indices = [\r\n\t\t0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n\tthis.type = 'OctahedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n};\r\n\r\nTHREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\nTHREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;\r\n\r\n// File:src/extras/geometries/TetrahedronGeometry.js\r\n\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.TetrahedronGeometry = function ( radius, detail ) {\r\n\r\n\tvar vertices = [\r\n\t\t 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\r\n\t];\r\n\r\n\tvar indices = [\r\n\t\t 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n\tthis.type = 'TetrahedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n};\r\n\r\nTHREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\nTHREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;\r\n\r\n// File:src/extras/geometries/ParametricGeometry.js\r\n\r\n/**\r\n * @author zz85 / https://github.com/zz85\r\n * Parametric Surfaces Geometry\r\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\r\n *\r\n * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );\r\n *\r\n */\r\n\r\nTHREE.ParametricGeometry = function ( func, slices, stacks ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'ParametricGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tfunc: func,\r\n\t\tslices: slices,\r\n\t\tstacks: stacks\r\n\t};\r\n\r\n\tvar verts = this.vertices;\r\n\tvar faces = this.faces;\r\n\tvar uvs = this.faceVertexUvs[ 0 ];\r\n\r\n\tvar i, j, p;\r\n\tvar u, v;\r\n\r\n\tvar sliceCount = slices + 1;\r\n\r\n\tfor ( i = 0; i <= stacks; i ++ ) {\r\n\r\n\t\tv = i / stacks;\r\n\r\n\t\tfor ( j = 0; j <= slices; j ++ ) {\r\n\r\n\t\t\tu = j / slices;\r\n\r\n\t\t\tp = func( u, v );\r\n\t\t\tverts.push( p );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar a, b, c, d;\r\n\tvar uva, uvb, uvc, uvd;\r\n\r\n\tfor ( i = 0; i < stacks; i ++ ) {\r\n\r\n\t\tfor ( j = 0; j < slices; j ++ ) {\r\n\r\n\t\t\ta = i * sliceCount + j;\r\n\t\t\tb = i * sliceCount + j + 1;\r\n\t\t\tc = ( i + 1 ) * sliceCount + j + 1;\r\n\t\t\td = ( i + 1 ) * sliceCount + j;\r\n\r\n\t\t\tuva = new THREE.Vector2( j / slices, i / stacks );\r\n\t\t\tuvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\r\n\t\t\tuvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\r\n\t\t\tuvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\r\n\r\n\t\t\tfaces.push( new THREE.Face3( a, b, d ) );\r\n\t\t\tuvs.push( [ uva, uvb, uvd ] );\r\n\r\n\t\t\tfaces.push( new THREE.Face3( b, c, d ) );\r\n\t\t\tuvs.push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// console.log(this);\r\n\r\n\t// magic bullet\r\n\t// var diff = this.mergeVertices();\r\n\t// console.log('removed ', diff, ' vertices by merging');\r\n\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;\r\n\r\n// File:src/extras/geometries/WireframeGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.WireframeGeometry = function ( geometry ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tvar edge = [ 0, 0 ], hash = {};\r\n\r\n\tfunction sortFunction( a, b ) {\r\n\r\n\t\treturn a - b;\r\n\r\n\t}\r\n\r\n\tvar keys = [ 'a', 'b', 'c' ];\r\n\r\n\tif ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\tvar vertices = geometry.vertices;\r\n\t\tvar faces = geometry.faces;\r\n\t\tvar numEdges = 0;\r\n\r\n\t\t// allocate maximal size\r\n\t\tvar edges = new Uint32Array( 6 * faces.length );\r\n\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\r\n\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n\t\t\t\tedge.sort( sortFunction );\r\n\r\n\t\t\t\tvar key = edge.toString();\r\n\r\n\t\t\t\tif ( hash[ key ] === undefined ) {\r\n\r\n\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\r\n\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n\t\t\t\t\thash[ key ] = true;\r\n\t\t\t\t\tnumEdges ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\r\n\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\r\n\t\t\tfor ( var j = 0; j < 2; j ++ ) {\r\n\r\n\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j ] ];\r\n\r\n\t\t\t\tvar index = 6 * i + 3 * j;\r\n\t\t\t\tcoords[ index + 0 ] = vertex.x;\r\n\t\t\t\tcoords[ index + 1 ] = vertex.y;\r\n\t\t\t\tcoords[ index + 2 ] = vertex.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\r\n\t} else if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\tif ( geometry.index !== null ) {\r\n\r\n\t\t\t// Indexed BufferGeometry\r\n\r\n\t\t\tvar indices = geometry.index.array;\r\n\t\t\tvar vertices = geometry.attributes.position;\r\n\t\t\tvar groups = geometry.groups;\r\n\t\t\tvar numEdges = 0;\r\n\r\n\t\t\tif ( groups.length === 0 ) {\r\n\r\n\t\t\t\tgeometry.addGroup( 0, indices.length );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// allocate maximal size\r\n\t\t\tvar edges = new Uint32Array( 2 * indices.length );\r\n\r\n\t\t\tfor ( var o = 0, ol = groups.length; o < ol; ++ o ) {\r\n\r\n\t\t\t\tvar group = groups[ o ];\r\n\r\n\t\t\t\tvar start = group.start;\r\n\t\t\t\tvar count = group.count;\r\n\r\n\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\t\tedge[ 0 ] = indices[ i + j ];\r\n\t\t\t\t\t\tedge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];\r\n\t\t\t\t\t\tedge.sort( sortFunction );\r\n\r\n\t\t\t\t\t\tvar key = edge.toString();\r\n\r\n\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\r\n\r\n\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\r\n\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n\t\t\t\t\t\t\thash[ key ] = true;\r\n\t\t\t\t\t\t\tnumEdges ++;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\r\n\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\r\n\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\r\n\r\n\t\t\t\t\tvar index = 6 * i + 3 * j;\r\n\t\t\t\t\tvar index2 = edges[ 2 * i + j ];\r\n\r\n\t\t\t\t\tcoords[ index + 0 ] = vertices.getX( index2 );\r\n\t\t\t\t\tcoords[ index + 1 ] = vertices.getY( index2 );\r\n\t\t\t\t\tcoords[ index + 2 ] = vertices.getZ( index2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// non-indexed BufferGeometry\r\n\r\n\t\t\tvar vertices = geometry.attributes.position.array;\r\n\t\t\tvar numEdges = vertices.length / 3;\r\n\t\t\tvar numTris = numEdges / 3;\r\n\r\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\r\n\t\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\r\n\r\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\tvar index = 18 * i + 6 * j;\r\n\r\n\t\t\t\t\tvar index1 = 9 * i + 3 * j;\r\n\t\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\r\n\t\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\r\n\t\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\r\n\r\n\t\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\r\n\t\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\r\n\t\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\r\n\t\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;\r\n\r\n// File:src/extras/helpers/AxisHelper.js\r\n\r\n/**\r\n * @author sroucheray / http://sroucheray.org/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AxisHelper = function ( size ) {\r\n\r\n\tsize = size || 1;\r\n\r\n\tvar vertices = new Float32Array( [\r\n\t\t0, 0, 0,  size, 0, 0,\r\n\t\t0, 0, 0,  0, size, 0,\r\n\t\t0, 0, 0,  0, 0, size\r\n\t] );\r\n\r\n\tvar colors = new Float32Array( [\r\n\t\t1, 0, 0,  1, 0.6, 0,\r\n\t\t0, 1, 0,  0.6, 1, 0,\r\n\t\t0, 0, 1,  0, 0.6, 1\r\n\t] );\r\n\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\tgeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\r\n\r\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\r\n\tTHREE.LineSegments.call( this, geometry, material );\r\n\r\n};\r\n\r\nTHREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.AxisHelper.prototype.constructor = THREE.AxisHelper;\r\n\r\n// File:src/extras/helpers/ArrowHelper.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author zz85 / http://github.com/zz85\r\n * @author bhouston / http://clara.io\r\n *\r\n * Creates an arrow for visualizing directions\r\n *\r\n * Parameters:\r\n *  dir - Vector3\r\n *  origin - Vector3\r\n *  length - Number\r\n *  color - color in hex value\r\n *  headLength - Number\r\n *  headWidth - Number\r\n */\r\n\r\nTHREE.ArrowHelper = ( function () {\r\n\r\n\tvar lineGeometry = new THREE.Geometry();\r\n\tlineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );\r\n\r\n\tvar coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );\r\n\tconeGeometry.translate( 0, - 0.5, 0 );\r\n\r\n\treturn function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\r\n\r\n\t\t// dir is assumed to be normalized\r\n\r\n\t\tTHREE.Object3D.call( this );\r\n\r\n\t\tif ( color === undefined ) color = 0xffff00;\r\n\t\tif ( length === undefined ) length = 1;\r\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\r\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\r\n\t\tthis.position.copy( origin );\r\n\t\t\r\n\t\tthis.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );\r\n\t\tthis.line.matrixAutoUpdate = false;\r\n\t\tthis.add( this.line );\r\n\r\n\t\tthis.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );\r\n\t\tthis.cone.matrixAutoUpdate = false;\r\n\t\tthis.add( this.cone );\r\n\r\n\t\tthis.setDirection( dir );\r\n\t\tthis.setLength( length, headLength, headWidth );\r\n\r\n\t}\r\n\r\n}() );\r\n\r\nTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;\r\n\r\nTHREE.ArrowHelper.prototype.setDirection = ( function () {\r\n\r\n\tvar axis = new THREE.Vector3();\r\n\tvar radians;\r\n\r\n\treturn function setDirection( dir ) {\r\n\r\n\t\t// dir is assumed to be normalized\r\n\r\n\t\tif ( dir.y > 0.99999 ) {\r\n\r\n\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\r\n\r\n\t\t} else if ( dir.y < - 0.99999 ) {\r\n\r\n\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\r\n\r\n\t\t\tradians = Math.acos( dir.y );\r\n\r\n\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}() );\r\n\r\nTHREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\r\n\r\n\tif ( headLength === undefined ) headLength = 0.2 * length;\r\n\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\r\n\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\r\n\tthis.line.updateMatrix();\r\n\r\n\tthis.cone.scale.set( headWidth, headLength, headWidth );\r\n\tthis.cone.position.y = length;\r\n\tthis.cone.updateMatrix();\r\n\r\n};\r\n\r\nTHREE.ArrowHelper.prototype.setColor = function ( color ) {\r\n\r\n\tthis.line.material.color.set( color );\r\n\tthis.cone.material.color.set( color );\r\n\r\n};\r\n\r\n// File:src/extras/helpers/BoxHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BoxHelper = function ( object ) {\r\n\r\n\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\r\n\tvar positions = new Float32Array( 8 * 3 );\r\n\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\r\n\r\n\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ) );\r\n\r\n\tif ( object !== undefined ) {\r\n\r\n\t\tthis.update( object );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.BoxHelper.prototype.constructor = THREE.BoxHelper;\r\n\r\nTHREE.BoxHelper.prototype.update = ( function () {\r\n\r\n\tvar box = new THREE.Box3();\r\n\r\n\treturn function ( object ) {\r\n\r\n\t\tbox.setFromObject( object );\r\n\r\n\t\tif ( box.isEmpty() ) return;\r\n\r\n\t\tvar min = box.min;\r\n\t\tvar max = box.max;\r\n\r\n\t\t/*\r\n\t\t  5____4\r\n\t\t1/___0/|\r\n\t\t| 6__|_7\r\n\t\t2/___3/\r\n\r\n\t\t0: max.x, max.y, max.z\r\n\t\t1: min.x, max.y, max.z\r\n\t\t2: min.x, min.y, max.z\r\n\t\t3: max.x, min.y, max.z\r\n\t\t4: max.x, max.y, min.z\r\n\t\t5: min.x, max.y, min.z\r\n\t\t6: min.x, min.y, min.z\r\n\t\t7: max.x, min.y, min.z\r\n\t\t*/\r\n\r\n\t\tvar position = this.geometry.attributes.position;\r\n\t\tvar array = position.array;\r\n\r\n\t\tarray[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;\r\n\t\tarray[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;\r\n\t\tarray[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;\r\n\t\tarray[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\r\n\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\r\n\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\r\n\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\r\n\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\r\n\r\n\t\tposition.needsUpdate = true;\r\n\r\n\t\tthis.geometry.computeBoundingSphere();\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n// File:src/extras/helpers/BoundingBoxHelper.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\n// a helper to show the world-axis-aligned bounding box for an object\r\n\r\nTHREE.BoundingBoxHelper = function ( object, hex ) {\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0x888888;\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.box = new THREE.Box3();\r\n\r\n\tTHREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );\r\n\r\n};\r\n\r\nTHREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;\r\n\r\nTHREE.BoundingBoxHelper.prototype.update = function () {\r\n\r\n\tthis.box.setFromObject( this.object );\r\n\r\n\tthis.box.size( this.scale );\r\n\r\n\tthis.box.center( this.position );\r\n\r\n};\r\n\r\n// File:src/extras/helpers/CameraHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n *\t- shows frustum, line of sight and up of the camera\r\n *\t- suitable for fast updates\r\n * \t- based on frustum visualization in lightgl.js shadowmap example\r\n *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\r\n */\r\n\r\nTHREE.CameraHelper = function ( camera ) {\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\tvar material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\r\n\r\n\tvar pointMap = {};\r\n\r\n\t// colors\r\n\r\n\tvar hexFrustum = 0xffaa00;\r\n\tvar hexCone = 0xff0000;\r\n\tvar hexUp = 0x00aaff;\r\n\tvar hexTarget = 0xffffff;\r\n\tvar hexCross = 0x333333;\r\n\r\n\t// near\r\n\r\n\taddLine( \"n1\", \"n2\", hexFrustum );\r\n\taddLine( \"n2\", \"n4\", hexFrustum );\r\n\taddLine( \"n4\", \"n3\", hexFrustum );\r\n\taddLine( \"n3\", \"n1\", hexFrustum );\r\n\r\n\t// far\r\n\r\n\taddLine( \"f1\", \"f2\", hexFrustum );\r\n\taddLine( \"f2\", \"f4\", hexFrustum );\r\n\taddLine( \"f4\", \"f3\", hexFrustum );\r\n\taddLine( \"f3\", \"f1\", hexFrustum );\r\n\r\n\t// sides\r\n\r\n\taddLine( \"n1\", \"f1\", hexFrustum );\r\n\taddLine( \"n2\", \"f2\", hexFrustum );\r\n\taddLine( \"n3\", \"f3\", hexFrustum );\r\n\taddLine( \"n4\", \"f4\", hexFrustum );\r\n\r\n\t// cone\r\n\r\n\taddLine( \"p\", \"n1\", hexCone );\r\n\taddLine( \"p\", \"n2\", hexCone );\r\n\taddLine( \"p\", \"n3\", hexCone );\r\n\taddLine( \"p\", \"n4\", hexCone );\r\n\r\n\t// up\r\n\r\n\taddLine( \"u1\", \"u2\", hexUp );\r\n\taddLine( \"u2\", \"u3\", hexUp );\r\n\taddLine( \"u3\", \"u1\", hexUp );\r\n\r\n\t// target\r\n\r\n\taddLine( \"c\", \"t\", hexTarget );\r\n\taddLine( \"p\", \"c\", hexCross );\r\n\r\n\t// cross\r\n\r\n\taddLine( \"cn1\", \"cn2\", hexCross );\r\n\taddLine( \"cn3\", \"cn4\", hexCross );\r\n\r\n\taddLine( \"cf1\", \"cf2\", hexCross );\r\n\taddLine( \"cf3\", \"cf4\", hexCross );\r\n\r\n\tfunction addLine( a, b, hex ) {\r\n\r\n\t\taddPoint( a, hex );\r\n\t\taddPoint( b, hex );\r\n\r\n\t}\r\n\r\n\tfunction addPoint( id, hex ) {\r\n\r\n\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\tgeometry.colors.push( new THREE.Color( hex ) );\r\n\r\n\t\tif ( pointMap[ id ] === undefined ) {\r\n\r\n\t\t\tpointMap[ id ] = [];\r\n\r\n\t\t}\r\n\r\n\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\r\n\r\n\t}\r\n\r\n\tTHREE.LineSegments.call( this, geometry, material );\r\n\r\n\tthis.camera = camera;\r\n\tthis.camera.updateProjectionMatrix();\r\n\r\n\tthis.matrix = camera.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.pointMap = pointMap;\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.CameraHelper.prototype.constructor = THREE.CameraHelper;\r\n\r\nTHREE.CameraHelper.prototype.update = function () {\r\n\r\n\tvar geometry, pointMap;\r\n\r\n\tvar vector = new THREE.Vector3();\r\n\tvar camera = new THREE.Camera();\r\n\r\n\tfunction setPoint( point, x, y, z ) {\r\n\r\n\t\tvector.set( x, y, z ).unproject( camera );\r\n\r\n\t\tvar points = pointMap[ point ];\r\n\r\n\t\tif ( points !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tgeometry.vertices[ points[ i ] ].copy( vector );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn function () {\r\n\r\n\t\tgeometry = this.geometry;\r\n\t\tpointMap = this.pointMap;\r\n\r\n\t\tvar w = 1, h = 1;\r\n\r\n\t\t// we need just camera projection matrix\r\n\t\t// world matrix must be identity\r\n\r\n\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\r\n\r\n\t\t// center / target\r\n\r\n\t\tsetPoint( \"c\", 0, 0, - 1 );\r\n\t\tsetPoint( \"t\", 0, 0,  1 );\r\n\r\n\t\t// near\r\n\r\n\t\tsetPoint( \"n1\", - w, - h, - 1 );\r\n\t\tsetPoint( \"n2\",   w, - h, - 1 );\r\n\t\tsetPoint( \"n3\", - w,   h, - 1 );\r\n\t\tsetPoint( \"n4\",   w,   h, - 1 );\r\n\r\n\t\t// far\r\n\r\n\t\tsetPoint( \"f1\", - w, - h, 1 );\r\n\t\tsetPoint( \"f2\",   w, - h, 1 );\r\n\t\tsetPoint( \"f3\", - w,   h, 1 );\r\n\t\tsetPoint( \"f4\",   w,   h, 1 );\r\n\r\n\t\t// up\r\n\r\n\t\tsetPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\r\n\t\tsetPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\r\n\t\tsetPoint( \"u3\",         0, h * 2,   - 1 );\r\n\r\n\t\t// cross\r\n\r\n\t\tsetPoint( \"cf1\", - w,   0, 1 );\r\n\t\tsetPoint( \"cf2\",   w,   0, 1 );\r\n\t\tsetPoint( \"cf3\",   0, - h, 1 );\r\n\t\tsetPoint( \"cf4\",   0,   h, 1 );\r\n\r\n\t\tsetPoint( \"cn1\", - w,   0, - 1 );\r\n\t\tsetPoint( \"cn2\",   w,   0, - 1 );\r\n\t\tsetPoint( \"cn3\",   0, - h, - 1 );\r\n\t\tsetPoint( \"cn4\",   0,   h, - 1 );\r\n\r\n\t\tgeometry.verticesNeedUpdate = true;\r\n\r\n\t};\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/DirectionalLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.DirectionalLightHelper = function ( light, size ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tthis.matrix = light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tsize = size || 1;\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\tgeometry.vertices.push(\r\n\t\tnew THREE.Vector3( - size,   size, 0 ),\r\n\t\tnew THREE.Vector3(   size,   size, 0 ),\r\n\t\tnew THREE.Vector3(   size, - size, 0 ),\r\n\t\tnew THREE.Vector3( - size, - size, 0 ),\r\n\t\tnew THREE.Vector3( - size,   size, 0 )\r\n\t);\r\n\r\n\tvar material = new THREE.LineBasicMaterial( { fog: false } );\r\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\tthis.lightPlane = new THREE.Line( geometry, material );\r\n\tthis.add( this.lightPlane );\r\n\r\n\tgeometry = new THREE.Geometry();\r\n\tgeometry.vertices.push(\r\n\t\tnew THREE.Vector3(),\r\n\t\tnew THREE.Vector3()\r\n\t);\r\n\r\n\tmaterial = new THREE.LineBasicMaterial( { fog: false } );\r\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\tthis.targetLine = new THREE.Line( geometry, material );\r\n\tthis.add( this.targetLine );\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;\r\n\r\nTHREE.DirectionalLightHelper.prototype.dispose = function () {\r\n\r\n\tthis.lightPlane.geometry.dispose();\r\n\tthis.lightPlane.material.dispose();\r\n\tthis.targetLine.geometry.dispose();\r\n\tthis.targetLine.material.dispose();\r\n\r\n};\r\n\r\nTHREE.DirectionalLightHelper.prototype.update = function () {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\tvar v2 = new THREE.Vector3();\r\n\tvar v3 = new THREE.Vector3();\r\n\r\n\treturn function () {\r\n\r\n\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\r\n\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n\t\tv3.subVectors( v2, v1 );\r\n\r\n\t\tthis.lightPlane.lookAt( v3 );\r\n\t\tthis.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\t\tthis.targetLine.geometry.vertices[ 1 ].copy( v3 );\r\n\t\tthis.targetLine.geometry.verticesNeedUpdate = true;\r\n\t\tthis.targetLine.material.color.copy( this.lightPlane.material.color );\r\n\r\n\t};\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/EdgesHelper.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @param object THREE.Mesh whose geometry will be used\r\n * @param hex line color\r\n * @param thresholdAngle the minimum angle (in degrees),\r\n * between the face normals of adjacent faces,\r\n * that is required to render an edge. A value of 10 means\r\n * an edge is only rendered if the angle is at least 10 degrees.\r\n */\r\n\r\nTHREE.EdgesHelper = function ( object, hex, thresholdAngle ) {\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\r\n\tTHREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );\r\n\r\n\tthis.matrix = object.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;\r\n\r\n// File:src/extras/helpers/FaceNormalsHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\r\n\t// FaceNormalsHelper only supports THREE.Geometry\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.size = ( size !== undefined ) ? size : 1;\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\r\n\r\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\r\n\t//\r\n\r\n\tvar nNormals = 0;\r\n\r\n\tvar objGeometry = this.object.geometry;\r\n\r\n\tif ( objGeometry instanceof THREE.Geometry ) {\r\n\r\n\t\tnNormals = objGeometry.faces.length;\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\r\n\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\r\n\r\n\tgeometry.addAttribute( 'position', positions );\r\n\r\n\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\r\n\r\n\t//\r\n\r\n\tthis.matrixAutoUpdate = false;\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;\r\n\r\nTHREE.FaceNormalsHelper.prototype.update = ( function () {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\tvar v2 = new THREE.Vector3();\r\n\tvar normalMatrix = new THREE.Matrix3();\r\n\r\n\treturn function update() {\r\n\r\n\t\tthis.object.updateMatrixWorld( true );\r\n\r\n\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\r\n\r\n\t\tvar matrixWorld = this.object.matrixWorld;\r\n\r\n\t\tvar position = this.geometry.attributes.position;\r\n\r\n\t\t//\r\n\r\n\t\tvar objGeometry = this.object.geometry;\r\n\r\n\t\tvar vertices = objGeometry.vertices;\r\n\r\n\t\tvar faces = objGeometry.faces;\r\n\r\n\t\tvar idx = 0;\r\n\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tvar normal = face.normal;\r\n\r\n\t\t\tv1.copy( vertices[ face.a ] )\r\n\t\t\t\t.add( vertices[ face.b ] )\r\n\t\t\t\t.add( vertices[ face.c ] )\r\n\t\t\t\t.divideScalar( 3 )\r\n\t\t\t\t.applyMatrix4( matrixWorld );\r\n\r\n\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\r\n\r\n\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\r\n\r\n\t\t\tidx = idx + 1;\r\n\r\n\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\r\n\r\n\t\t\tidx = idx + 1;\r\n\r\n\t\t}\r\n\r\n\t\tposition.needsUpdate = true;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}() );\r\n\r\n// File:src/extras/helpers/GridHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.GridHelper = function ( size, step ) {\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\r\n\tthis.color1 = new THREE.Color( 0x444444 );\r\n\tthis.color2 = new THREE.Color( 0x888888 );\r\n\r\n\tfor ( var i = - size; i <= size; i += step ) {\r\n\r\n\t\tgeometry.vertices.push(\r\n\t\t\tnew THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),\r\n\t\t\tnew THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )\r\n\t\t);\r\n\r\n\t\tvar color = i === 0 ? this.color1 : this.color2;\r\n\r\n\t\tgeometry.colors.push( color, color, color, color );\r\n\r\n\t}\r\n\r\n\tTHREE.LineSegments.call( this, geometry, material );\r\n\r\n};\r\n\r\nTHREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.GridHelper.prototype.constructor = THREE.GridHelper;\r\n\r\nTHREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {\r\n\r\n\tthis.color1.set( colorCenterLine );\r\n\tthis.color2.set( colorGrid );\r\n\r\n\tthis.geometry.colorsNeedUpdate = true;\r\n\r\n};\r\n\r\n// File:src/extras/helpers/HemisphereLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.HemisphereLightHelper = function ( light, sphereSize ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tthis.matrix = light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.colors = [ new THREE.Color(), new THREE.Color() ];\r\n\r\n\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\r\n\tgeometry.rotateX( - Math.PI / 2 );\r\n\r\n\tfor ( var i = 0, il = 8; i < il; i ++ ) {\r\n\r\n\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\r\n\r\n\t}\r\n\r\n\tvar material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );\r\n\r\n\tthis.lightSphere = new THREE.Mesh( geometry, material );\r\n\tthis.add( this.lightSphere );\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;\r\n\r\nTHREE.HemisphereLightHelper.prototype.dispose = function () {\r\n\r\n\tthis.lightSphere.geometry.dispose();\r\n\tthis.lightSphere.material.dispose();\r\n\r\n};\r\n\r\nTHREE.HemisphereLightHelper.prototype.update = function () {\r\n\r\n\tvar vector = new THREE.Vector3();\r\n\r\n\treturn function () {\r\n\r\n\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\r\n\r\n\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\r\n\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\r\n\r\n\t}\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/PointLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.PointLightHelper = function ( light, sphereSize ) {\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\r\n\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\r\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\tthis.matrix = this.light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\t/*\r\n\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\r\n\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\r\n\r\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\r\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\r\n\r\n\tvar d = light.distance;\r\n\r\n\tif ( d === 0.0 ) {\r\n\r\n\t\tthis.lightDistance.visible = false;\r\n\r\n\t} else {\r\n\r\n\t\tthis.lightDistance.scale.set( d, d, d );\r\n\r\n\t}\r\n\r\n\tthis.add( this.lightDistance );\r\n\t*/\r\n\r\n};\r\n\r\nTHREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;\r\n\r\nTHREE.PointLightHelper.prototype.dispose = function () {\r\n\r\n\tthis.geometry.dispose();\r\n\tthis.material.dispose();\r\n\r\n};\r\n\r\nTHREE.PointLightHelper.prototype.update = function () {\r\n\r\n\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\t/*\r\n\tvar d = this.light.distance;\r\n\r\n\tif ( d === 0.0 ) {\r\n\r\n\t\tthis.lightDistance.visible = false;\r\n\r\n\t} else {\r\n\r\n\t\tthis.lightDistance.visible = true;\r\n\t\tthis.lightDistance.scale.set( d, d, d );\r\n\r\n\t}\r\n\t*/\r\n\r\n};\r\n\r\n// File:src/extras/helpers/SkeletonHelper.js\r\n\r\n/**\r\n * @author Sean Griffin / http://twitter.com/sgrif\r\n * @author Michael Guerrero / http://realitymeltdown.com\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.SkeletonHelper = function ( object ) {\r\n\r\n\tthis.bones = this.getBoneList( object );\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\r\n\tfor ( var i = 0; i < this.bones.length; i ++ ) {\r\n\r\n\t\tvar bone = this.bones[ i ];\r\n\r\n\t\tif ( bone.parent instanceof THREE.Bone ) {\r\n\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\tgeometry.colors.push( new THREE.Color( 0, 0, 1 ) );\r\n\t\t\tgeometry.colors.push( new THREE.Color( 0, 1, 0 ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgeometry.dynamic = true;\r\n\r\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );\r\n\r\n\tTHREE.LineSegments.call( this, geometry, material );\r\n\r\n\tthis.root = object;\r\n\r\n\tthis.matrix = object.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\n\r\nTHREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;\r\n\r\nTHREE.SkeletonHelper.prototype.getBoneList = function( object ) {\r\n\r\n\tvar boneList = [];\r\n\r\n\tif ( object instanceof THREE.Bone ) {\r\n\r\n\t\tboneList.push( object );\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0; i < object.children.length; i ++ ) {\r\n\r\n\t\tboneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\r\n\r\n\t}\r\n\r\n\treturn boneList;\r\n\r\n};\r\n\r\nTHREE.SkeletonHelper.prototype.update = function () {\r\n\r\n\tvar geometry = this.geometry;\r\n\r\n\tvar matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );\r\n\r\n\tvar boneMatrix = new THREE.Matrix4();\r\n\r\n\tvar j = 0;\r\n\r\n\tfor ( var i = 0; i < this.bones.length; i ++ ) {\r\n\r\n\t\tvar bone = this.bones[ i ];\r\n\r\n\t\tif ( bone.parent instanceof THREE.Bone ) {\r\n\r\n\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\r\n\t\t\tgeometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\r\n\r\n\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\r\n\t\t\tgeometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\r\n\r\n\t\t\tj += 2;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgeometry.verticesNeedUpdate = true;\r\n\r\n\tgeometry.computeBoundingSphere();\r\n\r\n};\r\n\r\n// File:src/extras/helpers/SpotLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.SpotLightHelper = function ( light ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tthis.matrix = light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tvar geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );\r\n\r\n\tgeometry.translate( 0, - 0.5, 0 );\r\n\tgeometry.rotateX( - Math.PI / 2 );\r\n\r\n\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\r\n\r\n\tthis.cone = new THREE.Mesh( geometry, material );\r\n\tthis.add( this.cone );\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;\r\n\r\nTHREE.SpotLightHelper.prototype.dispose = function () {\r\n\r\n\tthis.cone.geometry.dispose();\r\n\tthis.cone.material.dispose();\r\n\r\n};\r\n\r\nTHREE.SpotLightHelper.prototype.update = function () {\r\n\r\n\tvar vector = new THREE.Vector3();\r\n\tvar vector2 = new THREE.Vector3();\r\n\r\n\treturn function () {\r\n\r\n\t\tvar coneLength = this.light.distance ? this.light.distance : 10000;\r\n\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\r\n\r\n\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\r\n\r\n\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\r\n\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n\r\n\t\tthis.cone.lookAt( vector2.sub( vector ) );\r\n\r\n\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\t};\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/VertexNormalsHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.size = ( size !== undefined ) ? size : 1;\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\r\n\r\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\r\n\t//\r\n\r\n\tvar nNormals = 0;\r\n\r\n\tvar objGeometry = this.object.geometry;\r\n\r\n\tif ( objGeometry instanceof THREE.Geometry ) {\r\n\r\n\t\tnNormals = objGeometry.faces.length * 3;\r\n\r\n\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\tnNormals = objGeometry.attributes.normal.count\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\r\n\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\r\n\r\n\tgeometry.addAttribute( 'position', positions );\r\n\r\n\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\r\n\r\n\t//\r\n\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;\r\n\r\nTHREE.VertexNormalsHelper.prototype.update = ( function () {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\tvar v2 = new THREE.Vector3();\r\n\tvar normalMatrix = new THREE.Matrix3();\r\n\r\n\treturn function update() {\r\n\r\n\t\tvar keys = [ 'a', 'b', 'c' ];\r\n\r\n\t\tthis.object.updateMatrixWorld( true );\r\n\r\n\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\r\n\r\n\t\tvar matrixWorld = this.object.matrixWorld;\r\n\r\n\t\tvar position = this.geometry.attributes.position;\r\n\r\n\t\t//\r\n\r\n\t\tvar objGeometry = this.object.geometry;\r\n\r\n\t\tif ( objGeometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\tvar vertices = objGeometry.vertices;\r\n\r\n\t\t\tvar faces = objGeometry.faces;\r\n\r\n\t\t\tvar idx = 0;\r\n\r\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tvar vertex = vertices[ face[ keys[ j ] ] ];\r\n\r\n\t\t\t\t\tvar normal = face.vertexNormals[ j ];\r\n\r\n\t\t\t\t\tv1.copy( vertex ).applyMatrix4( matrixWorld );\r\n\r\n\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\r\n\r\n\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\r\n\r\n\t\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\r\n\r\n\t\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\tvar objPos = objGeometry.attributes.position;\r\n\r\n\t\t\tvar objNorm = objGeometry.attributes.normal;\r\n\r\n\t\t\tvar idx = 0;\r\n\r\n\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\r\n\r\n\t\t\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\r\n\r\n\t\t\t\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\r\n\r\n\t\t\t\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\r\n\r\n\t\t\t\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\r\n\r\n\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\r\n\r\n\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\r\n\r\n\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tposition.needsUpdate = true;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}() );\r\n\r\n// File:src/extras/helpers/WireframeHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.WireframeHelper = function ( object, hex ) {\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\r\n\tTHREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );\r\n\r\n\tthis.matrix = object.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;\r\n\r\n// File:src/extras/objects/ImmediateRenderObject.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.ImmediateRenderObject = function ( material ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.material = material;\r\n\tthis.render = function ( renderCallback ) {};\r\n\r\n};\r\n\r\nTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;\r\n\r\n// File:src/extras/objects/MorphBlendMesh.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.MorphBlendMesh = function( geometry, material ) {\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\tthis.animationsMap = {};\r\n\tthis.animationsList = [];\r\n\r\n\t// prepare default animation\r\n\t// (all frames played together in 1 second)\r\n\r\n\tvar numFrames = this.geometry.morphTargets.length;\r\n\r\n\tvar name = \"__default\";\r\n\r\n\tvar startFrame = 0;\r\n\tvar endFrame = numFrames - 1;\r\n\r\n\tvar fps = numFrames / 1;\r\n\r\n\tthis.createAnimation( name, startFrame, endFrame, fps );\r\n\tthis.setAnimationWeight( name, 1 );\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;\r\n\r\nTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\r\n\r\n\tvar animation = {\r\n\r\n\t\tstart: start,\r\n\t\tend: end,\r\n\r\n\t\tlength: end - start + 1,\r\n\r\n\t\tfps: fps,\r\n\t\tduration: ( end - start ) / fps,\r\n\r\n\t\tlastFrame: 0,\r\n\t\tcurrentFrame: 0,\r\n\r\n\t\tactive: false,\r\n\r\n\t\ttime: 0,\r\n\t\tdirection: 1,\r\n\t\tweight: 1,\r\n\r\n\t\tdirectionBackwards: false,\r\n\t\tmirroredLoop: false\r\n\r\n\t};\r\n\r\n\tthis.animationsMap[ name ] = animation;\r\n\tthis.animationsList.push( animation );\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\r\n\r\n\tvar pattern = /([a-z]+)_?(\\d+)/i;\r\n\r\n\tvar firstAnimation, frameRanges = {};\r\n\r\n\tvar geometry = this.geometry;\r\n\r\n\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\tvar chunks = morph.name.match( pattern );\r\n\r\n\t\tif ( chunks && chunks.length > 1 ) {\r\n\r\n\t\t\tvar name = chunks[ 1 ];\r\n\r\n\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\r\n\r\n\t\t\tvar range = frameRanges[ name ];\r\n\r\n\t\t\tif ( i < range.start ) range.start = i;\r\n\t\t\tif ( i > range.end ) range.end = i;\r\n\r\n\t\t\tif ( ! firstAnimation ) firstAnimation = name;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( var name in frameRanges ) {\r\n\r\n\t\tvar range = frameRanges[ name ];\r\n\t\tthis.createAnimation( name, range.start, range.end, fps );\r\n\r\n\t}\r\n\r\n\tthis.firstAnimation = firstAnimation;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.direction = 1;\r\n\t\tanimation.directionBackwards = false;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.direction = - 1;\r\n\t\tanimation.directionBackwards = true;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.fps = fps;\r\n\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.duration = duration;\r\n\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.weight = weight;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.time = time;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\r\n\r\n\tvar time = 0;\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\ttime = animation.time;\r\n\r\n\t}\r\n\r\n\treturn time;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\r\n\r\n\tvar duration = - 1;\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tduration = animation.duration;\r\n\r\n\t}\r\n\r\n\treturn duration;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.time = 0;\r\n\t\tanimation.active = true;\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.active = false;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\r\n\r\n\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\r\n\r\n\t\tvar animation = this.animationsList[ i ];\r\n\r\n\t\tif ( ! animation.active ) continue;\r\n\r\n\t\tvar frameTime = animation.duration / animation.length;\r\n\r\n\t\tanimation.time += animation.direction * delta;\r\n\r\n\t\tif ( animation.mirroredLoop ) {\r\n\r\n\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\r\n\r\n\t\t\t\tanimation.direction *= - 1;\r\n\r\n\t\t\t\tif ( animation.time > animation.duration ) {\r\n\r\n\t\t\t\t\tanimation.time = animation.duration;\r\n\t\t\t\t\tanimation.directionBackwards = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( animation.time < 0 ) {\r\n\r\n\t\t\t\t\tanimation.time = 0;\r\n\t\t\t\t\tanimation.directionBackwards = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tanimation.time = animation.time % animation.duration;\r\n\r\n\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\r\n\r\n\t\t}\r\n\r\n\t\tvar keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\r\n\t\tvar weight = animation.weight;\r\n\r\n\t\tif ( keyframe !== animation.currentFrame ) {\r\n\r\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\r\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\r\n\r\n\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\r\n\t\t\tanimation.lastFrame = animation.currentFrame;\r\n\t\t\tanimation.currentFrame = keyframe;\r\n\r\n\t\t}\r\n\r\n\t\tvar mix = ( animation.time % frameTime ) / frameTime;\r\n\r\n\t\tif ( animation.directionBackwards ) mix = 1 - mix;\r\n\r\n\t\tif ( animation.currentFrame !== animation.lastFrame ) {\r\n\r\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\r\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = weight;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n// Export the THREE object for **Node.js**, with\r\n// backwards-compatibility for the old `require()` API. If we're in\r\n// the browser, add `_` as a global object via a string identifier,\r\n// for Closure Compiler \"advanced\" mode.\r\nif (typeof exports !== 'undefined') {\r\n  if (typeof module !== 'undefined' && module.exports) {\r\n    exports = module.exports = THREE;\r\n  }\r\n  exports.THREE = THREE;\r\n} else {\r\n  this['THREE'] = THREE;\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/three/three.js\n ** module id = 1\n ** module chunks = 0\n **/"],"sourceRoot":""}